(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
};

exports.addAll = addAll;


function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = { data: d },
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d,
      i,
      n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
      var z = x1 - x0 || 1,
          node = this._root,
          parent,
          i;

      while (x0 > x || x >= x1 || y0 > y || y >= y1) {
        i = (y < y0) << 1 | x < x0;
        parent = new Array(4), parent[i] = node, node = parent, z *= 2;
        switch (i) {
          case 0:
            x1 = x0 + z, y1 = y0 + z;break;
          case 1:
            x0 = x1 - z, y1 = y0 + z;break;
          case 2:
            x1 = x0 + z, y0 = y1 - z;break;
          case 3:
            x0 = x1 - z, y0 = y1 - z;break;
        }
      }

      if (this._root && this._root.length) this._root = node;
    }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
};

},{}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var data = [];
  this.visit(function (node) {
    if (!node.length) do {
      data.push(node.data);
    } while (node = node.next);
  });
  return data;
};

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (_) {
    return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
};

},{}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new _quad2.default(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > y3 || (x2 = q.x1) < x0 || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(new _quad2.default(node[3], xm, ym, x2, y2), new _quad2.default(node[2], x1, ym, xm, y2), new _quad2.default(node[1], xm, y1, x2, ym), new _quad2.default(node[0], x1, y1, xm, ym));

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | x >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
        var dx = x - +this._x.call(null, node.data),
            dy = y - +this._y.call(null, node.data),
            d2 = dx * dx + dy * dy;
        if (d2 < radius) {
          var d = Math.sqrt(radius = d2);
          x0 = x - d, y0 = y - d;
          x3 = x + d, y3 = y + d;
          data = node.data;
        }
      }
  }

  return data;
};

var _quad = require("./quad.js");

var _quad2 = _interopRequireDefault(_quad);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./quad.js":7}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _quadtree = require("./quadtree.js");

Object.defineProperty(exports, "quadtree", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_quadtree).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./quadtree.js":8}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
};

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quadtree;

var _add = require("./add.js");

var _add2 = _interopRequireDefault(_add);

var _cover = require("./cover.js");

var _cover2 = _interopRequireDefault(_cover);

var _data = require("./data.js");

var _data2 = _interopRequireDefault(_data);

var _extent = require("./extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _find = require("./find.js");

var _find2 = _interopRequireDefault(_find);

var _remove = require("./remove.js");

var _remove2 = _interopRequireDefault(_remove);

var _root = require("./root.js");

var _root2 = _interopRequireDefault(_root);

var _size = require("./size.js");

var _size2 = _interopRequireDefault(_size);

var _visit = require("./visit.js");

var _visit2 = _interopRequireDefault(_visit);

var _visitAfter = require("./visitAfter.js");

var _visitAfter2 = _interopRequireDefault(_visitAfter);

var _x = require("./x.js");

var _x2 = _interopRequireDefault(_x);

var _y = require("./y.js");

var _y2 = _interopRequireDefault(_y);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x.defaultX : x, y == null ? _y.defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = { data: leaf.data },
      next = copy;
  while (leaf = leaf.next) {
    next = next.next = { data: leaf.data };
  }return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function () {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{ source: node, target: copy._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({ source: child, target: node.target[i] = new Array(4) });else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add2.default;
treeProto.addAll = _add.addAll;
treeProto.cover = _cover2.default;
treeProto.data = _data2.default;
treeProto.extent = _extent2.default;
treeProto.find = _find2.default;
treeProto.remove = _remove2.default;
treeProto.removeAll = _remove.removeAll;
treeProto.root = _root2.default;
treeProto.size = _size2.default;
treeProto.visit = _visit2.default;
treeProto.visitAfter = _visitAfter2.default;
treeProto.x = _x2.default;
treeProto.y = _y2.default;

},{"./add.js":1,"./cover.js":2,"./data.js":3,"./extent.js":4,"./find.js":5,"./remove.js":9,"./root.js":10,"./size.js":11,"./visit.js":12,"./visitAfter.js":13,"./x.js":14,"./y.js":15}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) {
    if (!(previous = node, node = node.next)) return this;
  }if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return next ? previous.next = next : delete previous.next, this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;else this._root = node;
  }

  return this;
};

exports.removeAll = removeAll;
function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) {
    this.remove(data[i]);
  }return this;
}

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return this._root;
};

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var size = 0;
  this.visit(function (node) {
    if (!node.length) do {
      ++size;
    } while (node = node.next);
  });
  return size;
};

},{}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (callback) {
  var quads = [],
      q,
      node = this._root,
      child,
      x0,
      y0,
      x1,
      y1;
  if (node) quads.push(new _quad2.default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2,
          ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad2.default(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad2.default(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad2.default(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad2.default(child, x0, y0, xm, ym));
    }
  }
  return this;
};

var _quad = require("./quad.js");

var _quad2 = _interopRequireDefault(_quad);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./quad.js":7}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (callback) {
  var quads = [],
      next = [],
      q;
  if (this._root) quads.push(new _quad2.default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child,
          x0 = q.x0,
          y0 = q.y0,
          x1 = q.x1,
          y1 = q.y1,
          xm = (x0 + x1) / 2,
          ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad2.default(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad2.default(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad2.default(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad2.default(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
};

var _quad = require("./quad.js");

var _quad2 = _interopRequireDefault(_quad);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./quad.js":7}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultX = defaultX;

exports.default = function (_) {
  return arguments.length ? (this._x = _, this) : this._x;
};

function defaultX(d) {
  return d[0];
}

},{}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultY = defaultY;

exports.default = function (_) {
  return arguments.length ? (this._y = _, this) : this._y;
};

function defaultY(d) {
  return d[1];
}

},{}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
exports.equals = equals;
exports.RANDOM = exports.ARRAY_TYPE = exports.EPSILON = void 0;

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

exports.RANDOM = RANDOM;

function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */


function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};
},{}],17:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.fromMat4 = fromMat4;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromMat2d = fromMat2d;
exports.fromQuat = fromQuat;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(9);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */


function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */


function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */


function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */


function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/


function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */


function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */


function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":16}],18:[function(require,module,exports){
module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}

},{}],19:[function(require,module,exports){
module.exports = function eventify(subject) {
  validateSubject(subject);

  var eventsStorage = createEventsStorage(subject);
  subject.on = eventsStorage.on;
  subject.off = eventsStorage.off;
  subject.fire = eventsStorage.fire;
  return subject;
};

function createEventsStorage(subject) {
  // Store all event listeners to this hash. Key is event name, value is array
  // of callback records.
  //
  // A callback record consists of callback function and its optional context:
  // { 'eventName' => [{callback: function, ctx: object}] }
  var registeredEvents = Object.create(null);

  return {
    on: function (eventName, callback, ctx) {
      if (typeof callback !== 'function') {
        throw new Error('callback is expected to be a function');
      }
      var handlers = registeredEvents[eventName];
      if (!handlers) {
        handlers = registeredEvents[eventName] = [];
      }
      handlers.push({callback: callback, ctx: ctx});

      return subject;
    },

    off: function (eventName, callback) {
      var wantToRemoveAll = (typeof eventName === 'undefined');
      if (wantToRemoveAll) {
        // Killing old events storage should be enough in this case:
        registeredEvents = Object.create(null);
        return subject;
      }

      if (registeredEvents[eventName]) {
        var deleteAllCallbacksForEvent = (typeof callback !== 'function');
        if (deleteAllCallbacksForEvent) {
          delete registeredEvents[eventName];
        } else {
          var callbacks = registeredEvents[eventName];
          for (var i = 0; i < callbacks.length; ++i) {
            if (callbacks[i].callback === callback) {
              callbacks.splice(i, 1);
            }
          }
        }
      }

      return subject;
    },

    fire: function (eventName) {
      var callbacks = registeredEvents[eventName];
      if (!callbacks) {
        return subject;
      }

      var fireArguments;
      if (arguments.length > 1) {
        fireArguments = Array.prototype.splice.call(arguments, 1);
      }
      for(var i = 0; i < callbacks.length; ++i) {
        var callbackInfo = callbacks[i];
        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);
      }

      return subject;
    }
  };
}

function validateSubject(subject) {
  if (!subject) {
    throw new Error('Eventify cannot use falsy object as events subject');
  }
  var reservedWords = ['on', 'fire', 'off'];
  for (var i = 0; i < reservedWords.length; ++i) {
    if (subject.hasOwnProperty(reservedWords[i])) {
      throw new Error("Subject cannot be eventified, since it already has property '" + reservedWords[i] + "'");
    }
  }
}

},{}],20:[function(require,module,exports){
/**
 * @fileOverview Contains definition of the core graph object.
 */

// TODO: need to change storage layer:
// 1. Be able to get all nodes O(1)
// 2. Be able to get number of links O(1)

/**
 * @example
 *  var graph = require('ngraph.graph')();
 *  graph.addNode(1);     // graph has one node.
 *  graph.addLink(2, 3);  // now graph contains three nodes and one link.
 *
 */
module.exports = createGraph;

var eventify = require('ngraph.events');

/**
 * Creates a new graph
 */
function createGraph(options) {
  // Graph structure is maintained as dictionary of nodes
  // and array of links. Each node has 'links' property which
  // hold all links related to that node. And general links
  // array is used to speed up all links enumeration. This is inefficient
  // in terms of memory, but simplifies coding.
  options = options || {};
  if ('uniqueLinkId' in options) {
    console.warn(
      'ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\n' +
      'Use `multigraph` option instead\n',
      '\n',
      'Note: there is also change in default behavior: From now on each graph\n'+
      'is considered to be not a multigraph by default (each edge is unique).'
    );

    options.multigraph = options.uniqueLinkId;
  }

  // Dear reader, the non-multigraphs do not guarantee that there is only
  // one link for a given pair of node. When this option is set to false
  // we can save some memory and CPU (18% faster for non-multigraph);
  if (options.multigraph === undefined) options.multigraph = false;

  if (typeof Map !== 'function') {
    // TODO: Should we polyfill it ourselves? We don't use much operations there..
    throw new Error('ngraph.graph requires `Map` to be defined. Please polyfill it before using ngraph');
  } 

  var nodes = new Map();
  var links = [],
    // Hash of multi-edges. Used to track ids of edges between same nodes
    multiEdges = {},
    suspendEvents = 0,

    createLink = options.multigraph ? createUniqueLink : createSingleLink,

    // Our graph API provides means to listen to graph changes. Users can subscribe
    // to be notified about changes in the graph by using `on` method. However
    // in some cases they don't use it. To avoid unnecessary memory consumption
    // we will not record graph changes until we have at least one subscriber.
    // Code below supports this optimization.
    //
    // Accumulates all changes made during graph updates.
    // Each change element contains:
    //  changeType - one of the strings: 'add', 'remove' or 'update';
    //  node - if change is related to node this property is set to changed graph's node;
    //  link - if change is related to link this property is set to changed graph's link;
    changes = [],
    recordLinkChange = noop,
    recordNodeChange = noop,
    enterModification = noop,
    exitModification = noop;

  // this is our public API:
  var graphPart = {
    /**
     * Adds node to the graph. If node with given id already exists in the graph
     * its data is extended with whatever comes in 'data' argument.
     *
     * @param nodeId the node's identifier. A string or number is preferred.
     * @param [data] additional data for the node being added. If node already
     *   exists its data object is augmented with the new one.
     *
     * @return {node} The newly added node or node with given id if it already exists.
     */
    addNode: addNode,

    /**
     * Adds a link to the graph. The function always create a new
     * link between two nodes. If one of the nodes does not exists
     * a new node is created.
     *
     * @param fromId link start node id;
     * @param toId link end node id;
     * @param [data] additional data to be set on the new link;
     *
     * @return {link} The newly created link
     */
    addLink: addLink,

    /**
     * Removes link from the graph. If link does not exist does nothing.
     *
     * @param link - object returned by addLink() or getLinks() methods.
     *
     * @returns true if link was removed; false otherwise.
     */
    removeLink: removeLink,

    /**
     * Removes node with given id from the graph. If node does not exist in the graph
     * does nothing.
     *
     * @param nodeId node's identifier passed to addNode() function.
     *
     * @returns true if node was removed; false otherwise.
     */
    removeNode: removeNode,

    /**
     * Gets node with given identifier. If node does not exist undefined value is returned.
     *
     * @param nodeId requested node identifier;
     *
     * @return {node} in with requested identifier or undefined if no such node exists.
     */
    getNode: getNode,

    /**
     * Gets number of nodes in this graph.
     *
     * @return number of nodes in the graph.
     */
    getNodeCount: getNodeCount,

    /**
     * Gets total number of links in the graph.
     */
    getLinkCount: getLinkCount,

    /**
     * Synonym for `getLinkCount()`
     */
    getLinksCount: getLinkCount,
    
    /**
     * Synonym for `getNodeCount()`
     */
    getNodesCount: getNodeCount,

    /**
     * Gets all links (inbound and outbound) from the node with given id.
     * If node with given id is not found null is returned.
     *
     * @param nodeId requested node identifier.
     *
     * @return Array of links from and to requested node if such node exists;
     *   otherwise null is returned.
     */
    getLinks: getLinks,

    /**
     * Invokes callback on each node of the graph.
     *
     * @param {Function(node)} callback Function to be invoked. The function
     *   is passed one argument: visited node.
     */
    forEachNode: forEachNode,

    /**
     * Invokes callback on every linked (adjacent) node to the given one.
     *
     * @param nodeId Identifier of the requested node.
     * @param {Function(node, link)} callback Function to be called on all linked nodes.
     *   The function is passed two parameters: adjacent node and link object itself.
     * @param oriented if true graph treated as oriented.
     */
    forEachLinkedNode: forEachLinkedNode,

    /**
     * Enumerates all links in the graph
     *
     * @param {Function(link)} callback Function to be called on all links in the graph.
     *   The function is passed one parameter: graph's link object.
     *
     * Link object contains at least the following fields:
     *  fromId - node id where link starts;
     *  toId - node id where link ends,
     *  data - additional data passed to graph.addLink() method.
     */
    forEachLink: forEachLink,

    /**
     * Suspend all notifications about graph changes until
     * endUpdate is called.
     */
    beginUpdate: enterModification,

    /**
     * Resumes all notifications about graph changes and fires
     * graph 'changed' event in case there are any pending changes.
     */
    endUpdate: exitModification,

    /**
     * Removes all nodes and links from the graph.
     */
    clear: clear,

    /**
     * Detects whether there is a link between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     * NOTE: this function is synonim for getLink()
     *
     * @returns link if there is one. null otherwise.
     */
    hasLink: getLink,

    /**
     * Detects whether there is a node with given id
     * 
     * Operation complexity is O(1)
     * NOTE: this function is synonim for getNode()
     *
     * @returns node if there is one; Falsy value otherwise.
     */
    hasNode: getNode,

    /**
     * Gets an edge between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     *
     * @param {string} fromId link start identifier
     * @param {string} toId link end identifier
     *
     * @returns link if there is one. null otherwise.
     */
    getLink: getLink
  };

  // this will add `on()` and `fire()` methods.
  eventify(graphPart);

  monitorSubscribers();

  return graphPart;

  function monitorSubscribers() {
    var realOn = graphPart.on;

    // replace real `on` with our temporary on, which will trigger change
    // modification monitoring:
    graphPart.on = on;

    function on() {
      // now it's time to start tracking stuff:
      graphPart.beginUpdate = enterModification = enterModificationReal;
      graphPart.endUpdate = exitModification = exitModificationReal;
      recordLinkChange = recordLinkChangeReal;
      recordNodeChange = recordNodeChangeReal;

      // this will replace current `on` method with real pub/sub from `eventify`.
      graphPart.on = realOn;
      // delegate to real `on` handler:
      return realOn.apply(graphPart, arguments);
    }
  }

  function recordLinkChangeReal(link, changeType) {
    changes.push({
      link: link,
      changeType: changeType
    });
  }

  function recordNodeChangeReal(node, changeType) {
    changes.push({
      node: node,
      changeType: changeType
    });
  }

  function addNode(nodeId, data) {
    if (nodeId === undefined) {
      throw new Error('Invalid node identifier');
    }

    enterModification();

    var node = getNode(nodeId);
    if (!node) {
      node = new Node(nodeId, data);
      recordNodeChange(node, 'add');
    } else {
      node.data = data;
      recordNodeChange(node, 'update');
    }

    nodes.set(nodeId, node);

    exitModification();
    return node;
  }

  function getNode(nodeId) {
    return nodes.get(nodeId);
  }

  function removeNode(nodeId) {
    var node = getNode(nodeId);
    if (!node) {
      return false;
    }

    enterModification();

    var prevLinks = node.links;
    if (prevLinks) {
      node.links = null;
      for(var i = 0; i < prevLinks.length; ++i) {
        removeLink(prevLinks[i]);
      }
    }

    nodes.delete(nodeId)

    recordNodeChange(node, 'remove');

    exitModification();

    return true;
  }


  function addLink(fromId, toId, data) {
    enterModification();

    var fromNode = getNode(fromId) || addNode(fromId);
    var toNode = getNode(toId) || addNode(toId);

    var link = createLink(fromId, toId, data);

    links.push(link);

    // TODO: this is not cool. On large graphs potentially would consume more memory.
    addLinkToNode(fromNode, link);
    if (fromId !== toId) {
      // make sure we are not duplicating links for self-loops
      addLinkToNode(toNode, link);
    }

    recordLinkChange(link, 'add');

    exitModification();

    return link;
  }

  function createSingleLink(fromId, toId, data) {
    var linkId = makeLinkId(fromId, toId);
    return new Link(fromId, toId, data, linkId);
  }

  function createUniqueLink(fromId, toId, data) {
    // TODO: Get rid of this method.
    var linkId = makeLinkId(fromId, toId);
    var isMultiEdge = multiEdges.hasOwnProperty(linkId);
    if (isMultiEdge || getLink(fromId, toId)) {
      if (!isMultiEdge) {
        multiEdges[linkId] = 0;
      }
      var suffix = '@' + (++multiEdges[linkId]);
      linkId = makeLinkId(fromId + suffix, toId + suffix);
    }

    return new Link(fromId, toId, data, linkId);
  }

  function getNodeCount() {
    return nodes.size;
  }

  function getLinkCount() {
    return links.length;
  }

  function getLinks(nodeId) {
    var node = getNode(nodeId);
    return node ? node.links : null;
  }

  function removeLink(link) {
    if (!link) {
      return false;
    }
    var idx = indexOfElementInArray(link, links);
    if (idx < 0) {
      return false;
    }

    enterModification();

    links.splice(idx, 1);

    var fromNode = getNode(link.fromId);
    var toNode = getNode(link.toId);

    if (fromNode) {
      idx = indexOfElementInArray(link, fromNode.links);
      if (idx >= 0) {
        fromNode.links.splice(idx, 1);
      }
    }

    if (toNode) {
      idx = indexOfElementInArray(link, toNode.links);
      if (idx >= 0) {
        toNode.links.splice(idx, 1);
      }
    }

    recordLinkChange(link, 'remove');

    exitModification();

    return true;
  }

  function getLink(fromNodeId, toNodeId) {
    // TODO: Use sorted links to speed this up
    var node = getNode(fromNodeId),
      i;
    if (!node || !node.links) {
      return null;
    }

    for (i = 0; i < node.links.length; ++i) {
      var link = node.links[i];
      if (link.fromId === fromNodeId && link.toId === toNodeId) {
        return link;
      }
    }

    return null; // no link.
  }

  function clear() {
    enterModification();
    forEachNode(function(node) {
      removeNode(node.id);
    });
    exitModification();
  }

  function forEachLink(callback) {
    var i, length;
    if (typeof callback === 'function') {
      for (i = 0, length = links.length; i < length; ++i) {
        callback(links[i]);
      }
    }
  }

  function forEachLinkedNode(nodeId, callback, oriented) {
    var node = getNode(nodeId);

    if (node && node.links && typeof callback === 'function') {
      if (oriented) {
        return forEachOrientedLink(node.links, nodeId, callback);
      } else {
        return forEachNonOrientedLink(node.links, nodeId, callback);
      }
    }
  }

  function forEachNonOrientedLink(links, nodeId, callback) {
    var quitFast;
    for (var i = 0; i < links.length; ++i) {
      var link = links[i];
      var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;

      quitFast = callback(nodes.get(linkedNodeId), link);
      if (quitFast) {
        return true; // Client does not need more iterations. Break now.
      }
    }
  }

  function forEachOrientedLink(links, nodeId, callback) {
    var quitFast;
    for (var i = 0; i < links.length; ++i) {
      var link = links[i];
      if (link.fromId === nodeId) {
        quitFast = callback(nodes.get(link.toId), link)
        if (quitFast) {
          return true; // Client does not need more iterations. Break now.
        }
      }
    }
  }

  // we will not fire anything until users of this library explicitly call `on()`
  // method.
  function noop() {}

  // Enter, Exit modification allows bulk graph updates without firing events.
  function enterModificationReal() {
    suspendEvents += 1;
  }

  function exitModificationReal() {
    suspendEvents -= 1;
    if (suspendEvents === 0 && changes.length > 0) {
      graphPart.fire('changed', changes);
      changes.length = 0;
    }
  }

  function forEachNode(callback) {
    if (typeof callback !== 'function') {
      throw new Error('Function is expected to iterate over graph nodes. You passed ' + callback);
    }

    var valuesIterator = nodes.values();
    var nextValue = valuesIterator.next();
    while (!nextValue.done) {
      if (callback(nextValue.value)) {
        return true; // client doesn't want to proceed. Return.
      }
      nextValue = valuesIterator.next();
    }
  }
}

// need this for old browsers. Should this be a separate module?
function indexOfElementInArray(element, array) {
  if (!array) return -1;

  if (array.indexOf) {
    return array.indexOf(element);
  }

  var len = array.length,
    i;

  for (i = 0; i < len; i += 1) {
    if (array[i] === element) {
      return i;
    }
  }

  return -1;
}

/**
 * Internal structure to represent node;
 */
function Node(id, data) {
  this.id = id;
  this.links = null;
  this.data = data;
}

function addLinkToNode(node, link) {
  if (node.links) {
    node.links.push(link);
  } else {
    node.links = [link];
  }
}

/**
 * Internal structure to represent links;
 */
function Link(fromId, toId, data, id) {
  this.fromId = fromId;
  this.toId = toId;
  this.data = data;
  this.id = id;
}

function makeLinkId(fromId, toId) {
  return fromId.toString() + '👉 ' + toId.toString();
}

},{"ngraph.events":19}],21:[function(require,module,exports){
/**
 * Based on https://github.com/mourner/tinyqueue
 * Copyright (c) 2017, Vladimir Agafonkin https://github.com/mourner/tinyqueue/blob/master/LICENSE
 * 
 * Adapted for PathFinding needs by @anvaka
 * Copyright (c) 2017, Andrei Kashcha
 */
module.exports = NodeHeap;

function NodeHeap(data, options) {
  if (!(this instanceof NodeHeap)) return new NodeHeap(data, options);

  if (!Array.isArray(data)) {
    // assume first argument is our config object;
    options = data;
    data = [];
  }

  options = options || {};

  this.data = data || [];
  this.length = this.data.length;
  this.compare = options.compare || defaultCompare;
  this.setNodeId = options.setNodeId || noop;

  if (this.length > 0) {
    for (var i = (this.length >> 1); i >= 0; i--) this._down(i);
  }

  if (options.setNodeId) {
    for (var i = 0; i < this.length; ++i) {
      this.setNodeId(this.data[i], i);
    }
  }
}

function noop() {}

function defaultCompare(a, b) {
  return a - b;
}

NodeHeap.prototype = {

  push: function (item) {
    this.data.push(item);
    this.setNodeId(item, this.length);
    this.length++;
    this._up(this.length - 1);
  },

  pop: function () {
    if (this.length === 0) return undefined;

    var top = this.data[0];
    this.length--;

    if (this.length > 0) {
      this.data[0] = this.data[this.length];
      this.setNodeId(this.data[0], 0);
      this._down(0);
    }
    this.data.pop();

    return top;
  },

  peek: function () {
    return this.data[0];
  },

  updateItem: function (pos) {
    this._down(pos);
    this._up(pos);
  },

  _up: function (pos) {
    var data = this.data;
    var compare = this.compare;
    var setNodeId = this.setNodeId;
    var item = data[pos];

    while (pos > 0) {
      var parent = (pos - 1) >> 1;
      var current = data[parent];
      if (compare(item, current) >= 0) break;
        data[pos] = current;

       setNodeId(current, pos);
       pos = parent;
    }

    data[pos] = item;
    setNodeId(item, pos);
  },

  _down: function (pos) {
    var data = this.data;
    var compare = this.compare;
    var halfLength = this.length >> 1;
    var item = data[pos];
    var setNodeId = this.setNodeId;

    while (pos < halfLength) {
      var left = (pos << 1) + 1;
      var right = left + 1;
      var best = data[left];

      if (right < this.length && compare(data[right], best) < 0) {
        left = right;
        best = data[right];
      }
      if (compare(best, item) >= 0) break;

      data[pos] = best;
      setNodeId(best, pos);
      pos = left;
    }

    data[pos] = item;
    setNodeId(item, pos);
  }
};
},{}],22:[function(require,module,exports){
/**
 * Performs suboptimal, greed A Star path finding.
 * This finder does not necessary finds the shortest path. The path
 * that it finds is very close to the shortest one. It is very fast though.
 */
module.exports = aStarBi;

var NodeHeap = require('./NodeHeap');
var makeSearchStatePool = require('./makeSearchStatePool');
var heuristics = require('./heuristics');
var defaultSettings = require('./defaultSettings');

var BY_FROM = 1;
var BY_TO = 2;
var NO_PATH = defaultSettings.NO_PATH;

module.exports.l2 = heuristics.l2;
module.exports.l1 = heuristics.l1;

/**
 * Creates a new instance of pathfinder. A pathfinder has just one method:
 * `find(fromId, toId)`, it may be extended in future.
 * 
 * NOTE: Algorithm implemented in this code DOES NOT find optimal path.
 * Yet the path that it finds is always near optimal, and it finds it very fast.
 * 
 * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph
 * 
 * @param {Object} options that configures search
 * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between
 * nodes `a` and `b`.  Defaults function returns 0, which makes this search equivalent to Dijkstra search.
 * @param {Function(a, b)} options.distance - a function that returns actual distance between two
 * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);
 * @param {Boolean} options.oriented - whether graph should be considered oriented or not.
 * 
 * @returns {Object} A pathfinder with single method `find()`.
 */
function aStarBi(graph, options) {
  options = options || {};
  // whether traversal should be considered over oriented graph.
  var oriented = options.oriented;

  var heuristic = options.heuristic;
  if (!heuristic) heuristic = defaultSettings.heuristic;

  var distance = options.distance;
  if (!distance) distance = defaultSettings.distance;
  var pool = makeSearchStatePool();

  return {
    find: find
  };

  function find(fromId, toId) {
    // Not sure if we should return NO_PATH or throw. Throw seem to be more
    // helpful to debug errors. So, throwing.
    var from = graph.getNode(fromId);
    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);
    var to = graph.getNode(toId);
    if (!to) throw new Error('toId is not defined in this graph: ' + toId);

    if (from === to) return [from]; // trivial case.

    pool.reset();

    var callVisitor = oriented ? orientedVisitor : nonOrientedVisitor;

    // Maps nodeId to NodeSearchState.
    var nodeState = new Map();

    var openSetFrom = new NodeHeap({
      compare: defaultSettings.compareFScore,
      setNodeId: defaultSettings.setHeapIndex
    });

    var openSetTo = new NodeHeap({
      compare: defaultSettings.compareFScore,
      setNodeId: defaultSettings.setHeapIndex
    });


    var startNode = pool.createNewState(from);
    nodeState.set(fromId, startNode);

    // For the first node, fScore is completely heuristic.
    startNode.fScore = heuristic(from, to);
    // The cost of going from start to start is zero.
    startNode.distanceToSource = 0;
    openSetFrom.push(startNode);
    startNode.open = BY_FROM;

    var endNode = pool.createNewState(to);
    endNode.fScore = heuristic(to, from);
    endNode.distanceToSource = 0;
    openSetTo.push(endNode);
    endNode.open = BY_TO;

    // Cost of the best solution found so far. Used for accurate termination
    var lMin = Number.POSITIVE_INFINITY;
    var minFrom;
    var minTo;

    var currentSet = openSetFrom;
    var currentOpener = BY_FROM;

    while (openSetFrom.length > 0 && openSetTo.length > 0) {
      if (openSetFrom.length < openSetTo.length) {
        // we pick a set with less elements
        currentOpener = BY_FROM;
        currentSet = openSetFrom;
      } else {
        currentOpener = BY_TO;
        currentSet = openSetTo;
      }

      var current = currentSet.pop();

      // no need to visit this node anymore
      current.closed = true;

      if (current.distanceToSource > lMin) continue;

      graph.forEachLinkedNode(current.node.id, callVisitor);

      if (minFrom && minTo) {
        // This is not necessary the best path, but we are so greedy that we
        // can't resist:
        return reconstructBiDirectionalPath(minFrom, minTo);
      }
    }

    return NO_PATH; // No path.

    function nonOrientedVisitor(otherNode, link) {
      return visitNode(otherNode, link, current);
    }

    function orientedVisitor(otherNode, link) {
      // For oritned graphs we need to reverse graph, when traveling
      // backwards. So, we use non-oriented ngraph's traversal, and 
      // filter link orientation here.
      if (currentOpener === BY_FROM) {
        if (link.fromId === current.node.id) return visitNode(otherNode, link, current)
      } else if (currentOpener === BY_TO) {
        if (link.toId === current.node.id) return visitNode(otherNode, link, current);
      }
    }

    function canExit(currentNode) {
      var opener = currentNode.open
      if (opener && opener !== currentOpener) {
        return true;
      }

      return false;
    }

    function reconstructBiDirectionalPath(a, b) {
      var pathOfNodes = [];
      var aParent = a;
      while(aParent) {
        pathOfNodes.push(aParent.node);
        aParent = aParent.parent;
      }
      var bParent = b;
      while (bParent) {
        pathOfNodes.unshift(bParent.node);
        bParent = bParent.parent
      }
      return pathOfNodes;
    }

    function visitNode(otherNode, link, cameFrom) {
      var otherSearchState = nodeState.get(otherNode.id);
      if (!otherSearchState) {
        otherSearchState = pool.createNewState(otherNode);
        nodeState.set(otherNode.id, otherSearchState);
      }

      if (otherSearchState.closed) {
        // Already processed this node.
        return;
      }

      if (canExit(otherSearchState, cameFrom)) {
        // this node was opened by alternative opener. The sets intersect now,
        // we found an optimal path, that goes through *this* node. However, there
        // is no guarantee that this is the global optimal solution path.

        var potentialLMin = otherSearchState.distanceToSource + cameFrom.distanceToSource;
        if (potentialLMin < lMin) {
          minFrom = otherSearchState;
          minTo = cameFrom
          lMin = potentialLMin;
        }
        // we are done with this node.
        return;
      }

      var tentativeDistance = cameFrom.distanceToSource + distance(otherSearchState.node, cameFrom.node, link);

      if (tentativeDistance >= otherSearchState.distanceToSource) {
        // This would only make our path longer. Ignore this route.
        return;
      }

      // Choose target based on current working set:
      var target = (currentOpener === BY_FROM) ? to : from;
      var newFScore = tentativeDistance + heuristic(otherSearchState.node, target);
      if (newFScore >= lMin) {
        // this can't be optimal path, as we have already found a shorter path.
        return;
      }
      otherSearchState.fScore = newFScore;

      if (otherSearchState.open === 0) {
        // Remember this node in the current set
        currentSet.push(otherSearchState);
        currentSet.updateItem(otherSearchState.heapIndex);

        otherSearchState.open = currentOpener;
      }

      // bingo! we found shorter path:
      otherSearchState.parent = cameFrom;
      otherSearchState.distanceToSource = tentativeDistance;
    }
  }
}

},{"./NodeHeap":21,"./defaultSettings":24,"./heuristics":25,"./makeSearchStatePool":26}],23:[function(require,module,exports){
/**
 * Performs a uni-directional A Star search on graph.
 * 
 * We will try to minimize f(n) = g(n) + h(n), where
 * g(n) is actual distance from source node to `n`, and
 * h(n) is heuristic distance from `n` to target node.
 */
module.exports = aStarPathSearch;

var NodeHeap = require('./NodeHeap');
var makeSearchStatePool = require('./makeSearchStatePool');
var heuristics = require('./heuristics');
var defaultSettings = require('./defaultSettings.js');

var NO_PATH = defaultSettings.NO_PATH;

module.exports.l2 = heuristics.l2;
module.exports.l1 = heuristics.l1;

/**
 * Creates a new instance of pathfinder. A pathfinder has just one method:
 * `find(fromId, toId)`, it may be extended in future.
 * 
 * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph
 * @param {Object} options that configures search
 * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between
 * nodes `a` and `b`. This function should never overestimate actual distance between two
 * nodes (otherwise the found path will not be the shortest). Defaults function returns 0,
 * which makes this search equivalent to Dijkstra search.
 * @param {Function(a, b)} options.distance - a function that returns actual distance between two
 * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);
 * @param {Boolean} options.oriented - whether graph should be considered oriented or not.
 * 
 * @returns {Object} A pathfinder with single method `find()`.
 */
function aStarPathSearch(graph, options) {
  options = options || {};
  // whether traversal should be considered over oriented graph.
  var oriented = options.oriented;

  var heuristic = options.heuristic;
  if (!heuristic) heuristic = defaultSettings.heuristic;

  var distance = options.distance;
  if (!distance) distance = defaultSettings.distance;
  var pool = makeSearchStatePool();

  return {
    /**
     * Finds a path between node `fromId` and `toId`.
     * @returns {Array} of nodes between `toId` and `fromId`. Empty array is returned
     * if no path is found.
     */
    find: find
  };

  function find(fromId, toId) {
    var from = graph.getNode(fromId);
    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);
    var to = graph.getNode(toId);
    if (!to) throw new Error('toId is not defined in this graph: ' + toId);
    pool.reset();

    // Maps nodeId to NodeSearchState.
    var nodeState = new Map();

    // the nodes that we still need to evaluate
    var openSet = new NodeHeap({
      compare: defaultSettings.compareFScore,
      setNodeId: defaultSettings.setHeapIndex
    });

    var startNode = pool.createNewState(from);
    nodeState.set(fromId, startNode);
    
    var visitedLinks = [];

    // For the first node, fScore is completely heuristic.
    startNode.fScore = heuristic(from, to);

    // The cost of going from start to start is zero.
    startNode.distanceToSource = 0;
    openSet.push(startNode);
    startNode.open = 1;

    var cameFrom;

    while (openSet.length > 0) {
      cameFrom = openSet.pop();
      if (goalReached(cameFrom, to)) return {
        path: reconstructPath(cameFrom),
        visited: visitedLinks
      }

      // no need to visit this node anymore
      cameFrom.closed = true;
      graph.forEachLinkedNode(cameFrom.node.id, visitNeighbour, oriented);
    }

    // If we got here, then there is no path.
    return NO_PATH;

    function visitNeighbour(otherNode, link) {
      var otherSearchState = nodeState.get(otherNode.id);
      if (!otherSearchState) {
        otherSearchState = pool.createNewState(otherNode);
        nodeState.set(otherNode.id, otherSearchState);
      }

      if (otherSearchState.closed) {
        // Already processed this node.
        return;
      }
      if (otherSearchState.open === 0) {
        // Remember this node.
        openSet.push(otherSearchState);
        otherSearchState.open = 1;
      }

      var tentativeDistance = cameFrom.distanceToSource + distance(otherNode, cameFrom.node, link);
      if (tentativeDistance >= otherSearchState.distanceToSource) {
        // This would only make our path longer. Ignore this route.
        return;
      }

      // bingo! we found shorter path:
      otherSearchState.parent = cameFrom;
      otherSearchState.distanceToSource = tentativeDistance;
      otherSearchState.fScore = tentativeDistance + heuristic(otherSearchState.node, to);

      visitedLinks.push(cameFrom.node.id);
      visitedLinks.push(otherNode.id);

      openSet.updateItem(otherSearchState.heapIndex);
    }
  }
}

function goalReached(searchState, targetNode) {
  return searchState.node === targetNode;
}

function reconstructPath(searchState) {
  var path = [searchState.node];
  var parent = searchState.parent;

  while (parent) {
    path.push(parent.node);
    parent = parent.parent;
  }
  return path;
}

},{"./NodeHeap":21,"./defaultSettings.js":24,"./heuristics":25,"./makeSearchStatePool":26}],24:[function(require,module,exports){
// We reuse instance of array, but we trie to freeze it as well,
// so that consumers don't modify it. Maybe it's a bad idea.
var NO_PATH = [];
if (typeof Object.freeze === 'function') Object.freeze(NO_PATH);

module.exports = {
  // Path search settings
  heuristic: blindHeuristic,
  distance: constantDistance,
  compareFScore: compareFScore,
  NO_PATH: NO_PATH,

  // heap settings
  setHeapIndex: setHeapIndex,

  // nba:
  setH1: setH1,
  setH2: setH2,
  compareF1Score: compareF1Score,
  compareF2Score: compareF2Score,
}

function blindHeuristic(/* a, b */) {
  // blind heuristic makes this search equal to plain Dijkstra path search.
  return 0;
}

function constantDistance(/* a, b */) {
  return 1;
}

function compareFScore(a, b) {
  var result = a.fScore - b.fScore;
  // TODO: Can I improve speed with smarter ties-breaking?
  // I tried distanceToSource, but it didn't seem to have much effect
  return result;
}

function setHeapIndex(nodeSearchState, heapIndex) {
  nodeSearchState.heapIndex = heapIndex;
}

function compareF1Score(a, b) {
  return a.f1 - b.f1;
}

function compareF2Score(a, b) {
  return a.f2 - b.f2;
}

function setH1(node, heapIndex) {
  node.h1 = heapIndex;
}

function setH2(node, heapIndex) {
  node.h2 = heapIndex;
}
},{}],25:[function(require,module,exports){
module.exports = {
  l2: l2,
  l1: l1
};

/**
 * Euclid distance (l2 norm);
 * 
 * @param {*} a 
 * @param {*} b 
 */
function l2(a, b) {
  var dx = a.x - b.x;
  var dy = a.y - b.y;
  return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Manhattan distance (l1 norm);
 * @param {*} a 
 * @param {*} b 
 */
function l1(a, b) {
  var dx = a.x - b.x;
  var dy = a.y - b.y;
  return Math.abs(dx) + Math.abs(dy);
}

},{}],26:[function(require,module,exports){
/**
 * This class represents a single search node in the exploration tree for
 * A* algorithm.
 * 
 * @param {Object} node  original node in the graph
 */
function NodeSearchState(node) {
  this.node = node;

  // How we came to this node?
  this.parent = null;

  this.closed = false;
  this.open = 0;

  this.distanceToSource = Number.POSITIVE_INFINITY;
  // the f(n) = g(n) + h(n) value
  this.fScore = Number.POSITIVE_INFINITY;

  // used to reconstruct heap when fScore is updated.
  this.heapIndex = -1;
};

function makeSearchStatePool() {
  var currentInCache = 0;
  var nodeCache = [];

  return {
    createNewState: createNewState,
    reset: reset
  };

  function reset() {
    currentInCache = 0;
  }

  function createNewState(node) {
    var cached = nodeCache[currentInCache];
    if (cached) {
      // TODO: This almost duplicates constructor code. Not sure if
      // it would impact performance if I move this code into a function
      cached.node = node;
      // How we came to this node?
      cached.parent = null;

      cached.closed = false;
      cached.open = 0;

      cached.distanceToSource = Number.POSITIVE_INFINITY;
      // the f(n) = g(n) + h(n) value
      cached.fScore = Number.POSITIVE_INFINITY;

      // used to reconstruct heap when fScore is updated.
      cached.heapIndex = -1;

    } else {
      cached = new NodeSearchState(node);
      nodeCache[currentInCache] = cached;
    }
    currentInCache++;
    return cached;
  }
}
module.exports = makeSearchStatePool;
},{}],27:[function(require,module,exports){
module.exports = nba;

var NodeHeap = require('../NodeHeap');
var heuristics = require('../heuristics');
var defaultSettings = require('../defaultSettings.js');
var makeNBASearchStatePool = require('./makeNBASearchStatePool.js');

var NO_PATH = defaultSettings.NO_PATH;

module.exports.l2 = heuristics.l2;
module.exports.l1 = heuristics.l1;

/**
 * Creates a new instance of pathfinder. A pathfinder has just one method:
 * `find(fromId, toId)`.
 * 
 * This is implementation of the NBA* algorithm described in 
 * 
 *  "Yet another bidirectional algorithm for shortest paths" paper by Wim Pijls and Henk Post
 * 
 * The paper is available here: https://repub.eur.nl/pub/16100/ei2009-10.pdf
 * 
 * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph
 * @param {Object} options that configures search
 * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between
 * nodes `a` and `b`. This function should never overestimate actual distance between two
 * nodes (otherwise the found path will not be the shortest). Defaults function returns 0,
 * which makes this search equivalent to Dijkstra search.
 * @param {Function(a, b)} options.distance - a function that returns actual distance between two
 * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);
 * 
 * @returns {Object} A pathfinder with single method `find()`.
 */
function nba(graph, options) {
  options = options || {};
  // whether traversal should be considered over oriented graph.
  var oriented = options.oriented;
  var quitFast = options.quitFast;

  var heuristic = options.heuristic;
  if (!heuristic) heuristic = defaultSettings.heuristic;

  var distance = options.distance;
  if (!distance) distance = defaultSettings.distance;

  // During stress tests I noticed that garbage collection was one of the heaviest
  // contributors to the algorithm's speed. So I'm using an object pool to recycle nodes.
  var pool = makeNBASearchStatePool();

  return {
    /**
     * Finds a path between node `fromId` and `toId`.
     * @returns {Array} of nodes between `toId` and `fromId`. Empty array is returned
     * if no path is found.
     */
    find: find
  };

  function find(fromId, toId) {
    // I must apologize for the code duplication. This was the easiest way for me to
    // implement the algorithm fast.
    var from = graph.getNode(fromId);
    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);
    var to = graph.getNode(toId);
    if (!to) throw new Error('toId is not defined in this graph: ' + toId);

    pool.reset();

    // I must also apologize for somewhat cryptic names. The NBA* is bi-directional
    // search algorithm, which means it runs two searches in parallel. One is called
    // forward search and it runs from source node to target, while the other one
    // (backward search) runs from target to source.

    // Everywhere where you see `1` it means it's for the forward search. `2` is for 
    // backward search.

    // For oriented graph path finding, we need to reverse the graph, so that
    // backward search visits correct link. Obviously we don't want to duplicate
    // the graph, instead we always traverse the graph as non-oriented, and filter
    // edges in `visitN1Oriented/visitN2Oritented`
    var forwardVisitor = oriented ? visitN1Oriented : visitN1;
    var reverseVisitor = oriented ? visitN2Oriented : visitN2;

    // Maps nodeId to NBASearchState.
    var nodeState = new Map();

    // These two heaps store nodes by their underestimated values.
    var open1Set = new NodeHeap({
      compare: defaultSettings.compareF1Score,
      setNodeId: defaultSettings.setH1
    });
    var open2Set = new NodeHeap({
      compare: defaultSettings.compareF2Score,
      setNodeId: defaultSettings.setH2
    });

    // This is where both searches will meet.
    var minNode;

    // The smallest path length seen so far is stored here:
    var lMin = Number.POSITIVE_INFINITY;

    // We start by putting start/end nodes to the corresponding heaps
    // If variable names like `f1`, `g1` are too confusing, please refer
    // to makeNBASearchStatePool.js file, which has detailed description.
    var startNode = pool.createNewState(from);
    nodeState.set(fromId, startNode); 
    startNode.g1 = 0;
    var f1 = heuristic(from, to);
    startNode.f1 = f1;
    open1Set.push(startNode);

    var endNode = pool.createNewState(to);
    nodeState.set(toId, endNode);
    endNode.g2 = 0;
    var f2 = f1; // they should agree originally
    endNode.f2 = f2;
    open2Set.push(endNode)

    // the `cameFrom` variable is accessed by both searches, so that we can store parents.
    var cameFrom;

    // this is the main algorithm loop:
    while (open2Set.length && open1Set.length) {
      if (open1Set.length < open2Set.length) {
        forwardSearch();
      } else {
        reverseSearch();
      }

      if (quitFast && minNode) break;
    }

    var path = reconstructPath(minNode);
    return path; // the public API is over

    function forwardSearch() {
      cameFrom = open1Set.pop();
      if (cameFrom.closed) {
        return;
      }

      cameFrom.closed = true;

      if (cameFrom.f1 < lMin && (cameFrom.g1 + f2 - heuristic(from, cameFrom.node)) < lMin) {
        graph.forEachLinkedNode(cameFrom.node.id, forwardVisitor);
      }

      if (open1Set.length > 0) {
        // this will be used in reverse search
        f1 = open1Set.peek().f1;
      } 
    }

    function reverseSearch() {
      cameFrom = open2Set.pop();
      if (cameFrom.closed) {
        return;
      }
      cameFrom.closed = true;

      if (cameFrom.f2 < lMin && (cameFrom.g2 + f1 - heuristic(cameFrom.node, to)) < lMin) {
        graph.forEachLinkedNode(cameFrom.node.id, reverseVisitor);
      }

      if (open2Set.length > 0) {
        // this will be used in forward search
        f2 = open2Set.peek().f2;
      }
    }

    function visitN1(otherNode, link) {
      var otherSearchState = nodeState.get(otherNode.id);
      if (!otherSearchState) {
        otherSearchState = pool.createNewState(otherNode);
        nodeState.set(otherNode.id, otherSearchState);
      }

      if (otherSearchState.closed) return;

      var tentativeDistance = cameFrom.g1 + distance(cameFrom.node, otherNode, link);

      if (tentativeDistance < otherSearchState.g1) {
        otherSearchState.g1 = tentativeDistance;
        otherSearchState.f1 = tentativeDistance + heuristic(otherSearchState.node, to);
        otherSearchState.p1 = cameFrom;
        if (otherSearchState.h1 < 0) {
          open1Set.push(otherSearchState);
        } else {
          open1Set.updateItem(otherSearchState.h1);
        }
      }
      var potentialMin = otherSearchState.g1 + otherSearchState.g2;
      if (potentialMin < lMin) { 
        lMin = potentialMin;
        minNode = otherSearchState;
      }
    }

    function visitN2(otherNode, link) {
      var otherSearchState = nodeState.get(otherNode.id);
      if (!otherSearchState) {
        otherSearchState = pool.createNewState(otherNode);
        nodeState.set(otherNode.id, otherSearchState);
      }

      if (otherSearchState.closed) return;

      var tentativeDistance = cameFrom.g2 + distance(cameFrom.node, otherNode, link);

      if (tentativeDistance < otherSearchState.g2) {
        otherSearchState.g2 = tentativeDistance;
        otherSearchState.f2 = tentativeDistance + heuristic(from, otherSearchState.node);
        otherSearchState.p2 = cameFrom;
        if (otherSearchState.h2 < 0) {
          open2Set.push(otherSearchState);
        } else {
          open2Set.updateItem(otherSearchState.h2);
        }
      }
      var potentialMin = otherSearchState.g1 + otherSearchState.g2;
      if (potentialMin < lMin) {
        lMin = potentialMin;
        minNode = otherSearchState;
      }
    }

    function visitN2Oriented(otherNode, link) {
      // we are going backwards, graph needs to be reversed. 
      if (link.toId === cameFrom.node.id) return visitN2(otherNode, link);
    }
    function visitN1Oriented(otherNode, link) {
      // this is forward direction, so we should be coming FROM:
      if (link.fromId === cameFrom.node.id) return visitN1(otherNode, link);
    }
  }
}

function reconstructPath(searchState) {
  if (!searchState) return NO_PATH;

  var path = [searchState.node];
  var parent = searchState.p1;

  while (parent) {
    path.push(parent.node);
    parent = parent.p1;
  }

  var child = searchState.p2;

  while (child) {
    path.unshift(child.node);
    child = child.p2;
  }
  return path;
}

},{"../NodeHeap":21,"../defaultSettings.js":24,"../heuristics":25,"./makeNBASearchStatePool.js":28}],28:[function(require,module,exports){
module.exports = makeNBASearchStatePool;

/**
 * Creates new instance of NBASearchState. The instance stores information
 * about search state, and is used by NBA* algorithm.
 *
 * @param {Object} node - original graph node
 */
function NBASearchState(node) {
  /**
   * Original graph node.
   */
  this.node = node;

  /**
   * Parent of this node in forward search
   */
  this.p1 = null;

  /**
   * Parent of this node in reverse search
   */
  this.p2 = null;

  /**
   * If this is set to true, then the node was already processed
   * and we should not touch it anymore.
   */
  this.closed = false;

  /**
   * Actual distance from this node to its parent in forward search
   */
  this.g1 = Number.POSITIVE_INFINITY;

  /**
   * Actual distance from this node to its parent in reverse search
   */
  this.g2 = Number.POSITIVE_INFINITY;


  /**
   * Underestimated distance from this node to the path-finding source.
   */
  this.f1 = Number.POSITIVE_INFINITY;

  /**
   * Underestimated distance from this node to the path-finding target.
   */
  this.f2 = Number.POSITIVE_INFINITY;

  // used to reconstruct heap when fScore is updated. TODO: do I need them both?

  /**
   * Index of this node in the forward heap.
   */
  this.h1 = -1;

  /**
   * Index of this node in the reverse heap.
   */
  this.h2 = -1;
}

/**
 * As path-finding is memory-intensive process, we want to reduce pressure on
 * garbage collector. This class helps us to recycle path-finding nodes and significantly
 * reduces the search time (~20% faster than without it).
 */
function makeNBASearchStatePool() {
  var currentInCache = 0;
  var nodeCache = [];

  return {
    /**
     * Creates a new NBASearchState instance
     */
    createNewState: createNewState,

    /**
     * Marks all created instances available for recycling.
     */
    reset: reset
  };

  function reset() {
    currentInCache = 0;
  }

  function createNewState(node) {
    var cached = nodeCache[currentInCache];
    if (cached) {
      // TODO: This almost duplicates constructor code. Not sure if
      // it would impact performance if I move this code into a function
      cached.node = node;

      // How we came to this node?
      cached.p1 = null;
      cached.p2 = null;

      cached.closed = false;

      cached.g1 = Number.POSITIVE_INFINITY;
      cached.g2 = Number.POSITIVE_INFINITY;
      cached.f1 = Number.POSITIVE_INFINITY;
      cached.f2 = Number.POSITIVE_INFINITY;

      // used to reconstruct heap when fScore is updated.
      cached.h1 = -1;
      cached.h2 = -1;
    } else {
      cached = new NBASearchState(node);
      nodeCache[currentInCache] = cached;
    }
    currentInCache++;
    return cached;
  }
}

},{}],29:[function(require,module,exports){
module.exports = {
  aStar: require('./a-star/a-star.js'),
  aGreedy: require('./a-star/a-greedy-star'),
  nba: require('./a-star/nba/index.js'),
}

},{"./a-star/a-greedy-star":22,"./a-star/a-star.js":23,"./a-star/nba/index.js":27}],30:[function(require,module,exports){
/*!
 * @license twgl.js 4.19.1 Copyright (c) 2015, Gregg Tavares All Rights Reserved.
 * Available via the MIT license.
 * see: http://github.com/greggman/twgl.js for details
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["twgl"] = factory();
	else
		root["twgl"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/twgl-full.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/attributes.js":
/*!***************************!*\
  !*** ./src/attributes.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.createAttribsFromArrays = createAttribsFromArrays;
exports.createBuffersFromArrays = createBuffersFromArrays;
exports.createBufferFromArray = createBufferFromArray;
exports.createBufferFromTypedArray = createBufferFromTypedArray;
exports.createBufferInfoFromArrays = createBufferInfoFromArrays;
exports.setAttribInfoBufferFromArray = setAttribInfoBufferFromArray;
exports.setAttributePrefix = setAttributePrefix;
exports.setAttributeDefaults_ = setDefaults;
exports.getNumComponents_ = getNumComponents;
exports.getArray_ = getArray;

var typedArrays = _interopRequireWildcard(__webpack_require__(/*! ./typedarrays.js */ "./src/typedarrays.js"));

var helper = _interopRequireWildcard(__webpack_require__(/*! ./helper.js */ "./src/helper.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
var STATIC_DRAW = 0x88e4;
var ARRAY_BUFFER = 0x8892;
var ELEMENT_ARRAY_BUFFER = 0x8893;
var BUFFER_SIZE = 0x8764;
var BYTE = 0x1400;
var UNSIGNED_BYTE = 0x1401;
var SHORT = 0x1402;
var UNSIGNED_SHORT = 0x1403;
var INT = 0x1404;
var UNSIGNED_INT = 0x1405;
var FLOAT = 0x1406;
/**
 * Low level attribute and buffer related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.attributes` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/attributes
 */
// make sure we don't see a global gl

var gl = undefined;
/* eslint-disable-line */

var defaults = {
  attribPrefix: ""
};
/**
 * Sets the default attrib prefix
 *
 * When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`
 * as it makes it clear where they came from. But, when building geometry I prefer using un-prefixed names.
 *
 * In other words I'll create arrays of geometry like this
 *
 *     var arrays = {
 *       position: ...
 *       normal: ...
 *       texcoord: ...
 *     };
 *
 * But need those mapped to attributes and my attributes start with `a_`.
 *
 * @deprecated see {@link module:twgl.setDefaults}
 * @param {string} prefix prefix for attribs
 * @memberOf module:twgl/attributes
 */

function setAttributePrefix(prefix) {
  defaults.attribPrefix = prefix;
}

function setDefaults(newDefaults) {
  helper.copyExistingProperties(newDefaults, defaults);
}

function setBufferFromTypedArray(gl, type, buffer, array, drawType) {
  gl.bindBuffer(type, buffer);
  gl.bufferData(type, array, drawType || STATIC_DRAW);
}
/**
 * Given typed array creates a WebGLBuffer and copies the typed array
 * into it.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {ArrayBuffer|SharedArrayBuffer|ArrayBufferView|WebGLBuffer} typedArray the typed array. Note: If a WebGLBuffer is passed in it will just be returned. No action will be taken
 * @param {number} [type] the GL bind type for the buffer. Default = `gl.ARRAY_BUFFER`.
 * @param {number} [drawType] the GL draw type for the buffer. Default = 'gl.STATIC_DRAW`.
 * @return {WebGLBuffer} the created WebGLBuffer
 * @memberOf module:twgl/attributes
 */


function createBufferFromTypedArray(gl, typedArray, type, drawType) {
  if (helper.isBuffer(gl, typedArray)) {
    return typedArray;
  }

  type = type || ARRAY_BUFFER;
  var buffer = gl.createBuffer();
  setBufferFromTypedArray(gl, type, buffer, typedArray, drawType);
  return buffer;
}

function isIndices(name) {
  return name === "indices";
} // This is really just a guess. Though I can't really imagine using
// anything else? Maybe for some compression?


function getNormalizationForTypedArray(typedArray) {
  if (typedArray instanceof Int8Array) {
    return true;
  } // eslint-disable-line


  if (typedArray instanceof Uint8Array) {
    return true;
  } // eslint-disable-line


  return false;
} // This is really just a guess. Though I can't really imagine using
// anything else? Maybe for some compression?


function getNormalizationForTypedArrayType(typedArrayType) {
  if (typedArrayType === Int8Array) {
    return true;
  } // eslint-disable-line


  if (typedArrayType === Uint8Array) {
    return true;
  } // eslint-disable-line


  return false;
}

function getArray(array) {
  return array.length ? array : array.data;
}

var texcoordRE = /coord|texture/i;
var colorRE = /color|colour/i;

function guessNumComponentsFromName(name, length) {
  var numComponents;

  if (texcoordRE.test(name)) {
    numComponents = 2;
  } else if (colorRE.test(name)) {
    numComponents = 4;
  } else {
    numComponents = 3; // position, normals, indices ...
  }

  if (length % numComponents > 0) {
    throw new Error("Can not guess numComponents for attribute '".concat(name, "'. Tried ").concat(numComponents, " but ").concat(length, " values is not evenly divisible by ").concat(numComponents, ". You should specify it."));
  }

  return numComponents;
}

function getNumComponents(array, arrayName) {
  return array.numComponents || array.size || guessNumComponentsFromName(arrayName, getArray(array).length);
}

function makeTypedArray(array, name) {
  if (typedArrays.isArrayBuffer(array)) {
    return array;
  }

  if (typedArrays.isArrayBuffer(array.data)) {
    return array.data;
  }

  if (Array.isArray(array)) {
    array = {
      data: array
    };
  }

  var Type = array.type;

  if (!Type) {
    if (isIndices(name)) {
      Type = Uint16Array;
    } else {
      Type = Float32Array;
    }
  }

  return new Type(array.data);
}
/**
 * The info for an attribute. This is effectively just the arguments to `gl.vertexAttribPointer` plus the WebGLBuffer
 * for the attribute.
 *
 * @typedef {Object} AttribInfo
 * @property {number[]|ArrayBufferView} [value] a constant value for the attribute. Note: if this is set the attribute will be
 *    disabled and set to this constant value and all other values will be ignored.
 * @property {number} [numComponents] the number of components for this attribute.
 * @property {number} [size] synonym for `numComponents`.
 * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`
 * @property {boolean} [normalize] whether or not to normalize the data. Default = false
 * @property {number} [offset] offset into buffer in bytes. Default = 0
 * @property {number} [stride] the stride in bytes per element. Default = 0
 * @property {number} [divisor] the divisor in instances. Default = undefined. Note: undefined = don't call gl.vertexAttribDivisor
 *    where as anything else = do call it with this value
 * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute
 * @property {number} [drawType] the draw type passed to gl.bufferData. Default = gl.STATIC_DRAW
 * @memberOf module:twgl
 */

/**
 * Use this type of array spec when TWGL can't guess the type or number of components of an array
 * @typedef {Object} FullArraySpec
 * @property {number[]|ArrayBufferView} [value] a constant value for the attribute. Note: if this is set the attribute will be
 *    disabled and set to this constant value and all other values will be ignored.
 * @property {(number|number[]|ArrayBufferView)} data The data of the array. A number alone becomes the number of elements of type.
 * @property {number} [numComponents] number of components for `vertexAttribPointer`. Default is based on the name of the array.
 *    If `coord` is in the name assumes `numComponents = 2`.
 *    If `color` is in the name assumes `numComponents = 4`.
 *    otherwise assumes `numComponents = 3`
 * @property {constructor} [type] type. This is only used if `data` is a JavaScript array. It is the constructor for the typedarray. (eg. `Uint8Array`).
 * For example if you want colors in a `Uint8Array` you might have a `FullArraySpec` like `{ type: Uint8Array, data: [255,0,255,255, ...], }`.
 * @property {number} [size] synonym for `numComponents`.
 * @property {boolean} [normalize] normalize for `vertexAttribPointer`. Default is true if type is `Int8Array` or `Uint8Array` otherwise false.
 * @property {number} [stride] stride for `vertexAttribPointer`. Default = 0
 * @property {number} [offset] offset for `vertexAttribPointer`. Default = 0
 * @property {number} [divisor] divisor for `vertexAttribDivisor`. Default = undefined. Note: undefined = don't call gl.vertexAttribDivisor
 *    where as anything else = do call it with this value
 * @property {string} [attrib] name of attribute this array maps to. Defaults to same name as array prefixed by the default attribPrefix.
 * @property {string} [name] synonym for `attrib`.
 * @property {string} [attribName] synonym for `attrib`.
 * @property {WebGLBuffer} [buffer] Buffer to use for this attribute. This lets you use your own buffer
 *    but you will need to supply `numComponents` and `type`. You can effectively pass an `AttribInfo`
 *    to provide this. Example:
 *
 *         const bufferInfo1 = twgl.createBufferInfoFromArrays(gl, {
 *           position: [1, 2, 3, ... ],
 *         });
 *         const bufferInfo2 = twgl.createBufferInfoFromArrays(gl, {
 *           position: bufferInfo1.attribs.position,  // use the same buffer from bufferInfo1
 *         });
 *
 * @memberOf module:twgl
 */

/**
 * An individual array in {@link module:twgl.Arrays}
 *
 * When passed to {@link module:twgl.createBufferInfoFromArrays} if an ArraySpec is `number[]` or `ArrayBufferView`
 * the types will be guessed based on the name. `indices` will be `Uint16Array`, everything else will
 * be `Float32Array`. If an ArraySpec is a number it's the number of floats for an empty (zeroed) buffer.
 *
 * @typedef {(number|number[]|ArrayBufferView|module:twgl.FullArraySpec)} ArraySpec
 * @memberOf module:twgl
 */

/**
 * This is a JavaScript object of arrays by name. The names should match your shader's attributes. If your
 * attributes have a common prefix you can specify it by calling {@link module:twgl.setAttributePrefix}.
 *
 *     Bare JavaScript Arrays
 *
 *         var arrays = {
 *            position: [-1, 1, 0],
 *            normal: [0, 1, 0],
 *            ...
 *         }
 *
 *     Bare TypedArrays
 *
 *         var arrays = {
 *            position: new Float32Array([-1, 1, 0]),
 *            color: new Uint8Array([255, 128, 64, 255]),
 *            ...
 *         }
 *
 * *   Will guess at `numComponents` if not specified based on name.
 *
 *     If `coord` is in the name assumes `numComponents = 2`
 *
 *     If `color` is in the name assumes `numComponents = 4`
 *
 *     otherwise assumes `numComponents = 3`
 *
 * Objects with various fields. See {@link module:twgl.FullArraySpec}.
 *
 *     var arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *     };
 *
 * @typedef {Object.<string, module:twgl.ArraySpec>} Arrays
 * @memberOf module:twgl
 */

/**
 * Creates a set of attribute data and WebGLBuffers from set of arrays
 *
 * Given
 *
 *      var arrays = {
 *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },
 *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *      };
 *
 * returns something like
 *
 *      var attribs = {
 *        position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },
 *      };
 *
 * notes:
 *
 * *   Arrays can take various forms
 *
 *     Bare JavaScript Arrays
 *
 *         var arrays = {
 *            position: [-1, 1, 0],
 *            normal: [0, 1, 0],
 *            ...
 *         }
 *
 *     Bare TypedArrays
 *
 *         var arrays = {
 *            position: new Float32Array([-1, 1, 0]),
 *            color: new Uint8Array([255, 128, 64, 255]),
 *            ...
 *         }
 *
 * *   Will guess at `numComponents` if not specified based on name.
 *
 *     If `coord` is in the name assumes `numComponents = 2`
 *
 *     If `color` is in the name assumes `numComponents = 4`
 *
 *     otherwise assumes `numComponents = 3`
 *
 * @param {WebGLRenderingContext} gl The webgl rendering context.
 * @param {module:twgl.Arrays} arrays The arrays
 * @param {module:twgl.BufferInfo} [srcBufferInfo] a BufferInfo to copy from
 *   This lets you share buffers. Any arrays you supply will override
 *   the buffers from srcBufferInfo.
 * @return {Object.<string, module:twgl.AttribInfo>} the attribs
 * @memberOf module:twgl/attributes
 */


function createAttribsFromArrays(gl, arrays) {
  var attribs = {};
  Object.keys(arrays).forEach(function (arrayName) {
    if (!isIndices(arrayName)) {
      var array = arrays[arrayName];
      var attribName = array.attrib || array.name || array.attribName || defaults.attribPrefix + arrayName;

      if (array.value) {
        if (!Array.isArray(array.value) && !typedArrays.isArrayBuffer(array.value)) {
          throw new Error('array.value is not array or typedarray');
        }

        attribs[attribName] = {
          value: array.value
        };
      } else {
        var buffer;
        var type;
        var normalization;
        var numComponents;

        if (array.buffer && array.buffer instanceof WebGLBuffer) {
          buffer = array.buffer;
          numComponents = array.numComponents || array.size;
          type = array.type;
          normalization = array.normalize;
        } else if (typeof array === "number" || typeof array.data === "number") {
          var numValues = array.data || array;
          var arrayType = array.type || Float32Array;
          var numBytes = numValues * arrayType.BYTES_PER_ELEMENT;
          type = typedArrays.getGLTypeForTypedArrayType(arrayType);
          normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArrayType(arrayType);
          numComponents = array.numComponents || array.size || guessNumComponentsFromName(arrayName, numValues);
          buffer = gl.createBuffer();
          gl.bindBuffer(ARRAY_BUFFER, buffer);
          gl.bufferData(ARRAY_BUFFER, numBytes, array.drawType || STATIC_DRAW);
        } else {
          var typedArray = makeTypedArray(array, arrayName);
          buffer = createBufferFromTypedArray(gl, typedArray, undefined, array.drawType);
          type = typedArrays.getGLTypeForTypedArray(typedArray);
          normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArray(typedArray);
          numComponents = getNumComponents(array, arrayName);
        }

        attribs[attribName] = {
          buffer: buffer,
          numComponents: numComponents,
          type: type,
          normalize: normalization,
          stride: array.stride || 0,
          offset: array.offset || 0,
          divisor: array.divisor === undefined ? undefined : array.divisor,
          drawType: array.drawType
        };
      }
    }
  });
  gl.bindBuffer(ARRAY_BUFFER, null);
  return attribs;
}
/**
 * Sets the contents of a buffer attached to an attribInfo
 *
 * This is helper function to dynamically update a buffer.
 *
 * Let's say you make a bufferInfo
 *
 *     var arrays = {
 *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),
 *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),
 *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),
 *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),
 *     };
 *     var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
 *
 *  And you want to dynamically update the positions. You could do this
 *
 *     // assuming arrays.position has already been updated with new data.
 *     twgl.setAttribInfoBufferFromArray(gl, bufferInfo.attribs.position, arrays.position);
 *
 * @param {WebGLRenderingContext} gl
 * @param {AttribInfo} attribInfo The attribInfo who's buffer contents to set. NOTE: If you have an attribute prefix
 *   the name of the attribute will include the prefix.
 * @param {ArraySpec} array Note: it is arguably inefficient to pass in anything but a typed array because anything
 *    else will have to be converted to a typed array before it can be used by WebGL. During init time that
 *    inefficiency is usually not important but if you're updating data dynamically best to be efficient.
 * @param {number} [offset] an optional offset into the buffer. This is only an offset into the WebGL buffer
 *    not the array. To pass in an offset into the array itself use a typed array and create an `ArrayBufferView`
 *    for the portion of the array you want to use.
 *
 *        var someArray = new Float32Array(1000); // an array with 1000 floats
 *        var someSubArray = new Float32Array(someArray.buffer, offsetInBytes, sizeInUnits); // a view into someArray
 *
 *    Now you can pass `someSubArray` into setAttribInfoBufferFromArray`
 * @memberOf module:twgl/attributes
 */


function setAttribInfoBufferFromArray(gl, attribInfo, array, offset) {
  array = makeTypedArray(array);

  if (offset !== undefined) {
    gl.bindBuffer(ARRAY_BUFFER, attribInfo.buffer);
    gl.bufferSubData(ARRAY_BUFFER, offset, array);
  } else {
    setBufferFromTypedArray(gl, ARRAY_BUFFER, attribInfo.buffer, array, attribInfo.drawType);
  }
}

function getBytesPerValueForGLType(gl, type) {
  if (type === BYTE) return 1; // eslint-disable-line

  if (type === UNSIGNED_BYTE) return 1; // eslint-disable-line

  if (type === SHORT) return 2; // eslint-disable-line

  if (type === UNSIGNED_SHORT) return 2; // eslint-disable-line

  if (type === INT) return 4; // eslint-disable-line

  if (type === UNSIGNED_INT) return 4; // eslint-disable-line

  if (type === FLOAT) return 4; // eslint-disable-line

  return 0;
} // Tries to get the number of elements from a set of arrays.


var positionKeys = ['position', 'positions', 'a_position'];

function getNumElementsFromNonIndexedArrays(arrays) {
  var key;
  var ii;

  for (ii = 0; ii < positionKeys.length; ++ii) {
    key = positionKeys[ii];

    if (key in arrays) {
      break;
    }
  }

  if (ii === positionKeys.length) {
    key = Object.keys(arrays)[0];
  }

  var array = arrays[key];
  var length = getArray(array).length;
  var numComponents = getNumComponents(array, key);
  var numElements = length / numComponents;

  if (length % numComponents > 0) {
    throw new Error("numComponents ".concat(numComponents, " not correct for length ").concat(length));
  }

  return numElements;
}

function getNumElementsFromAttributes(gl, attribs) {
  var key;
  var ii;

  for (ii = 0; ii < positionKeys.length; ++ii) {
    key = positionKeys[ii];

    if (key in attribs) {
      break;
    }

    key = defaults.attribPrefix + key;

    if (key in attribs) {
      break;
    }
  }

  if (ii === positionKeys.length) {
    key = Object.keys(attribs)[0];
  }

  var attrib = attribs[key];
  gl.bindBuffer(ARRAY_BUFFER, attrib.buffer);
  var numBytes = gl.getBufferParameter(ARRAY_BUFFER, BUFFER_SIZE);
  gl.bindBuffer(ARRAY_BUFFER, null);
  var bytesPerValue = getBytesPerValueForGLType(gl, attrib.type);
  var totalElements = numBytes / bytesPerValue;
  var numComponents = attrib.numComponents || attrib.size; // TODO: check stride

  var numElements = totalElements / numComponents;

  if (numElements % 1 !== 0) {
    throw new Error("numComponents ".concat(numComponents, " not correct for length ").concat(length));
  }

  return numElements;
}
/**
 * @typedef {Object} BufferInfo
 * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.
 * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..
 * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.
 * @property {Object.<string, module:twgl.AttribInfo>} [attribs] The attribs appropriate to call `setAttributes`
 * @memberOf module:twgl
 */

/**
 * Creates a BufferInfo from an object of arrays.
 *
 * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to
 * {@link module:twgl:drawBufferInfo}.
 *
 * Given an object like
 *
 *     var arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *     };
 *
 *  Creates an BufferInfo like this
 *
 *     bufferInfo = {
 *       numElements: 4,        // or whatever the number of elements is
 *       indices: WebGLBuffer,  // this property will not exist if there are no indices
 *       attribs: {
 *         position: { buffer: WebGLBuffer, numComponents: 3, },
 *         normal:   { buffer: WebGLBuffer, numComponents: 3, },
 *         texcoord: { buffer: WebGLBuffer, numComponents: 2, },
 *       },
 *     };
 *
 *  The properties of arrays can be JavaScript arrays in which case the number of components
 *  will be guessed.
 *
 *     var arrays = {
 *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],
 *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],
 *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
 *        indices:  [0, 1, 2, 1, 2, 3],
 *     };
 *
 *  They can also be TypedArrays
 *
 *     var arrays = {
 *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),
 *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),
 *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),
 *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),
 *     };
 *
 *  Or AugmentedTypedArrays
 *
 *     var positions = createAugmentedTypedArray(3, 4);
 *     var texcoords = createAugmentedTypedArray(2, 4);
 *     var normals   = createAugmentedTypedArray(3, 4);
 *     var indices   = createAugmentedTypedArray(3, 2, Uint16Array);
 *
 *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);
 *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);
 *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
 *     indices.push([0, 1, 2, 1, 2, 3]);
 *
 *     var arrays = {
 *        position: positions,
 *        texcoord: texcoords,
 *        normal:   normals,
 *        indices:  indices,
 *     };
 *
 * For the last example it is equivalent to
 *
 *     var bufferInfo = {
 *       attribs: {
 *         position: { numComponents: 3, buffer: gl.createBuffer(), },
 *         texcoord: { numComponents: 2, buffer: gl.createBuffer(), },
 *         normal: { numComponents: 3, buffer: gl.createBuffer(), },
 *       },
 *       indices: gl.createBuffer(),
 *       numElements: 6,
 *     };
 *
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.position.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.texcoord.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.normal.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);
 *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.Arrays} arrays Your data
 * @param {module:twgl.BufferInfo} [srcBufferInfo] An existing
 *        buffer info to start from. WebGLBuffers etc specified
 *        in the srcBufferInfo will be used in a new BufferInfo
 *        with any arrays specified overriding the ones in
 *        srcBufferInfo.
 * @return {module:twgl.BufferInfo} A BufferInfo
 * @memberOf module:twgl/attributes
 */


function createBufferInfoFromArrays(gl, arrays, srcBufferInfo) {
  var newAttribs = createAttribsFromArrays(gl, arrays);
  var bufferInfo = Object.assign({}, srcBufferInfo ? srcBufferInfo : {});
  bufferInfo.attribs = Object.assign({}, srcBufferInfo ? srcBufferInfo.attribs : {}, newAttribs);
  var indices = arrays.indices;

  if (indices) {
    var newIndices = makeTypedArray(indices, "indices");
    bufferInfo.indices = createBufferFromTypedArray(gl, newIndices, ELEMENT_ARRAY_BUFFER);
    bufferInfo.numElements = newIndices.length;
    bufferInfo.elementType = typedArrays.getGLTypeForTypedArray(newIndices);
  } else if (!bufferInfo.numElements) {
    bufferInfo.numElements = getNumElementsFromAttributes(gl, bufferInfo.attribs);
  }

  return bufferInfo;
}
/**
 * Creates a buffer from an array, typed array, or array spec
 *
 * Given something like this
 *
 *     [1, 2, 3],
 *
 * or
 *
 *     new Uint16Array([1,2,3]);
 *
 * or
 *
 *     {
 *        data: [1, 2, 3],
 *        type: Uint8Array,
 *     }
 *
 * returns a WebGLBuffer that contains the given data.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {module:twgl.ArraySpec} array an array, typed array, or array spec.
 * @param {string} arrayName name of array. Used to guess the type if type can not be derived otherwise.
 * @return {WebGLBuffer} a WebGLBuffer containing the data in array.
 * @memberOf module:twgl/attributes
 */


function createBufferFromArray(gl, array, arrayName) {
  var type = arrayName === "indices" ? ELEMENT_ARRAY_BUFFER : ARRAY_BUFFER;
  var typedArray = makeTypedArray(array, arrayName);
  return createBufferFromTypedArray(gl, typedArray, type);
}
/**
 * Creates buffers from arrays or typed arrays
 *
 * Given something like this
 *
 *     var arrays = {
 *        positions: [1, 2, 3],
 *        normals: [0, 0, 1],
 *     }
 *
 * returns something like
 *
 *     buffers = {
 *       positions: WebGLBuffer,
 *       normals: WebGLBuffer,
 *     }
 *
 * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {module:twgl.Arrays} arrays
 * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array
 * @memberOf module:twgl/attributes
 */


function createBuffersFromArrays(gl, arrays) {
  var buffers = {};
  Object.keys(arrays).forEach(function (key) {
    buffers[key] = createBufferFromArray(gl, arrays[key], key);
  }); // Ugh!

  if (arrays.indices) {
    buffers.numElements = arrays.indices.length;
    buffers.elementType = typedArrays.getGLTypeForTypedArray(makeTypedArray(arrays.indices), 'indices');
  } else {
    buffers.numElements = getNumElementsFromNonIndexedArrays(arrays);
  }

  return buffers;
}

/***/ }),

/***/ "./src/draw.js":
/*!*********************!*\
  !*** ./src/draw.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.drawBufferInfo = drawBufferInfo;
exports.drawObjectList = drawObjectList;

var programs = _interopRequireWildcard(__webpack_require__(/*! ./programs.js */ "./src/programs.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
var TRIANGLES = 0x0004;
var UNSIGNED_SHORT = 0x1403;
/**
 * Drawing related functions
 *
 * For backward compatibility they are available at both `twgl.draw` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/draw
 */

/**
 * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate
 *
 * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself
 * but calling this means if you switch from indexed data to non-indexed
 * data you don't have to remember to update your draw call.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} bufferInfo A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays} or
 *   a VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}
 * @param {number} [type] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...). Defaults to `gl.TRIANGLES`
 * @param {number} [count] An optional count. Defaults to bufferInfo.numElements
 * @param {number} [offset] An optional offset. Defaults to 0.
 * @param {number} [instanceCount] An optional instanceCount. if set then `drawArraysInstanced` or `drawElementsInstanced` will be called
 * @memberOf module:twgl/draw
 */

function drawBufferInfo(gl, bufferInfo, type, count, offset, instanceCount) {
  type = type === undefined ? TRIANGLES : type;
  var indices = bufferInfo.indices;
  var elementType = bufferInfo.elementType;
  var numElements = count === undefined ? bufferInfo.numElements : count;
  offset = offset === undefined ? 0 : offset;

  if (elementType || indices) {
    if (instanceCount !== undefined) {
      gl.drawElementsInstanced(type, numElements, elementType === undefined ? UNSIGNED_SHORT : bufferInfo.elementType, offset, instanceCount);
    } else {
      gl.drawElements(type, numElements, elementType === undefined ? UNSIGNED_SHORT : bufferInfo.elementType, offset);
    }
  } else {
    if (instanceCount !== undefined) {
      gl.drawArraysInstanced(type, offset, numElements, instanceCount);
    } else {
      gl.drawArrays(type, offset, numElements);
    }
  }
}
/**
 * A DrawObject is useful for putting objects in to an array and passing them to {@link module:twgl.drawObjectList}.
 *
 * You need either a `BufferInfo` or a `VertexArrayInfo`.
 *
 * @typedef {Object} DrawObject
 * @property {boolean} [active] whether or not to draw. Default = `true` (must be `false` to be not true). In other words `undefined` = `true`
 * @property {number} [type] type to draw eg. `gl.TRIANGLES`, `gl.LINES`, etc...
 * @property {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}
 * @property {module:twgl.BufferInfo} [bufferInfo] A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays}
 * @property {module:twgl.VertexArrayInfo} [vertexArrayInfo] A VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}
 * @property {Object<string, ?>} uniforms The values for the uniforms.
 *   You can pass multiple objects by putting them in an array. For example
 *
 *     var sharedUniforms = {
 *       u_fogNear: 10,
 *       u_projection: ...
 *       ...
 *     };
 *
 *     var localUniforms = {
 *       u_world: ...
 *       u_diffuseColor: ...
 *     };
 *
 *     var drawObj = {
 *       ...
 *       uniforms: [sharedUniforms, localUniforms],
 *     };
 *
 * @property {number} [offset] the offset to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to 0.
 * @property {number} [count] the count to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to bufferInfo.numElements.
 * @property {number} [instanceCount] the number of instances. Defaults to undefined.
 * @memberOf module:twgl
 */

/**
 * Draws a list of objects
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {DrawObject[]} objectsToDraw an array of objects to draw.
 * @memberOf module:twgl/draw
 */


function drawObjectList(gl, objectsToDraw) {
  var lastUsedProgramInfo = null;
  var lastUsedBufferInfo = null;
  objectsToDraw.forEach(function (object) {
    if (object.active === false) {
      return;
    }

    var programInfo = object.programInfo;
    var bufferInfo = object.vertexArrayInfo || object.bufferInfo;
    var bindBuffers = false;
    var type = object.type === undefined ? TRIANGLES : object.type;

    if (programInfo !== lastUsedProgramInfo) {
      lastUsedProgramInfo = programInfo;
      gl.useProgram(programInfo.program); // We have to rebind buffers when changing programs because we
      // only bind buffers the program uses. So if 2 programs use the same
      // bufferInfo but the 1st one uses only positions the when the
      // we switch to the 2nd one some of the attributes will not be on.

      bindBuffers = true;
    } // Setup all the needed attributes.


    if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {
      if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject && !bufferInfo.vertexArrayObject) {
        gl.bindVertexArray(null);
      }

      lastUsedBufferInfo = bufferInfo;
      programs.setBuffersAndAttributes(gl, programInfo, bufferInfo);
    } // Set the uniforms.


    programs.setUniforms(programInfo, object.uniforms); // Draw

    drawBufferInfo(gl, bufferInfo, type, object.count, object.offset, object.instanceCount);
  });

  if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject) {
    gl.bindVertexArray(null);
  }
}

/***/ }),

/***/ "./src/framebuffers.js":
/*!*****************************!*\
  !*** ./src/framebuffers.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.bindFramebufferInfo = bindFramebufferInfo;
exports.createFramebufferInfo = createFramebufferInfo;
exports.resizeFramebufferInfo = resizeFramebufferInfo;

var textures = _interopRequireWildcard(__webpack_require__(/*! ./textures.js */ "./src/textures.js"));

var helper = _interopRequireWildcard(__webpack_require__(/*! ./helper.js */ "./src/helper.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Framebuffer related functions
 *
 * For backward compatibility they are available at both `twgl.framebuffer` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/framebuffers
 */
// make sure we don't see a global gl
var gl = undefined;
/* eslint-disable-line */

var FRAMEBUFFER = 0x8d40;
var RENDERBUFFER = 0x8d41;
var TEXTURE_2D = 0x0de1;
var UNSIGNED_BYTE = 0x1401;
/* PixelFormat */

var DEPTH_COMPONENT = 0x1902;
var RGBA = 0x1908;
var DEPTH_COMPONENT24 = 0x81a6;
var DEPTH_COMPONENT32F = 0x8cac;
var DEPTH24_STENCIL8 = 0x88f0;
var DEPTH32F_STENCIL8 = 0x8cad;
/* Framebuffer Object. */

var RGBA4 = 0x8056;
var RGB5_A1 = 0x8057;
var RGB565 = 0x8D62;
var DEPTH_COMPONENT16 = 0x81A5;
var STENCIL_INDEX = 0x1901;
var STENCIL_INDEX8 = 0x8D48;
var DEPTH_STENCIL = 0x84F9;
var COLOR_ATTACHMENT0 = 0x8CE0;
var DEPTH_ATTACHMENT = 0x8D00;
var STENCIL_ATTACHMENT = 0x8D20;
var DEPTH_STENCIL_ATTACHMENT = 0x821A;
/* TextureWrapMode */

var CLAMP_TO_EDGE = 0x812F;
/* TextureMagFilter */

var LINEAR = 0x2601;
/**
 * The options for a framebuffer attachment.
 *
 * Note: For a `format` that is a texture include all the texture
 * options from {@link module:twgl.TextureOptions} for example
 * `min`, `mag`, `clamp`, etc... Note that unlike {@link module:twgl.TextureOptions}
 * `auto` defaults to `false` for attachment textures but `min` and `mag` default
 * to `gl.LINEAR` and `wrap` defaults to `CLAMP_TO_EDGE`
 *
 * @typedef {Object} AttachmentOptions
 * @property {number} [attachmentPoint] The attachment point. Defaults
 *   to `gl.COLOR_ATTACHMENT0 + ndx` unless type is a depth or stencil type
 *   then it's gl.DEPTH_ATTACHMENT or `gl.DEPTH_STENCIL_ATTACHMENT` depending
 *   on the format or attachment type.
 * @property {number} [format] The format. If one of `gl.RGBA4`,
 *   `gl.RGB565`, `gl.RGB5_A1`, `gl.DEPTH_COMPONENT16`,
 *   `gl.STENCIL_INDEX8` or `gl.DEPTH_STENCIL` then will create a
 *   renderbuffer. Otherwise will create a texture. Default = `gl.RGBA`
 * @property {number} [type] The type. Used for texture. Default = `gl.UNSIGNED_BYTE`.
 * @property {number} [target] The texture target for `gl.framebufferTexture2D`.
 *   Defaults to `gl.TEXTURE_2D`. Set to appropriate face for cube maps.
 * @property {number} [level] level for `gl.framebufferTexture2D`. Defaults to 0.
 * @property {number} [layer] layer for `gl.framebufferTextureLayer`. Defaults to undefined.
 *   If set then `gl.framebufferTextureLayer` is called, if not then `gl.framebufferTexture2D`
 * @property {WebGLObject} [attachment] An existing renderbuffer or texture.
 *    If provided will attach this Object. This allows you to share
 *    attachments across framebuffers.
 * @memberOf module:twgl
 * @mixes module:twgl.TextureOptions
 */

var defaultAttachments = [{
  format: RGBA,
  type: UNSIGNED_BYTE,
  min: LINEAR,
  wrap: CLAMP_TO_EDGE
}, {
  format: DEPTH_STENCIL
}];
var attachmentsByFormat = {};
attachmentsByFormat[DEPTH_STENCIL] = DEPTH_STENCIL_ATTACHMENT;
attachmentsByFormat[STENCIL_INDEX] = STENCIL_ATTACHMENT;
attachmentsByFormat[STENCIL_INDEX8] = STENCIL_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT16] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT24] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT32F] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH24_STENCIL8] = DEPTH_STENCIL_ATTACHMENT;
attachmentsByFormat[DEPTH32F_STENCIL8] = DEPTH_STENCIL_ATTACHMENT;

function getAttachmentPointForFormat(format, internalFormat) {
  return attachmentsByFormat[format] || attachmentsByFormat[internalFormat];
}

var renderbufferFormats = {};
renderbufferFormats[RGBA4] = true;
renderbufferFormats[RGB5_A1] = true;
renderbufferFormats[RGB565] = true;
renderbufferFormats[DEPTH_STENCIL] = true;
renderbufferFormats[DEPTH_COMPONENT16] = true;
renderbufferFormats[STENCIL_INDEX] = true;
renderbufferFormats[STENCIL_INDEX8] = true;

function isRenderbufferFormat(format) {
  return renderbufferFormats[format];
}
/**
 * @typedef {Object} FramebufferInfo
 * @property {WebGLFramebuffer} framebuffer The WebGLFramebuffer for this framebufferInfo
 * @property {WebGLObject[]} attachments The created attachments in the same order as passed in to {@link module:twgl.createFramebufferInfo}.
 * @property {number} width The width of the framebuffer and its attachments
 * @property {number} height The width of the framebuffer and its attachments
 * @memberOf module:twgl
 */

/**
 * Creates a framebuffer and attachments.
 *
 * This returns a {@link module:twgl.FramebufferInfo} because it needs to return the attachments as well as the framebuffer.
 *
 * The simplest usage
 *
 *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer
 *     const fbi = twgl.createFramebufferInfo(gl);
 *
 * More complex usage
 *
 *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer
 *     const attachments = [
 *       { format: RGB565, mag: NEAREST },
 *       { format: STENCIL_INDEX8 },
 *     ]
 *     const fbi = twgl.createFramebufferInfo(gl, attachments);
 *
 * Passing in a specific size
 *
 *     const width = 256;
 *     const height = 256;
 *     const fbi = twgl.createFramebufferInfo(gl, attachments, width, height);
 *
 * **Note!!** It is up to you to check if the framebuffer is renderable by calling `gl.checkFramebufferStatus`.
 * [WebGL1 only guarantees 3 combinations of attachments work](https://www.khronos.org/registry/webgl/specs/latest/1.0/#6.6).
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.AttachmentOptions[]} [attachments] which attachments to create. If not provided the default is a framebuffer with an
 *    `RGBA`, `UNSIGNED_BYTE` texture `COLOR_ATTACHMENT0` and a `DEPTH_STENCIL` renderbuffer `DEPTH_STENCIL_ATTACHMENT`.
 * @param {number} [width] the width for the attachments. Default = size of drawingBuffer
 * @param {number} [height] the height for the attachments. Default = size of drawingBuffer
 * @return {module:twgl.FramebufferInfo} the framebuffer and attachments.
 * @memberOf module:twgl/framebuffers
 */


function createFramebufferInfo(gl, attachments, width, height) {
  var target = FRAMEBUFFER;
  var fb = gl.createFramebuffer();
  gl.bindFramebuffer(target, fb);
  width = width || gl.drawingBufferWidth;
  height = height || gl.drawingBufferHeight;
  attachments = attachments || defaultAttachments;
  var colorAttachmentCount = 0;
  var framebufferInfo = {
    framebuffer: fb,
    attachments: [],
    width: width,
    height: height
  };
  attachments.forEach(function (attachmentOptions) {
    var attachment = attachmentOptions.attachment;
    var format = attachmentOptions.format;
    var attachmentPoint = attachmentOptions.attachmentPoint || getAttachmentPointForFormat(format, attachmentOptions.internalFormat);

    if (!attachmentPoint) {
      attachmentPoint = COLOR_ATTACHMENT0 + colorAttachmentCount++;
    }

    if (!attachment) {
      if (isRenderbufferFormat(format)) {
        attachment = gl.createRenderbuffer();
        gl.bindRenderbuffer(RENDERBUFFER, attachment);
        gl.renderbufferStorage(RENDERBUFFER, format, width, height);
      } else {
        var textureOptions = Object.assign({}, attachmentOptions);
        textureOptions.width = width;
        textureOptions.height = height;

        if (textureOptions.auto === undefined) {
          textureOptions.auto = false;
          textureOptions.min = textureOptions.min || textureOptions.minMag || LINEAR;
          textureOptions.mag = textureOptions.mag || textureOptions.minMag || LINEAR;
          textureOptions.wrapS = textureOptions.wrapS || textureOptions.wrap || CLAMP_TO_EDGE;
          textureOptions.wrapT = textureOptions.wrapT || textureOptions.wrap || CLAMP_TO_EDGE;
        }

        attachment = textures.createTexture(gl, textureOptions);
      }
    }

    if (helper.isRenderbuffer(gl, attachment)) {
      gl.framebufferRenderbuffer(target, attachmentPoint, RENDERBUFFER, attachment);
    } else if (helper.isTexture(gl, attachment)) {
      if (attachmentOptions.layer !== undefined) {
        gl.framebufferTextureLayer(target, attachmentPoint, attachment, attachmentOptions.level || 0, attachmentOptions.layer);
      } else {
        gl.framebufferTexture2D(target, attachmentPoint, attachmentOptions.target || TEXTURE_2D, attachment, attachmentOptions.level || 0);
      }
    } else {
      throw new Error('unknown attachment type');
    }

    framebufferInfo.attachments.push(attachment);
  });
  return framebufferInfo;
}
/**
 * Resizes the attachments of a framebuffer.
 *
 * You need to pass in the same `attachments` as you passed in {@link module:twgl.createFramebufferInfo}
 * because TWGL has no idea the format/type of each attachment.
 *
 * The simplest usage
 *
 *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer
 *     const fbi = twgl.createFramebufferInfo(gl);
 *
 *     ...
 *
 *     function render() {
 *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {
 *         // resize the attachments
 *         twgl.resizeFramebufferInfo(gl, fbi);
 *       }
 *
 * More complex usage
 *
 *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer
 *     const attachments = [
 *       { format: RGB565, mag: NEAREST },
 *       { format: STENCIL_INDEX8 },
 *     ]
 *     const fbi = twgl.createFramebufferInfo(gl, attachments);
 *
 *     ...
 *
 *     function render() {
 *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {
 *         // resize the attachments to match
 *         twgl.resizeFramebufferInfo(gl, fbi, attachments);
 *       }
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.FramebufferInfo} framebufferInfo a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.
 * @param {module:twgl.AttachmentOptions[]} [attachments] the same attachments options as passed to {@link module:twgl.createFramebufferInfo}.
 * @param {number} [width] the width for the attachments. Default = size of drawingBuffer
 * @param {number} [height] the height for the attachments. Default = size of drawingBuffer
 * @memberOf module:twgl/framebuffers
 */


function resizeFramebufferInfo(gl, framebufferInfo, attachments, width, height) {
  width = width || gl.drawingBufferWidth;
  height = height || gl.drawingBufferHeight;
  framebufferInfo.width = width;
  framebufferInfo.height = height;
  attachments = attachments || defaultAttachments;
  attachments.forEach(function (attachmentOptions, ndx) {
    var attachment = framebufferInfo.attachments[ndx];
    var format = attachmentOptions.format;

    if (helper.isRenderbuffer(gl, attachment)) {
      gl.bindRenderbuffer(RENDERBUFFER, attachment);
      gl.renderbufferStorage(RENDERBUFFER, format, width, height);
    } else if (helper.isTexture(gl, attachment)) {
      textures.resizeTexture(gl, attachment, attachmentOptions, width, height);
    } else {
      throw new Error('unknown attachment type');
    }
  });
}
/**
 * Binds a framebuffer
 *
 * This function pretty much solely exists because I spent hours
 * trying to figure out why something I wrote wasn't working only
 * to realize I forget to set the viewport dimensions.
 * My hope is this function will fix that.
 *
 * It is effectively the same as
 *
 *     gl.bindFramebuffer(gl.FRAMEBUFFER, someFramebufferInfo.framebuffer);
 *     gl.viewport(0, 0, someFramebufferInfo.width, someFramebufferInfo.height);
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.FramebufferInfo|null} [framebufferInfo] a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.
 *   If falsy will bind the canvas.
 * @param {number} [target] The target. If not passed `gl.FRAMEBUFFER` will be used.
 * @memberOf module:twgl/framebuffers
 */


function bindFramebufferInfo(gl, framebufferInfo, target) {
  target = target || FRAMEBUFFER;

  if (framebufferInfo) {
    gl.bindFramebuffer(target, framebufferInfo.framebuffer);
    gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);
  } else {
    gl.bindFramebuffer(target, null);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }
}

/***/ }),

/***/ "./src/helper.js":
/*!***********************!*\
  !*** ./src/helper.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.copyExistingProperties = copyExistingProperties;
exports.copyNamedProperties = copyNamedProperties;
exports.error = error;
exports.warn = warn;
exports.isBuffer = isBuffer;
exports.isRenderbuffer = isRenderbuffer;
exports.isShader = isShader;
exports.isTexture = isTexture;
exports.isSampler = isSampler;

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/* eslint no-console: "off" */

/**
 * Copy named properties
 *
 * @param {string[]} names names of properties to copy
 * @param {object} src object to copy properties from
 * @param {object} dst object to copy properties to
 * @private
 */
function copyNamedProperties(names, src, dst) {
  names.forEach(function (name) {
    var value = src[name];

    if (value !== undefined) {
      dst[name] = value;
    }
  });
}
/**
 * Copies properties from source to dest only if a matching key is in dest
 *
 * @param {Object.<string, ?>} src the source
 * @param {Object.<string, ?>} dst the dest
 * @private
 */


function copyExistingProperties(src, dst) {
  Object.keys(dst).forEach(function (key) {
    if (dst.hasOwnProperty(key) && src.hasOwnProperty(key)) {
      /* eslint no-prototype-builtins: 0 */
      dst[key] = src[key];
    }
  });
}

function error() {
  var _console;

  (_console = console).error.apply(_console, arguments);
}

function warn() {
  var _console2;

  (_console2 = console).warn.apply(_console2, arguments);
}

function isBuffer(gl, t) {
  return typeof WebGLBuffer !== 'undefined' && t instanceof WebGLBuffer;
}

function isRenderbuffer(gl, t) {
  return typeof WebGLRenderbuffer !== 'undefined' && t instanceof WebGLRenderbuffer;
}

function isShader(gl, t) {
  return typeof WebGLShader !== 'undefined' && t instanceof WebGLShader;
}

function isTexture(gl, t) {
  return typeof WebGLTexture !== 'undefined' && t instanceof WebGLTexture;
}

function isSampler(gl, t) {
  return typeof WebGLSampler !== 'undefined' && t instanceof WebGLSampler;
}

/***/ }),

/***/ "./src/m4.js":
/*!*******************!*\
  !*** ./src/m4.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.axisRotate = axisRotate;
exports.axisRotation = axisRotation;
exports.copy = copy;
exports.frustum = frustum;
exports.getAxis = getAxis;
exports.getTranslation = getTranslation;
exports.identity = identity;
exports.inverse = inverse;
exports.lookAt = lookAt;
exports.multiply = multiply;
exports.negate = negate;
exports.ortho = ortho;
exports.perspective = perspective;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.rotationX = rotationX;
exports.rotationY = rotationY;
exports.rotationZ = rotationZ;
exports.scale = scale;
exports.scaling = scaling;
exports.setAxis = setAxis;
exports.setDefaultType = setDefaultType;
exports.setTranslation = setTranslation;
exports.transformDirection = transformDirection;
exports.transformNormal = transformNormal;
exports.transformPoint = transformPoint;
exports.translate = translate;
exports.translation = translation;
exports.transpose = transpose;

var v3 = _interopRequireWildcard(__webpack_require__(/*! ./v3.js */ "./src/v3.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * 4x4 Matrix math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new matrix. In other words you can do this
 *
 *     const mat = m4.translation([1, 2, 3]);  // Creates a new translation matrix
 *
 * or
 *
 *     const mat = m4.create();
 *     m4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any matrix as the destination. So for example
 *
 *     const mat = m4.identity();
 *     const trans = m4.translation([1, 2, 3]);
 *     m4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.
 *
 * @module twgl/m4
 */
var MatType = Float32Array;
/**
 * A JavaScript array with 16 values or a Float32Array with 16 values.
 * When created by the library will create the default type which is `Float32Array`
 * but can be set by calling {@link module:twgl/m4.setDefaultType}.
 * @typedef {(number[]|Float32Array)} Mat4
 * @memberOf module:twgl/m4
 */

/**
 * Sets the type this library creates for a Mat4
 * @param {constructor} ctor the constructor for the type. Either `Float32Array` or `Array`
 * @return {constructor} previous constructor for Mat4
 * @memberOf module:twgl/m4
 */

function setDefaultType(ctor) {
  var oldType = MatType;
  MatType = ctor;
  return oldType;
}
/**
 * Negates a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} -m.
 * @memberOf module:twgl/m4
 */


function negate(m, dst) {
  dst = dst || new MatType(16);
  dst[0] = -m[0];
  dst[1] = -m[1];
  dst[2] = -m[2];
  dst[3] = -m[3];
  dst[4] = -m[4];
  dst[5] = -m[5];
  dst[6] = -m[6];
  dst[7] = -m[7];
  dst[8] = -m[8];
  dst[9] = -m[9];
  dst[10] = -m[10];
  dst[11] = -m[11];
  dst[12] = -m[12];
  dst[13] = -m[13];
  dst[14] = -m[14];
  dst[15] = -m[15];
  return dst;
}
/**
 * Copies a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] The matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} A copy of m.
 * @memberOf module:twgl/m4
 */


function copy(m, dst) {
  dst = dst || new MatType(16);
  dst[0] = m[0];
  dst[1] = m[1];
  dst[2] = m[2];
  dst[3] = m[3];
  dst[4] = m[4];
  dst[5] = m[5];
  dst[6] = m[6];
  dst[7] = m[7];
  dst[8] = m[8];
  dst[9] = m[9];
  dst[10] = m[10];
  dst[11] = m[11];
  dst[12] = m[12];
  dst[13] = m[13];
  dst[14] = m[14];
  dst[15] = m[15];
  return dst;
}
/**
 * Creates an n-by-n identity matrix.
 *
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} An n-by-n identity matrix.
 * @memberOf module:twgl/m4
 */


function identity(dst) {
  dst = dst || new MatType(16);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Takes the transpose of a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The transpose of m.
 * @memberOf module:twgl/m4
 */


function transpose(m, dst) {
  dst = dst || new MatType(16);

  if (dst === m) {
    var t;
    t = m[1];
    m[1] = m[4];
    m[4] = t;
    t = m[2];
    m[2] = m[8];
    m[8] = t;
    t = m[3];
    m[3] = m[12];
    m[12] = t;
    t = m[6];
    m[6] = m[9];
    m[9] = t;
    t = m[7];
    m[7] = m[13];
    m[13] = t;
    t = m[11];
    m[11] = m[14];
    m[14] = t;
    return dst;
  }

  var m00 = m[0 * 4 + 0];
  var m01 = m[0 * 4 + 1];
  var m02 = m[0 * 4 + 2];
  var m03 = m[0 * 4 + 3];
  var m10 = m[1 * 4 + 0];
  var m11 = m[1 * 4 + 1];
  var m12 = m[1 * 4 + 2];
  var m13 = m[1 * 4 + 3];
  var m20 = m[2 * 4 + 0];
  var m21 = m[2 * 4 + 1];
  var m22 = m[2 * 4 + 2];
  var m23 = m[2 * 4 + 3];
  var m30 = m[3 * 4 + 0];
  var m31 = m[3 * 4 + 1];
  var m32 = m[3 * 4 + 2];
  var m33 = m[3 * 4 + 3];
  dst[0] = m00;
  dst[1] = m10;
  dst[2] = m20;
  dst[3] = m30;
  dst[4] = m01;
  dst[5] = m11;
  dst[6] = m21;
  dst[7] = m31;
  dst[8] = m02;
  dst[9] = m12;
  dst[10] = m22;
  dst[11] = m32;
  dst[12] = m03;
  dst[13] = m13;
  dst[14] = m23;
  dst[15] = m33;
  return dst;
}
/**
 * Computes the inverse of a 4-by-4 matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The inverse of m.
 * @memberOf module:twgl/m4
 */


function inverse(m, dst) {
  dst = dst || new MatType(16);
  var m00 = m[0 * 4 + 0];
  var m01 = m[0 * 4 + 1];
  var m02 = m[0 * 4 + 2];
  var m03 = m[0 * 4 + 3];
  var m10 = m[1 * 4 + 0];
  var m11 = m[1 * 4 + 1];
  var m12 = m[1 * 4 + 2];
  var m13 = m[1 * 4 + 3];
  var m20 = m[2 * 4 + 0];
  var m21 = m[2 * 4 + 1];
  var m22 = m[2 * 4 + 2];
  var m23 = m[2 * 4 + 3];
  var m30 = m[3 * 4 + 0];
  var m31 = m[3 * 4 + 1];
  var m32 = m[3 * 4 + 2];
  var m33 = m[3 * 4 + 3];
  var tmp_0 = m22 * m33;
  var tmp_1 = m32 * m23;
  var tmp_2 = m12 * m33;
  var tmp_3 = m32 * m13;
  var tmp_4 = m12 * m23;
  var tmp_5 = m22 * m13;
  var tmp_6 = m02 * m33;
  var tmp_7 = m32 * m03;
  var tmp_8 = m02 * m23;
  var tmp_9 = m22 * m03;
  var tmp_10 = m02 * m13;
  var tmp_11 = m12 * m03;
  var tmp_12 = m20 * m31;
  var tmp_13 = m30 * m21;
  var tmp_14 = m10 * m31;
  var tmp_15 = m30 * m11;
  var tmp_16 = m10 * m21;
  var tmp_17 = m20 * m11;
  var tmp_18 = m00 * m31;
  var tmp_19 = m30 * m01;
  var tmp_20 = m00 * m21;
  var tmp_21 = m20 * m01;
  var tmp_22 = m00 * m11;
  var tmp_23 = m10 * m01;
  var t0 = tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31 - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
  var t1 = tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31 - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
  var t2 = tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31 - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
  var t3 = tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21 - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);
  var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
  dst[0] = d * t0;
  dst[1] = d * t1;
  dst[2] = d * t2;
  dst[3] = d * t3;
  dst[4] = d * (tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30 - (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));
  dst[5] = d * (tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30 - (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));
  dst[6] = d * (tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30 - (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));
  dst[7] = d * (tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20 - (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));
  dst[8] = d * (tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33 - (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));
  dst[9] = d * (tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33 - (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));
  dst[10] = d * (tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33 - (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));
  dst[11] = d * (tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23 - (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));
  dst[12] = d * (tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12 - (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));
  dst[13] = d * (tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22 - (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));
  dst[14] = d * (tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02 - (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));
  dst[15] = d * (tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12 - (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));
  return dst;
}
/**
 * Multiplies two 4-by-4 matrices with a on the left and b on the right
 * @param {module:twgl/m4.Mat4} a The matrix on the left.
 * @param {module:twgl/m4.Mat4} b The matrix on the right.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix product of a and b.
 * @memberOf module:twgl/m4
 */


function multiply(a, b, dst) {
  dst = dst || new MatType(16);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4 + 0];
  var a11 = a[4 + 1];
  var a12 = a[4 + 2];
  var a13 = a[4 + 3];
  var a20 = a[8 + 0];
  var a21 = a[8 + 1];
  var a22 = a[8 + 2];
  var a23 = a[8 + 3];
  var a30 = a[12 + 0];
  var a31 = a[12 + 1];
  var a32 = a[12 + 2];
  var a33 = a[12 + 3];
  var b00 = b[0];
  var b01 = b[1];
  var b02 = b[2];
  var b03 = b[3];
  var b10 = b[4 + 0];
  var b11 = b[4 + 1];
  var b12 = b[4 + 2];
  var b13 = b[4 + 3];
  var b20 = b[8 + 0];
  var b21 = b[8 + 1];
  var b22 = b[8 + 2];
  var b23 = b[8 + 3];
  var b30 = b[12 + 0];
  var b31 = b[12 + 1];
  var b32 = b[12 + 2];
  var b33 = b[12 + 3];
  dst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
  dst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
  dst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
  dst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
  dst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
  dst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
  dst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
  dst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
  dst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
  dst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
  dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
  dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
  dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
  dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
  dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
  dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
  return dst;
}
/**
 * Sets the translation component of a 4-by-4 matrix to the given
 * vector.
 * @param {module:twgl/m4.Mat4} a The matrix.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix with translation set.
 * @memberOf module:twgl/m4
 */


function setTranslation(a, v, dst) {
  dst = dst || identity();

  if (a !== dst) {
    dst[0] = a[0];
    dst[1] = a[1];
    dst[2] = a[2];
    dst[3] = a[3];
    dst[4] = a[4];
    dst[5] = a[5];
    dst[6] = a[6];
    dst[7] = a[7];
    dst[8] = a[8];
    dst[9] = a[9];
    dst[10] = a[10];
    dst[11] = a[11];
  }

  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}
/**
 * Returns the translation component of a 4-by-4 matrix as a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The translation component of m.
 * @memberOf module:twgl/m4
 */


function getTranslation(m, dst) {
  dst = dst || v3.create();
  dst[0] = m[12];
  dst[1] = m[13];
  dst[2] = m[14];
  return dst;
}
/**
 * Returns an axis of a 4x4 matrix as a vector with 3 entries
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} axis The axis 0 = x, 1 = y, 2 = z;
 * @return {module:twgl/v3.Vec3} [dst] vector.
 * @return {module:twgl/v3.Vec3} The axis component of m.
 * @memberOf module:twgl/m4
 */


function getAxis(m, axis, dst) {
  dst = dst || v3.create();
  var off = axis * 4;
  dst[0] = m[off + 0];
  dst[1] = m[off + 1];
  dst[2] = m[off + 2];
  return dst;
}
/**
 * Sets an axis of a 4x4 matrix as a vector with 3 entries
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v the axis vector
 * @param {number} axis The axis  0 = x, 1 = y, 2 = z;
 * @param {module:twgl/m4.Mat4} [dst] The matrix to set. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix with axis set.
 * @memberOf module:twgl/m4
 */


function setAxis(a, v, axis, dst) {
  if (dst !== a) {
    dst = copy(a, dst);
  }

  var off = axis * 4;
  dst[off + 0] = v[0];
  dst[off + 1] = v[1];
  dst[off + 2] = v[2];
  return dst;
}
/**
 * Computes a 4-by-4 perspective transformation matrix given the angular height
 * of the frustum, the aspect ratio, and the near and far clipping planes.  The
 * arguments define a frustum extending in the negative z direction.  The given
 * angle is the vertical angle of the frustum, and the horizontal angle is
 * determined to produce the given aspect ratio.  The arguments near and far are
 * the distances to the near and far clipping planes.  Note that near and far
 * are not z coordinates, but rather they are distances along the negative
 * z-axis.  The matrix generated sends the viewing frustum to the unit box.
 * We assume a unit box extending from -1 to 1 in the x and y dimensions and
 * from 0 to 1 in the z dimension.
 * @param {number} fieldOfViewYInRadians The camera angle from top to bottom (in radians).
 * @param {number} aspect The aspect ratio width / height.
 * @param {number} zNear The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param {number} zFar The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective matrix.
 * @memberOf module:twgl/m4
 */


function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {
  dst = dst || new MatType(16);
  var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);
  var rangeInv = 1.0 / (zNear - zFar);
  dst[0] = f / aspect;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = f;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = (zNear + zFar) * rangeInv;
  dst[11] = -1;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = zNear * zFar * rangeInv * 2;
  dst[15] = 0;
  return dst;
}
/**
 * Computes a 4-by-4 orthogonal transformation matrix given the left, right,
 * bottom, and top dimensions of the near clipping plane as well as the
 * near and far clipping plane distances.
 * @param {number} left Left side of the near clipping plane viewport.
 * @param {number} right Right side of the near clipping plane viewport.
 * @param {number} bottom Bottom of the near clipping plane viewport.
 * @param {number} top Top of the near clipping plane viewport.
 * @param {number} near The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param {number} far The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param {module:twgl/m4.Mat4} [dst] Output matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective matrix.
 * @memberOf module:twgl/m4
 */


function ortho(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);
  dst[0] = 2 / (right - left);
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 2 / (top - bottom);
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 2 / (near - far);
  dst[11] = 0;
  dst[12] = (right + left) / (left - right);
  dst[13] = (top + bottom) / (bottom - top);
  dst[14] = (far + near) / (near - far);
  dst[15] = 1;
  return dst;
}
/**
 * Computes a 4-by-4 perspective transformation matrix given the left, right,
 * top, bottom, near and far clipping planes. The arguments define a frustum
 * extending in the negative z direction. The arguments near and far are the
 * distances to the near and far clipping planes. Note that near and far are not
 * z coordinates, but rather they are distances along the negative z-axis. The
 * matrix generated sends the viewing frustum to the unit box. We assume a unit
 * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z
 * dimension.
 * @param {number} left The x coordinate of the left plane of the box.
 * @param {number} right The x coordinate of the right plane of the box.
 * @param {number} bottom The y coordinate of the bottom plane of the box.
 * @param {number} top The y coordinate of the right plane of the box.
 * @param {number} near The negative z coordinate of the near plane of the box.
 * @param {number} far The negative z coordinate of the far plane of the box.
 * @param {module:twgl/m4.Mat4} [dst] Output matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective projection matrix.
 * @memberOf module:twgl/m4
 */


function frustum(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);
  var dx = right - left;
  var dy = top - bottom;
  var dz = near - far;
  dst[0] = 2 * near / dx;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 2 * near / dy;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = (left + right) / dx;
  dst[9] = (top + bottom) / dy;
  dst[10] = far / dz;
  dst[11] = -1;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = near * far / dz;
  dst[15] = 0;
  return dst;
}

var xAxis;
var yAxis;
var zAxis;
/**
 * Computes a 4-by-4 look-at transformation.
 *
 * This is a matrix which positions the camera itself. If you want
 * a view matrix (a matrix which moves things in front of the camera)
 * take the inverse of this.
 *
 * @param {module:twgl/v3.Vec3} eye The position of the eye.
 * @param {module:twgl/v3.Vec3} target The position meant to be viewed.
 * @param {module:twgl/v3.Vec3} up A vector pointing up.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The look-at matrix.
 * @memberOf module:twgl/m4
 */

function lookAt(eye, target, up, dst) {
  dst = dst || new MatType(16);
  xAxis = xAxis || v3.create();
  yAxis = yAxis || v3.create();
  zAxis = zAxis || v3.create();
  v3.normalize(v3.subtract(eye, target, zAxis), zAxis);
  v3.normalize(v3.cross(up, zAxis, xAxis), xAxis);
  v3.normalize(v3.cross(zAxis, xAxis, yAxis), yAxis);
  dst[0] = xAxis[0];
  dst[1] = xAxis[1];
  dst[2] = xAxis[2];
  dst[3] = 0;
  dst[4] = yAxis[0];
  dst[5] = yAxis[1];
  dst[6] = yAxis[2];
  dst[7] = 0;
  dst[8] = zAxis[0];
  dst[9] = zAxis[1];
  dst[10] = zAxis[2];
  dst[11] = 0;
  dst[12] = eye[0];
  dst[13] = eye[1];
  dst[14] = eye[2];
  dst[15] = 1;
  return dst;
}
/**
 * Creates a 4-by-4 matrix which translates by the given vector v.
 * @param {module:twgl/v3.Vec3} v The vector by
 *     which to translate.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The translation matrix.
 * @memberOf module:twgl/m4
 */


function translation(v, dst) {
  dst = dst || new MatType(16);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}
/**
 * Translates the given 4-by-4 matrix by the given vector v.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The vector by
 *     which to translate.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The translated matrix.
 * @memberOf module:twgl/m4
 */


function translate(m, v, dst) {
  dst = dst || new MatType(16);
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  var m00 = m[0];
  var m01 = m[1];
  var m02 = m[2];
  var m03 = m[3];
  var m10 = m[1 * 4 + 0];
  var m11 = m[1 * 4 + 1];
  var m12 = m[1 * 4 + 2];
  var m13 = m[1 * 4 + 3];
  var m20 = m[2 * 4 + 0];
  var m21 = m[2 * 4 + 1];
  var m22 = m[2 * 4 + 2];
  var m23 = m[2 * 4 + 3];
  var m30 = m[3 * 4 + 0];
  var m31 = m[3 * 4 + 1];
  var m32 = m[3 * 4 + 2];
  var m33 = m[3 * 4 + 3];

  if (m !== dst) {
    dst[0] = m00;
    dst[1] = m01;
    dst[2] = m02;
    dst[3] = m03;
    dst[4] = m10;
    dst[5] = m11;
    dst[6] = m12;
    dst[7] = m13;
    dst[8] = m20;
    dst[9] = m21;
    dst[10] = m22;
    dst[11] = m23;
  }

  dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;
  dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;
  dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;
  dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;
  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */


function rotationX(angleInRadians, dst) {
  dst = dst || new MatType(16);
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = c;
  dst[6] = s;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = -s;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the x-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */


function rotateX(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var m10 = m[4];
  var m11 = m[5];
  var m12 = m[6];
  var m13 = m[7];
  var m20 = m[8];
  var m21 = m[9];
  var m22 = m[10];
  var m23 = m[11];
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[4] = c * m10 + s * m20;
  dst[5] = c * m11 + s * m21;
  dst[6] = c * m12 + s * m22;
  dst[7] = c * m13 + s * m23;
  dst[8] = c * m20 - s * m10;
  dst[9] = c * m21 - s * m11;
  dst[10] = c * m22 - s * m12;
  dst[11] = c * m23 - s * m13;

  if (m !== dst) {
    dst[0] = m[0];
    dst[1] = m[1];
    dst[2] = m[2];
    dst[3] = m[3];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */


function rotationY(angleInRadians, dst) {
  dst = dst || new MatType(16);
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = c;
  dst[1] = 0;
  dst[2] = -s;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = s;
  dst[9] = 0;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the y-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */


function rotateY(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var m00 = m[0 * 4 + 0];
  var m01 = m[0 * 4 + 1];
  var m02 = m[0 * 4 + 2];
  var m03 = m[0 * 4 + 3];
  var m20 = m[2 * 4 + 0];
  var m21 = m[2 * 4 + 1];
  var m22 = m[2 * 4 + 2];
  var m23 = m[2 * 4 + 3];
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = c * m00 - s * m20;
  dst[1] = c * m01 - s * m21;
  dst[2] = c * m02 - s * m22;
  dst[3] = c * m03 - s * m23;
  dst[8] = c * m20 + s * m00;
  dst[9] = c * m21 + s * m01;
  dst[10] = c * m22 + s * m02;
  dst[11] = c * m23 + s * m03;

  if (m !== dst) {
    dst[4] = m[4];
    dst[5] = m[5];
    dst[6] = m[6];
    dst[7] = m[7];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */


function rotationZ(angleInRadians, dst) {
  dst = dst || new MatType(16);
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = c;
  dst[1] = s;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = -s;
  dst[5] = c;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the z-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */


function rotateZ(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var m00 = m[0 * 4 + 0];
  var m01 = m[0 * 4 + 1];
  var m02 = m[0 * 4 + 2];
  var m03 = m[0 * 4 + 3];
  var m10 = m[1 * 4 + 0];
  var m11 = m[1 * 4 + 1];
  var m12 = m[1 * 4 + 2];
  var m13 = m[1 * 4 + 3];
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = c * m00 + s * m10;
  dst[1] = c * m01 + s * m11;
  dst[2] = c * m02 + s * m12;
  dst[3] = c * m03 + s * m13;
  dst[4] = c * m10 - s * m00;
  dst[5] = c * m11 - s * m01;
  dst[6] = c * m12 - s * m02;
  dst[7] = c * m13 - s * m03;

  if (m !== dst) {
    dst[8] = m[8];
    dst[9] = m[9];
    dst[10] = m[10];
    dst[11] = m[11];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the given axis by the given
 * angle.
 * @param {module:twgl/v3.Vec3} axis The axis
 *     about which to rotate.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} A matrix which rotates angle radians
 *     around the axis.
 * @memberOf module:twgl/m4
 */


function axisRotation(axis, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var x = axis[0];
  var y = axis[1];
  var z = axis[2];
  var n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  var xx = x * x;
  var yy = y * y;
  var zz = z * z;
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  var oneMinusCosine = 1 - c;
  dst[0] = xx + (1 - xx) * c;
  dst[1] = x * y * oneMinusCosine + z * s;
  dst[2] = x * z * oneMinusCosine - y * s;
  dst[3] = 0;
  dst[4] = x * y * oneMinusCosine - z * s;
  dst[5] = yy + (1 - yy) * c;
  dst[6] = y * z * oneMinusCosine + x * s;
  dst[7] = 0;
  dst[8] = x * z * oneMinusCosine + y * s;
  dst[9] = y * z * oneMinusCosine - x * s;
  dst[10] = zz + (1 - zz) * c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the given axis by the
 * given angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} axis The axis
 *     about which to rotate.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */


function axisRotate(m, axis, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var x = axis[0];
  var y = axis[1];
  var z = axis[2];
  var n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  var xx = x * x;
  var yy = y * y;
  var zz = z * z;
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  var oneMinusCosine = 1 - c;
  var r00 = xx + (1 - xx) * c;
  var r01 = x * y * oneMinusCosine + z * s;
  var r02 = x * z * oneMinusCosine - y * s;
  var r10 = x * y * oneMinusCosine - z * s;
  var r11 = yy + (1 - yy) * c;
  var r12 = y * z * oneMinusCosine + x * s;
  var r20 = x * z * oneMinusCosine + y * s;
  var r21 = y * z * oneMinusCosine - x * s;
  var r22 = zz + (1 - zz) * c;
  var m00 = m[0];
  var m01 = m[1];
  var m02 = m[2];
  var m03 = m[3];
  var m10 = m[4];
  var m11 = m[5];
  var m12 = m[6];
  var m13 = m[7];
  var m20 = m[8];
  var m21 = m[9];
  var m22 = m[10];
  var m23 = m[11];
  dst[0] = r00 * m00 + r01 * m10 + r02 * m20;
  dst[1] = r00 * m01 + r01 * m11 + r02 * m21;
  dst[2] = r00 * m02 + r01 * m12 + r02 * m22;
  dst[3] = r00 * m03 + r01 * m13 + r02 * m23;
  dst[4] = r10 * m00 + r11 * m10 + r12 * m20;
  dst[5] = r10 * m01 + r11 * m11 + r12 * m21;
  dst[6] = r10 * m02 + r11 * m12 + r12 * m22;
  dst[7] = r10 * m03 + r11 * m13 + r12 * m23;
  dst[8] = r20 * m00 + r21 * m10 + r22 * m20;
  dst[9] = r20 * m01 + r21 * m11 + r22 * m21;
  dst[10] = r20 * m02 + r21 * m12 + r22 * m22;
  dst[11] = r20 * m03 + r21 * m13 + r22 * m23;

  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Creates a 4-by-4 matrix which scales in each dimension by an amount given by
 * the corresponding entry in the given vector; assumes the vector has three
 * entries.
 * @param {module:twgl/v3.Vec3} v A vector of
 *     three entries specifying the factor by which to scale in each dimension.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The scaling matrix.
 * @memberOf module:twgl/m4
 */


function scaling(v, dst) {
  dst = dst || new MatType(16);
  dst[0] = v[0];
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = v[1];
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = v[2];
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Scales the given 4-by-4 matrix in each dimension by an amount
 * given by the corresponding entry in the given vector; assumes the vector has
 * three entries.
 * @param {module:twgl/m4.Mat4} m The matrix to be modified.
 * @param {module:twgl/v3.Vec3} v A vector of three entries specifying the
 *     factor by which to scale in each dimension.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The scaled matrix.
 * @memberOf module:twgl/m4
 */


function scale(m, v, dst) {
  dst = dst || new MatType(16);
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  dst[0] = v0 * m[0 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2];
  dst[3] = v0 * m[0 * 4 + 3];
  dst[4] = v1 * m[1 * 4 + 0];
  dst[5] = v1 * m[1 * 4 + 1];
  dst[6] = v1 * m[1 * 4 + 2];
  dst[7] = v1 * m[1 * 4 + 3];
  dst[8] = v2 * m[2 * 4 + 0];
  dst[9] = v2 * m[2 * 4 + 1];
  dst[10] = v2 * m[2 * 4 + 2];
  dst[11] = v2 * m[2 * 4 + 3];

  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Takes a 4-by-4 matrix and a vector with 3 entries,
 * interprets the vector as a point, transforms that point by the matrix, and
 * returns the result as a vector with 3 entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The point.
 * @param {module:twgl/v3.Vec3} [dst] optional vec3 to store result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed point.
 * @memberOf module:twgl/m4
 */


function transformPoint(m, v, dst) {
  dst = dst || v3.create();
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  var d = v0 * m[0 * 4 + 3] + v1 * m[1 * 4 + 3] + v2 * m[2 * 4 + 3] + m[3 * 4 + 3];
  dst[0] = (v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0] + m[3 * 4 + 0]) / d;
  dst[1] = (v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1] + m[3 * 4 + 1]) / d;
  dst[2] = (v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2] + m[3 * 4 + 2]) / d;
  return dst;
}
/**
 * Takes a 4-by-4 matrix and a vector with 3 entries, interprets the vector as a
 * direction, transforms that direction by the matrix, and returns the result;
 * assumes the transformation of 3-dimensional space represented by the matrix
 * is parallel-preserving, i.e. any combination of rotation, scaling and
 * translation, but not a perspective distortion. Returns a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The direction.
 * @param {module:twgl/v3.Vec3} [dst] optional Vec3 to store result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed direction.
 * @memberOf module:twgl/m4
 */


function transformDirection(m, v, dst) {
  dst = dst || v3.create();
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];
  return dst;
}
/**
 * Takes a 4-by-4 matrix m and a vector v with 3 entries, interprets the vector
 * as a normal to a surface, and computes a vector which is normal upon
 * transforming that surface by the matrix. The effect of this function is the
 * same as transforming v (as a direction) by the inverse-transpose of m.  This
 * function assumes the transformation of 3-dimensional space represented by the
 * matrix is parallel-preserving, i.e. any combination of rotation, scaling and
 * translation, but not a perspective distortion.  Returns a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The normal.
 * @param {module:twgl/v3.Vec3} [dst] The direction. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed normal.
 * @memberOf module:twgl/m4
 */


function transformNormal(m, v, dst) {
  dst = dst || v3.create();
  var mi = inverse(m);
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];
  dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];
  dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];
  return dst;
}

/***/ }),

/***/ "./src/primitives.js":
/*!***************************!*\
  !*** ./src/primitives.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.create3DFVertices = create3DFVertices;
exports.createAugmentedTypedArray = createAugmentedTypedArray;
exports.createCubeVertices = createCubeVertices;
exports.createPlaneVertices = createPlaneVertices;
exports.createSphereVertices = createSphereVertices;
exports.createTruncatedConeVertices = createTruncatedConeVertices;
exports.createXYQuadVertices = createXYQuadVertices;
exports.createCrescentVertices = createCrescentVertices;
exports.createCylinderVertices = createCylinderVertices;
exports.createTorusVertices = createTorusVertices;
exports.createDiscVertices = createDiscVertices;
exports.deindexVertices = deindexVertices;
exports.flattenNormals = flattenNormals;
exports.makeRandomVertexColors = makeRandomVertexColors;
exports.reorientDirections = reorientDirections;
exports.reorientNormals = reorientNormals;
exports.reorientPositions = reorientPositions;
exports.reorientVertices = reorientVertices;
exports.concatVertices = concatVertices;
exports.duplicateVertices = duplicateVertices;
exports.createDiscBuffers = exports.createDiscBufferInfo = exports.createTorusBuffers = exports.createTorusBufferInfo = exports.createCylinderBuffers = exports.createCylinderBufferInfo = exports.createCrescentBuffers = exports.createCrescentBufferInfo = exports.createCresentVertices = exports.createCresentBuffers = exports.createCresentBufferInfo = exports.createXYQuadBuffers = exports.createXYQuadBufferInfo = exports.createTruncatedConeBuffers = exports.createTruncatedConeBufferInfo = exports.createSphereBuffers = exports.createSphereBufferInfo = exports.createPlaneBuffers = exports.createPlaneBufferInfo = exports.createCubeBuffers = exports.createCubeBufferInfo = exports.create3DFBuffers = exports.create3DFBufferInfo = void 0;

var attributes = _interopRequireWildcard(__webpack_require__(/*! ./attributes.js */ "./src/attributes.js"));

var helper = _interopRequireWildcard(__webpack_require__(/*! ./helper.js */ "./src/helper.js"));

var typedArrays = _interopRequireWildcard(__webpack_require__(/*! ./typedarrays.js */ "./src/typedarrays.js"));

var m4 = _interopRequireWildcard(__webpack_require__(/*! ./m4.js */ "./src/m4.js"));

var v3 = _interopRequireWildcard(__webpack_require__(/*! ./v3.js */ "./src/v3.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Various functions to make simple primitives
 *
 * note: Most primitive functions come in 3 styles
 *
 * *  `createSomeShapeBufferInfo`
 *
 *    These functions are almost always the functions you want to call. They
 *    create vertices then make WebGLBuffers and create {@link module:twgl.AttribInfo}s
 *    returning a {@link module:twgl.BufferInfo} you can pass to {@link module:twgl.setBuffersAndAttributes}
 *    and {@link module:twgl.drawBufferInfo} etc...
 *
 * *  `createSomeShapeBuffers`
 *
 *    These create WebGLBuffers and put your data in them but nothing else.
 *    It's a shortcut to doing it yourself if you don't want to use
 *    the higher level functions.
 *
 * *  `createSomeShapeVertices`
 *
 *    These just create vertices, no buffers. This allows you to manipulate the vertices
 *    or add more data before generating a {@link module:twgl.BufferInfo}. Once you're finished
 *    manipulating the vertices call {@link module:twgl.createBufferInfoFromArrays}.
 *
 *    example:
 *
 *        const arrays = twgl.primitives.createPlaneArrays(1);
 *        twgl.primitives.reorientVertices(arrays, m4.rotationX(Math.PI * 0.5));
 *        const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
 *
 * @module twgl/primitives
 */
var getArray = attributes.getArray_; // eslint-disable-line

var getNumComponents = attributes.getNumComponents_; // eslint-disable-line

/**
 * @typedef {(Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array)} TypedArray
 */

/**
 * Add `push` to a typed array. It just keeps a 'cursor'
 * and allows use to `push` values into the array so we
 * don't have to manually compute offsets
 * @param {TypedArray} typedArray TypedArray to augment
 * @param {number} numComponents number of components.
 * @private
 */

function augmentTypedArray(typedArray, numComponents) {
  var cursor = 0;

  typedArray.push = function () {
    for (var ii = 0; ii < arguments.length; ++ii) {
      var value = arguments[ii];

      if (value instanceof Array || typedArrays.isArrayBuffer(value)) {
        for (var jj = 0; jj < value.length; ++jj) {
          typedArray[cursor++] = value[jj];
        }
      } else {
        typedArray[cursor++] = value;
      }
    }
  };

  typedArray.reset = function (opt_index) {
    cursor = opt_index || 0;
  };

  typedArray.numComponents = numComponents;
  Object.defineProperty(typedArray, 'numElements', {
    get: function get() {
      return this.length / this.numComponents | 0;
    }
  });
  return typedArray;
}
/**
 * creates a typed array with a `push` function attached
 * so that you can easily *push* values.
 *
 * `push` can take multiple arguments. If an argument is an array each element
 * of the array will be added to the typed array.
 *
 * Example:
 *
 *     const array = createAugmentedTypedArray(3, 2);  // creates a Float32Array with 6 values
 *     array.push(1, 2, 3);
 *     array.push([4, 5, 6]);
 *     // array now contains [1, 2, 3, 4, 5, 6]
 *
 * Also has `numComponents` and `numElements` properties.
 *
 * @param {number} numComponents number of components
 * @param {number} numElements number of elements. The total size of the array will be `numComponents * numElements`.
 * @param {constructor} opt_type A constructor for the type. Default = `Float32Array`.
 * @return {ArrayBufferView} A typed array.
 * @memberOf module:twgl/primitives
 */


function createAugmentedTypedArray(numComponents, numElements, opt_type) {
  var Type = opt_type || Float32Array;
  return augmentTypedArray(new Type(numComponents * numElements), numComponents);
}

function allButIndices(name) {
  return name !== "indices";
}
/**
 * Given indexed vertices creates a new set of vertices un-indexed by expanding the indexed vertices.
 * @param {Object.<string, TypedArray>} vertices The indexed vertices to deindex
 * @return {Object.<string, TypedArray>} The deindexed vertices
 * @memberOf module:twgl/primitives
 */


function deindexVertices(vertices) {
  var indices = vertices.indices;
  var newVertices = {};
  var numElements = indices.length;

  function expandToUnindexed(channel) {
    var srcBuffer = vertices[channel];
    var numComponents = srcBuffer.numComponents;
    var dstBuffer = createAugmentedTypedArray(numComponents, numElements, srcBuffer.constructor);

    for (var ii = 0; ii < numElements; ++ii) {
      var ndx = indices[ii];
      var offset = ndx * numComponents;

      for (var jj = 0; jj < numComponents; ++jj) {
        dstBuffer.push(srcBuffer[offset + jj]);
      }
    }

    newVertices[channel] = dstBuffer;
  }

  Object.keys(vertices).filter(allButIndices).forEach(expandToUnindexed);
  return newVertices;
}
/**
 * flattens the normals of deindexed vertices in place.
 * @param {Object.<string, TypedArray>} vertices The deindexed vertices who's normals to flatten
 * @return {Object.<string, TypedArray>} The flattened vertices (same as was passed in)
 * @memberOf module:twgl/primitives
 */


function flattenNormals(vertices) {
  if (vertices.indices) {
    throw new Error('can not flatten normals of indexed vertices. deindex them first');
  }

  var normals = vertices.normal;
  var numNormals = normals.length;

  for (var ii = 0; ii < numNormals; ii += 9) {
    // pull out the 3 normals for this triangle
    var nax = normals[ii + 0];
    var nay = normals[ii + 1];
    var naz = normals[ii + 2];
    var nbx = normals[ii + 3];
    var nby = normals[ii + 4];
    var nbz = normals[ii + 5];
    var ncx = normals[ii + 6];
    var ncy = normals[ii + 7];
    var ncz = normals[ii + 8]; // add them

    var nx = nax + nbx + ncx;
    var ny = nay + nby + ncy;
    var nz = naz + nbz + ncz; // normalize them

    var length = Math.sqrt(nx * nx + ny * ny + nz * nz);
    nx /= length;
    ny /= length;
    nz /= length; // copy them back in

    normals[ii + 0] = nx;
    normals[ii + 1] = ny;
    normals[ii + 2] = nz;
    normals[ii + 3] = nx;
    normals[ii + 4] = ny;
    normals[ii + 5] = nz;
    normals[ii + 6] = nx;
    normals[ii + 7] = ny;
    normals[ii + 8] = nz;
  }

  return vertices;
}

function applyFuncToV3Array(array, matrix, fn) {
  var len = array.length;
  var tmp = new Float32Array(3);

  for (var ii = 0; ii < len; ii += 3) {
    fn(matrix, [array[ii], array[ii + 1], array[ii + 2]], tmp);
    array[ii] = tmp[0];
    array[ii + 1] = tmp[1];
    array[ii + 2] = tmp[2];
  }
}

function transformNormal(mi, v, dst) {
  dst = dst || v3.create();
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];
  dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];
  dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];
  return dst;
}
/**
 * Reorients directions by the given matrix..
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */


function reorientDirections(array, matrix) {
  applyFuncToV3Array(array, matrix, m4.transformDirection);
  return array;
}
/**
 * Reorients normals by the inverse-transpose of the given
 * matrix..
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */


function reorientNormals(array, matrix) {
  applyFuncToV3Array(array, m4.inverse(matrix), transformNormal);
  return array;
}
/**
 * Reorients positions by the given matrix. In other words, it
 * multiplies each vertex by the given matrix.
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */


function reorientPositions(array, matrix) {
  applyFuncToV3Array(array, matrix, m4.transformPoint);
  return array;
}
/**
 * @typedef {(number[]|TypedArray)} NativeArrayOrTypedArray
 */

/**
 * Reorients arrays by the given matrix. Assumes arrays have
 * names that contains 'pos' could be reoriented as positions,
 * 'binorm' or 'tan' as directions, and 'norm' as normals.
 *
 * @param {Object.<string, NativeArrayOrTypedArray>} arrays The vertices to reorient
 * @param {module:twgl/m4.Mat4} matrix matrix to reorient by.
 * @return {Object.<string, NativeArrayOrTypedArray>} same arrays that were passed in.
 * @memberOf module:twgl/primitives
 */


function reorientVertices(arrays, matrix) {
  Object.keys(arrays).forEach(function (name) {
    var array = arrays[name];

    if (name.indexOf("pos") >= 0) {
      reorientPositions(array, matrix);
    } else if (name.indexOf("tan") >= 0 || name.indexOf("binorm") >= 0) {
      reorientDirections(array, matrix);
    } else if (name.indexOf("norm") >= 0) {
      reorientNormals(array, matrix);
    }
  });
  return arrays;
}
/**
 * Creates XY quad BufferInfo
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0, 0.5);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {Object.<string, WebGLBuffer>} the created XY Quad BufferInfo
 * @memberOf module:twgl/primitives
 * @function createXYQuadBuffers
 */

/**
 * Creates XY quad Buffers
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0, 0.5);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {module:twgl.BufferInfo} the created XY Quad buffers
 * @memberOf module:twgl/primitives
 * @function createXYQuadBufferInfo
 */

/**
 * Creates XY quad vertices
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadVertices(1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadVertices(1, 0, 0.5);
 *
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {Object.<string, TypedArray>} the created XY Quad vertices
 * @memberOf module:twgl/primitives
 */


function createXYQuadVertices(size, xOffset, yOffset) {
  size = size || 2;
  xOffset = xOffset || 0;
  yOffset = yOffset || 0;
  size *= 0.5;
  return {
    position: {
      numComponents: 2,
      data: [xOffset + -1 * size, yOffset + -1 * size, xOffset + 1 * size, yOffset + -1 * size, xOffset + -1 * size, yOffset + 1 * size, xOffset + 1 * size, yOffset + 1 * size]
    },
    normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
    texcoord: [0, 0, 1, 0, 0, 1, 1, 1],
    indices: [0, 1, 2, 2, 1, 3]
  };
}
/**
 * Creates XZ plane BufferInfo.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {module:twgl.BufferInfo} The created plane BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createPlaneBufferInfo
 */

/**
 * Creates XZ plane buffers.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {Object.<string, WebGLBuffer>} The created plane buffers.
 * @memberOf module:twgl/primitives
 * @function createPlaneBuffers
 */

/**
 * Creates XZ plane vertices.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {Object.<string, TypedArray>} The created plane vertices.
 * @memberOf module:twgl/primitives
 */


function createPlaneVertices(width, depth, subdivisionsWidth, subdivisionsDepth, matrix) {
  width = width || 1;
  depth = depth || 1;
  subdivisionsWidth = subdivisionsWidth || 1;
  subdivisionsDepth = subdivisionsDepth || 1;
  matrix = matrix || m4.identity();
  var numVertices = (subdivisionsWidth + 1) * (subdivisionsDepth + 1);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);

  for (var z = 0; z <= subdivisionsDepth; z++) {
    for (var x = 0; x <= subdivisionsWidth; x++) {
      var u = x / subdivisionsWidth;
      var v = z / subdivisionsDepth;
      positions.push(width * u - width * 0.5, 0, depth * v - depth * 0.5);
      normals.push(0, 1, 0);
      texcoords.push(u, v);
    }
  }

  var numVertsAcross = subdivisionsWidth + 1;
  var indices = createAugmentedTypedArray(3, subdivisionsWidth * subdivisionsDepth * 2, Uint16Array);

  for (var _z = 0; _z < subdivisionsDepth; _z++) {
    // eslint-disable-line
    for (var _x = 0; _x < subdivisionsWidth; _x++) {
      // eslint-disable-line
      // Make triangle 1 of quad.
      indices.push((_z + 0) * numVertsAcross + _x, (_z + 1) * numVertsAcross + _x, (_z + 0) * numVertsAcross + _x + 1); // Make triangle 2 of quad.

      indices.push((_z + 1) * numVertsAcross + _x, (_z + 1) * numVertsAcross + _x + 1, (_z + 0) * numVertsAcross + _x + 1);
    }
  }

  var arrays = reorientVertices({
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  }, matrix);
  return arrays;
}
/**
 * Creates sphere BufferInfo.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {module:twgl.BufferInfo} The created sphere BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createSphereBufferInfo
 */

/**
 * Creates sphere buffers.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {Object.<string, WebGLBuffer>} The created sphere buffers.
 * @memberOf module:twgl/primitives
 * @function createSphereBuffers
 */

/**
 * Creates sphere vertices.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {Object.<string, TypedArray>} The created sphere vertices.
 * @memberOf module:twgl/primitives
 */


function createSphereVertices(radius, subdivisionsAxis, subdivisionsHeight, opt_startLatitudeInRadians, opt_endLatitudeInRadians, opt_startLongitudeInRadians, opt_endLongitudeInRadians) {
  if (subdivisionsAxis <= 0 || subdivisionsHeight <= 0) {
    throw new Error('subdivisionAxis and subdivisionHeight must be > 0');
  }

  opt_startLatitudeInRadians = opt_startLatitudeInRadians || 0;
  opt_endLatitudeInRadians = opt_endLatitudeInRadians || Math.PI;
  opt_startLongitudeInRadians = opt_startLongitudeInRadians || 0;
  opt_endLongitudeInRadians = opt_endLongitudeInRadians || Math.PI * 2;
  var latRange = opt_endLatitudeInRadians - opt_startLatitudeInRadians;
  var longRange = opt_endLongitudeInRadians - opt_startLongitudeInRadians; // We are going to generate our sphere by iterating through its
  // spherical coordinates and generating 2 triangles for each quad on a
  // ring of the sphere.

  var numVertices = (subdivisionsAxis + 1) * (subdivisionsHeight + 1);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices); // Generate the individual vertices in our vertex buffer.

  for (var y = 0; y <= subdivisionsHeight; y++) {
    for (var x = 0; x <= subdivisionsAxis; x++) {
      // Generate a vertex based on its spherical coordinates
      var u = x / subdivisionsAxis;
      var v = y / subdivisionsHeight;
      var theta = longRange * u + opt_startLongitudeInRadians;
      var phi = latRange * v + opt_startLatitudeInRadians;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var sinPhi = Math.sin(phi);
      var cosPhi = Math.cos(phi);
      var ux = cosTheta * sinPhi;
      var uy = cosPhi;
      var uz = sinTheta * sinPhi;
      positions.push(radius * ux, radius * uy, radius * uz);
      normals.push(ux, uy, uz);
      texcoords.push(1 - u, v);
    }
  }

  var numVertsAround = subdivisionsAxis + 1;
  var indices = createAugmentedTypedArray(3, subdivisionsAxis * subdivisionsHeight * 2, Uint16Array);

  for (var _x2 = 0; _x2 < subdivisionsAxis; _x2++) {
    // eslint-disable-line
    for (var _y = 0; _y < subdivisionsHeight; _y++) {
      // eslint-disable-line
      // Make triangle 1 of quad.
      indices.push((_y + 0) * numVertsAround + _x2, (_y + 0) * numVertsAround + _x2 + 1, (_y + 1) * numVertsAround + _x2); // Make triangle 2 of quad.

      indices.push((_y + 1) * numVertsAround + _x2, (_y + 0) * numVertsAround + _x2 + 1, (_y + 1) * numVertsAround + _x2 + 1);
    }
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Array of the indices of corners of each face of a cube.
 * @type {Array.<number[]>}
 * @private
 */


var CUBE_FACE_INDICES = [[3, 7, 5, 1], // right
[6, 2, 0, 4], // left
[6, 7, 3, 2], // ??
[0, 1, 5, 4], // ??
[7, 6, 4, 5], // front
[2, 3, 1, 0] // back
];
/**
 * Creates a BufferInfo for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] width, height and depth of the cube.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCubeBufferInfo
 */

/**
 * Creates the buffers and indices for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] width, height and depth of the cube.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCubeBuffers
 */

/**
 * Creates the vertices and indices for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {number} [size] width, height and depth of the cube.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */

function createCubeVertices(size) {
  size = size || 1;
  var k = size / 2;
  var cornerVertices = [[-k, -k, -k], [+k, -k, -k], [-k, +k, -k], [+k, +k, -k], [-k, -k, +k], [+k, -k, +k], [-k, +k, +k], [+k, +k, +k]];
  var faceNormals = [[+1, +0, +0], [-1, +0, +0], [+0, +1, +0], [+0, -1, +0], [+0, +0, +1], [+0, +0, -1]];
  var uvCoords = [[1, 0], [0, 0], [0, 1], [1, 1]];
  var numVertices = 6 * 4;
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);
  var indices = createAugmentedTypedArray(3, 6 * 2, Uint16Array);

  for (var f = 0; f < 6; ++f) {
    var faceIndices = CUBE_FACE_INDICES[f];

    for (var v = 0; v < 4; ++v) {
      var position = cornerVertices[faceIndices[v]];
      var normal = faceNormals[f];
      var uv = uvCoords[v]; // Each face needs all four vertices because the normals and texture
      // coordinates are not all the same.

      positions.push(position);
      normals.push(normal);
      texcoords.push(uv);
    } // Two triangles make a square face.


    var offset = 4 * f;
    indices.push(offset + 0, offset + 1, offset + 2);
    indices.push(offset + 0, offset + 2, offset + 3);
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Creates a BufferInfo for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {module:twgl.BufferInfo} The created cone BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createTruncatedConeBufferInfo
 */

/**
 * Creates buffers for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, WebGLBuffer>} The created cone buffers.
 * @memberOf module:twgl/primitives
 * @function createTruncatedConeBuffers
 */

/**
 * Creates vertices for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis. .
 *
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, TypedArray>} The created cone vertices.
 * @memberOf module:twgl/primitives
 */


function createTruncatedConeVertices(bottomRadius, topRadius, height, radialSubdivisions, verticalSubdivisions, opt_topCap, opt_bottomCap) {
  if (radialSubdivisions < 3) {
    throw new Error('radialSubdivisions must be 3 or greater');
  }

  if (verticalSubdivisions < 1) {
    throw new Error('verticalSubdivisions must be 1 or greater');
  }

  var topCap = opt_topCap === undefined ? true : opt_topCap;
  var bottomCap = opt_bottomCap === undefined ? true : opt_bottomCap;
  var extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
  var numVertices = (radialSubdivisions + 1) * (verticalSubdivisions + 1 + extra);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);
  var indices = createAugmentedTypedArray(3, radialSubdivisions * (verticalSubdivisions + extra / 2) * 2, Uint16Array);
  var vertsAroundEdge = radialSubdivisions + 1; // The slant of the cone is constant across its surface

  var slant = Math.atan2(bottomRadius - topRadius, height);
  var cosSlant = Math.cos(slant);
  var sinSlant = Math.sin(slant);
  var start = topCap ? -2 : 0;
  var end = verticalSubdivisions + (bottomCap ? 2 : 0);

  for (var yy = start; yy <= end; ++yy) {
    var v = yy / verticalSubdivisions;
    var y = height * v;
    var ringRadius = void 0;

    if (yy < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (yy > verticalSubdivisions) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius + (topRadius - bottomRadius) * (yy / verticalSubdivisions);
    }

    if (yy === -2 || yy === verticalSubdivisions + 2) {
      ringRadius = 0;
      v = 0;
    }

    y -= height / 2;

    for (var ii = 0; ii < vertsAroundEdge; ++ii) {
      var sin = Math.sin(ii * Math.PI * 2 / radialSubdivisions);
      var cos = Math.cos(ii * Math.PI * 2 / radialSubdivisions);
      positions.push(sin * ringRadius, y, cos * ringRadius);

      if (yy < 0) {
        normals.push(0, -1, 0);
      } else if (yy > verticalSubdivisions) {
        normals.push(0, 1, 0);
      } else if (ringRadius === 0.0) {
        normals.push(0, 0, 0);
      } else {
        normals.push(sin * cosSlant, sinSlant, cos * cosSlant);
      }

      texcoords.push(ii / radialSubdivisions, 1 - v);
    }
  }

  for (var _yy = 0; _yy < verticalSubdivisions + extra; ++_yy) {
    // eslint-disable-line
    if (_yy === 1 && topCap || _yy === verticalSubdivisions + extra - 2 && bottomCap) {
      continue;
    }

    for (var _ii = 0; _ii < radialSubdivisions; ++_ii) {
      // eslint-disable-line
      indices.push(vertsAroundEdge * (_yy + 0) + 0 + _ii, vertsAroundEdge * (_yy + 0) + 1 + _ii, vertsAroundEdge * (_yy + 1) + 1 + _ii);
      indices.push(vertsAroundEdge * (_yy + 0) + 0 + _ii, vertsAroundEdge * (_yy + 1) + 1 + _ii, vertsAroundEdge * (_yy + 1) + 0 + _ii);
    }
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Expands RLE data
 * @param {number[]} rleData data in format of run-length, x, y, z, run-length, x, y, z
 * @param {number[]} [padding] value to add each entry with.
 * @return {number[]} the expanded rleData
 * @private
 */


function expandRLEData(rleData, padding) {
  padding = padding || [];
  var data = [];

  for (var ii = 0; ii < rleData.length; ii += 4) {
    var runLength = rleData[ii];
    var element = rleData.slice(ii + 1, ii + 4);
    element.push.apply(element, padding);

    for (var jj = 0; jj < runLength; ++jj) {
      data.push.apply(data, element);
    }
  }

  return data;
}
/**
 * Creates 3D 'F' BufferInfo.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function create3DFBufferInfo
 */

/**
 * Creates 3D 'F' buffers.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function create3DFBuffers
 */

/**
 * Creates 3D 'F' vertices.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color arrays.
 *
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function create3DFVertices() {
  var positions = [// left column front
  0, 0, 0, 0, 150, 0, 30, 0, 0, 0, 150, 0, 30, 150, 0, 30, 0, 0, // top rung front
  30, 0, 0, 30, 30, 0, 100, 0, 0, 30, 30, 0, 100, 30, 0, 100, 0, 0, // middle rung front
  30, 60, 0, 30, 90, 0, 67, 60, 0, 30, 90, 0, 67, 90, 0, 67, 60, 0, // left column back
  0, 0, 30, 30, 0, 30, 0, 150, 30, 0, 150, 30, 30, 0, 30, 30, 150, 30, // top rung back
  30, 0, 30, 100, 0, 30, 30, 30, 30, 30, 30, 30, 100, 0, 30, 100, 30, 30, // middle rung back
  30, 60, 30, 67, 60, 30, 30, 90, 30, 30, 90, 30, 67, 60, 30, 67, 90, 30, // top
  0, 0, 0, 100, 0, 0, 100, 0, 30, 0, 0, 0, 100, 0, 30, 0, 0, 30, // top rung front
  100, 0, 0, 100, 30, 0, 100, 30, 30, 100, 0, 0, 100, 30, 30, 100, 0, 30, // under top rung
  30, 30, 0, 30, 30, 30, 100, 30, 30, 30, 30, 0, 100, 30, 30, 100, 30, 0, // between top rung and middle
  30, 30, 0, 30, 60, 30, 30, 30, 30, 30, 30, 0, 30, 60, 0, 30, 60, 30, // top of middle rung
  30, 60, 0, 67, 60, 30, 30, 60, 30, 30, 60, 0, 67, 60, 0, 67, 60, 30, // front of middle rung
  67, 60, 0, 67, 90, 30, 67, 60, 30, 67, 60, 0, 67, 90, 0, 67, 90, 30, // bottom of middle rung.
  30, 90, 0, 30, 90, 30, 67, 90, 30, 30, 90, 0, 67, 90, 30, 67, 90, 0, // front of bottom
  30, 90, 0, 30, 150, 30, 30, 90, 30, 30, 90, 0, 30, 150, 0, 30, 150, 30, // bottom
  0, 150, 0, 0, 150, 30, 30, 150, 30, 0, 150, 0, 30, 150, 30, 30, 150, 0, // left side
  0, 0, 0, 0, 0, 30, 0, 150, 30, 0, 0, 0, 0, 150, 30, 0, 150, 0];
  var texcoords = [// left column front
  0.22, 0.19, 0.22, 0.79, 0.34, 0.19, 0.22, 0.79, 0.34, 0.79, 0.34, 0.19, // top rung front
  0.34, 0.19, 0.34, 0.31, 0.62, 0.19, 0.34, 0.31, 0.62, 0.31, 0.62, 0.19, // middle rung front
  0.34, 0.43, 0.34, 0.55, 0.49, 0.43, 0.34, 0.55, 0.49, 0.55, 0.49, 0.43, // left column back
  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, // top rung back
  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, // middle rung back
  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, // top
  0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, // top rung front
  0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, // under top rung
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, // between top rung and middle
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, // top of middle rung
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, // front of middle rung
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, // bottom of middle rung.
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, // front of bottom
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, // bottom
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, // left side
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0];
  var normals = expandRLEData([// left column front
  // top rung front
  // middle rung front
  18, 0, 0, 1, // left column back
  // top rung back
  // middle rung back
  18, 0, 0, -1, // top
  6, 0, 1, 0, // top rung front
  6, 1, 0, 0, // under top rung
  6, 0, -1, 0, // between top rung and middle
  6, 1, 0, 0, // top of middle rung
  6, 0, 1, 0, // front of middle rung
  6, 1, 0, 0, // bottom of middle rung.
  6, 0, -1, 0, // front of bottom
  6, 1, 0, 0, // bottom
  6, 0, -1, 0, // left side
  6, -1, 0, 0]);
  var colors = expandRLEData([// left column front
  // top rung front
  // middle rung front
  18, 200, 70, 120, // left column back
  // top rung back
  // middle rung back
  18, 80, 70, 200, // top
  6, 70, 200, 210, // top rung front
  6, 200, 200, 70, // under top rung
  6, 210, 100, 70, // between top rung and middle
  6, 210, 160, 70, // top of middle rung
  6, 70, 180, 210, // front of middle rung
  6, 100, 70, 210, // bottom of middle rung.
  6, 76, 210, 100, // front of bottom
  6, 140, 210, 80, // bottom
  6, 90, 130, 110, // left side
  6, 160, 160, 220], [255]);
  var numVerts = positions.length / 3;
  var arrays = {
    position: createAugmentedTypedArray(3, numVerts),
    texcoord: createAugmentedTypedArray(2, numVerts),
    normal: createAugmentedTypedArray(3, numVerts),
    color: createAugmentedTypedArray(4, numVerts, Uint8Array),
    indices: createAugmentedTypedArray(3, numVerts / 3, Uint16Array)
  };
  arrays.position.push(positions);
  arrays.texcoord.push(texcoords);
  arrays.normal.push(normals);
  arrays.color.push(colors);

  for (var ii = 0; ii < numVerts; ++ii) {
    arrays.indices.push(ii);
  }

  return arrays;
}
/**
 * Creates crescent BufferInfo.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCresentBufferInfo
 */

/**
 * Creates crescent buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCresentBuffers
 */

/**
 * Creates crescent vertices.
 *
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 * @function createCresentBuffers
 */

/**
 * Creates crescent BufferInfo.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCrescentBufferInfo
 */

/**
 * Creates crescent buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCrescentBuffers
 */

/**
 * Creates crescent vertices.
 *
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function createCrescentVertices(verticalRadius, outerRadius, innerRadius, thickness, subdivisionsDown, startOffset, endOffset) {
  if (subdivisionsDown <= 0) {
    throw new Error('subdivisionDown must be > 0');
  }

  startOffset = startOffset || 0;
  endOffset = endOffset || 1;
  var subdivisionsThick = 2;
  var offsetRange = endOffset - startOffset;
  var numVertices = (subdivisionsDown + 1) * 2 * (2 + subdivisionsThick);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);

  function lerp(a, b, s) {
    return a + (b - a) * s;
  }

  function createArc(arcRadius, x, normalMult, normalAdd, uMult, uAdd) {
    for (var z = 0; z <= subdivisionsDown; z++) {
      var uBack = x / (subdivisionsThick - 1);
      var v = z / subdivisionsDown;
      var xBack = (uBack - 0.5) * 2;
      var angle = (startOffset + v * offsetRange) * Math.PI;
      var s = Math.sin(angle);
      var c = Math.cos(angle);
      var radius = lerp(verticalRadius, arcRadius, s);
      var px = xBack * thickness;
      var py = c * verticalRadius;
      var pz = s * radius;
      positions.push(px, py, pz);
      var n = v3.add(v3.multiply([0, s, c], normalMult), normalAdd);
      normals.push(n);
      texcoords.push(uBack * uMult + uAdd, v);
    }
  } // Generate the individual vertices in our vertex buffer.


  for (var x = 0; x < subdivisionsThick; x++) {
    var uBack = (x / (subdivisionsThick - 1) - 0.5) * 2;
    createArc(outerRadius, x, [1, 1, 1], [0, 0, 0], 1, 0);
    createArc(outerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 0);
    createArc(innerRadius, x, [1, 1, 1], [0, 0, 0], 1, 0);
    createArc(innerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 1);
  } // Do outer surface.


  var indices = createAugmentedTypedArray(3, subdivisionsDown * 2 * (2 + subdivisionsThick), Uint16Array);

  function createSurface(leftArcOffset, rightArcOffset) {
    for (var z = 0; z < subdivisionsDown; ++z) {
      // Make triangle 1 of quad.
      indices.push(leftArcOffset + z + 0, leftArcOffset + z + 1, rightArcOffset + z + 0); // Make triangle 2 of quad.

      indices.push(leftArcOffset + z + 1, rightArcOffset + z + 1, rightArcOffset + z + 0);
    }
  }

  var numVerticesDown = subdivisionsDown + 1; // front

  createSurface(numVerticesDown * 0, numVerticesDown * 4); // right

  createSurface(numVerticesDown * 5, numVerticesDown * 7); // back

  createSurface(numVerticesDown * 6, numVerticesDown * 2); // left

  createSurface(numVerticesDown * 3, numVerticesDown * 1);
  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Creates cylinder BufferInfo. The cylinder will be created around the origin
 * along the y-axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of cylinder.
 * @param {number} height Height of cylinder.
 * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
 * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
 * @param {boolean} [topCap] Create top cap. Default = true.
 * @param {boolean} [bottomCap] Create bottom cap. Default = true.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCylinderBufferInfo
 */

/**
 * Creates cylinder buffers. The cylinder will be created around the origin
 * along the y-axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of cylinder.
 * @param {number} height Height of cylinder.
 * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
 * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
 * @param {boolean} [topCap] Create top cap. Default = true.
 * @param {boolean} [bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCylinderBuffers
 */

/**
 * Creates cylinder vertices. The cylinder will be created around the origin
 * along the y-axis.
 *
 * @param {number} radius Radius of cylinder.
 * @param {number} height Height of cylinder.
 * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
 * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
 * @param {boolean} [topCap] Create top cap. Default = true.
 * @param {boolean} [bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function createCylinderVertices(radius, height, radialSubdivisions, verticalSubdivisions, topCap, bottomCap) {
  return createTruncatedConeVertices(radius, radius, height, radialSubdivisions, verticalSubdivisions, topCap, bottomCap);
}
/**
 * Creates BufferInfo for a torus
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createTorusBufferInfo
 */

/**
 * Creates buffers for a torus
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createTorusBuffers
 */

/**
 * Creates vertices for a torus
 *
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function createTorusVertices(radius, thickness, radialSubdivisions, bodySubdivisions, startAngle, endAngle) {
  if (radialSubdivisions < 3) {
    throw new Error('radialSubdivisions must be 3 or greater');
  }

  if (bodySubdivisions < 3) {
    throw new Error('verticalSubdivisions must be 3 or greater');
  }

  startAngle = startAngle || 0;
  endAngle = endAngle || Math.PI * 2;
  var range = endAngle - startAngle;
  var radialParts = radialSubdivisions + 1;
  var bodyParts = bodySubdivisions + 1;
  var numVertices = radialParts * bodyParts;
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);
  var indices = createAugmentedTypedArray(3, radialSubdivisions * bodySubdivisions * 2, Uint16Array);

  for (var slice = 0; slice < bodyParts; ++slice) {
    var v = slice / bodySubdivisions;
    var sliceAngle = v * Math.PI * 2;
    var sliceSin = Math.sin(sliceAngle);
    var ringRadius = radius + sliceSin * thickness;
    var ny = Math.cos(sliceAngle);
    var y = ny * thickness;

    for (var ring = 0; ring < radialParts; ++ring) {
      var u = ring / radialSubdivisions;
      var ringAngle = startAngle + u * range;
      var xSin = Math.sin(ringAngle);
      var zCos = Math.cos(ringAngle);
      var x = xSin * ringRadius;
      var z = zCos * ringRadius;
      var nx = xSin * sliceSin;
      var nz = zCos * sliceSin;
      positions.push(x, y, z);
      normals.push(nx, ny, nz);
      texcoords.push(u, 1 - v);
    }
  }

  for (var _slice = 0; _slice < bodySubdivisions; ++_slice) {
    // eslint-disable-line
    for (var _ring = 0; _ring < radialSubdivisions; ++_ring) {
      // eslint-disable-line
      var nextRingIndex = 1 + _ring;
      var nextSliceIndex = 1 + _slice;
      indices.push(radialParts * _slice + _ring, radialParts * nextSliceIndex + _ring, radialParts * _slice + nextRingIndex);
      indices.push(radialParts * nextSliceIndex + _ring, radialParts * nextSliceIndex + nextRingIndex, radialParts * _slice + nextRingIndex);
    }
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Creates a disc BufferInfo. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createDiscBufferInfo
 */

/**
 * Creates disc buffers. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createDiscBuffers
 */

/**
 * Creates disc vertices. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function createDiscVertices(radius, divisions, stacks, innerRadius, stackPower) {
  if (divisions < 3) {
    throw new Error('divisions must be at least 3');
  }

  stacks = stacks ? stacks : 1;
  stackPower = stackPower ? stackPower : 1;
  innerRadius = innerRadius ? innerRadius : 0; // Note: We don't share the center vertex because that would
  // mess up texture coordinates.

  var numVertices = (divisions + 1) * (stacks + 1);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);
  var indices = createAugmentedTypedArray(3, stacks * divisions * 2, Uint16Array);
  var firstIndex = 0;
  var radiusSpan = radius - innerRadius;
  var pointsPerStack = divisions + 1; // Build the disk one stack at a time.

  for (var stack = 0; stack <= stacks; ++stack) {
    var stackRadius = innerRadius + radiusSpan * Math.pow(stack / stacks, stackPower);

    for (var i = 0; i <= divisions; ++i) {
      var theta = 2.0 * Math.PI * i / divisions;
      var x = stackRadius * Math.cos(theta);
      var z = stackRadius * Math.sin(theta);
      positions.push(x, 0, z);
      normals.push(0, 1, 0);
      texcoords.push(1 - i / divisions, stack / stacks);

      if (stack > 0 && i !== divisions) {
        // a, b, c and d are the indices of the vertices of a quad.  unless
        // the current stack is the one closest to the center, in which case
        // the vertices a and b connect to the center vertex.
        var a = firstIndex + (i + 1);
        var b = firstIndex + i;
        var c = firstIndex + i - pointsPerStack;
        var d = firstIndex + (i + 1) - pointsPerStack; // Make a quad of the vertices a, b, c, d.

        indices.push(a, b, c);
        indices.push(a, c, d);
      }
    }

    firstIndex += divisions + 1;
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * creates a random integer between 0 and range - 1 inclusive.
 * @param {number} range
 * @return {number} random value between 0 and range - 1 inclusive.
 * @private
 */


function randInt(range) {
  return Math.random() * range | 0;
}
/**
 * Used to supply random colors
 * @callback RandomColorFunc
 * @param {number} ndx index of triangle/quad if unindexed or index of vertex if indexed
 * @param {number} channel 0 = red, 1 = green, 2 = blue, 3 = alpha
 * @return {number} a number from 0 to 255
 * @memberOf module:twgl/primitives
 */

/**
 * @typedef {Object} RandomVerticesOptions
 * @property {number} [vertsPerColor] Defaults to 3 for non-indexed vertices
 * @property {module:twgl/primitives.RandomColorFunc} [rand] A function to generate random numbers
 * @memberOf module:twgl/primitives
 */

/**
 * Creates an augmentedTypedArray of random vertex colors.
 * If the vertices are indexed (have an indices array) then will
 * just make random colors. Otherwise assumes they are triangles
 * and makes one random color for every 3 vertices.
 * @param {Object.<string, AugmentedTypedArray>} vertices Vertices as returned from one of the createXXXVertices functions.
 * @param {module:twgl/primitives.RandomVerticesOptions} [options] options.
 * @return {Object.<string, AugmentedTypedArray>} same vertices as passed in with `color` added.
 * @memberOf module:twgl/primitives
 */


function makeRandomVertexColors(vertices, options) {
  options = options || {};
  var numElements = vertices.position.numElements;
  var vColors = createAugmentedTypedArray(4, numElements, Uint8Array);

  var rand = options.rand || function (ndx, channel) {
    return channel < 3 ? randInt(256) : 255;
  };

  vertices.color = vColors;

  if (vertices.indices) {
    // just make random colors if index
    for (var ii = 0; ii < numElements; ++ii) {
      vColors.push(rand(ii, 0), rand(ii, 1), rand(ii, 2), rand(ii, 3));
    }
  } else {
    // make random colors per triangle
    var numVertsPerColor = options.vertsPerColor || 3;
    var numSets = numElements / numVertsPerColor;

    for (var _ii2 = 0; _ii2 < numSets; ++_ii2) {
      // eslint-disable-line
      var color = [rand(_ii2, 0), rand(_ii2, 1), rand(_ii2, 2), rand(_ii2, 3)];

      for (var jj = 0; jj < numVertsPerColor; ++jj) {
        vColors.push(color);
      }
    }
  }

  return vertices;
}
/**
 * creates a function that calls fn to create vertices and then
 * creates a buffers for them
 * @private
 */


function createBufferFunc(fn) {
  return function (gl) {
    var arrays = fn.apply(this, Array.prototype.slice.call(arguments, 1));
    return attributes.createBuffersFromArrays(gl, arrays);
  };
}
/**
 * creates a function that calls fn to create vertices and then
 * creates a bufferInfo object for them
 * @private
 */


function createBufferInfoFunc(fn) {
  return function (gl) {
    var arrays = fn.apply(null, Array.prototype.slice.call(arguments, 1));
    return attributes.createBufferInfoFromArrays(gl, arrays);
  };
}

var arraySpecPropertyNames = ["numComponents", "size", "type", "normalize", "stride", "offset", "attrib", "name", "attribName"];
/**
 * Copy elements from one array to another
 *
 * @param {Array|TypedArray} src source array
 * @param {Array|TypedArray} dst dest array
 * @param {number} dstNdx index in dest to copy src
 * @param {number} [offset] offset to add to copied values
 * @private
 */

function copyElements(src, dst, dstNdx, offset) {
  offset = offset || 0;
  var length = src.length;

  for (var ii = 0; ii < length; ++ii) {
    dst[dstNdx + ii] = src[ii] + offset;
  }
}
/**
 * Creates an array of the same time
 *
 * @param {(number[]|ArrayBufferView|module:twgl.FullArraySpec)} srcArray array who's type to copy
 * @param {number} length size of new array
 * @return {(number[]|ArrayBufferView|module:twgl.FullArraySpec)} array with same type as srcArray
 * @private
 */


function createArrayOfSameType(srcArray, length) {
  var arraySrc = getArray(srcArray);
  var newArray = new arraySrc.constructor(length);
  var newArraySpec = newArray; // If it appears to have been augmented make new one augmented

  if (arraySrc.numComponents && arraySrc.numElements) {
    augmentTypedArray(newArray, arraySrc.numComponents);
  } // If it was a full spec make new one a full spec


  if (srcArray.data) {
    newArraySpec = {
      data: newArray
    };
    helper.copyNamedProperties(arraySpecPropertyNames, srcArray, newArraySpec);
  }

  return newArraySpec;
}
/**
 * Concatenates sets of vertices
 *
 * Assumes the vertices match in composition. For example
 * if one set of vertices has positions, normals, and indices
 * all sets of vertices must have positions, normals, and indices
 * and of the same type.
 *
 * Example:
 *
 *      const cubeVertices = twgl.primitives.createCubeVertices(2);
 *      const sphereVertices = twgl.primitives.createSphereVertices(1, 10, 10);
 *      // move the sphere 2 units up
 *      twgl.primitives.reorientVertices(
 *          sphereVertices, twgl.m4.translation([0, 2, 0]));
 *      // merge the sphere with the cube
 *      const cubeSphereVertices = twgl.primitives.concatVertices(
 *          [cubeVertices, sphereVertices]);
 *      // turn them into WebGL buffers and attrib data
 *      const bufferInfo = twgl.createBufferInfoFromArrays(gl, cubeSphereVertices);
 *
 * @param {module:twgl.Arrays[]} arrays Array of arrays of vertices
 * @return {module:twgl.Arrays} The concatenated vertices.
 * @memberOf module:twgl/primitives
 */


function concatVertices(arrayOfArrays) {
  var names = {};
  var baseName; // get names of all arrays.
  // and numElements for each set of vertices

  var _loop = function _loop(ii) {
    var arrays = arrayOfArrays[ii];
    Object.keys(arrays).forEach(function (name) {
      // eslint-disable-line
      if (!names[name]) {
        names[name] = [];
      }

      if (!baseName && name !== 'indices') {
        baseName = name;
      }

      var arrayInfo = arrays[name];
      var numComponents = getNumComponents(arrayInfo, name);
      var array = getArray(arrayInfo);
      var numElements = array.length / numComponents;
      names[name].push(numElements);
    });
  };

  for (var ii = 0; ii < arrayOfArrays.length; ++ii) {
    _loop(ii);
  } // compute length of combined array
  // and return one for reference


  function getLengthOfCombinedArrays(name) {
    var length = 0;
    var arraySpec;

    for (var _ii3 = 0; _ii3 < arrayOfArrays.length; ++_ii3) {
      var arrays = arrayOfArrays[_ii3];
      var arrayInfo = arrays[name];
      var array = getArray(arrayInfo);
      length += array.length;

      if (!arraySpec || arrayInfo.data) {
        arraySpec = arrayInfo;
      }
    }

    return {
      length: length,
      spec: arraySpec
    };
  }

  function copyArraysToNewArray(name, base, newArray) {
    var baseIndex = 0;
    var offset = 0;

    for (var _ii4 = 0; _ii4 < arrayOfArrays.length; ++_ii4) {
      var arrays = arrayOfArrays[_ii4];
      var arrayInfo = arrays[name];
      var array = getArray(arrayInfo);

      if (name === 'indices') {
        copyElements(array, newArray, offset, baseIndex);
        baseIndex += base[_ii4];
      } else {
        copyElements(array, newArray, offset);
      }

      offset += array.length;
    }
  }

  var base = names[baseName];
  var newArrays = {};
  Object.keys(names).forEach(function (name) {
    var info = getLengthOfCombinedArrays(name);
    var newArraySpec = createArrayOfSameType(info.spec, info.length);
    copyArraysToNewArray(name, base, getArray(newArraySpec));
    newArrays[name] = newArraySpec;
  });
  return newArrays;
}
/**
 * Creates a duplicate set of vertices
 *
 * This is useful for calling reorientVertices when you
 * also want to keep the original available
 *
 * @param {module:twgl.Arrays} arrays of vertices
 * @return {module:twgl.Arrays} The duplicated vertices.
 * @memberOf module:twgl/primitives
 */


function duplicateVertices(arrays) {
  var newArrays = {};
  Object.keys(arrays).forEach(function (name) {
    var arraySpec = arrays[name];
    var srcArray = getArray(arraySpec);
    var newArraySpec = createArrayOfSameType(arraySpec, srcArray.length);
    copyElements(srcArray, getArray(newArraySpec), 0);
    newArrays[name] = newArraySpec;
  });
  return newArrays;
}

var create3DFBufferInfo = createBufferInfoFunc(create3DFVertices);
exports.create3DFBufferInfo = create3DFBufferInfo;
var create3DFBuffers = createBufferFunc(create3DFVertices);
exports.create3DFBuffers = create3DFBuffers;
var createCubeBufferInfo = createBufferInfoFunc(createCubeVertices);
exports.createCubeBufferInfo = createCubeBufferInfo;
var createCubeBuffers = createBufferFunc(createCubeVertices);
exports.createCubeBuffers = createCubeBuffers;
var createPlaneBufferInfo = createBufferInfoFunc(createPlaneVertices);
exports.createPlaneBufferInfo = createPlaneBufferInfo;
var createPlaneBuffers = createBufferFunc(createPlaneVertices);
exports.createPlaneBuffers = createPlaneBuffers;
var createSphereBufferInfo = createBufferInfoFunc(createSphereVertices);
exports.createSphereBufferInfo = createSphereBufferInfo;
var createSphereBuffers = createBufferFunc(createSphereVertices);
exports.createSphereBuffers = createSphereBuffers;
var createTruncatedConeBufferInfo = createBufferInfoFunc(createTruncatedConeVertices);
exports.createTruncatedConeBufferInfo = createTruncatedConeBufferInfo;
var createTruncatedConeBuffers = createBufferFunc(createTruncatedConeVertices);
exports.createTruncatedConeBuffers = createTruncatedConeBuffers;
var createXYQuadBufferInfo = createBufferInfoFunc(createXYQuadVertices);
exports.createXYQuadBufferInfo = createXYQuadBufferInfo;
var createXYQuadBuffers = createBufferFunc(createXYQuadVertices);
exports.createXYQuadBuffers = createXYQuadBuffers;
var createCrescentBufferInfo = createBufferInfoFunc(createCrescentVertices);
exports.createCrescentBufferInfo = createCrescentBufferInfo;
var createCrescentBuffers = createBufferFunc(createCrescentVertices);
exports.createCrescentBuffers = createCrescentBuffers;
var createCylinderBufferInfo = createBufferInfoFunc(createCylinderVertices);
exports.createCylinderBufferInfo = createCylinderBufferInfo;
var createCylinderBuffers = createBufferFunc(createCylinderVertices);
exports.createCylinderBuffers = createCylinderBuffers;
var createTorusBufferInfo = createBufferInfoFunc(createTorusVertices);
exports.createTorusBufferInfo = createTorusBufferInfo;
var createTorusBuffers = createBufferFunc(createTorusVertices);
exports.createTorusBuffers = createTorusBuffers;
var createDiscBufferInfo = createBufferInfoFunc(createDiscVertices);
exports.createDiscBufferInfo = createDiscBufferInfo;
var createDiscBuffers = createBufferFunc(createDiscVertices); // these were mis-spelled until 4.12

exports.createDiscBuffers = createDiscBuffers;
var createCresentBufferInfo = createCrescentBufferInfo;
exports.createCresentBufferInfo = createCresentBufferInfo;
var createCresentBuffers = createCrescentBuffers;
exports.createCresentBuffers = createCresentBuffers;
var createCresentVertices = createCrescentVertices;
exports.createCresentVertices = createCresentVertices;

/***/ }),

/***/ "./src/programs.js":
/*!*************************!*\
  !*** ./src/programs.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.createAttributeSetters = createAttributeSetters;
exports.createProgram = createProgram;
exports.createProgramFromScripts = createProgramFromScripts;
exports.createProgramFromSources = createProgramFromSources;
exports.createProgramInfo = createProgramInfo;
exports.createProgramInfoFromProgram = createProgramInfoFromProgram;
exports.createUniformSetters = createUniformSetters;
exports.createUniformBlockSpecFromProgram = createUniformBlockSpecFromProgram;
exports.createUniformBlockInfoFromProgram = createUniformBlockInfoFromProgram;
exports.createUniformBlockInfo = createUniformBlockInfo;
exports.createTransformFeedback = createTransformFeedback;
exports.createTransformFeedbackInfo = createTransformFeedbackInfo;
exports.bindTransformFeedbackInfo = bindTransformFeedbackInfo;
exports.setAttributes = setAttributes;
exports.setBuffersAndAttributes = setBuffersAndAttributes;
exports.setUniforms = setUniforms;
exports.setUniformBlock = setUniformBlock;
exports.setBlockUniforms = setBlockUniforms;
exports.bindUniformBlock = bindUniformBlock;
exports.setUniformsAndBindTextures = void 0;

var utils = _interopRequireWildcard(__webpack_require__(/*! ./utils.js */ "./src/utils.js"));

var helper = _interopRequireWildcard(__webpack_require__(/*! ./helper.js */ "./src/helper.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Low level shader program related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.programs` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/programs
 */
var error = helper.error;
var warn = helper.warn;

function getElementById(id) {
  return typeof document !== 'undefined' && document.getElementById ? document.getElementById(id) : null;
}

var TEXTURE0 = 0x84c0;
var DYNAMIC_DRAW = 0x88e8;
var ARRAY_BUFFER = 0x8892;
var ELEMENT_ARRAY_BUFFER = 0x8893;
var UNIFORM_BUFFER = 0x8a11;
var TRANSFORM_FEEDBACK_BUFFER = 0x8c8e;
var TRANSFORM_FEEDBACK = 0x8e22;
var COMPILE_STATUS = 0x8b81;
var LINK_STATUS = 0x8b82;
var FRAGMENT_SHADER = 0x8b30;
var VERTEX_SHADER = 0x8b31;
var SEPARATE_ATTRIBS = 0x8c8d;
var ACTIVE_UNIFORMS = 0x8b86;
var ACTIVE_ATTRIBUTES = 0x8b89;
var TRANSFORM_FEEDBACK_VARYINGS = 0x8c83;
var ACTIVE_UNIFORM_BLOCKS = 0x8a36;
var UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8a44;
var UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8a46;
var UNIFORM_BLOCK_DATA_SIZE = 0x8a40;
var UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8a43;
var FLOAT = 0x1406;
var FLOAT_VEC2 = 0x8B50;
var FLOAT_VEC3 = 0x8B51;
var FLOAT_VEC4 = 0x8B52;
var INT = 0x1404;
var INT_VEC2 = 0x8B53;
var INT_VEC3 = 0x8B54;
var INT_VEC4 = 0x8B55;
var BOOL = 0x8B56;
var BOOL_VEC2 = 0x8B57;
var BOOL_VEC3 = 0x8B58;
var BOOL_VEC4 = 0x8B59;
var FLOAT_MAT2 = 0x8B5A;
var FLOAT_MAT3 = 0x8B5B;
var FLOAT_MAT4 = 0x8B5C;
var SAMPLER_2D = 0x8B5E;
var SAMPLER_CUBE = 0x8B60;
var SAMPLER_3D = 0x8B5F;
var SAMPLER_2D_SHADOW = 0x8B62;
var FLOAT_MAT2x3 = 0x8B65;
var FLOAT_MAT2x4 = 0x8B66;
var FLOAT_MAT3x2 = 0x8B67;
var FLOAT_MAT3x4 = 0x8B68;
var FLOAT_MAT4x2 = 0x8B69;
var FLOAT_MAT4x3 = 0x8B6A;
var SAMPLER_2D_ARRAY = 0x8DC1;
var SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;
var SAMPLER_CUBE_SHADOW = 0x8DC5;
var UNSIGNED_INT = 0x1405;
var UNSIGNED_INT_VEC2 = 0x8DC6;
var UNSIGNED_INT_VEC3 = 0x8DC7;
var UNSIGNED_INT_VEC4 = 0x8DC8;
var INT_SAMPLER_2D = 0x8DCA;
var INT_SAMPLER_3D = 0x8DCB;
var INT_SAMPLER_CUBE = 0x8DCC;
var INT_SAMPLER_2D_ARRAY = 0x8DCF;
var UNSIGNED_INT_SAMPLER_2D = 0x8DD2;
var UNSIGNED_INT_SAMPLER_3D = 0x8DD3;
var UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;
var UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;
var TEXTURE_2D = 0x0DE1;
var TEXTURE_CUBE_MAP = 0x8513;
var TEXTURE_3D = 0x806F;
var TEXTURE_2D_ARRAY = 0x8C1A;
var typeMap = {};
/**
 * Returns the corresponding bind point for a given sampler type
 */

function getBindPointForSamplerType(gl, type) {
  return typeMap[type].bindPoint;
} // This kind of sucks! If you could compose functions as in `var fn = gl[name];`
// this code could be a lot smaller but that is sadly really slow (T_T)


function floatSetter(gl, location) {
  return function (v) {
    gl.uniform1f(location, v);
  };
}

function floatArraySetter(gl, location) {
  return function (v) {
    gl.uniform1fv(location, v);
  };
}

function floatVec2Setter(gl, location) {
  return function (v) {
    gl.uniform2fv(location, v);
  };
}

function floatVec3Setter(gl, location) {
  return function (v) {
    gl.uniform3fv(location, v);
  };
}

function floatVec4Setter(gl, location) {
  return function (v) {
    gl.uniform4fv(location, v);
  };
}

function intSetter(gl, location) {
  return function (v) {
    gl.uniform1i(location, v);
  };
}

function intArraySetter(gl, location) {
  return function (v) {
    gl.uniform1iv(location, v);
  };
}

function intVec2Setter(gl, location) {
  return function (v) {
    gl.uniform2iv(location, v);
  };
}

function intVec3Setter(gl, location) {
  return function (v) {
    gl.uniform3iv(location, v);
  };
}

function intVec4Setter(gl, location) {
  return function (v) {
    gl.uniform4iv(location, v);
  };
}

function uintSetter(gl, location) {
  return function (v) {
    gl.uniform1ui(location, v);
  };
}

function uintArraySetter(gl, location) {
  return function (v) {
    gl.uniform1uiv(location, v);
  };
}

function uintVec2Setter(gl, location) {
  return function (v) {
    gl.uniform2uiv(location, v);
  };
}

function uintVec3Setter(gl, location) {
  return function (v) {
    gl.uniform3uiv(location, v);
  };
}

function uintVec4Setter(gl, location) {
  return function (v) {
    gl.uniform4uiv(location, v);
  };
}

function floatMat2Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix2fv(location, false, v);
  };
}

function floatMat3Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix3fv(location, false, v);
  };
}

function floatMat4Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix4fv(location, false, v);
  };
}

function floatMat23Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix2x3fv(location, false, v);
  };
}

function floatMat32Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix3x2fv(location, false, v);
  };
}

function floatMat24Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix2x4fv(location, false, v);
  };
}

function floatMat42Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix4x2fv(location, false, v);
  };
}

function floatMat34Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix3x4fv(location, false, v);
  };
}

function floatMat43Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix4x3fv(location, false, v);
  };
}

function samplerSetter(gl, type, unit, location) {
  var bindPoint = getBindPointForSamplerType(gl, type);
  return utils.isWebGL2(gl) ? function (textureOrPair) {
    var texture;
    var sampler;

    if (helper.isTexture(gl, textureOrPair)) {
      texture = textureOrPair;
      sampler = null;
    } else {
      texture = textureOrPair.texture;
      sampler = textureOrPair.sampler;
    }

    gl.uniform1i(location, unit);
    gl.activeTexture(TEXTURE0 + unit);
    gl.bindTexture(bindPoint, texture);
    gl.bindSampler(unit, sampler);
  } : function (texture) {
    gl.uniform1i(location, unit);
    gl.activeTexture(TEXTURE0 + unit);
    gl.bindTexture(bindPoint, texture);
  };
}

function samplerArraySetter(gl, type, unit, location, size) {
  var bindPoint = getBindPointForSamplerType(gl, type);
  var units = new Int32Array(size);

  for (var ii = 0; ii < size; ++ii) {
    units[ii] = unit + ii;
  }

  return utils.isWebGL2(gl) ? function (textures) {
    gl.uniform1iv(location, units);
    textures.forEach(function (textureOrPair, index) {
      gl.activeTexture(TEXTURE0 + units[index]);
      var texture;
      var sampler;

      if (helper.isTexture(gl, textureOrPair)) {
        texture = textureOrPair;
        sampler = null;
      } else {
        texture = textureOrPair.texture;
        sampler = textureOrPair.sampler;
      }

      gl.bindSampler(unit, sampler);
      gl.bindTexture(bindPoint, texture);
    });
  } : function (textures) {
    gl.uniform1iv(location, units);
    textures.forEach(function (texture, index) {
      gl.activeTexture(TEXTURE0 + units[index]);
      gl.bindTexture(bindPoint, texture);
    });
  };
}

typeMap[FLOAT] = {
  Type: Float32Array,
  size: 4,
  setter: floatSetter,
  arraySetter: floatArraySetter
};
typeMap[FLOAT_VEC2] = {
  Type: Float32Array,
  size: 8,
  setter: floatVec2Setter
};
typeMap[FLOAT_VEC3] = {
  Type: Float32Array,
  size: 12,
  setter: floatVec3Setter
};
typeMap[FLOAT_VEC4] = {
  Type: Float32Array,
  size: 16,
  setter: floatVec4Setter
};
typeMap[INT] = {
  Type: Int32Array,
  size: 4,
  setter: intSetter,
  arraySetter: intArraySetter
};
typeMap[INT_VEC2] = {
  Type: Int32Array,
  size: 8,
  setter: intVec2Setter
};
typeMap[INT_VEC3] = {
  Type: Int32Array,
  size: 12,
  setter: intVec3Setter
};
typeMap[INT_VEC4] = {
  Type: Int32Array,
  size: 16,
  setter: intVec4Setter
};
typeMap[UNSIGNED_INT] = {
  Type: Uint32Array,
  size: 4,
  setter: uintSetter,
  arraySetter: uintArraySetter
};
typeMap[UNSIGNED_INT_VEC2] = {
  Type: Uint32Array,
  size: 8,
  setter: uintVec2Setter
};
typeMap[UNSIGNED_INT_VEC3] = {
  Type: Uint32Array,
  size: 12,
  setter: uintVec3Setter
};
typeMap[UNSIGNED_INT_VEC4] = {
  Type: Uint32Array,
  size: 16,
  setter: uintVec4Setter
};
typeMap[BOOL] = {
  Type: Uint32Array,
  size: 4,
  setter: intSetter,
  arraySetter: intArraySetter
};
typeMap[BOOL_VEC2] = {
  Type: Uint32Array,
  size: 8,
  setter: intVec2Setter
};
typeMap[BOOL_VEC3] = {
  Type: Uint32Array,
  size: 12,
  setter: intVec3Setter
};
typeMap[BOOL_VEC4] = {
  Type: Uint32Array,
  size: 16,
  setter: intVec4Setter
};
typeMap[FLOAT_MAT2] = {
  Type: Float32Array,
  size: 16,
  setter: floatMat2Setter
};
typeMap[FLOAT_MAT3] = {
  Type: Float32Array,
  size: 36,
  setter: floatMat3Setter
};
typeMap[FLOAT_MAT4] = {
  Type: Float32Array,
  size: 64,
  setter: floatMat4Setter
};
typeMap[FLOAT_MAT2x3] = {
  Type: Float32Array,
  size: 24,
  setter: floatMat23Setter
};
typeMap[FLOAT_MAT2x4] = {
  Type: Float32Array,
  size: 32,
  setter: floatMat24Setter
};
typeMap[FLOAT_MAT3x2] = {
  Type: Float32Array,
  size: 24,
  setter: floatMat32Setter
};
typeMap[FLOAT_MAT3x4] = {
  Type: Float32Array,
  size: 48,
  setter: floatMat34Setter
};
typeMap[FLOAT_MAT4x2] = {
  Type: Float32Array,
  size: 32,
  setter: floatMat42Setter
};
typeMap[FLOAT_MAT4x3] = {
  Type: Float32Array,
  size: 48,
  setter: floatMat43Setter
};
typeMap[SAMPLER_2D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D
};
typeMap[SAMPLER_CUBE] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP
};
typeMap[SAMPLER_3D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_3D
};
typeMap[SAMPLER_2D_SHADOW] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D
};
typeMap[SAMPLER_2D_ARRAY] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY
};
typeMap[SAMPLER_2D_ARRAY_SHADOW] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY
};
typeMap[SAMPLER_CUBE_SHADOW] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP
};
typeMap[INT_SAMPLER_2D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D
};
typeMap[INT_SAMPLER_3D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_3D
};
typeMap[INT_SAMPLER_CUBE] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP
};
typeMap[INT_SAMPLER_2D_ARRAY] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY
};
typeMap[UNSIGNED_INT_SAMPLER_2D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D
};
typeMap[UNSIGNED_INT_SAMPLER_3D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_3D
};
typeMap[UNSIGNED_INT_SAMPLER_CUBE] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP
};
typeMap[UNSIGNED_INT_SAMPLER_2D_ARRAY] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY
};

function floatAttribSetter(gl, index) {
  return function (b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);

      switch (b.value.length) {
        case 4:
          gl.vertexAttrib4fv(index, b.value);
          break;

        case 3:
          gl.vertexAttrib3fv(index, b.value);
          break;

        case 2:
          gl.vertexAttrib2fv(index, b.value);
          break;

        case 1:
          gl.vertexAttrib1fv(index, b.value);
          break;

        default:
          throw new Error('the length of a float constant value must be between 1 and 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribPointer(index, b.numComponents || b.size, b.type || FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);

      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index, b.divisor);
      }
    }
  };
}

function intAttribSetter(gl, index) {
  return function (b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);

      if (b.value.length === 4) {
        gl.vertexAttrib4iv(index, b.value);
      } else {
        throw new Error('The length of an integer constant value must be 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribIPointer(index, b.numComponents || b.size, b.type || INT, b.stride || 0, b.offset || 0);

      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index, b.divisor);
      }
    }
  };
}

function uintAttribSetter(gl, index) {
  return function (b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);

      if (b.value.length === 4) {
        gl.vertexAttrib4uiv(index, b.value);
      } else {
        throw new Error('The length of an unsigned integer constant value must be 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribIPointer(index, b.numComponents || b.size, b.type || UNSIGNED_INT, b.stride || 0, b.offset || 0);

      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index, b.divisor);
      }
    }
  };
}

function matAttribSetter(gl, index, typeInfo) {
  var defaultSize = typeInfo.size;
  var count = typeInfo.count;
  return function (b) {
    gl.bindBuffer(ARRAY_BUFFER, b.buffer);
    var numComponents = b.size || b.numComponents || defaultSize;
    var size = numComponents / count;
    var type = b.type || FLOAT;
    var typeInfo = typeMap[type];
    var stride = typeInfo.size * numComponents;
    var normalize = b.normalize || false;
    var offset = b.offset || 0;
    var rowOffset = stride / count;

    for (var i = 0; i < count; ++i) {
      gl.enableVertexAttribArray(index + i);
      gl.vertexAttribPointer(index + i, size, type, normalize, stride, offset + rowOffset * i);

      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index + i, b.divisor);
      }
    }
  };
}

var attrTypeMap = {};
attrTypeMap[FLOAT] = {
  size: 4,
  setter: floatAttribSetter
};
attrTypeMap[FLOAT_VEC2] = {
  size: 8,
  setter: floatAttribSetter
};
attrTypeMap[FLOAT_VEC3] = {
  size: 12,
  setter: floatAttribSetter
};
attrTypeMap[FLOAT_VEC4] = {
  size: 16,
  setter: floatAttribSetter
};
attrTypeMap[INT] = {
  size: 4,
  setter: intAttribSetter
};
attrTypeMap[INT_VEC2] = {
  size: 8,
  setter: intAttribSetter
};
attrTypeMap[INT_VEC3] = {
  size: 12,
  setter: intAttribSetter
};
attrTypeMap[INT_VEC4] = {
  size: 16,
  setter: intAttribSetter
};
attrTypeMap[UNSIGNED_INT] = {
  size: 4,
  setter: uintAttribSetter
};
attrTypeMap[UNSIGNED_INT_VEC2] = {
  size: 8,
  setter: uintAttribSetter
};
attrTypeMap[UNSIGNED_INT_VEC3] = {
  size: 12,
  setter: uintAttribSetter
};
attrTypeMap[UNSIGNED_INT_VEC4] = {
  size: 16,
  setter: uintAttribSetter
};
attrTypeMap[BOOL] = {
  size: 4,
  setter: intAttribSetter
};
attrTypeMap[BOOL_VEC2] = {
  size: 8,
  setter: intAttribSetter
};
attrTypeMap[BOOL_VEC3] = {
  size: 12,
  setter: intAttribSetter
};
attrTypeMap[BOOL_VEC4] = {
  size: 16,
  setter: intAttribSetter
};
attrTypeMap[FLOAT_MAT2] = {
  size: 4,
  setter: matAttribSetter,
  count: 2
};
attrTypeMap[FLOAT_MAT3] = {
  size: 9,
  setter: matAttribSetter,
  count: 3
};
attrTypeMap[FLOAT_MAT4] = {
  size: 16,
  setter: matAttribSetter,
  count: 4
}; // make sure we don't see a global gl

var gl = undefined;
/* eslint-disable-line */

var errorRE = /ERROR:\s*\d+:(\d+)/gi;

function addLineNumbersWithError(src) {
  var log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var lineOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  // Note: Error message formats are not defined by any spec so this may or may not work.
  var matches = _toConsumableArray(log.matchAll(errorRE));

  var lineNoToErrorMap = new Map(matches.map(function (m, ndx) {
    var lineNo = parseInt(m[1]);
    var next = matches[ndx + 1];
    var end = next ? next.index : log.length;
    var msg = log.substring(m.index, end);
    return [lineNo - 1, msg];
  }));
  return src.split('\n').map(function (line, lineNo) {
    var err = lineNoToErrorMap.get(lineNo);
    return "".concat(lineNo + 1 + lineOffset, ": ").concat(line).concat(err ? "\n\n^^^ ".concat(err) : '');
  }).join('\n');
}
/**
 * Error Callback
 * @callback ErrorCallback
 * @param {string} msg error message.
 * @param {number} [lineOffset] amount to add to line number
 * @memberOf module:twgl
 */


var spaceRE = /^[ \t]*\n/;
/**
 * Loads a shader.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {string} shaderSource The shader source.
 * @param {number} shaderType The type of shader.
 * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors.
 * @return {WebGLShader} The created shader.
 * @private
 */

function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {
  var errFn = opt_errorCallback || error; // Create the shader object

  var shader = gl.createShader(shaderType); // Remove the first end of line because WebGL 2.0 requires
  // #version 300 es
  // as the first line. No whitespace allowed before that line
  // so
  //
  // <script>
  // #version 300 es
  // </script>
  //
  // Has one line before it which is invalid according to GLSL ES 3.00
  //

  var lineOffset = 0;

  if (spaceRE.test(shaderSource)) {
    lineOffset = 1;
    shaderSource = shaderSource.replace(spaceRE, '');
  } // Load the shader source


  gl.shaderSource(shader, shaderSource); // Compile the shader

  gl.compileShader(shader); // Check the compile status

  var compiled = gl.getShaderParameter(shader, COMPILE_STATUS);

  if (!compiled) {
    // Something went wrong during compilation; get the error
    var lastError = gl.getShaderInfoLog(shader);
    errFn("".concat(addLineNumbersWithError(shaderSource, lastError, lineOffset), "\nError compiling ").concat(utils.glEnumToString(gl, shaderType), ": ").concat(lastError));
    gl.deleteShader(shader);
    return null;
  }

  return shader;
}
/**
 * @typedef {Object} ProgramOptions
 * @property {function(string)} [errorCallback] callback for errors
 * @property {Object.<string,number>} [attribLocations] a attribute name to location map
 * @property {(module:twgl.BufferInfo|Object.<string,module:twgl.AttribInfo>|string[])} [transformFeedbackVaryings] If passed
 *   a BufferInfo will use the attribs names inside. If passed an object of AttribInfos will use the names from that object. Otherwise
 *   you can pass an array of names.
 * @property {number} [transformFeedbackMode] the mode to pass `gl.transformFeedbackVaryings`. Defaults to `SEPARATE_ATTRIBS`.
 * @memberOf module:twgl
 */

/**
 * Gets the program options based on all these optional arguments
 * @param {module:twgl.ProgramOptions|string[]} [opt_attribs] Options for the program or an array of attribs names. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {module:twgl.ProgramOptions} an instance of ProgramOptions based on the arguments passed in
 * @private
 */


function getProgramOptions(opt_attribs, opt_locations, opt_errorCallback) {
  var transformFeedbackVaryings;
  var transformFeedbackMode;

  if (typeof opt_locations === 'function') {
    opt_errorCallback = opt_locations;
    opt_locations = undefined;
  }

  if (typeof opt_attribs === 'function') {
    opt_errorCallback = opt_attribs;
    opt_attribs = undefined;
  } else if (opt_attribs && !Array.isArray(opt_attribs)) {
    // If we have an errorCallback we can just return this object
    // Otherwise we need to construct one with default errorCallback
    if (opt_attribs.errorCallback) {
      return opt_attribs;
    }

    var opt = opt_attribs;
    opt_errorCallback = opt.errorCallback;
    opt_attribs = opt.attribLocations;
    transformFeedbackVaryings = opt.transformFeedbackVaryings;
    transformFeedbackMode = opt.transformFeedbackMode;
  }

  var options = {
    errorCallback: opt_errorCallback || error,
    transformFeedbackVaryings: transformFeedbackVaryings,
    transformFeedbackMode: transformFeedbackMode
  };

  if (opt_attribs) {
    var attribLocations = {};

    if (Array.isArray(opt_attribs)) {
      opt_attribs.forEach(function (attrib, ndx) {
        attribLocations[attrib] = opt_locations ? opt_locations[ndx] : ndx;
      });
    } else {
      attribLocations = opt_attribs;
    }

    options.attribLocations = attribLocations;
  }

  return options;
}

var defaultShaderType = ["VERTEX_SHADER", "FRAGMENT_SHADER"];

function getShaderTypeFromScriptType(gl, scriptType) {
  if (scriptType.indexOf("frag") >= 0) {
    return FRAGMENT_SHADER;
  } else if (scriptType.indexOf("vert") >= 0) {
    return VERTEX_SHADER;
  }

  return undefined;
}

function deleteShaders(gl, shaders) {
  shaders.forEach(function (shader) {
    gl.deleteShader(shader);
  });
}
/**
 * Creates a program, attaches (and/or compiles) shaders, binds attrib locations, links the
 * program and calls useProgram.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgram(gl, [vs, fs], options);
 *     twgl.createProgram(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLShader[]|string[]} shaders The shaders to attach, or element ids for their source, or strings that contain their source
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error.
 * @memberOf module:twgl/programs
 */


function createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {
  var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  var realShaders = [];
  var newShaders = [];

  for (var ndx = 0; ndx < shaders.length; ++ndx) {
    var shader = shaders[ndx];

    if (typeof shader === 'string') {
      var elem = getElementById(shader);
      var src = elem ? elem.text : shader;
      var type = gl[defaultShaderType[ndx]];

      if (elem && elem.type) {
        type = getShaderTypeFromScriptType(gl, elem.type) || type;
      }

      shader = loadShader(gl, src, type, progOptions.errorCallback);
      newShaders.push(shader);
    }

    if (helper.isShader(gl, shader)) {
      realShaders.push(shader);
    }
  }

  if (realShaders.length !== shaders.length) {
    progOptions.errorCallback("not enough shaders for program");
    deleteShaders(gl, newShaders);
    return null;
  }

  var program = gl.createProgram();
  realShaders.forEach(function (shader) {
    gl.attachShader(program, shader);
  });

  if (progOptions.attribLocations) {
    Object.keys(progOptions.attribLocations).forEach(function (attrib) {
      gl.bindAttribLocation(program, progOptions.attribLocations[attrib], attrib);
    });
  }

  var varyings = progOptions.transformFeedbackVaryings;

  if (varyings) {
    if (varyings.attribs) {
      varyings = varyings.attribs;
    }

    if (!Array.isArray(varyings)) {
      varyings = Object.keys(varyings);
    }

    gl.transformFeedbackVaryings(program, varyings, progOptions.transformFeedbackMode || SEPARATE_ATTRIBS);
  }

  gl.linkProgram(program); // Check the link status

  var linked = gl.getProgramParameter(program, LINK_STATUS);

  if (!linked) {
    // something went wrong with the link
    var lastError = gl.getProgramInfoLog(program);
    progOptions.errorCallback("".concat(realShaders.map(function (shader) {
      var src = addLineNumbersWithError(gl.getShaderSource(shader), '', 0);
      var type = gl.getShaderParameter(shader, gl.SHADER_TYPE);
      return "".concat(utils.glEnumToString(gl, type), "\n").concat(src, "}");
    }).join('\n'), "\nError in program linking: ").concat(lastError));
    gl.deleteProgram(program);
    deleteShaders(gl, newShaders);
    return null;
  }

  return program;
}
/**
 * Loads a shader from a script tag.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {string} scriptId The id of the script tag.
 * @param {number} [opt_shaderType] The type of shader. If not passed in it will
 *     be derived from the type of the script tag.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors.
 * @return {WebGLShader?} The created shader or null if error.
 * @private
 */


function createShaderFromScript(gl, scriptId, opt_shaderType, opt_errorCallback) {
  var shaderSource = "";
  var shaderScript = getElementById(scriptId);

  if (!shaderScript) {
    throw new Error("unknown script element: ".concat(scriptId));
  }

  shaderSource = shaderScript.text;
  var shaderType = opt_shaderType || getShaderTypeFromScriptType(gl, shaderScript.type);

  if (!shaderType) {
    throw new Error('unknown shader type');
  }

  return loadShader(gl, shaderSource, shaderType, opt_errorCallback);
}
/**
 * Creates a program from 2 script tags.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_options);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderScriptIds Array of ids of the script
 *        tags for the shaders. The first is assumed to be the
 *        vertex shader, the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error.
 * @memberOf module:twgl/programs
 */


function createProgramFromScripts(gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {
  var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  var shaders = [];

  for (var ii = 0; ii < shaderScriptIds.length; ++ii) {
    var shader = createShaderFromScript(gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], progOptions.errorCallback);

    if (!shader) {
      return null;
    }

    shaders.push(shader);
  }

  return createProgram(gl, shaders, progOptions);
}
/**
 * Creates a program from 2 sources.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_options);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderSources Array of sources for the
 *        shaders. The first is assumed to be the vertex shader,
 *        the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error.
 * @memberOf module:twgl/programs
 */


function createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
  var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  var shaders = [];

  for (var ii = 0; ii < shaderSources.length; ++ii) {
    var shader = loadShader(gl, shaderSources[ii], gl[defaultShaderType[ii]], progOptions.errorCallback);

    if (!shader) {
      return null;
    }

    shaders.push(shader);
  }

  return createProgram(gl, shaders, progOptions);
}
/**
 * Returns true if attribute/uniform is a reserved/built in
 *
 * It makes no sense to me why GL returns these because it's
 * illegal to call `gl.getUniformLocation` and `gl.getAttribLocation`
 * with names that start with `gl_` (and `webgl_` in WebGL)
 *
 * I can only assume they are there because they might count
 * when computing the number of uniforms/attributes used when you want to
 * know if you are near the limit. That doesn't really make sense
 * to me but the fact that these get returned are in the spec.
 *
 * @param {WebGLActiveInfo} info As returned from `gl.getActiveUniform` or
 *    `gl.getActiveAttrib`.
 * @return {bool} true if it's reserved
 * @private
 */


function isBuiltIn(info) {
  var name = info.name;
  return name.startsWith("gl_") || name.startsWith("webgl_");
}
/**
 * Creates setter functions for all uniforms of a shader
 * program.
 *
 * @see {@link module:twgl.setUniforms}
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program the program to create setters for.
 * @returns {Object.<string, function>} an object with a setter by name for each uniform
 * @memberOf module:twgl/programs
 */


function createUniformSetters(gl, program) {
  var textureUnit = 0;
  /**
   * Creates a setter for a uniform of the given program with it's
   * location embedded in the setter.
   * @param {WebGLProgram} program
   * @param {WebGLUniformInfo} uniformInfo
   * @returns {function} the created setter.
   */

  function createUniformSetter(program, uniformInfo, location) {
    var isArray = uniformInfo.name.endsWith("[0]");
    var type = uniformInfo.type;
    var typeInfo = typeMap[type];

    if (!typeInfo) {
      throw new Error("unknown type: 0x".concat(type.toString(16))); // we should never get here.
    }

    var setter;

    if (typeInfo.bindPoint) {
      // it's a sampler
      var unit = textureUnit;
      textureUnit += uniformInfo.size;

      if (isArray) {
        setter = typeInfo.arraySetter(gl, type, unit, location, uniformInfo.size);
      } else {
        setter = typeInfo.setter(gl, type, unit, location, uniformInfo.size);
      }
    } else {
      if (typeInfo.arraySetter && isArray) {
        setter = typeInfo.arraySetter(gl, location);
      } else {
        setter = typeInfo.setter(gl, location);
      }
    }

    setter.location = location;
    return setter;
  }

  var uniformSetters = {};
  var numUniforms = gl.getProgramParameter(program, ACTIVE_UNIFORMS);

  for (var ii = 0; ii < numUniforms; ++ii) {
    var uniformInfo = gl.getActiveUniform(program, ii);

    if (isBuiltIn(uniformInfo)) {
      continue;
    }

    var name = uniformInfo.name; // remove the array suffix.

    if (name.endsWith("[0]")) {
      name = name.substr(0, name.length - 3);
    }

    var location = gl.getUniformLocation(program, uniformInfo.name); // the uniform will have no location if it's in a uniform block

    if (location) {
      uniformSetters[name] = createUniformSetter(program, uniformInfo, location);
    }
  }

  return uniformSetters;
}
/**
 * @typedef {Object} TransformFeedbackInfo
 * @property {number} index index of transform feedback
 * @property {number} type GL type
 * @property {number} size 1 - 4
 * @memberOf module:twgl
 */

/**
 * Create TransformFeedbackInfo for passing to bindTransformFeedbackInfo.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program an existing WebGLProgram.
 * @return {Object<string, module:twgl.TransformFeedbackInfo>}
 * @memberOf module:twgl
 */


function createTransformFeedbackInfo(gl, program) {
  var info = {};
  var numVaryings = gl.getProgramParameter(program, TRANSFORM_FEEDBACK_VARYINGS);

  for (var ii = 0; ii < numVaryings; ++ii) {
    var varying = gl.getTransformFeedbackVarying(program, ii);
    info[varying.name] = {
      index: ii,
      type: varying.type,
      size: varying.size
    };
  }

  return info;
}
/**
 * Binds buffers for transform feedback.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {(module:twgl.ProgramInfo|Object<string, module:twgl.TransformFeedbackInfo>)} transformFeedbackInfo A ProgramInfo or TransformFeedbackInfo.
 * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.
 * @memberOf module:twgl
 */


function bindTransformFeedbackInfo(gl, transformFeedbackInfo, bufferInfo) {
  if (transformFeedbackInfo.transformFeedbackInfo) {
    transformFeedbackInfo = transformFeedbackInfo.transformFeedbackInfo;
  }

  if (bufferInfo.attribs) {
    bufferInfo = bufferInfo.attribs;
  }

  for (var name in bufferInfo) {
    var varying = transformFeedbackInfo[name];

    if (varying) {
      var buf = bufferInfo[name];

      if (buf.offset) {
        gl.bindBufferRange(TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer, buf.offset, buf.size);
      } else {
        gl.bindBufferBase(TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer);
      }
    }
  }
}
/**
 * Creates a transform feedback and sets the buffers
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}
 * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.
 * @return {WebGLTransformFeedback} the created transform feedback
 * @memberOf module:twgl
 */


function createTransformFeedback(gl, programInfo, bufferInfo) {
  var tf = gl.createTransformFeedback();
  gl.bindTransformFeedback(TRANSFORM_FEEDBACK, tf);
  gl.useProgram(programInfo.program);
  bindTransformFeedbackInfo(gl, programInfo, bufferInfo);
  gl.bindTransformFeedback(TRANSFORM_FEEDBACK, null);
  return tf;
}
/**
 * @typedef {Object} UniformData
 * @property {number} type The WebGL type enum for this uniform
 * @property {number} size The number of elements for this uniform
 * @property {number} blockNdx The block index this uniform appears in
 * @property {number} offset The byte offset in the block for this uniform's value
 * @memberOf module:twgl
 */

/**
 * The specification for one UniformBlockObject
 *
 * @typedef {Object} BlockSpec
 * @property {number} index The index of the block.
 * @property {number} size The size in bytes needed for the block
 * @property {number[]} uniformIndices The indices of the uniforms used by the block. These indices
 *    correspond to entries in a UniformData array in the {@link module:twgl.UniformBlockSpec}.
 * @property {bool} usedByVertexShader Self explanatory
 * @property {bool} usedByFragmentShader Self explanatory
 * @property {bool} used Self explanatory
 * @memberOf module:twgl
 */

/**
 * A `UniformBlockSpec` represents the data needed to create and bind
 * UniformBlockObjects for a given program
 *
 * @typedef {Object} UniformBlockSpec
 * @property {Object.<string, module:twgl.BlockSpec> blockSpecs The BlockSpec for each block by block name
 * @property {UniformData[]} uniformData An array of data for each uniform by uniform index.
 * @memberOf module:twgl
 */

/**
 * Creates a UniformBlockSpec for the given program.
 *
 * A UniformBlockSpec represents the data needed to create and bind
 * UniformBlockObjects
 *
 * @param {WebGL2RenderingContext} gl A WebGL2 Rendering Context
 * @param {WebGLProgram} program A WebGLProgram for a successfully linked program
 * @return {module:twgl.UniformBlockSpec} The created UniformBlockSpec
 * @memberOf module:twgl/programs
 */


function createUniformBlockSpecFromProgram(gl, program) {
  var numUniforms = gl.getProgramParameter(program, ACTIVE_UNIFORMS);
  var uniformData = [];
  var uniformIndices = [];

  for (var ii = 0; ii < numUniforms; ++ii) {
    uniformIndices.push(ii);
    uniformData.push({});
    var uniformInfo = gl.getActiveUniform(program, ii);

    if (isBuiltIn(uniformInfo)) {
      break;
    }

    uniformData[ii].name = uniformInfo.name;
  }

  [["UNIFORM_TYPE", "type"], ["UNIFORM_SIZE", "size"], // num elements
  ["UNIFORM_BLOCK_INDEX", "blockNdx"], ["UNIFORM_OFFSET", "offset"]].forEach(function (pair) {
    var pname = pair[0];
    var key = pair[1];
    gl.getActiveUniforms(program, uniformIndices, gl[pname]).forEach(function (value, ndx) {
      uniformData[ndx][key] = value;
    });
  });
  var blockSpecs = {};
  var numUniformBlocks = gl.getProgramParameter(program, ACTIVE_UNIFORM_BLOCKS);

  for (var _ii = 0; _ii < numUniformBlocks; ++_ii) {
    var name = gl.getActiveUniformBlockName(program, _ii);
    var blockSpec = {
      index: gl.getUniformBlockIndex(program, name),
      usedByVertexShader: gl.getActiveUniformBlockParameter(program, _ii, UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),
      usedByFragmentShader: gl.getActiveUniformBlockParameter(program, _ii, UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),
      size: gl.getActiveUniformBlockParameter(program, _ii, UNIFORM_BLOCK_DATA_SIZE),
      uniformIndices: gl.getActiveUniformBlockParameter(program, _ii, UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES)
    };
    blockSpec.used = blockSpec.usedByVertexShader || blockSpec.usedByFragmentShader;
    blockSpecs[name] = blockSpec;
  }

  return {
    blockSpecs: blockSpecs,
    uniformData: uniformData
  };
}

var arraySuffixRE = /\[\d+\]\.$/; // better way to check?

var pad = function pad(v, padding) {
  return ((v + (padding - 1)) / padding | 0) * padding;
};

function createUniformBlockUniformSetter(view, Type, typeSize, paddedSize, isArray) {
  if (isArray) {
    var numElements = typeSize / Type.BYTES_PER_ELEMENT;
    var numPaddedElements = paddedSize / Type.BYTES_PER_ELEMENT;
    return function (value) {
      var dst = 0;

      for (var src = 0; src < value.length; src += numElements) {
        for (var i = 0; i < numElements; ++i) {
          view[dst + i] = value[src + i];
        }

        dst += numPaddedElements;
      }
    };
  } else {
    return function (value) {
      if (value.length) {
        view.set(value);
      } else {
        view[0] = value;
      }
    };
  }
}
/**
 * Represents a UniformBlockObject including an ArrayBuffer with all the uniform values
 * and a corresponding WebGLBuffer to hold those values on the GPU
 *
 * @typedef {Object} UniformBlockInfo
 * @property {string} name The name of the block
 * @property {ArrayBuffer} array The array buffer that contains the uniform values
 * @property {Float32Array} asFloat A float view on the array buffer. This is useful
 *    inspecting the contents of the buffer in the debugger.
 * @property {WebGLBuffer} buffer A WebGL buffer that will hold a copy of the uniform values for rendering.
 * @property {number} [offset] offset into buffer
 * @property {Object<string, ArrayBufferView>} uniforms A uniform name to ArrayBufferView map.
 *   each Uniform has a correctly typed `ArrayBufferView` into array at the correct offset
 *   and length of that uniform. So for example a float uniform would have a 1 float `Float32Array`
 *   view. A single mat4 would have a 16 element `Float32Array` view. An ivec2 would have an
 *   `Int32Array` view, etc.
 * @property {Object<string, function>} setters A setter for this uniform.
 *   The reason to use setters is elements of arrays are padded to vec4 sizes which
 *   means if you want to set an array of 4 floats you'd need to set 16 values
 *   (or set elements 0, 4, 8, 12). In other words
 *   `someBlockInfo.uniforms.some4FloatArrayUniform.set([0, , , , 1, , , , 2, , , , 3])`
 *   where as the setter handles just passing in [0, 1, 2, 3] either directly as in
 *   `someBlockInfo.setter.some4FloatArrayUniform.set([0, 1, 2, 3])` (not recommended)
 *   or via {@link module:twgl.setBlockUniforms}
 * @memberOf module:twgl
 */

/**
 * Creates a `UniformBlockInfo` for the specified block
 *
 * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy
 * `UniformBlockInfo` is returned**. This is because when debugging GLSL
 * it is common to comment out large portions of a shader or for example set
 * the final output to a constant. When that happens blocks get optimized out.
 * If this function did not create dummy blocks your code would crash when debugging.
 *
 * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext
 * @param {WebGLProgram} program A WebGLProgram
 * @param {module:twgl.UniformBlockSpec} uniformBlockSpec. A UniformBlockSpec as returned
 *     from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {string} blockName The name of the block.
 * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo
 * @memberOf module:twgl/programs
 */


function createUniformBlockInfoFromProgram(gl, program, uniformBlockSpec, blockName) {
  var blockSpecs = uniformBlockSpec.blockSpecs;
  var uniformData = uniformBlockSpec.uniformData;
  var blockSpec = blockSpecs[blockName];

  if (!blockSpec) {
    warn("no uniform block object named:", blockName);
    return {
      name: blockName,
      uniforms: {}
    };
  }

  var array = new ArrayBuffer(blockSpec.size);
  var buffer = gl.createBuffer();
  var uniformBufferIndex = blockSpec.index;
  gl.bindBuffer(UNIFORM_BUFFER, buffer);
  gl.uniformBlockBinding(program, blockSpec.index, uniformBufferIndex);
  var prefix = blockName + ".";

  if (arraySuffixRE.test(prefix)) {
    prefix = prefix.replace(arraySuffixRE, ".");
  }

  var uniforms = {};
  var setters = {};
  blockSpec.uniformIndices.forEach(function (uniformNdx) {
    var data = uniformData[uniformNdx];
    var typeInfo = typeMap[data.type];
    var Type = typeInfo.Type;
    var paddedSize = pad(typeInfo.size, 16);
    var length = typeInfo.size + (data.size - 1) * paddedSize;
    var name = data.name;

    if (name.startsWith(prefix)) {
      name = name.substr(prefix.length);
    }

    var isArray = name.endsWith('[0]');

    if (isArray) {
      name = name.substr(0, name.length - 3);
    }

    var uniformView = new Type(array, data.offset, length / Type.BYTES_PER_ELEMENT);
    uniforms[name] = uniformView;
    setters[name] = createUniformBlockUniformSetter(uniformView, Type, typeInfo.size, paddedSize, isArray);
  });
  return {
    name: blockName,
    array: array,
    asFloat: new Float32Array(array),
    // for debugging
    buffer: buffer,
    uniforms: uniforms,
    setters: setters
  };
}
/**
 * Creates a `UniformBlockInfo` for the specified block
 *
 * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy
 * `UniformBlockInfo` is returned**. This is because when debugging GLSL
 * it is common to comment out large portions of a shader or for example set
 * the final output to a constant. When that happens blocks get optimized out.
 * If this function did not create dummy blocks your code would crash when debugging.
 *
 * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext
 * @param {module:twgl.ProgramInfo} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo}
 * @param {string} blockName The name of the block.
 * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo
 * @memberOf module:twgl/programs
 */


function createUniformBlockInfo(gl, programInfo, blockName) {
  return createUniformBlockInfoFromProgram(gl, programInfo.program, programInfo.uniformBlockSpec, blockName);
}
/**
 * Binds a uniform block to the matching uniform block point.
 * Matches by blocks by name so blocks must have the same name not just the same
 * structure.
 *
 * If you have changed any values and you upload the values into the corresponding WebGLBuffer
 * call {@link module:twgl.setUniformBlock} instead.
 *
 * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.
 * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as
 *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from
 *     {@link module:twgl.createUniformBlockInfo}.
 * @return {bool} true if buffer was bound. If the programInfo has no block with the same block name
 *     no buffer is bound.
 * @memberOf module:twgl/programs
 */


function bindUniformBlock(gl, programInfo, uniformBlockInfo) {
  var uniformBlockSpec = programInfo.uniformBlockSpec || programInfo;
  var blockSpec = uniformBlockSpec.blockSpecs[uniformBlockInfo.name];

  if (blockSpec) {
    var bufferBindIndex = blockSpec.index;
    gl.bindBufferRange(UNIFORM_BUFFER, bufferBindIndex, uniformBlockInfo.buffer, uniformBlockInfo.offset || 0, uniformBlockInfo.array.byteLength);
    return true;
  }

  return false;
}
/**
 * Uploads the current uniform values to the corresponding WebGLBuffer
 * and binds that buffer to the program's corresponding bind point for the uniform block object.
 *
 * If you haven't changed any values and you only need to bind the uniform block object
 * call {@link module:twgl.bindUniformBlock} instead.
 *
 * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.
 * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as
 *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from
 *     {@link module:twgl.createUniformBlockInfo}.
 * @memberOf module:twgl/programs
 */


function setUniformBlock(gl, programInfo, uniformBlockInfo) {
  if (bindUniformBlock(gl, programInfo, uniformBlockInfo)) {
    gl.bufferData(UNIFORM_BUFFER, uniformBlockInfo.array, DYNAMIC_DRAW);
  }
}
/**
 * Sets values of a uniform block object
 *
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo A UniformBlockInfo as returned by {@link module:twgl.createUniformBlockInfo}.
 * @param {Object.<string, ?>} values A uniform name to value map where the value is correct for the given
 *    type of uniform. So for example given a block like
 *
 *       uniform SomeBlock {
 *         float someFloat;
 *         vec2 someVec2;
 *         vec3 someVec3Array[2];
 *         int someInt;
 *       }
 *
 *  You can set the values of the uniform block with
 *
 *       twgl.setBlockUniforms(someBlockInfo, {
 *          someFloat: 12.3,
 *          someVec2: [1, 2],
 *          someVec3Array: [1, 2, 3, 4, 5, 6],
 *          someInt: 5,
 *       }
 *
 *  Arrays can be JavaScript arrays or typed arrays
 *
 *  Any name that doesn't match will be ignored
 * @memberOf module:twgl/programs
 */


function setBlockUniforms(uniformBlockInfo, values) {
  var setters = uniformBlockInfo.setters;

  for (var name in values) {
    var setter = setters[name];

    if (setter) {
      var value = values[name];
      setter(value);
    }
  }
}
/**
 * Set uniforms and binds related textures.
 *
 * example:
 *
 *     const programInfo = createProgramInfo(
 *         gl, ["some-vs", "some-fs"]);
 *
 *     const tex1 = gl.createTexture();
 *     const tex2 = gl.createTexture();
 *
 *     ... assume we setup the textures with data ...
 *
 *     const uniforms = {
 *       u_someSampler: tex1,
 *       u_someOtherSampler: tex2,
 *       u_someColor: [1,0,0,1],
 *       u_somePosition: [0,1,1],
 *       u_someMatrix: [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ],
 *     };
 *
 *     gl.useProgram(program);
 *
 * This will automatically bind the textures AND set the
 * uniforms.
 *
 *     twgl.setUniforms(programInfo, uniforms);
 *
 * For the example above it is equivalent to
 *
 *     var texUnit = 0;
 *     gl.activeTexture(gl.TEXTURE0 + texUnit);
 *     gl.bindTexture(gl.TEXTURE_2D, tex1);
 *     gl.uniform1i(u_someSamplerLocation, texUnit++);
 *     gl.activeTexture(gl.TEXTURE0 + texUnit);
 *     gl.bindTexture(gl.TEXTURE_2D, tex2);
 *     gl.uniform1i(u_someSamplerLocation, texUnit++);
 *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);
 *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);
 *     gl.uniformMatrix4fv(u_someMatrix, false, [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ]);
 *
 * Note it is perfectly reasonable to call `setUniforms` multiple times. For example
 *
 *     const uniforms = {
 *       u_someSampler: tex1,
 *       u_someOtherSampler: tex2,
 *     };
 *
 *     const moreUniforms {
 *       u_someColor: [1,0,0,1],
 *       u_somePosition: [0,1,1],
 *       u_someMatrix: [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ],
 *     };
 *
 *     twgl.setUniforms(programInfo, uniforms);
 *     twgl.setUniforms(programInfo, moreUniforms);
 *
 * You can also add WebGLSamplers to uniform samplers as in
 *
 *     const uniforms = {
 *       u_someSampler: {
 *         texture: someWebGLTexture,
 *         sampler: someWebGLSampler,
 *       },
 *     };
 *
 * In which case both the sampler and texture will be bound to the
 * same unit.
 *
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from
 *        `createUniformSetters`.
 * @param {Object.<string, ?>} values an object with values for the
 *        uniforms.
 *   You can pass multiple objects by putting them in an array or by calling with more arguments.For example
 *
 *     const sharedUniforms = {
 *       u_fogNear: 10,
 *       u_projection: ...
 *       ...
 *     };
 *
 *     const localUniforms = {
 *       u_world: ...
 *       u_diffuseColor: ...
 *     };
 *
 *     twgl.setUniforms(programInfo, sharedUniforms, localUniforms);
 *
 *     // is the same as
 *
 *     twgl.setUniforms(programInfo, [sharedUniforms, localUniforms]);
 *
 *     // is the same as
 *
 *     twgl.setUniforms(programInfo, sharedUniforms);
 *     twgl.setUniforms(programInfo, localUniforms};
 *
 * @memberOf module:twgl/programs
 */


function setUniforms(setters, values) {
  // eslint-disable-line
  var actualSetters = setters.uniformSetters || setters;
  var numArgs = arguments.length;

  for (var aNdx = 1; aNdx < numArgs; ++aNdx) {
    var _values = arguments[aNdx];

    if (Array.isArray(_values)) {
      var numValues = _values.length;

      for (var ii = 0; ii < numValues; ++ii) {
        setUniforms(actualSetters, _values[ii]);
      }
    } else {
      for (var name in _values) {
        var setter = actualSetters[name];

        if (setter) {
          setter(_values[name]);
        }
      }
    }
  }
}
/**
 * Alias for `setUniforms`
 * @function
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from
 *        `createUniformSetters`.
 * @param {Object.<string, ?>} values an object with values for the
 * @memberOf module:twgl/programs
 */


var setUniformsAndBindTextures = setUniforms;
/**
 * Creates setter functions for all attributes of a shader
 * program. You can pass this to {@link module:twgl.setBuffersAndAttributes} to set all your buffers and attributes.
 *
 * @see {@link module:twgl.setAttributes} for example
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program the program to create setters for.
 * @return {Object.<string, function>} an object with a setter for each attribute by name.
 * @memberOf module:twgl/programs
 */

exports.setUniformsAndBindTextures = setUniformsAndBindTextures;

function createAttributeSetters(gl, program) {
  var attribSetters = {};
  var numAttribs = gl.getProgramParameter(program, ACTIVE_ATTRIBUTES);

  for (var ii = 0; ii < numAttribs; ++ii) {
    var attribInfo = gl.getActiveAttrib(program, ii);

    if (isBuiltIn(attribInfo)) {
      continue;
    }

    var index = gl.getAttribLocation(program, attribInfo.name);
    var typeInfo = attrTypeMap[attribInfo.type];
    var setter = typeInfo.setter(gl, index, typeInfo);
    setter.location = index;
    attribSetters[attribInfo.name] = setter;
  }

  return attribSetters;
}
/**
 * Sets attributes and binds buffers (deprecated... use {@link module:twgl.setBuffersAndAttributes})
 *
 * Example:
 *
 *     const program = createProgramFromScripts(
 *         gl, ["some-vs", "some-fs");
 *
 *     const attribSetters = createAttributeSetters(program);
 *
 *     const positionBuffer = gl.createBuffer();
 *     const texcoordBuffer = gl.createBuffer();
 *
 *     const attribs = {
 *       a_position: {buffer: positionBuffer, numComponents: 3},
 *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
 *     };
 *
 *     gl.useProgram(program);
 *
 * This will automatically bind the buffers AND set the
 * attributes.
 *
 *     setAttributes(attribSetters, attribs);
 *
 * Properties of attribs. For each attrib you can add
 * properties:
 *
 * *   type: the type of data in the buffer. Default = gl.FLOAT
 * *   normalize: whether or not to normalize the data. Default = false
 * *   stride: the stride. Default = 0
 * *   offset: offset into the buffer. Default = 0
 * *   divisor: the divisor for instances. Default = undefined
 *
 * For example if you had 3 value float positions, 2 value
 * float texcoord and 4 value uint8 colors you'd setup your
 * attribs like this
 *
 *     const attribs = {
 *       a_position: {buffer: positionBuffer, numComponents: 3},
 *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
 *       a_color: {
 *         buffer: colorBuffer,
 *         numComponents: 4,
 *         type: gl.UNSIGNED_BYTE,
 *         normalize: true,
 *       },
 *     };
 *
 * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters
 * @param {Object.<string, module:twgl.AttribInfo>} buffers AttribInfos mapped by attribute name.
 * @memberOf module:twgl/programs
 * @deprecated use {@link module:twgl.setBuffersAndAttributes}
 */


function setAttributes(setters, buffers) {
  for (var name in buffers) {
    var setter = setters[name];

    if (setter) {
      setter(buffers[name]);
    }
  }
}
/**
 * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate
 *
 * Example:
 *
 *     const programInfo = createProgramInfo(
 *         gl, ["some-vs", "some-fs");
 *
 *     const arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *     };
 *
 *     const bufferInfo = createBufferInfoFromArrays(gl, arrays);
 *
 *     gl.useProgram(programInfo.program);
 *
 * This will automatically bind the buffers AND set the
 * attributes.
 *
 *     setBuffersAndAttributes(gl, programInfo, bufferInfo);
 *
 * For the example above it is equivalent to
 *
 *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
 *     gl.enableVertexAttribArray(a_positionLocation);
 *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
 *     gl.enableVertexAttribArray(a_texcoordLocation);
 *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters A `ProgramInfo` as returned from {@link module:twgl.createProgramInfo} or Attribute setters as returned from {@link module:twgl.createAttributeSetters}
 * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} buffers a `BufferInfo` as returned from {@link module:twgl.createBufferInfoFromArrays}.
 *   or a `VertexArrayInfo` as returned from {@link module:twgl.createVertexArrayInfo}
 * @memberOf module:twgl/programs
 */


function setBuffersAndAttributes(gl, programInfo, buffers) {
  if (buffers.vertexArrayObject) {
    gl.bindVertexArray(buffers.vertexArrayObject);
  } else {
    setAttributes(programInfo.attribSetters || programInfo, buffers.attribs);

    if (buffers.indices) {
      gl.bindBuffer(ELEMENT_ARRAY_BUFFER, buffers.indices);
    }
  }
}
/**
 * @typedef {Object} ProgramInfo
 * @property {WebGLProgram} program A shader program
 * @property {Object<string, function>} uniformSetters object of setters as returned from createUniformSetters,
 * @property {Object<string, function>} attribSetters object of setters as returned from createAttribSetters,
 * @property {module:twgl.UniformBlockSpec} [uniformBlockSpace] a uniform block spec for making UniformBlockInfos with createUniformBlockInfo etc..
 * @property {Object<string, module:twgl.TransformFeedbackInfo>} [transformFeedbackInfo] info for transform feedbacks
 * @memberOf module:twgl
 */

/**
 * Creates a ProgramInfo from an existing program.
 *
 * A ProgramInfo contains
 *
 *     programInfo = {
 *        program: WebGLProgram,
 *        uniformSetters: object of setters as returned from createUniformSetters,
 *        attribSetters: object of setters as returned from createAttribSetters,
 *     }
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {WebGLProgram} program an existing WebGLProgram.
 * @return {module:twgl.ProgramInfo} The created ProgramInfo.
 * @memberOf module:twgl/programs
 */


function createProgramInfoFromProgram(gl, program) {
  var uniformSetters = createUniformSetters(gl, program);
  var attribSetters = createAttributeSetters(gl, program);
  var programInfo = {
    program: program,
    uniformSetters: uniformSetters,
    attribSetters: attribSetters
  };

  if (utils.isWebGL2(gl)) {
    programInfo.uniformBlockSpec = createUniformBlockSpecFromProgram(gl, program);
    programInfo.transformFeedbackInfo = createTransformFeedbackInfo(gl, program);
  }

  return programInfo;
}
/**
 * Creates a ProgramInfo from 2 sources.
 *
 * A ProgramInfo contains
 *
 *     programInfo = {
 *        program: WebGLProgram,
 *        uniformSetters: object of setters as returned from createUniformSetters,
 *        attribSetters: object of setters as returned from createAttribSetters,
 *     }
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramInfo(gl, [vs, fs], options);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderSources Array of sources for the
 *        shaders or ids. The first is assumed to be the vertex shader,
 *        the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {module:twgl.ProgramInfo?} The created ProgramInfo or null if it failed to link or compile
 * @memberOf module:twgl/programs
 */


function createProgramInfo(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
  var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  var good = true;
  shaderSources = shaderSources.map(function (source) {
    // Lets assume if there is no \n it's an id
    if (source.indexOf("\n") < 0) {
      var script = getElementById(source);

      if (!script) {
        progOptions.errorCallback("no element with id: " + source);
        good = false;
      } else {
        source = script.text;
      }
    }

    return source;
  });

  if (!good) {
    return null;
  }

  var program = createProgramFromSources(gl, shaderSources, progOptions);

  if (!program) {
    return null;
  }

  return createProgramInfoFromProgram(gl, program);
}

/***/ }),

/***/ "./src/textures.js":
/*!*************************!*\
  !*** ./src/textures.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.setTextureDefaults_ = setDefaults;
exports.createSampler = createSampler;
exports.createSamplers = createSamplers;
exports.setSamplerParameters = setSamplerParameters;
exports.createTexture = createTexture;
exports.setEmptyTexture = setEmptyTexture;
exports.setTextureFromArray = setTextureFromArray;
exports.loadTextureFromUrl = loadTextureFromUrl;
exports.setTextureFromElement = setTextureFromElement;
exports.setTextureFilteringForSize = setTextureFilteringForSize;
exports.setTextureParameters = setTextureParameters;
exports.setDefaultTextureColor = setDefaultTextureColor;
exports.createTextures = createTextures;
exports.resizeTexture = resizeTexture;
exports.canGenerateMipmap = canGenerateMipmap;
exports.canFilter = canFilter;
exports.getNumComponentsForFormat = getNumComponentsForFormat;
exports.getBytesPerElementForInternalFormat = getBytesPerElementForInternalFormat;
exports.getFormatAndTypeForInternalFormat = getFormatAndTypeForInternalFormat;

var utils = _interopRequireWildcard(__webpack_require__(/*! ./utils.js */ "./src/utils.js"));

var typedArrays = _interopRequireWildcard(__webpack_require__(/*! ./typedarrays.js */ "./src/typedarrays.js"));

var helper = _interopRequireWildcard(__webpack_require__(/*! ./helper.js */ "./src/helper.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Low level texture related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.textures` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/textures
 */
// make sure we don't see a global gl
var gl = undefined;
/* eslint-disable-line */

var defaults = {
  textureColor: new Uint8Array([128, 192, 255, 255]),
  textureOptions: {},
  crossOrigin: undefined
};
var isArrayBuffer = typedArrays.isArrayBuffer; // Should we make this on demand?

var getShared2DContext = function () {
  var s_ctx;
  return function getShared2DContext() {
    s_ctx = s_ctx || (typeof document !== 'undefined' && document.createElement ? document.createElement("canvas").getContext("2d") : null);
    return s_ctx;
  };
}(); // NOTE: Chrome supports 2D canvas in a Worker (behind flag as of v64 but
//       not only does Firefox NOT support it but Firefox freezes immediately
//       if you try to create one instead of just returning null and continuing.
//  : (global.OffscreenCanvas && (new global.OffscreenCanvas(1, 1)).getContext("2d"));  // OffscreenCanvas may not support 2d
// NOTE: We can maybe remove some of the need for the 2d canvas. In WebGL2
// we can use the various unpack settings. Otherwise we could try using
// the ability of an ImageBitmap to be cut. Unfortunately cutting an ImageBitmap
// is async and the current TWGL code expects a non-Async result though that
// might not be a problem. ImageBitmap though is not available in Edge or Safari
// as of 2018-01-02

/* PixelFormat */


var ALPHA = 0x1906;
var RGB = 0x1907;
var RGBA = 0x1908;
var LUMINANCE = 0x1909;
var LUMINANCE_ALPHA = 0x190A;
var DEPTH_COMPONENT = 0x1902;
var DEPTH_STENCIL = 0x84F9;
/* TextureWrapMode */
// const REPEAT                         = 0x2901;
// const MIRRORED_REPEAT                = 0x8370;

var CLAMP_TO_EDGE = 0x812f;
/* TextureMagFilter */

var NEAREST = 0x2600;
var LINEAR = 0x2601;
/* TextureMinFilter */
// const NEAREST_MIPMAP_NEAREST         = 0x2700;
// const LINEAR_MIPMAP_NEAREST          = 0x2701;
// const NEAREST_MIPMAP_LINEAR          = 0x2702;
// const LINEAR_MIPMAP_LINEAR           = 0x2703;

/* Texture Target */

var TEXTURE_2D = 0x0de1;
var TEXTURE_CUBE_MAP = 0x8513;
var TEXTURE_3D = 0x806f;
var TEXTURE_2D_ARRAY = 0x8c1a;
/* Cubemap Targets */

var TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
var TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
var TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
var TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
var TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
var TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a;
/* Texture Parameters */

var TEXTURE_MIN_FILTER = 0x2801;
var TEXTURE_MAG_FILTER = 0x2800;
var TEXTURE_WRAP_S = 0x2802;
var TEXTURE_WRAP_T = 0x2803;
var TEXTURE_WRAP_R = 0x8072;
var TEXTURE_MIN_LOD = 0x813a;
var TEXTURE_MAX_LOD = 0x813b;
var TEXTURE_BASE_LEVEL = 0x813c;
var TEXTURE_MAX_LEVEL = 0x813d;
/* Pixel store */

var UNPACK_ALIGNMENT = 0x0cf5;
var UNPACK_ROW_LENGTH = 0x0cf2;
var UNPACK_IMAGE_HEIGHT = 0x806e;
var UNPACK_SKIP_PIXELS = 0x0cf4;
var UNPACK_SKIP_ROWS = 0x0cf3;
var UNPACK_SKIP_IMAGES = 0x806d;
var UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
var UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
var UNPACK_FLIP_Y_WEBGL = 0x9240;
var R8 = 0x8229;
var R8_SNORM = 0x8F94;
var R16F = 0x822D;
var R32F = 0x822E;
var R8UI = 0x8232;
var R8I = 0x8231;
var RG16UI = 0x823A;
var RG16I = 0x8239;
var RG32UI = 0x823C;
var RG32I = 0x823B;
var RG8 = 0x822B;
var RG8_SNORM = 0x8F95;
var RG16F = 0x822F;
var RG32F = 0x8230;
var RG8UI = 0x8238;
var RG8I = 0x8237;
var R16UI = 0x8234;
var R16I = 0x8233;
var R32UI = 0x8236;
var R32I = 0x8235;
var RGB8 = 0x8051;
var SRGB8 = 0x8C41;
var RGB565 = 0x8D62;
var RGB8_SNORM = 0x8F96;
var R11F_G11F_B10F = 0x8C3A;
var RGB9_E5 = 0x8C3D;
var RGB16F = 0x881B;
var RGB32F = 0x8815;
var RGB8UI = 0x8D7D;
var RGB8I = 0x8D8F;
var RGB16UI = 0x8D77;
var RGB16I = 0x8D89;
var RGB32UI = 0x8D71;
var RGB32I = 0x8D83;
var RGBA8 = 0x8058;
var SRGB8_ALPHA8 = 0x8C43;
var RGBA8_SNORM = 0x8F97;
var RGB5_A1 = 0x8057;
var RGBA4 = 0x8056;
var RGB10_A2 = 0x8059;
var RGBA16F = 0x881A;
var RGBA32F = 0x8814;
var RGBA8UI = 0x8D7C;
var RGBA8I = 0x8D8E;
var RGB10_A2UI = 0x906F;
var RGBA16UI = 0x8D76;
var RGBA16I = 0x8D88;
var RGBA32I = 0x8D82;
var RGBA32UI = 0x8D70;
var DEPTH_COMPONENT16 = 0x81A5;
var DEPTH_COMPONENT24 = 0x81A6;
var DEPTH_COMPONENT32F = 0x8CAC;
var DEPTH32F_STENCIL8 = 0x8CAD;
var DEPTH24_STENCIL8 = 0x88F0;
/* DataType */

var BYTE = 0x1400;
var UNSIGNED_BYTE = 0x1401;
var SHORT = 0x1402;
var UNSIGNED_SHORT = 0x1403;
var INT = 0x1404;
var UNSIGNED_INT = 0x1405;
var FLOAT = 0x1406;
var UNSIGNED_SHORT_4_4_4_4 = 0x8033;
var UNSIGNED_SHORT_5_5_5_1 = 0x8034;
var UNSIGNED_SHORT_5_6_5 = 0x8363;
var HALF_FLOAT = 0x140B;
var HALF_FLOAT_OES = 0x8D61; // Thanks Khronos for making this different >:(

var UNSIGNED_INT_2_10_10_10_REV = 0x8368;
var UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;
var UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;
var FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;
var UNSIGNED_INT_24_8 = 0x84FA;
var RG = 0x8227;
var RG_INTEGER = 0x8228;
var RED = 0x1903;
var RED_INTEGER = 0x8D94;
var RGB_INTEGER = 0x8D98;
var RGBA_INTEGER = 0x8D99;
var formatInfo = {};
{
  // NOTE: this is named `numColorComponents` vs `numComponents` so we can let Uglify mangle
  // the name.
  var f = formatInfo;
  f[ALPHA] = {
    numColorComponents: 1
  };
  f[LUMINANCE] = {
    numColorComponents: 1
  };
  f[LUMINANCE_ALPHA] = {
    numColorComponents: 2
  };
  f[RGB] = {
    numColorComponents: 3
  };
  f[RGBA] = {
    numColorComponents: 4
  };
  f[RED] = {
    numColorComponents: 1
  };
  f[RED_INTEGER] = {
    numColorComponents: 1
  };
  f[RG] = {
    numColorComponents: 2
  };
  f[RG_INTEGER] = {
    numColorComponents: 2
  };
  f[RGB] = {
    numColorComponents: 3
  };
  f[RGB_INTEGER] = {
    numColorComponents: 3
  };
  f[RGBA] = {
    numColorComponents: 4
  };
  f[RGBA_INTEGER] = {
    numColorComponents: 4
  };
  f[DEPTH_COMPONENT] = {
    numColorComponents: 1
  };
  f[DEPTH_STENCIL] = {
    numColorComponents: 2
  };
}
/**
 * @typedef {Object} TextureFormatDetails
 * @property {number} textureFormat format to pass texImage2D and similar functions.
 * @property {boolean} colorRenderable true if you can render to this format of texture.
 * @property {boolean} textureFilterable true if you can filter the texture, false if you can ony use `NEAREST`.
 * @property {number[]} type Array of possible types you can pass to texImage2D and similar function
 * @property {Object.<number,number>} bytesPerElementMap A map of types to bytes per element
 * @private
 */

var s_textureInternalFormatInfo;

function getTextureInternalFormatInfo(internalFormat) {
  if (!s_textureInternalFormatInfo) {
    // NOTE: these properties need unique names so we can let Uglify mangle the name.
    var t = {}; // unsized formats

    t[ALPHA] = {
      textureFormat: ALPHA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [1, 2, 2, 4],
      type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT]
    };
    t[LUMINANCE] = {
      textureFormat: LUMINANCE,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [1, 2, 2, 4],
      type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT]
    };
    t[LUMINANCE_ALPHA] = {
      textureFormat: LUMINANCE_ALPHA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [2, 4, 4, 8],
      type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT]
    };
    t[RGB] = {
      textureFormat: RGB,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [3, 6, 6, 12, 2],
      type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_5_6_5]
    };
    t[RGBA] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4, 8, 8, 16, 2, 2],
      type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_4_4_4_4, UNSIGNED_SHORT_5_5_5_1]
    };
    t[DEPTH_COMPONENT] = {
      textureFormat: DEPTH_COMPONENT,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2, 4],
      type: [UNSIGNED_INT, UNSIGNED_SHORT]
    }; // sized formats

    t[R8] = {
      textureFormat: RED,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [1],
      type: [UNSIGNED_BYTE]
    };
    t[R8_SNORM] = {
      textureFormat: RED,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [1],
      type: [BYTE]
    };
    t[R16F] = {
      textureFormat: RED,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [4, 2],
      type: [FLOAT, HALF_FLOAT]
    };
    t[R32F] = {
      textureFormat: RED,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [FLOAT]
    };
    t[R8UI] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [1],
      type: [UNSIGNED_BYTE]
    };
    t[R8I] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [1],
      type: [BYTE]
    };
    t[R16UI] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2],
      type: [UNSIGNED_SHORT]
    };
    t[R16I] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2],
      type: [SHORT]
    };
    t[R32UI] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_INT]
    };
    t[R32I] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [INT]
    };
    t[RG8] = {
      textureFormat: RG,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [2],
      type: [UNSIGNED_BYTE]
    };
    t[RG8_SNORM] = {
      textureFormat: RG,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [2],
      type: [BYTE]
    };
    t[RG16F] = {
      textureFormat: RG,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [8, 4],
      type: [FLOAT, HALF_FLOAT]
    };
    t[RG32F] = {
      textureFormat: RG,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [FLOAT]
    };
    t[RG8UI] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2],
      type: [UNSIGNED_BYTE]
    };
    t[RG8I] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2],
      type: [BYTE]
    };
    t[RG16UI] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_SHORT]
    };
    t[RG16I] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [SHORT]
    };
    t[RG32UI] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [UNSIGNED_INT]
    };
    t[RG32I] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [INT]
    };
    t[RGB8] = {
      textureFormat: RGB,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [3],
      type: [UNSIGNED_BYTE]
    };
    t[SRGB8] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [3],
      type: [UNSIGNED_BYTE]
    };
    t[RGB565] = {
      textureFormat: RGB,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [3, 2],
      type: [UNSIGNED_BYTE, UNSIGNED_SHORT_5_6_5]
    };
    t[RGB8_SNORM] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [3],
      type: [BYTE]
    };
    t[R11F_G11F_B10F] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [12, 6, 4],
      type: [FLOAT, HALF_FLOAT, UNSIGNED_INT_10F_11F_11F_REV]
    };
    t[RGB9_E5] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [12, 6, 4],
      type: [FLOAT, HALF_FLOAT, UNSIGNED_INT_5_9_9_9_REV]
    };
    t[RGB16F] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [12, 6],
      type: [FLOAT, HALF_FLOAT]
    };
    t[RGB32F] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [12],
      type: [FLOAT]
    };
    t[RGB8UI] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [3],
      type: [UNSIGNED_BYTE]
    };
    t[RGB8I] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [3],
      type: [BYTE]
    };
    t[RGB16UI] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [6],
      type: [UNSIGNED_SHORT]
    };
    t[RGB16I] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [6],
      type: [SHORT]
    };
    t[RGB32UI] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [12],
      type: [UNSIGNED_INT]
    };
    t[RGB32I] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [12],
      type: [INT]
    };
    t[RGBA8] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4],
      type: [UNSIGNED_BYTE]
    };
    t[SRGB8_ALPHA8] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4],
      type: [UNSIGNED_BYTE]
    };
    t[RGBA8_SNORM] = {
      textureFormat: RGBA,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [4],
      type: [BYTE]
    };
    t[RGB5_A1] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4, 2, 4],
      type: [UNSIGNED_BYTE, UNSIGNED_SHORT_5_5_5_1, UNSIGNED_INT_2_10_10_10_REV]
    };
    t[RGBA4] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4, 2],
      type: [UNSIGNED_BYTE, UNSIGNED_SHORT_4_4_4_4]
    };
    t[RGB10_A2] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4],
      type: [UNSIGNED_INT_2_10_10_10_REV]
    };
    t[RGBA16F] = {
      textureFormat: RGBA,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [16, 8],
      type: [FLOAT, HALF_FLOAT]
    };
    t[RGBA32F] = {
      textureFormat: RGBA,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [16],
      type: [FLOAT]
    };
    t[RGBA8UI] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_BYTE]
    };
    t[RGBA8I] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [BYTE]
    };
    t[RGB10_A2UI] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_INT_2_10_10_10_REV]
    };
    t[RGBA16UI] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [UNSIGNED_SHORT]
    };
    t[RGBA16I] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [SHORT]
    };
    t[RGBA32I] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [16],
      type: [INT]
    };
    t[RGBA32UI] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [16],
      type: [UNSIGNED_INT]
    }; // Sized Internal

    t[DEPTH_COMPONENT16] = {
      textureFormat: DEPTH_COMPONENT,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2, 4],
      type: [UNSIGNED_SHORT, UNSIGNED_INT]
    };
    t[DEPTH_COMPONENT24] = {
      textureFormat: DEPTH_COMPONENT,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_INT]
    };
    t[DEPTH_COMPONENT32F] = {
      textureFormat: DEPTH_COMPONENT,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [FLOAT]
    };
    t[DEPTH24_STENCIL8] = {
      textureFormat: DEPTH_STENCIL,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_INT_24_8]
    };
    t[DEPTH32F_STENCIL8] = {
      textureFormat: DEPTH_STENCIL,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [FLOAT_32_UNSIGNED_INT_24_8_REV]
    };
    Object.keys(t).forEach(function (internalFormat) {
      var info = t[internalFormat];
      info.bytesPerElementMap = {};
      info.bytesPerElement.forEach(function (bytesPerElement, ndx) {
        var type = info.type[ndx];
        info.bytesPerElementMap[type] = bytesPerElement;
      });
    });
    s_textureInternalFormatInfo = t;
  }

  return s_textureInternalFormatInfo[internalFormat];
}
/**
 * Gets the number of bytes per element for a given internalFormat / type
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @param {number} type The type parameter for texImage2D etc..
 * @return {number} the number of bytes per element for the given internalFormat, type combo
 * @memberOf module:twgl/textures
 */


function getBytesPerElementForInternalFormat(internalFormat, type) {
  var info = getTextureInternalFormatInfo(internalFormat);

  if (!info) {
    throw "unknown internal format";
  }

  var bytesPerElement = info.bytesPerElementMap[type];

  if (bytesPerElement === undefined) {
    throw "unknown internal format";
  }

  return bytesPerElement;
}
/**
 * Info related to a specific texture internalFormat as returned
 * from {@link module:twgl/textures.getFormatAndTypeForInternalFormat}.
 *
 * @typedef {Object} TextureFormatInfo
 * @property {number} format Format to pass to texImage2D and related functions
 * @property {number} type Type to pass to texImage2D and related functions
 * @memberOf module:twgl/textures
 */

/**
 * Gets the format and type for a given internalFormat
 *
 * @param {number} internalFormat The internal format
 * @return {module:twgl/textures.TextureFormatInfo} the corresponding format and type,
 * @memberOf module:twgl/textures
 */


function getFormatAndTypeForInternalFormat(internalFormat) {
  var info = getTextureInternalFormatInfo(internalFormat);

  if (!info) {
    throw "unknown internal format";
  }

  return {
    format: info.textureFormat,
    type: info.type[0]
  };
}
/**
 * Returns true if value is power of 2
 * @param {number} value number to check.
 * @return true if value is power of 2
 * @private
 */


function isPowerOf2(value) {
  return (value & value - 1) === 0;
}
/**
 * Gets whether or not we can generate mips for the given
 * internal format.
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {number} width The width parameter from texImage2D etc..
 * @param {number} height The height parameter from texImage2D etc..
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @return {boolean} true if we can generate mips
 * @memberOf module:twgl/textures
 */


function canGenerateMipmap(gl, width, height, internalFormat) {
  if (!utils.isWebGL2(gl)) {
    return isPowerOf2(width) && isPowerOf2(height);
  }

  var info = getTextureInternalFormatInfo(internalFormat);

  if (!info) {
    throw "unknown internal format";
  }

  return info.colorRenderable && info.textureFilterable;
}
/**
 * Gets whether or not we can generate mips for the given format
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @return {boolean} true if we can generate mips
 * @memberOf module:twgl/textures
 */


function canFilter(internalFormat) {
  var info = getTextureInternalFormatInfo(internalFormat);

  if (!info) {
    throw "unknown internal format";
  }

  return info.textureFilterable;
}
/**
 * Gets the number of components for a given image format.
 * @param {number} format the format.
 * @return {number} the number of components for the format.
 * @memberOf module:twgl/textures
 */


function getNumComponentsForFormat(format) {
  var info = formatInfo[format];

  if (!info) {
    throw "unknown format: " + format;
  }

  return info.numColorComponents;
}
/**
 * Gets the texture type for a given array type.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @return {number} the gl texture type
 * @private
 */


function getTextureTypeForArrayType(gl, src, defaultType) {
  if (isArrayBuffer(src)) {
    return typedArrays.getGLTypeForTypedArray(src);
  }

  return defaultType || UNSIGNED_BYTE;
}

function guessDimensions(gl, target, width, height, numElements) {
  if (numElements % 1 !== 0) {
    throw "can't guess dimensions";
  }

  if (!width && !height) {
    var size = Math.sqrt(numElements / (target === TEXTURE_CUBE_MAP ? 6 : 1));

    if (size % 1 === 0) {
      width = size;
      height = size;
    } else {
      width = numElements;
      height = 1;
    }
  } else if (!height) {
    height = numElements / width;

    if (height % 1) {
      throw "can't guess dimensions";
    }
  } else if (!width) {
    width = numElements / height;

    if (width % 1) {
      throw "can't guess dimensions";
    }
  }

  return {
    width: width,
    height: height
  };
}
/**
 * Sets the default texture color.
 *
 * The default texture color is used when loading textures from
 * urls. Because the URL will be loaded async we'd like to be
 * able to use the texture immediately. By putting a 1x1 pixel
 * color in the texture we can start using the texture before
 * the URL has loaded.
 *
 * @param {number[]} color Array of 4 values in the range 0 to 1
 * @deprecated see {@link module:twgl.setDefaults}
 * @memberOf module:twgl/textures
 */


function setDefaultTextureColor(color) {
  defaults.textureColor = new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);
}

function setDefaults(newDefaults) {
  helper.copyExistingProperties(newDefaults, defaults);

  if (newDefaults.textureColor) {
    setDefaultTextureColor(newDefaults.textureColor);
  }
}
/**
 * A function to generate the source for a texture.
 * @callback TextureFunc
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options the texture options
 * @return {*} Returns any of the things documented for `src` for {@link module:twgl.TextureOptions}.
 * @memberOf module:twgl
 */

/**
 * Texture options passed to most texture functions. Each function will use whatever options
 * are appropriate for its needs. This lets you pass the same options to all functions.
 *
 * Note: A `TexImageSource` is defined in the WebGL spec as a `HTMLImageElement`, `HTMLVideoElement`,
 * `HTMLCanvasElement`, `ImageBitmap`, or `ImageData`.
 *
 * @typedef {Object} TextureOptions
 * @property {number} [target] the type of texture `gl.TEXTURE_2D` or `gl.TEXTURE_CUBE_MAP`. Defaults to `gl.TEXTURE_2D`.
 * @property {number} [level] the mip level to affect. Defaults to 0. Note, if set auto will be considered false unless explicitly set to true.
 * @property {number} [width] the width of the texture. Only used if src is an array or typed array or null.
 * @property {number} [height] the height of a texture. Only used if src is an array or typed array or null.
 * @property {number} [depth] the depth of a texture. Only used if src is an array or type array or null and target is `TEXTURE_3D` .
 * @property {number} [min] the min filter setting (eg. `gl.LINEAR`). Defaults to `gl.NEAREST_MIPMAP_LINEAR`
 *     or if texture is not a power of 2 on both dimensions then defaults to `gl.LINEAR`.
 * @property {number} [mag] the mag filter setting (eg. `gl.LINEAR`). Defaults to `gl.LINEAR`
 * @property {number} [minMag] both the min and mag filter settings.
 * @property {number} [internalFormat] internal format for texture. Defaults to `gl.RGBA`
 * @property {number} [format] format for texture. Defaults to `gl.RGBA`.
 * @property {number} [type] type for texture. Defaults to `gl.UNSIGNED_BYTE` unless `src` is ArrayBufferView. If `src`
 *     is ArrayBufferView defaults to type that matches ArrayBufferView type.
 * @property {number} [wrap] Texture wrapping for both S and T (and R if TEXTURE_3D or WebGLSampler). Defaults to `gl.REPEAT` for 2D unless src is WebGL1 and src not npot and `gl.CLAMP_TO_EDGE` for cube
 * @property {number} [wrapS] Texture wrapping for S. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [wrapT] Texture wrapping for T. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [wrapR] Texture wrapping for R. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [minLod] TEXTURE_MIN_LOD setting
 * @property {number} [maxLod] TEXTURE_MAX_LOD setting
 * @property {number} [baseLevel] TEXTURE_BASE_LEVEL setting
 * @property {number} [maxLevel] TEXTURE_MAX_LEVEL setting
 * @property {number} [unpackAlignment] The `gl.UNPACK_ALIGNMENT` used when uploading an array. Defaults to 1.
 * @property {number[]|ArrayBufferView} [color] Color to initialize this texture with if loading an image asynchronously.
 *     The default use a blue 1x1 pixel texture. You can set another default by calling `twgl.setDefaults`
 *     or you can set an individual texture's initial color by setting this property. Example: `[1, .5, .5, 1]` = pink
 * @property {number} [premultiplyAlpha] Whether or not to premultiply alpha. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {number} [flipY] Whether or not to flip the texture vertically on upload. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {number} [colorspaceConversion] Whether or not to let the browser do colorspace conversion of the texture on upload. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {boolean} [auto] If `undefined` or `true`, in WebGL1, texture filtering is set automatically for non-power of 2 images and
 *    mips are generated for power of 2 images. In WebGL2 mips are generated if they can be. Note: if `level` is set above
 *    then then `auto` is assumed to be `false` unless explicity set to `true`.
 * @property {number[]} [cubeFaceOrder] The order that cube faces are pulled out of an img or set of images. The default is
 *
 *     [gl.TEXTURE_CUBE_MAP_POSITIVE_X,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
 *      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
 *      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]
 *
 * @property {(number[]|ArrayBufferView|TexImageSource|TexImageSource[]|string|string[]|module:twgl.TextureFunc)} [src] source for texture
 *
 *    If `string` then it's assumed to be a URL to an image. The image will be downloaded async. A usable
 *    1x1 pixel texture will be returned immediately. The texture will be updated once the image has downloaded.
 *    If `target` is `gl.TEXTURE_CUBE_MAP` will attempt to divide image into 6 square pieces. 1x6, 6x1, 3x2, 2x3.
 *    The pieces will be uploaded in `cubeFaceOrder`
 *
 *    If `string[]` or `TexImageSource[]` and target is `gl.TEXTURE_CUBE_MAP` then it must have 6 entries, one for each face of a cube map.
 *
 *    If `string[]` or `TexImageSource[]` and target is `gl.TEXTURE_2D_ARRAY` then each entry is a slice of the a 2d array texture
 *    and will be scaled to the specified width and height OR to the size of the first image that loads.
 *
 *    If `TexImageSource` then it wil be used immediately to create the contents of the texture. Examples `HTMLImageElement`,
 *    `HTMLCanvasElement`, `HTMLVideoElement`.
 *
 *    If `number[]` or `ArrayBufferView` it's assumed to be data for a texture. If `width` or `height` is
 *    not specified it is guessed as follows. First the number of elements is computed by `src.length / numComponents`
 *    where `numComponents` is derived from `format`. If `target` is `gl.TEXTURE_CUBE_MAP` then `numElements` is divided
 *    by 6. Then
 *
 *    *   If neither `width` nor `height` are specified and `sqrt(numElements)` is an integer then width and height
 *        are set to `sqrt(numElements)`. Otherwise `width = numElements` and `height = 1`.
 *
 *    *   If only one of `width` or `height` is specified then the other equals `numElements / specifiedDimension`.
 *
 * If `number[]` will be converted to `type`.
 *
 * If `src` is a function it will be called with a `WebGLRenderingContext` and these options.
 * Whatever it returns is subject to these rules. So it can return a string url, an `HTMLElement`
 * an array etc...
 *
 * If `src` is undefined then an empty texture will be created of size `width` by `height`.
 *
 * @property {string} [crossOrigin] What to set the crossOrigin property of images when they are downloaded.
 *    default: undefined. Also see {@link module:twgl.setDefaults}.
 *
 * @memberOf module:twgl
 */

/**
 * Sets any packing state that will be set based on the options.
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @private
 */


function setPackState(gl, options) {
  if (options.colorspaceConversion !== undefined) {
    gl.pixelStorei(UNPACK_COLORSPACE_CONVERSION_WEBGL, options.colorspaceConversion);
  }

  if (options.premultiplyAlpha !== undefined) {
    gl.pixelStorei(UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.premultiplyAlpha);
  }

  if (options.flipY !== undefined) {
    gl.pixelStorei(UNPACK_FLIP_Y_WEBGL, options.flipY);
  }
}
/**
 * Set skip state to defaults
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @private
 */


function setSkipStateToDefault(gl) {
  gl.pixelStorei(UNPACK_ALIGNMENT, 4);

  if (utils.isWebGL2(gl)) {
    gl.pixelStorei(UNPACK_ROW_LENGTH, 0);
    gl.pixelStorei(UNPACK_IMAGE_HEIGHT, 0);
    gl.pixelStorei(UNPACK_SKIP_PIXELS, 0);
    gl.pixelStorei(UNPACK_SKIP_ROWS, 0);
    gl.pixelStorei(UNPACK_SKIP_IMAGES, 0);
  }
}
/**
 * Sets the parameters of a texture or sampler
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {number|WebGLSampler} target texture target or sampler
 * @param {function()} parameteriFn texParameteri or samplerParameteri fn
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @private
 */


function setTextureSamplerParameters(gl, target, parameteriFn, options) {
  if (options.minMag) {
    parameteriFn.call(gl, target, TEXTURE_MIN_FILTER, options.minMag);
    parameteriFn.call(gl, target, TEXTURE_MAG_FILTER, options.minMag);
  }

  if (options.min) {
    parameteriFn.call(gl, target, TEXTURE_MIN_FILTER, options.min);
  }

  if (options.mag) {
    parameteriFn.call(gl, target, TEXTURE_MAG_FILTER, options.mag);
  }

  if (options.wrap) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_S, options.wrap);
    parameteriFn.call(gl, target, TEXTURE_WRAP_T, options.wrap);

    if (target === TEXTURE_3D || helper.isSampler(gl, target)) {
      parameteriFn.call(gl, target, TEXTURE_WRAP_R, options.wrap);
    }
  }

  if (options.wrapR) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_R, options.wrapR);
  }

  if (options.wrapS) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_S, options.wrapS);
  }

  if (options.wrapT) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_T, options.wrapT);
  }

  if (options.minLod) {
    parameteriFn.call(gl, target, TEXTURE_MIN_LOD, options.minLod);
  }

  if (options.maxLod) {
    parameteriFn.call(gl, target, TEXTURE_MAX_LOD, options.maxLod);
  }

  if (options.baseLevel) {
    parameteriFn.call(gl, target, TEXTURE_BASE_LEVEL, options.baseLevel);
  }

  if (options.maxLevel) {
    parameteriFn.call(gl, target, TEXTURE_MAX_LEVEL, options.maxLevel);
  }
}
/**
 * Sets the texture parameters of a texture.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */


function setTextureParameters(gl, tex, options) {
  var target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  setTextureSamplerParameters(gl, target, gl.texParameteri, options);
}
/**
 * Sets the sampler parameters of a sampler.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLSampler} sampler the WebGLSampler to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @memberOf module:twgl/textures
 */


function setSamplerParameters(gl, sampler, options) {
  setTextureSamplerParameters(gl, sampler, gl.samplerParameteri, options);
}
/**
 * Creates a new sampler object and sets parameters.
 *
 * Example:
 *
 *      const sampler = twgl.createSampler(gl, {
 *        minMag: gl.NEAREST,         // sets both TEXTURE_MIN_FILTER and TEXTURE_MAG_FILTER
 *        wrap: gl.CLAMP_TO_NEAREST,  // sets both TEXTURE_WRAP_S and TEXTURE_WRAP_T and TEXTURE_WRAP_R
 *      });
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per sampler.
 * @return {Object.<string,WebGLSampler>} the created samplers by name
 * @private
 */


function createSampler(gl, options) {
  var sampler = gl.createSampler();
  setSamplerParameters(gl, sampler, options);
  return sampler;
}
/**
 * Creates a multiple sampler objects and sets parameters on each.
 *
 * Example:
 *
 *      const samplers = twgl.createSamplers(gl, {
 *        nearest: {
 *          minMag: gl.NEAREST,
 *        },
 *        nearestClampS: {
 *          minMag: gl.NEAREST,
 *          wrapS: gl.CLAMP_TO_NEAREST,
 *        },
 *        linear: {
 *          minMag: gl.LINEAR,
 *        },
 *        nearestClamp: {
 *          minMag: gl.NEAREST,
 *          wrap: gl.CLAMP_TO_EDGE,
 *        },
 *        linearClamp: {
 *          minMag: gl.LINEAR,
 *          wrap: gl.CLAMP_TO_EDGE,
 *        },
 *        linearClampT: {
 *          minMag: gl.LINEAR,
 *          wrapT: gl.CLAMP_TO_EDGE,
 *        },
 *      });
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set on the sampler
 * @private
 */


function createSamplers(gl, samplerOptions) {
  var samplers = {};
  Object.keys(samplerOptions).forEach(function (name) {
    samplers[name] = createSampler(gl, samplerOptions[name]);
  });
  return samplers;
}
/**
 * Makes a 1x1 pixel
 * If no color is passed in uses the default color which can be set by calling `setDefaultTextureColor`.
 * @param {(number[]|ArrayBufferView)} [color] The color using 0-1 values
 * @return {Uint8Array} Unit8Array with color.
 * @private
 */


function make1Pixel(color) {
  color = color || defaults.textureColor;

  if (isArrayBuffer(color)) {
    return color;
  }

  return new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);
}
/**
 * Sets filtering or generates mips for texture based on width or height
 * If width or height is not passed in uses `options.width` and//or `options.height`
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @param {number} [width] width of texture
 * @param {number} [height] height of texture
 * @param {number} [internalFormat] The internalFormat parameter from texImage2D etc..
 * @memberOf module:twgl/textures
 */


function setTextureFilteringForSize(gl, tex, options, width, height, internalFormat) {
  options = options || defaults.textureOptions;
  internalFormat = internalFormat || RGBA;
  var target = options.target || TEXTURE_2D;
  width = width || options.width;
  height = height || options.height;
  gl.bindTexture(target, tex);

  if (canGenerateMipmap(gl, width, height, internalFormat)) {
    gl.generateMipmap(target);
  } else {
    var filtering = canFilter(internalFormat) ? LINEAR : NEAREST;
    gl.texParameteri(target, TEXTURE_MIN_FILTER, filtering);
    gl.texParameteri(target, TEXTURE_MAG_FILTER, filtering);
    gl.texParameteri(target, TEXTURE_WRAP_S, CLAMP_TO_EDGE);
    gl.texParameteri(target, TEXTURE_WRAP_T, CLAMP_TO_EDGE);
  }
}

function shouldAutomaticallySetTextureFilteringForSize(options) {
  return options.auto === true || options.auto === undefined && options.level === undefined;
}
/**
 * Gets an array of cubemap face enums
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @return {number[]} cubemap face enums
 * @private
 */


function getCubeFaceOrder(gl, options) {
  options = options || {};
  return options.cubeFaceOrder || [TEXTURE_CUBE_MAP_POSITIVE_X, TEXTURE_CUBE_MAP_NEGATIVE_X, TEXTURE_CUBE_MAP_POSITIVE_Y, TEXTURE_CUBE_MAP_NEGATIVE_Y, TEXTURE_CUBE_MAP_POSITIVE_Z, TEXTURE_CUBE_MAP_NEGATIVE_Z];
}
/**
 * @typedef {Object} FaceInfo
 * @property {number} face gl enum for texImage2D
 * @property {number} ndx face index (0 - 5) into source data
 * @ignore
 */

/**
 * Gets an array of FaceInfos
 * There's a bug in some NVidia drivers that will crash the driver if
 * `gl.TEXTURE_CUBE_MAP_POSITIVE_X` is not uploaded first. So, we take
 * the user's desired order from his faces to WebGL and make sure we
 * do the faces in WebGL order
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @return {FaceInfo[]} cubemap face infos. Arguably the `face` property of each element is redundant but
 *    it's needed internally to sort the array of `ndx` properties by `face`.
 * @private
 */


function getCubeFacesWithNdx(gl, options) {
  var faces = getCubeFaceOrder(gl, options); // work around bug in NVidia drivers. We have to upload the first face first else the driver crashes :(

  var facesWithNdx = faces.map(function (face, ndx) {
    return {
      face: face,
      ndx: ndx
    };
  });
  facesWithNdx.sort(function (a, b) {
    return a.face - b.face;
  });
  return facesWithNdx;
}
/**
 * Set a texture from the contents of an element. Will also set
 * texture filtering or generate mips based on the dimensions of the element
 * unless `options.auto === false`. If `target === gl.TEXTURE_CUBE_MAP` will
 * attempt to slice image into 1x6, 2x3, 3x2, or 6x1 images, one for each face.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {HTMLElement} element a canvas, img, or video element.
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 * @kind function
 */


function setTextureFromElement(gl, tex, element, options) {
  options = options || defaults.textureOptions;
  var target = options.target || TEXTURE_2D;
  var level = options.level || 0;
  var width = element.width;
  var height = element.height;
  var internalFormat = options.internalFormat || options.format || RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || formatType.type;
  setPackState(gl, options);
  gl.bindTexture(target, tex);

  if (target === TEXTURE_CUBE_MAP) {
    // guess the parts
    var imgWidth = element.width;
    var imgHeight = element.height;
    var size;
    var slices;

    if (imgWidth / 6 === imgHeight) {
      // It's 6x1
      size = imgHeight;
      slices = [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0];
    } else if (imgHeight / 6 === imgWidth) {
      // It's 1x6
      size = imgWidth;
      slices = [0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5];
    } else if (imgWidth / 3 === imgHeight / 2) {
      // It's 3x2
      size = imgWidth / 3;
      slices = [0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1];
    } else if (imgWidth / 2 === imgHeight / 3) {
      // It's 2x3
      size = imgWidth / 2;
      slices = [0, 0, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2];
    } else {
      throw "can't figure out cube map from element: " + (element.src ? element.src : element.nodeName);
    }

    var ctx = getShared2DContext();

    if (ctx) {
      ctx.canvas.width = size;
      ctx.canvas.height = size;
      width = size;
      height = size;
      getCubeFacesWithNdx(gl, options).forEach(function (f) {
        var xOffset = slices[f.ndx * 2 + 0] * size;
        var yOffset = slices[f.ndx * 2 + 1] * size;
        ctx.drawImage(element, xOffset, yOffset, size, size, 0, 0, size, size);
        gl.texImage2D(f.face, level, internalFormat, format, type, ctx.canvas);
      }); // Free up the canvas memory

      ctx.canvas.width = 1;
      ctx.canvas.height = 1;
    } else if (typeof createImageBitmap !== 'undefined') {
      // NOTE: It seems like we should prefer ImageBitmap because unlike canvas it's
      // note lossy? (alpha is not premultiplied? although I'm not sure what
      width = size;
      height = size;
      getCubeFacesWithNdx(gl, options).forEach(function (f) {
        var xOffset = slices[f.ndx * 2 + 0] * size;
        var yOffset = slices[f.ndx * 2 + 1] * size; // We can't easily use a default texture color here as it would have to match
        // the type across all faces where as with a 2D one there's only one face
        // so we're replacing everything all at once. It also has to be the correct size.
        // On the other hand we need all faces to be the same size so as one face loads
        // the rest match else the texture will be un-renderable.

        gl.texImage2D(f.face, level, internalFormat, size, size, 0, format, type, null);
        createImageBitmap(element, xOffset, yOffset, size, size, {
          premultiplyAlpha: 'none',
          colorSpaceConversion: 'none'
        }).then(function (imageBitmap) {
          setPackState(gl, options);
          gl.bindTexture(target, tex);
          gl.texImage2D(f.face, level, internalFormat, format, type, imageBitmap);

          if (shouldAutomaticallySetTextureFilteringForSize(options)) {
            setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
          }
        });
      });
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    var smallest = Math.min(element.width, element.height);
    var largest = Math.max(element.width, element.height);
    var depth = largest / smallest;

    if (depth % 1 !== 0) {
      throw "can not compute 3D dimensions of element";
    }

    var xMult = element.width === largest ? 1 : 0;
    var yMult = element.height === largest ? 1 : 0;
    gl.pixelStorei(UNPACK_ALIGNMENT, 1);
    gl.pixelStorei(UNPACK_ROW_LENGTH, element.width);
    gl.pixelStorei(UNPACK_IMAGE_HEIGHT, 0);
    gl.pixelStorei(UNPACK_SKIP_IMAGES, 0);
    gl.texImage3D(target, level, internalFormat, smallest, smallest, smallest, 0, format, type, null);

    for (var d = 0; d < depth; ++d) {
      var srcX = d * smallest * xMult;
      var srcY = d * smallest * yMult;
      gl.pixelStorei(UNPACK_SKIP_PIXELS, srcX);
      gl.pixelStorei(UNPACK_SKIP_ROWS, srcY);
      gl.texSubImage3D(target, level, 0, 0, d, smallest, smallest, 1, format, type, element);
    }

    setSkipStateToDefault(gl);
  } else {
    gl.texImage2D(target, level, internalFormat, format, type, element);
  }

  if (shouldAutomaticallySetTextureFilteringForSize(options)) {
    setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
  }

  setTextureParameters(gl, tex, options);
}

function noop() {}
/**
 * Checks whether the url's origin is the same so that we can set the `crossOrigin`
 * @param {string} url url to image
 * @returns {boolean} true if the window's origin is the same as image's url
 * @private
 */


function urlIsSameOrigin(url) {
  if (typeof document !== 'undefined') {
    // for IE really
    var a = document.createElement('a');
    a.href = url;
    return a.hostname === location.hostname && a.port === location.port && a.protocol === location.protocol;
  } else {
    var localOrigin = new URL(location.href).origin;
    var urlOrigin = new URL(url, location.href).origin;
    return urlOrigin === localOrigin;
  }
}

function setToAnonymousIfUndefinedAndURLIsNotSameOrigin(url, crossOrigin) {
  return crossOrigin === undefined && !urlIsSameOrigin(url) ? 'anonymous' : crossOrigin;
}
/**
 * Loads an image
 * @param {string} url url to image
 * @param {string} crossOrigin
 * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null
 *     if there was an error
 * @return {HTMLImageElement} the image being loaded.
 * @private
 */


function loadImage(url, crossOrigin, callback) {
  callback = callback || noop;
  var img;
  crossOrigin = crossOrigin !== undefined ? crossOrigin : defaults.crossOrigin;
  crossOrigin = setToAnonymousIfUndefinedAndURLIsNotSameOrigin(url, crossOrigin);

  if (typeof Image !== 'undefined') {
    img = new Image();

    if (crossOrigin !== undefined) {
      img.crossOrigin = crossOrigin;
    }

    var clearEventHandlers = function clearEventHandlers() {
      img.removeEventListener('error', onError); // eslint-disable-line

      img.removeEventListener('load', onLoad); // eslint-disable-line

      img = null;
    };

    var onError = function onError() {
      var msg = "couldn't load image: " + url;
      helper.error(msg);
      callback(msg, img);
      clearEventHandlers();
    };

    var onLoad = function onLoad() {
      callback(null, img);
      clearEventHandlers();
    };

    img.addEventListener('error', onError);
    img.addEventListener('load', onLoad);
    img.src = url;
    return img;
  } else if (typeof ImageBitmap !== 'undefined') {
    var err;
    var bm;

    var cb = function cb() {
      callback(err, bm);
    };

    var options = {};

    if (crossOrigin) {
      options.mode = 'cors'; // TODO: not sure how to translate image.crossOrigin
    }

    fetch(url, options).then(function (response) {
      if (!response.ok) {
        throw response;
      }

      return response.blob();
    }).then(function (blob) {
      return createImageBitmap(blob, {
        premultiplyAlpha: 'none',
        colorSpaceConversion: 'none'
      });
    }).then(function (bitmap) {
      // not sure if this works. We don't want
      // to catch the user's error. So, call
      // the callback in a timeout so we're
      // not in this scope inside the promise.
      bm = bitmap;
      setTimeout(cb);
    })["catch"](function (e) {
      err = e;
      setTimeout(cb);
    });
    img = null;
  }

  return img;
}
/**
 * check if object is a TexImageSource
 *
 * @param {Object} obj Object to test
 * @return {boolean} true if object is a TexImageSource
 * @private
 */


function isTexImageSource(obj) {
  return typeof ImageBitmap !== 'undefined' && obj instanceof ImageBitmap || typeof ImageData !== 'undefined' && obj instanceof ImageData || typeof HTMLElement !== 'undefined' && obj instanceof HTMLElement;
}
/**
 * if obj is an TexImageSource then just
 * uses it otherwise if obj is a string
 * then load it first.
 *
 * @param {string|TexImageSource} obj
 * @param {string} crossOrigin
 * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null
 *     if there was an error
 * @private
 */


function loadAndUseImage(obj, crossOrigin, callback) {
  if (isTexImageSource(obj)) {
    setTimeout(function () {
      callback(null, obj);
    });
    return obj;
  }

  return loadImage(obj, crossOrigin, callback);
}
/**
 * Sets a texture to a 1x1 pixel color. If `options.color === false` is nothing happens. If it's not set
 * the default texture color is used which can be set by calling `setDefaultTextureColor`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */


function setTextureTo1PixelColor(gl, tex, options) {
  options = options || defaults.textureOptions;
  var target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);

  if (options.color === false) {
    return;
  } // Assume it's a URL
  // Put 1x1 pixels in texture. That makes it renderable immediately regardless of filtering.


  var color = make1Pixel(options.color);

  if (target === TEXTURE_CUBE_MAP) {
    for (var ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, RGBA, 1, 1, 0, RGBA, UNSIGNED_BYTE, color);
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, 0, RGBA, 1, 1, 1, 0, RGBA, UNSIGNED_BYTE, color);
  } else {
    gl.texImage2D(target, 0, RGBA, 1, 1, 0, RGBA, UNSIGNED_BYTE, color);
  }
}
/**
 * The src image(s) used to create a texture.
 *
 * When you call {@link module:twgl.createTexture} or {@link module:twgl.createTextures}
 * you can pass in urls for images to load into the textures. If it's a single url
 * then this will be a single HTMLImageElement. If it's an array of urls used for a cubemap
 * this will be a corresponding array of images for the cubemap.
 *
 * @typedef {HTMLImageElement|HTMLImageElement[]} TextureSrc
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback TextureReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} texture the texture.
 * @param {module:twgl.TextureSrc} source image(s) used to as the src for the texture
 * @memberOf module:twgl
 */

/**
 * A callback for when all images have finished downloading and been uploaded into their respective textures
 * @callback TexturesReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {Object.<string, WebGLTexture>} textures the created textures by name. Same as returned by {@link module:twgl.createTextures}.
 * @param {Object.<string, module:twgl.TextureSrc>} sources the image(s) used for the texture by name.
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback CubemapReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} tex the texture.
 * @param {HTMLImageElement[]} imgs the images for each face.
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback ThreeDReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} tex the texture.
 * @param {HTMLImageElement[]} imgs the images for each slice.
 * @memberOf module:twgl
 */

/**
 * Loads a texture from an image from a Url as specified in `options.src`
 * If `options.color !== false` will set the texture to a 1x1 pixel color so that the texture is
 * immediately useable. It will be updated with the contents of the image once the image has finished
 * downloading. Filtering options will be set as appropriate for image unless `options.auto === false`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.TextureReadyCallback} [callback] A function to be called when the image has finished loading. err will
 *    be non null if there was an error.
 * @return {HTMLImageElement} the image being downloaded.
 * @memberOf module:twgl/textures
 */


function loadTextureFromUrl(gl, tex, options, callback) {
  callback = callback || noop;
  options = options || defaults.textureOptions;
  setTextureTo1PixelColor(gl, tex, options); // Because it's async we need to copy the options.

  options = Object.assign({}, options);
  var img = loadAndUseImage(options.src, options.crossOrigin, function (err, img) {
    if (err) {
      callback(err, tex, img);
    } else {
      setTextureFromElement(gl, tex, img, options);
      callback(null, tex, img);
    }
  });
  return img;
}
/**
 * Loads a cubemap from 6 urls or TexImageSources as specified in `options.src`. Will set the cubemap to a 1x1 pixel color
 * so that it is usable immediately unless `option.color === false`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.CubemapReadyCallback} [callback] A function to be called when all the images have finished loading. err will
 *    be non null if there was an error.
 * @memberOf module:twgl/textures
 */


function loadCubemapFromUrls(gl, tex, options, callback) {
  callback = callback || noop;
  var urls = options.src;

  if (urls.length !== 6) {
    throw "there must be 6 urls for a cubemap";
  }

  var level = options.level || 0;
  var internalFormat = options.internalFormat || options.format || RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || UNSIGNED_BYTE;
  var target = options.target || TEXTURE_2D;

  if (target !== TEXTURE_CUBE_MAP) {
    throw "target must be TEXTURE_CUBE_MAP";
  }

  setTextureTo1PixelColor(gl, tex, options); // Because it's async we need to copy the options.

  options = Object.assign({}, options);
  var numToLoad = 6;
  var errors = [];
  var faces = getCubeFaceOrder(gl, options);
  var imgs; // eslint-disable-line

  function uploadImg(faceTarget) {
    return function (err, img) {
      --numToLoad;

      if (err) {
        errors.push(err);
      } else {
        if (img.width !== img.height) {
          errors.push("cubemap face img is not a square: " + img.src);
        } else {
          setPackState(gl, options);
          gl.bindTexture(target, tex); // So assuming this is the first image we now have one face that's img sized
          // and 5 faces that are 1x1 pixel so size the other faces

          if (numToLoad === 5) {
            // use the default order
            getCubeFaceOrder(gl).forEach(function (otherTarget) {
              // Should we re-use the same face or a color?
              gl.texImage2D(otherTarget, level, internalFormat, format, type, img);
            });
          } else {
            gl.texImage2D(faceTarget, level, internalFormat, format, type, img);
          }

          if (shouldAutomaticallySetTextureFilteringForSize(options)) {
            gl.generateMipmap(target);
          }
        }
      }

      if (numToLoad === 0) {
        callback(errors.length ? errors : undefined, tex, imgs);
      }
    };
  }

  imgs = urls.map(function (url, ndx) {
    return loadAndUseImage(url, options.crossOrigin, uploadImg(faces[ndx]));
  });
}
/**
 * Loads a 2d array or 3d texture from urls OR TexImageSources as specified in `options.src`.
 * Will set the texture to a 1x1 pixel color
 * so that it is usable immediately unless `option.color === false`.
 *
 * If the width and height is not specified the width and height of the first
 * image loaded will be used. Note that since images are loaded async
 * which image downloads first is unknown.
 *
 * If an image is not the same size as the width and height it will be scaled
 * to that width and height.
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.ThreeDReadyCallback} [callback] A function to be called when all the images have finished loading. err will
 *    be non null if there was an error.
 * @memberOf module:twgl/textures
 */


function loadSlicesFromUrls(gl, tex, options, callback) {
  callback = callback || noop;
  var urls = options.src;
  var internalFormat = options.internalFormat || options.format || RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || UNSIGNED_BYTE;
  var target = options.target || TEXTURE_2D_ARRAY;

  if (target !== TEXTURE_3D && target !== TEXTURE_2D_ARRAY) {
    throw "target must be TEXTURE_3D or TEXTURE_2D_ARRAY";
  }

  setTextureTo1PixelColor(gl, tex, options); // Because it's async we need to copy the options.

  options = Object.assign({}, options);
  var numToLoad = urls.length;
  var errors = [];
  var imgs; // eslint-disable-line

  var level = options.level || 0;
  var width = options.width;
  var height = options.height;
  var depth = urls.length;
  var firstImage = true;

  function uploadImg(slice) {
    return function (err, img) {
      --numToLoad;

      if (err) {
        errors.push(err);
      } else {
        setPackState(gl, options);
        gl.bindTexture(target, tex);

        if (firstImage) {
          firstImage = false;
          width = options.width || img.width;
          height = options.height || img.height;
          gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, null); // put it in every slice otherwise some slices will be 0,0,0,0

          for (var s = 0; s < depth; ++s) {
            gl.texSubImage3D(target, level, 0, 0, s, width, height, 1, format, type, img);
          }
        } else {
          var src = img;
          var ctx;

          if (img.width !== width || img.height !== height) {
            // Size the image to fix
            ctx = getShared2DContext();
            src = ctx.canvas;
            ctx.canvas.width = width;
            ctx.canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
          }

          gl.texSubImage3D(target, level, 0, 0, slice, width, height, 1, format, type, src); // free the canvas memory

          if (ctx && src === ctx.canvas) {
            ctx.canvas.width = 0;
            ctx.canvas.height = 0;
          }
        }

        if (shouldAutomaticallySetTextureFilteringForSize(options)) {
          gl.generateMipmap(target);
        }
      }

      if (numToLoad === 0) {
        callback(errors.length ? errors : undefined, tex, imgs);
      }
    };
  }

  imgs = urls.map(function (url, ndx) {
    return loadAndUseImage(url, options.crossOrigin, uploadImg(ndx));
  });
}
/**
 * Sets a texture from an array or typed array. If the width or height is not provided will attempt to
 * guess the size. See {@link module:twgl.TextureOptions}.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {(number[]|ArrayBufferView)} src An array or typed arry with texture data.
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */


function setTextureFromArray(gl, tex, src, options) {
  options = options || defaults.textureOptions;
  var target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  var width = options.width;
  var height = options.height;
  var depth = options.depth;
  var level = options.level || 0;
  var internalFormat = options.internalFormat || options.format || RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);

  if (!isArrayBuffer(src)) {
    var Type = typedArrays.getTypedArrayTypeForGLType(type);
    src = new Type(src);
  } else if (src instanceof Uint8ClampedArray) {
    src = new Uint8Array(src.buffer);
  }

  var bytesPerElement = getBytesPerElementForInternalFormat(internalFormat, type);
  var numElements = src.byteLength / bytesPerElement; // TODO: check UNPACK_ALIGNMENT?

  if (numElements % 1) {
    throw "length wrong size for format: " + utils.glEnumToString(gl, format);
  }

  var dimensions;

  if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    if (!width && !height && !depth) {
      var size = Math.cbrt(numElements);

      if (size % 1 !== 0) {
        throw "can't guess cube size of array of numElements: " + numElements;
      }

      width = size;
      height = size;
      depth = size;
    } else if (width && (!height || !depth)) {
      dimensions = guessDimensions(gl, target, height, depth, numElements / width);
      height = dimensions.width;
      depth = dimensions.height;
    } else if (height && (!width || !depth)) {
      dimensions = guessDimensions(gl, target, width, depth, numElements / height);
      width = dimensions.width;
      depth = dimensions.height;
    } else {
      dimensions = guessDimensions(gl, target, width, height, numElements / depth);
      width = dimensions.width;
      height = dimensions.height;
    }
  } else {
    dimensions = guessDimensions(gl, target, width, height, numElements);
    width = dimensions.width;
    height = dimensions.height;
  }

  setSkipStateToDefault(gl);
  gl.pixelStorei(UNPACK_ALIGNMENT, options.unpackAlignment || 1);
  setPackState(gl, options);

  if (target === TEXTURE_CUBE_MAP) {
    var elementsPerElement = bytesPerElement / src.BYTES_PER_ELEMENT;
    var faceSize = numElements / 6 * elementsPerElement;
    getCubeFacesWithNdx(gl, options).forEach(function (f) {
      var offset = faceSize * f.ndx;
      var data = src.subarray(offset, offset + faceSize);
      gl.texImage2D(f.face, level, internalFormat, width, height, 0, format, type, data);
    });
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, src);
  } else {
    gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, src);
  }

  return {
    width: width,
    height: height,
    depth: depth,
    type: type
  };
}
/**
 * Sets a texture with no contents of a certain size. In other words calls `gl.texImage2D` with `null`.
 * You must set `options.width` and `options.height`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @memberOf module:twgl/textures
 */


function setEmptyTexture(gl, tex, options) {
  var target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  var level = options.level || 0;
  var internalFormat = options.internalFormat || options.format || RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || formatType.type;
  setPackState(gl, options);

  if (target === TEXTURE_CUBE_MAP) {
    for (var ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, level, internalFormat, options.width, options.height, 0, format, type, null);
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, level, internalFormat, options.width, options.height, options.depth, 0, format, type, null);
  } else {
    gl.texImage2D(target, level, internalFormat, options.width, options.height, 0, format, type, null);
  }
}
/**
 * Creates a texture based on the options passed in.
 *
 * Note: may reset UNPACK_ALIGNMENT, UNPACK_ROW_LENGTH, UNPACK_IMAGE_HEIGHT, UNPACK_SKIP_IMAGES
 * UNPACK_SKIP_PIXELS, and UNPACK_SKIP_ROWS
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.TextureReadyCallback} [callback] A callback called when an image has been downloaded and uploaded to the texture.
 * @return {WebGLTexture} the created texture.
 * @memberOf module:twgl/textures
 */


function createTexture(gl, options, callback) {
  callback = callback || noop;
  options = options || defaults.textureOptions;
  var tex = gl.createTexture();
  var target = options.target || TEXTURE_2D;
  var width = options.width || 1;
  var height = options.height || 1;
  var internalFormat = options.internalFormat || RGBA;
  gl.bindTexture(target, tex);

  if (target === TEXTURE_CUBE_MAP) {
    // this should have been the default for cubemaps :(
    gl.texParameteri(target, TEXTURE_WRAP_S, CLAMP_TO_EDGE);
    gl.texParameteri(target, TEXTURE_WRAP_T, CLAMP_TO_EDGE);
  }

  var src = options.src;

  if (src) {
    if (typeof src === "function") {
      src = src(gl, options);
    }

    if (typeof src === "string") {
      loadTextureFromUrl(gl, tex, options, callback);
    } else if (isArrayBuffer(src) || Array.isArray(src) && (typeof src[0] === 'number' || Array.isArray(src[0]) || isArrayBuffer(src[0]))) {
      var dimensions = setTextureFromArray(gl, tex, src, options);
      width = dimensions.width;
      height = dimensions.height;
    } else if (Array.isArray(src) && (typeof src[0] === 'string' || isTexImageSource(src[0]))) {
      if (target === TEXTURE_CUBE_MAP) {
        loadCubemapFromUrls(gl, tex, options, callback);
      } else {
        loadSlicesFromUrls(gl, tex, options, callback);
      }
    } else {
      // if (isTexImageSource(src))
      setTextureFromElement(gl, tex, src, options);
      width = src.width;
      height = src.height;
    }
  } else {
    setEmptyTexture(gl, tex, options);
  }

  if (shouldAutomaticallySetTextureFilteringForSize(options)) {
    setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
  }

  setTextureParameters(gl, tex, options);
  return tex;
}
/**
 * Resizes a texture based on the options passed in.
 *
 * Note: This is not a generic resize anything function.
 * It's mostly used by {@link module:twgl.resizeFramebufferInfo}
 * It will use `options.src` if it exists to try to determine a `type`
 * otherwise it will assume `gl.UNSIGNED_BYTE`. No data is provided
 * for the texture. Texture parameters will be set accordingly
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the texture to resize
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {number} [width] the new width. If not passed in will use `options.width`
 * @param {number} [height] the new height. If not passed in will use `options.height`
 * @param {number} [depth] the new depth. If not passed in will use `options.depth`
 * @memberOf module:twgl/textures
 */


function resizeTexture(gl, tex, options, width, height, depth) {
  width = width || options.width;
  height = height || options.height;
  depth = depth || options.depth;
  var target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  var level = options.level || 0;
  var internalFormat = options.internalFormat || options.format || RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type;
  var src = options.src;

  if (!src) {
    type = options.type || formatType.type;
  } else if (isArrayBuffer(src) || Array.isArray(src) && typeof src[0] === 'number') {
    type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);
  } else {
    type = options.type || formatType.type;
  }

  if (target === TEXTURE_CUBE_MAP) {
    for (var ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, level, internalFormat, width, height, 0, format, type, null);
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, null);
  } else {
    gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);
  }
}
/**
 * Check if a src is an async request.
 * if src is a string we're going to download an image
 * if src is an array of strings we're going to download cubemap images
 * @param {*} src The src from a TextureOptions
 * @returns {bool} true if src is async.
 * @private
 */


function isAsyncSrc(src) {
  return typeof src === 'string' || Array.isArray(src) && typeof src[0] === 'string';
}
/**
 * Creates a bunch of textures based on the passed in options.
 *
 * Example:
 *
 *     const textures = twgl.createTextures(gl, {
 *       // a power of 2 image
 *       hftIcon: { src: "images/hft-icon-16.png", mag: gl.NEAREST },
 *       // a non-power of 2 image
 *       clover: { src: "images/clover.jpg" },
 *       // From a canvas
 *       fromCanvas: { src: ctx.canvas },
 *       // A cubemap from 6 images
 *       yokohama: {
 *         target: gl.TEXTURE_CUBE_MAP,
 *         src: [
 *           'images/yokohama/posx.jpg',
 *           'images/yokohama/negx.jpg',
 *           'images/yokohama/posy.jpg',
 *           'images/yokohama/negy.jpg',
 *           'images/yokohama/posz.jpg',
 *           'images/yokohama/negz.jpg',
 *         ],
 *       },
 *       // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)
 *       goldengate: {
 *         target: gl.TEXTURE_CUBE_MAP,
 *         src: 'images/goldengate.jpg',
 *       },
 *       // A 2x2 pixel texture from a JavaScript array
 *       checker: {
 *         mag: gl.NEAREST,
 *         min: gl.LINEAR,
 *         src: [
 *           255,255,255,255,
 *           192,192,192,255,
 *           192,192,192,255,
 *           255,255,255,255,
 *         ],
 *       },
 *       // a 1x2 pixel texture from a typed array.
 *       stripe: {
 *         mag: gl.NEAREST,
 *         min: gl.LINEAR,
 *         format: gl.LUMINANCE,
 *         src: new Uint8Array([
 *           255,
 *           128,
 *           255,
 *           128,
 *           255,
 *           128,
 *           255,
 *           128,
 *         ]),
 *         width: 1,
 *       },
 *     });
 *
 * Now
 *
 * *   `textures.hftIcon` will be a 2d texture
 * *   `textures.clover` will be a 2d texture
 * *   `textures.fromCanvas` will be a 2d texture
 * *   `textures.yohohama` will be a cubemap texture
 * *   `textures.goldengate` will be a cubemap texture
 * *   `textures.checker` will be a 2d texture
 * *   `textures.stripe` will be a 2d texture
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per texture.
 * @param {module:twgl.TexturesReadyCallback} [callback] A callback called when all textures have been downloaded.
 * @return {Object.<string,WebGLTexture>} the created textures by name
 * @memberOf module:twgl/textures
 */


function createTextures(gl, textureOptions, callback) {
  callback = callback || noop;
  var numDownloading = 0;
  var errors = [];
  var textures = {};
  var images = {};

  function callCallbackIfReady() {
    if (numDownloading === 0) {
      setTimeout(function () {
        callback(errors.length ? errors : undefined, textures, images);
      }, 0);
    }
  }

  Object.keys(textureOptions).forEach(function (name) {
    var options = textureOptions[name];
    var onLoadFn;

    if (isAsyncSrc(options.src)) {
      onLoadFn = function onLoadFn(err, tex, img) {
        images[name] = img;
        --numDownloading;

        if (err) {
          errors.push(err);
        }

        callCallbackIfReady();
      };

      ++numDownloading;
    }

    textures[name] = createTexture(gl, options, onLoadFn);
  }); // queue the callback if there are no images to download.
  // We do this because if your code is structured to wait for
  // images to download but then you comment out all the async
  // images your code would break.

  callCallbackIfReady();
  return textures;
}

/***/ }),

/***/ "./src/twgl-full.js":
/*!**************************!*\
  !*** ./src/twgl-full.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
var _exportNames = {
  m4: true,
  v3: true,
  primitives: true
};
exports.primitives = exports.v3 = exports.m4 = void 0;

var m4 = _interopRequireWildcard(__webpack_require__(/*! ./m4.js */ "./src/m4.js"));

exports.m4 = m4;

var v3 = _interopRequireWildcard(__webpack_require__(/*! ./v3.js */ "./src/v3.js"));

exports.v3 = v3;

var primitives = _interopRequireWildcard(__webpack_require__(/*! ./primitives.js */ "./src/primitives.js"));

exports.primitives = primitives;

var _twgl = __webpack_require__(/*! ./twgl.js */ "./src/twgl.js");

Object.keys(_twgl).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _twgl[key];
});

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/***/ }),

/***/ "./src/twgl.js":
/*!*********************!*\
  !*** ./src/twgl.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
var _exportNames = {
  addExtensionsToContext: true,
  getContext: true,
  getWebGLContext: true,
  resizeCanvasToDisplaySize: true,
  setDefaults: true,
  attributes: true,
  textures: true,
  utils: true,
  draw: true,
  framebuffers: true,
  programs: true,
  typedarrays: true,
  vertexArrays: true
};
exports.addExtensionsToContext = addExtensionsToContext;
exports.getContext = getContext;
exports.getWebGLContext = getWebGLContext;
exports.resizeCanvasToDisplaySize = resizeCanvasToDisplaySize;
exports.setDefaults = setDefaults;
exports.vertexArrays = exports.typedarrays = exports.programs = exports.framebuffers = exports.draw = exports.utils = exports.textures = exports.attributes = void 0;

var attributes = _interopRequireWildcard(__webpack_require__(/*! ./attributes.js */ "./src/attributes.js"));

exports.attributes = attributes;
Object.keys(attributes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = attributes[key];
});

var textures = _interopRequireWildcard(__webpack_require__(/*! ./textures.js */ "./src/textures.js"));

exports.textures = textures;
Object.keys(textures).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = textures[key];
});

var helper = _interopRequireWildcard(__webpack_require__(/*! ./helper.js */ "./src/helper.js"));

var utils = _interopRequireWildcard(__webpack_require__(/*! ./utils.js */ "./src/utils.js"));

exports.utils = utils;
Object.keys(utils).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = utils[key];
});

var draw = _interopRequireWildcard(__webpack_require__(/*! ./draw.js */ "./src/draw.js"));

exports.draw = draw;
Object.keys(draw).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = draw[key];
});

var framebuffers = _interopRequireWildcard(__webpack_require__(/*! ./framebuffers.js */ "./src/framebuffers.js"));

exports.framebuffers = framebuffers;
Object.keys(framebuffers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = framebuffers[key];
});

var programs = _interopRequireWildcard(__webpack_require__(/*! ./programs.js */ "./src/programs.js"));

exports.programs = programs;
Object.keys(programs).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = programs[key];
});

var typedarrays = _interopRequireWildcard(__webpack_require__(/*! ./typedarrays.js */ "./src/typedarrays.js"));

exports.typedarrays = typedarrays;
Object.keys(typedarrays).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = typedarrays[key];
});

var vertexArrays = _interopRequireWildcard(__webpack_require__(/*! ./vertex-arrays.js */ "./src/vertex-arrays.js"));

exports.vertexArrays = vertexArrays;
Object.keys(vertexArrays).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = vertexArrays[key];
});

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * The main TWGL module.
 *
 * For most use cases you shouldn't need anything outside this module.
 * Exceptions between the stuff added to twgl-full (v3, m4, primitives)
 *
 * @module twgl
 * @borrows module:twgl/attributes.setAttribInfoBufferFromArray as setAttribInfoBufferFromArray
 * @borrows module:twgl/attributes.createBufferInfoFromArrays as createBufferInfoFromArrays
 * @borrows module:twgl/attributes.createVertexArrayInfo as createVertexArrayInfo
 * @borrows module:twgl/draw.drawBufferInfo as drawBufferInfo
 * @borrows module:twgl/draw.drawObjectList as drawObjectList
 * @borrows module:twgl/framebuffers.createFramebufferInfo as createFramebufferInfo
 * @borrows module:twgl/framebuffers.resizeFramebufferInfo as resizeFramebufferInfo
 * @borrows module:twgl/framebuffers.bindFramebufferInfo as bindFramebufferInfo
 * @borrows module:twgl/programs.createProgramInfo as createProgramInfo
 * @borrows module:twgl/programs.createUniformBlockInfo as createUniformBlockInfo
 * @borrows module:twgl/programs.bindUniformBlock as bindUniformBlock
 * @borrows module:twgl/programs.setUniformBlock as setUniformBlock
 * @borrows module:twgl/programs.setBlockUniforms as setBlockUniforms
 * @borrows module:twgl/programs.setUniforms as setUniforms
 * @borrows module:twgl/programs.setBuffersAndAttributes as setBuffersAndAttributes
 * @borrows module:twgl/textures.setTextureFromArray as setTextureFromArray
 * @borrows module:twgl/textures.createTexture as createTexture
 * @borrows module:twgl/textures.resizeTexture as resizeTexture
 * @borrows module:twgl/textures.createTextures as createTextures
 */
// make sure we don't see a global gl
var gl = undefined;
/* eslint-disable-line */

var defaults = {
  addExtensionsToContext: true
};
/**
 * Various default settings for twgl.
 *
 * Note: You can call this any number of times. Example:
 *
 *     twgl.setDefaults({ textureColor: [1, 0, 0, 1] });
 *     twgl.setDefaults({ attribPrefix: 'a_' });
 *
 * is equivalent to
 *
 *     twgl.setDefaults({
 *       textureColor: [1, 0, 0, 1],
 *       attribPrefix: 'a_',
 *     });
 *
 * @typedef {Object} Defaults
 * @property {string} [attribPrefix] The prefix to stick on attributes
 *
 *   When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`
 *   as it makes it clear where they came from. But, when building geometry I prefer using un-prefixed names.
 *
 *   In other words I'll create arrays of geometry like this
 *
 *       const arrays = {
 *         position: ...
 *         normal: ...
 *         texcoord: ...
 *       };
 *
 *   But need those mapped to attributes and my attributes start with `a_`.
 *
 *   Default: `""`
 *
 * @property {number[]} [textureColor] Array of 4 values in the range 0 to 1
 *
 *   The default texture color is used when loading textures from
 *   urls. Because the URL will be loaded async we'd like to be
 *   able to use the texture immediately. By putting a 1x1 pixel
 *   color in the texture we can start using the texture before
 *   the URL has loaded.
 *
 *   Default: `[0.5, 0.75, 1, 1]`
 *
 * @property {string} [crossOrigin]
 *
 *   If not undefined sets the crossOrigin attribute on images
 *   that twgl creates when downloading images for textures.
 *
 *   Also see {@link module:twgl.TextureOptions}.
 *
 * @property {bool} [addExtensionsToContext]
 *
 *   If true, then, when twgl will try to add any supported WebGL extensions
 *   directly to the context under their normal GL names. For example
 *   if ANGLE_instances_arrays exists then twgl would enable it,
 *   add the functions `vertexAttribDivisor`, `drawArraysInstanced`,
 *   `drawElementsInstanced`, and the constant `VERTEX_ATTRIB_ARRAY_DIVISOR`
 *   to the `WebGLRenderingContext`.
 *
 * @memberOf module:twgl
 */

/**
 * Sets various defaults for twgl.
 *
 * In the interest of terseness which is kind of the point
 * of twgl I've integrated a few of the older functions here
 *
 * @param {module:twgl.Defaults} newDefaults The default settings.
 * @memberOf module:twgl
 */

function setDefaults(newDefaults) {
  helper.copyExistingProperties(newDefaults, defaults);
  attributes.setAttributeDefaults_(newDefaults); // eslint-disable-line

  textures.setTextureDefaults_(newDefaults); // eslint-disable-line
}

var prefixRE = /^(.*?)_/;

function addExtensionToContext(gl, extensionName) {
  utils.glEnumToString(gl, 0);
  var ext = gl.getExtension(extensionName);

  if (ext) {
    var enums = {};
    var fnSuffix = prefixRE.exec(extensionName)[1];
    var enumSuffix = '_' + fnSuffix;

    for (var key in ext) {
      var value = ext[key];
      var isFunc = typeof value === 'function';
      var suffix = isFunc ? fnSuffix : enumSuffix;
      var name = key; // examples of where this is not true are WEBGL_compressed_texture_s3tc
      // and WEBGL_compressed_texture_pvrtc

      if (key.endsWith(suffix)) {
        name = key.substring(0, key.length - suffix.length);
      }

      if (gl[name] !== undefined) {
        if (!isFunc && gl[name] !== value) {
          helper.warn(name, gl[name], value, key);
        }
      } else {
        if (isFunc) {
          gl[name] = function (origFn) {
            return function () {
              return origFn.apply(ext, arguments);
            };
          }(value);
        } else {
          gl[name] = value;
          enums[name] = value;
        }
      }
    } // pass the modified enums to glEnumToString


    enums.constructor = {
      name: ext.constructor.name
    };
    utils.glEnumToString(enums, 0);
  }

  return ext;
}
/*
 * If you're wondering why the code doesn't just iterate
 * over all extensions using `gl.getExtensions` is that it's possible
 * some future extension is incompatible with this code. Rather than
 * have thing suddenly break it seems better to manually add to this
 * list.
 *
 */


var supportedExtensions = ['ANGLE_instanced_arrays', 'EXT_blend_minmax', 'EXT_color_buffer_float', 'EXT_color_buffer_half_float', 'EXT_disjoint_timer_query', 'EXT_disjoint_timer_query_webgl2', 'EXT_frag_depth', 'EXT_sRGB', 'EXT_shader_texture_lod', 'EXT_texture_filter_anisotropic', 'OES_element_index_uint', 'OES_standard_derivatives', 'OES_texture_float', 'OES_texture_float_linear', 'OES_texture_half_float', 'OES_texture_half_float_linear', 'OES_vertex_array_object', 'WEBGL_color_buffer_float', 'WEBGL_compressed_texture_atc', 'WEBGL_compressed_texture_etc1', 'WEBGL_compressed_texture_pvrtc', 'WEBGL_compressed_texture_s3tc', 'WEBGL_compressed_texture_s3tc_srgb', 'WEBGL_depth_texture', 'WEBGL_draw_buffers'];
/**
 * Attempts to enable all of the following extensions
 * and add their functions and constants to the
 * `WebGLRenderingContext` using their normal non-extension like names.
 *
 *      ANGLE_instanced_arrays
 *      EXT_blend_minmax
 *      EXT_color_buffer_float
 *      EXT_color_buffer_half_float
 *      EXT_disjoint_timer_query
 *      EXT_disjoint_timer_query_webgl2
 *      EXT_frag_depth
 *      EXT_sRGB
 *      EXT_shader_texture_lod
 *      EXT_texture_filter_anisotropic
 *      OES_element_index_uint
 *      OES_standard_derivatives
 *      OES_texture_float
 *      OES_texture_float_linear
 *      OES_texture_half_float
 *      OES_texture_half_float_linear
 *      OES_vertex_array_object
 *      WEBGL_color_buffer_float
 *      WEBGL_compressed_texture_atc
 *      WEBGL_compressed_texture_etc1
 *      WEBGL_compressed_texture_pvrtc
 *      WEBGL_compressed_texture_s3tc
 *      WEBGL_compressed_texture_s3tc_srgb
 *      WEBGL_depth_texture
 *      WEBGL_draw_buffers
 *
 * For example if `ANGLE_instanced_arrays` exists then the functions
 * `drawArraysInstanced`, `drawElementsInstanced`, `vertexAttribDivisor`
 * and the constant `VERTEX_ATTRIB_ARRAY_DIVISOR` are added to the
 * `WebGLRenderingContext`.
 *
 * Note that if you want to know if the extension exists you should
 * probably call `gl.getExtension` for each extension. Alternatively
 * you can check for the existence of the functions or constants that
 * are expected to be added. For example
 *
 *    if (gl.drawBuffers) {
 *      // Either WEBGL_draw_buffers was enabled OR you're running in WebGL2
 *      ....
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @memberOf module:twgl
 */

function addExtensionsToContext(gl) {
  for (var ii = 0; ii < supportedExtensions.length; ++ii) {
    addExtensionToContext(gl, supportedExtensions[ii]);
  }
}
/**
 * Creates a webgl context.
 * @param {HTMLCanvasElement} canvas The canvas tag to get
 *     context from. If one is not passed in one will be
 *     created.
 * @return {WebGLRenderingContext} The created context.
 * @private
 */


function create3DContext(canvas, opt_attribs) {
  var names = ["webgl", "experimental-webgl"];
  var context = null;

  for (var ii = 0; ii < names.length; ++ii) {
    context = canvas.getContext(names[ii], opt_attribs);

    if (context) {
      if (defaults.addExtensionsToContext) {
        addExtensionsToContext(context);
      }

      break;
    }
  }

  return context;
}
/**
 * Gets a WebGL1 context.
 *
 * Note: Will attempt to enable Vertex Array Objects
 * and add WebGL2 entry points. (unless you first set defaults with
 * `twgl.setDefaults({enableVertexArrayObjects: false})`;
 *
 * @param {HTMLCanvasElement} canvas a canvas element.
 * @param {WebGLContextAttributes} [opt_attribs] optional webgl context creation attributes
 * @return {WebGLRenderingContext} The created context.
 * @memberOf module:twgl
 */


function getWebGLContext(canvas, opt_attribs) {
  var gl = create3DContext(canvas, opt_attribs);
  return gl;
}
/**
 * Creates a webgl context.
 *
 * Will return a WebGL2 context if possible.
 *
 * You can check if it's WebGL2 with
 *
 *     twgl.isWebGL2(gl);
 *
 * @param {HTMLCanvasElement} canvas The canvas tag to get
 *     context from. If one is not passed in one will be
 *     created.
 * @return {WebGLRenderingContext} The created context.
 */


function createContext(canvas, opt_attribs) {
  var names = ["webgl2", "webgl", "experimental-webgl"];
  var context = null;

  for (var ii = 0; ii < names.length; ++ii) {
    context = canvas.getContext(names[ii], opt_attribs);

    if (context) {
      if (defaults.addExtensionsToContext) {
        addExtensionsToContext(context);
      }

      break;
    }
  }

  return context;
}
/**
 * Gets a WebGL context.  Will create a WebGL2 context if possible.
 *
 * You can check if it's WebGL2 with
 *
 *    function isWebGL2(gl) {
 *      return gl.getParameter(gl.VERSION).indexOf("WebGL 2.0 ") == 0;
 *    }
 *
 * Note: For a WebGL1 context will attempt to enable Vertex Array Objects
 * and add WebGL2 entry points. (unless you first set defaults with
 * `twgl.setDefaults({enableVertexArrayObjects: false})`;
 *
 * @param {HTMLCanvasElement} canvas a canvas element.
 * @param {WebGLContextAttributes} [opt_attribs] optional webgl context creation attributes
 * @return {WebGLRenderingContext} The created context.
 * @memberOf module:twgl
 */


function getContext(canvas, opt_attribs) {
  var gl = createContext(canvas, opt_attribs);
  return gl;
}
/**
 * Resize a canvas to match the size it's displayed.
 * @param {HTMLCanvasElement} canvas The canvas to resize.
 * @param {number} [multiplier] So you can pass in `window.devicePixelRatio` or other scale value if you want to.
 * @return {boolean} true if the canvas was resized.
 * @memberOf module:twgl
 */


function resizeCanvasToDisplaySize(canvas, multiplier) {
  multiplier = multiplier || 1;
  multiplier = Math.max(0, multiplier);
  var width = canvas.clientWidth * multiplier | 0;
  var height = canvas.clientHeight * multiplier | 0;

  if (canvas.width !== width || canvas.height !== height) {
    canvas.width = width;
    canvas.height = height;
    return true;
  }

  return false;
}

/***/ }),

/***/ "./src/typedarrays.js":
/*!****************************!*\
  !*** ./src/typedarrays.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getGLTypeForTypedArray = getGLTypeForTypedArray;
exports.getGLTypeForTypedArrayType = getGLTypeForTypedArrayType;
exports.getTypedArrayTypeForGLType = getTypedArrayTypeForGLType;
exports.isArrayBuffer = void 0;

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Low level shader typed array related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.typedArray` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/typedArray
 */
// make sure we don't see a global gl
var gl = undefined;
/* eslint-disable-line */

/* DataType */

var BYTE = 0x1400;
var UNSIGNED_BYTE = 0x1401;
var SHORT = 0x1402;
var UNSIGNED_SHORT = 0x1403;
var INT = 0x1404;
var UNSIGNED_INT = 0x1405;
var FLOAT = 0x1406;
var UNSIGNED_SHORT_4_4_4_4 = 0x8033;
var UNSIGNED_SHORT_5_5_5_1 = 0x8034;
var UNSIGNED_SHORT_5_6_5 = 0x8363;
var HALF_FLOAT = 0x140B;
var UNSIGNED_INT_2_10_10_10_REV = 0x8368;
var UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;
var UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;
var FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;
var UNSIGNED_INT_24_8 = 0x84FA;
var glTypeToTypedArray = {};
{
  var tt = glTypeToTypedArray;
  tt[BYTE] = Int8Array;
  tt[UNSIGNED_BYTE] = Uint8Array;
  tt[SHORT] = Int16Array;
  tt[UNSIGNED_SHORT] = Uint16Array;
  tt[INT] = Int32Array;
  tt[UNSIGNED_INT] = Uint32Array;
  tt[FLOAT] = Float32Array;
  tt[UNSIGNED_SHORT_4_4_4_4] = Uint16Array;
  tt[UNSIGNED_SHORT_5_5_5_1] = Uint16Array;
  tt[UNSIGNED_SHORT_5_6_5] = Uint16Array;
  tt[HALF_FLOAT] = Uint16Array;
  tt[UNSIGNED_INT_2_10_10_10_REV] = Uint32Array;
  tt[UNSIGNED_INT_10F_11F_11F_REV] = Uint32Array;
  tt[UNSIGNED_INT_5_9_9_9_REV] = Uint32Array;
  tt[FLOAT_32_UNSIGNED_INT_24_8_REV] = Uint32Array;
  tt[UNSIGNED_INT_24_8] = Uint32Array;
}
/**
 * Get the GL type for a typedArray
 * @param {ArrayBufferView} typedArray a typedArray
 * @return {number} the GL type for array. For example pass in an `Int8Array` and `gl.BYTE` will
 *   be returned. Pass in a `Uint32Array` and `gl.UNSIGNED_INT` will be returned
 * @memberOf module:twgl/typedArray
 */

function getGLTypeForTypedArray(typedArray) {
  if (typedArray instanceof Int8Array) {
    return BYTE;
  } // eslint-disable-line


  if (typedArray instanceof Uint8Array) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line


  if (typedArray instanceof Uint8ClampedArray) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line


  if (typedArray instanceof Int16Array) {
    return SHORT;
  } // eslint-disable-line


  if (typedArray instanceof Uint16Array) {
    return UNSIGNED_SHORT;
  } // eslint-disable-line


  if (typedArray instanceof Int32Array) {
    return INT;
  } // eslint-disable-line


  if (typedArray instanceof Uint32Array) {
    return UNSIGNED_INT;
  } // eslint-disable-line


  if (typedArray instanceof Float32Array) {
    return FLOAT;
  } // eslint-disable-line


  throw new Error('unsupported typed array type');
}
/**
 * Get the GL type for a typedArray type
 * @param {ArrayBufferView} typedArrayType a typedArray constructor
 * @return {number} the GL type for type. For example pass in `Int8Array` and `gl.BYTE` will
 *   be returned. Pass in `Uint32Array` and `gl.UNSIGNED_INT` will be returned
 * @memberOf module:twgl/typedArray
 */


function getGLTypeForTypedArrayType(typedArrayType) {
  if (typedArrayType === Int8Array) {
    return BYTE;
  } // eslint-disable-line


  if (typedArrayType === Uint8Array) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line


  if (typedArrayType === Uint8ClampedArray) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line


  if (typedArrayType === Int16Array) {
    return SHORT;
  } // eslint-disable-line


  if (typedArrayType === Uint16Array) {
    return UNSIGNED_SHORT;
  } // eslint-disable-line


  if (typedArrayType === Int32Array) {
    return INT;
  } // eslint-disable-line


  if (typedArrayType === Uint32Array) {
    return UNSIGNED_INT;
  } // eslint-disable-line


  if (typedArrayType === Float32Array) {
    return FLOAT;
  } // eslint-disable-line


  throw new Error('unsupported typed array type');
}
/**
 * Get the typed array constructor for a given GL type
 * @param {number} type the GL type. (eg: `gl.UNSIGNED_INT`)
 * @return {function} the constructor for a the corresponding typed array. (eg. `Uint32Array`).
 * @memberOf module:twgl/typedArray
 */


function getTypedArrayTypeForGLType(type) {
  var CTOR = glTypeToTypedArray[type];

  if (!CTOR) {
    throw new Error('unknown gl type');
  }

  return CTOR;
}

var isArrayBuffer = typeof SharedArrayBuffer !== 'undefined' ? function isArrayBufferOrSharedArrayBuffer(a) {
  return a && a.buffer && (a.buffer instanceof ArrayBuffer || a.buffer instanceof SharedArrayBuffer);
} : function isArrayBuffer(a) {
  return a && a.buffer && a.buffer instanceof ArrayBuffer;
};
exports.isArrayBuffer = isArrayBuffer;

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.isWebGL1 = isWebGL1;
exports.isWebGL2 = isWebGL2;
exports.glEnumToString = void 0;

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Gets the gl version as a number
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {number} version of gl
 * @private
 */
//function getVersionAsNumber(gl) {
//  return parseFloat(gl.getParameter(gl.VERSION).substr(6));
//}

/**
 * Check if context is WebGL 2.0
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {bool} true if it's WebGL 2.0
 * @memberOf module:twgl
 */
function isWebGL2(gl) {
  // This is the correct check but it's slow
  //  return gl.getParameter(gl.VERSION).indexOf("WebGL 2.0") === 0;
  // This might also be the correct check but I'm assuming it's slow-ish
  // return gl instanceof WebGL2RenderingContext;
  return !!gl.texStorage2D;
}
/**
 * Check if context is WebGL 1.0
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {bool} true if it's WebGL 1.0
 * @memberOf module:twgl
 */


function isWebGL1(gl) {
  // This is the correct check but it's slow
  // const version = getVersionAsNumber(gl);
  // return version <= 1.0 && version > 0.0;  // because as of 2016/5 Edge returns 0.96
  // This might also be the correct check but I'm assuming it's slow-ish
  // return gl instanceof WebGLRenderingContext;
  return !gl.texStorage2D;
}
/**
 * Gets a string for WebGL enum
 *
 * Note: Several enums are the same. Without more
 * context (which function) it's impossible to always
 * give the correct enum. As it is, for matching values
 * it gives all enums. Checking the WebGL2RenderingContext
 * that means
 *
 *      0     = ZERO | POINT | NONE | NO_ERROR
 *      1     = ONE | LINES | SYNC_FLUSH_COMMANDS_BIT
 *      32777 = BLEND_EQUATION_RGB | BLEND_EQUATION_RGB
 *      36662 = COPY_READ_BUFFER | COPY_READ_BUFFER_BINDING
 *      36663 = COPY_WRITE_BUFFER | COPY_WRITE_BUFFER_BINDING
 *      36006 = FRAMEBUFFER_BINDING | DRAW_FRAMEBUFFER_BINDING
 *
 * It's also not useful for bits really unless you pass in individual bits.
 * In other words
 *
 *     const bits = gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT;
 *     twgl.glEnumToString(gl, bits);  // not going to work
 *
 * Note that some enums only exist on extensions. If you
 * want them to show up you need to pass the extension at least
 * once. For example
 *
 *     const ext = gl.getExtension('WEBGL_compressed_texture_s3tc');
 *     if (ext) {
 *        twgl.glEnumToString(ext, 0);  // just prime the function
 *
 *        ..later..
 *
 *        const internalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
 *        console.log(twgl.glEnumToString(gl, internalFormat));
 *
 * Notice I didn't have to pass the extension the second time. This means
 * you can have place that generically gets an enum for texture formats for example.
 * and as long as you primed the function with the extensions
 *
 * If you're using `twgl.addExtensionsToContext` to enable your extensions
 * then twgl will automatically get the extension's enums.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext or any extension object
 * @param {number} value the value of the enum you want to look up.
 * @return {string} enum string or hex value
 * @memberOf module:twgl
 * @function glEnumToString
 */


var glEnumToString = function () {
  var haveEnumsForType = {};
  var enums = {};

  function addEnums(gl) {
    var type = gl.constructor.name;

    if (!haveEnumsForType[type]) {
      for (var key in gl) {
        if (typeof gl[key] === 'number') {
          var existing = enums[gl[key]];
          enums[gl[key]] = existing ? "".concat(existing, " | ").concat(key) : key;
        }
      }

      haveEnumsForType[type] = true;
    }
  }

  return function glEnumToString(gl, value) {
    addEnums(gl);
    return enums[value] || (typeof value === 'number' ? "0x".concat(value.toString(16)) : value);
  };
}();

exports.glEnumToString = glEnumToString;

/***/ }),

/***/ "./src/v3.js":
/*!*******************!*\
  !*** ./src/v3.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.add = add;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.distance = distance;
exports.distanceSq = distanceSq;
exports.divide = divide;
exports.divScalar = divScalar;
exports.dot = dot;
exports.lerp = lerp;
exports.lerpV = lerpV;
exports.length = length;
exports.lengthSq = lengthSq;
exports.max = max;
exports.min = min;
exports.mulScalar = mulScalar;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.setDefaultType = setDefaultType;
exports.subtract = subtract;

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 *
 * Vec3 math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new Vec3. In other words you can do this
 *
 *     var v = v3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.
 *
 * or
 *
 *     var v = v3.create();
 *     v3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any vector as the destination. So for example
 *
 *     v3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 * @module twgl/v3
 */
var VecType = Float32Array;
/**
 * A JavaScript array with 3 values or a Float32Array with 3 values.
 * When created by the library will create the default type which is `Float32Array`
 * but can be set by calling {@link module:twgl/v3.setDefaultType}.
 * @typedef {(number[]|Float32Array)} Vec3
 * @memberOf module:twgl/v3
 */

/**
 * Sets the type this library creates for a Vec3
 * @param {constructor} ctor the constructor for the type. Either `Float32Array` or `Array`
 * @return {constructor} previous constructor for Vec3
 * @memberOf module:twgl/v3
 */

function setDefaultType(ctor) {
  var oldType = VecType;
  VecType = ctor;
  return oldType;
}
/**
 * Creates a vec3; may be called with x, y, z to set initial values.
 * @param {number} [x] Initial x value.
 * @param {number} [y] Initial y value.
 * @param {number} [z] Initial z value.
 * @return {module:twgl/v3.Vec3} the created vector
 * @memberOf module:twgl/v3
 */


function create(x, y, z) {
  var dst = new VecType(3);

  if (x) {
    dst[0] = x;
  }

  if (y) {
    dst[1] = y;
  }

  if (z) {
    dst[2] = z;
  }

  return dst;
}
/**
 * Adds two vectors; assumes a and b have the same dimension.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A vector tha tis the sum of a and b.
 * @memberOf module:twgl/v3
 */


function add(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] + b[0];
  dst[1] = a[1] + b[1];
  dst[2] = a[2] + b[2];
  return dst;
}
/**
 * Subtracts two vectors.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A vector that is the difference of a and b.
 * @memberOf module:twgl/v3
 */


function subtract(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] - b[0];
  dst[1] = a[1] - b[1];
  dst[2] = a[2] - b[2];
  return dst;
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient t, returns
 * a + t * (b - a).
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {number} t Interpolation coefficient.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The linear interpolated result.
 * @memberOf module:twgl/v3
 */


function lerp(a, b, t, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] + t * (b[0] - a[0]);
  dst[1] = a[1] + t * (b[1] - a[1]);
  dst[2] = a[2] + t * (b[2] - a[2]);
  return dst;
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient vector t, returns
 * a + t * (b - a).
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} t Interpolation coefficients vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} the linear interpolated result.
 * @memberOf module:twgl/v3
 */


function lerpV(a, b, t, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] + t[0] * (b[0] - a[0]);
  dst[1] = a[1] + t[1] * (b[1] - a[1]);
  dst[2] = a[2] + t[2] * (b[2] - a[2]);
  return dst;
}
/**
 * Return max values of two vectors.
 * Given vectors a and b returns
 * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The max components vector.
 * @memberOf module:twgl/v3
 */


function max(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = Math.max(a[0], b[0]);
  dst[1] = Math.max(a[1], b[1]);
  dst[2] = Math.max(a[2], b[2]);
  return dst;
}
/**
 * Return min values of two vectors.
 * Given vectors a and b returns
 * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The min components vector.
 * @memberOf module:twgl/v3
 */


function min(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = Math.min(a[0], b[0]);
  dst[1] = Math.min(a[1], b[1]);
  dst[2] = Math.min(a[2], b[2]);
  return dst;
}
/**
 * Multiplies a vector by a scalar.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {number} k The scalar.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The scaled vector.
 * @memberOf module:twgl/v3
 */


function mulScalar(v, k, dst) {
  dst = dst || new VecType(3);
  dst[0] = v[0] * k;
  dst[1] = v[1] * k;
  dst[2] = v[2] * k;
  return dst;
}
/**
 * Divides a vector by a scalar.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {number} k The scalar.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The scaled vector.
 * @memberOf module:twgl/v3
 */


function divScalar(v, k, dst) {
  dst = dst || new VecType(3);
  dst[0] = v[0] / k;
  dst[1] = v[1] / k;
  dst[2] = v[2] / k;
  return dst;
}
/**
 * Computes the cross product of two vectors; assumes both vectors have
 * three entries.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of a cross b.
 * @memberOf module:twgl/v3
 */


function cross(a, b, dst) {
  dst = dst || new VecType(3);
  var t1 = a[2] * b[0] - a[0] * b[2];
  var t2 = a[0] * b[1] - a[1] * b[0];
  dst[0] = a[1] * b[2] - a[2] * b[1];
  dst[1] = t1;
  dst[2] = t2;
  return dst;
}
/**
 * Computes the dot product of two vectors; assumes both vectors have
 * three entries.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @return {number} dot product
 * @memberOf module:twgl/v3
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the length of vector
 * @param {module:twgl/v3.Vec3} v vector.
 * @return {number} length of vector.
 * @memberOf module:twgl/v3
 */


function length(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}
/**
 * Computes the square of the length of vector
 * @param {module:twgl/v3.Vec3} v vector.
 * @return {number} square of the length of vector.
 * @memberOf module:twgl/v3
 */


function lengthSq(v) {
  return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
}
/**
 * Computes the distance between 2 points
 * @param {module:twgl/v3.Vec3} a vector.
 * @param {module:twgl/v3.Vec3} b vector.
 * @return {number} distance between a and b
 * @memberOf module:twgl/v3
 */


function distance(a, b) {
  var dx = a[0] - b[0];
  var dy = a[1] - b[1];
  var dz = a[2] - b[2];
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}
/**
 * Computes the square of the distance between 2 points
 * @param {module:twgl/v3.Vec3} a vector.
 * @param {module:twgl/v3.Vec3} b vector.
 * @return {number} square of the distance between a and b
 * @memberOf module:twgl/v3
 */


function distanceSq(a, b) {
  var dx = a[0] - b[0];
  var dy = a[1] - b[1];
  var dz = a[2] - b[2];
  return dx * dx + dy * dy + dz * dz;
}
/**
 * Divides a vector by its Euclidean length and returns the quotient.
 * @param {module:twgl/v3.Vec3} a The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The normalized vector.
 * @memberOf module:twgl/v3
 */


function normalize(a, dst) {
  dst = dst || new VecType(3);
  var lenSq = a[0] * a[0] + a[1] * a[1] + a[2] * a[2];
  var len = Math.sqrt(lenSq);

  if (len > 0.00001) {
    dst[0] = a[0] / len;
    dst[1] = a[1] / len;
    dst[2] = a[2] / len;
  } else {
    dst[0] = 0;
    dst[1] = 0;
    dst[2] = 0;
  }

  return dst;
}
/**
 * Negates a vector.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} -v.
 * @memberOf module:twgl/v3
 */


function negate(v, dst) {
  dst = dst || new VecType(3);
  dst[0] = -v[0];
  dst[1] = -v[1];
  dst[2] = -v[2];
  return dst;
}
/**
 * Copies a vector.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A copy of v.
 * @memberOf module:twgl/v3
 */


function copy(v, dst) {
  dst = dst || new VecType(3);
  dst[0] = v[0];
  dst[1] = v[1];
  dst[2] = v[2];
  return dst;
}
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of products of entries of a and
 *     b.
 * @memberOf module:twgl/v3
 */


function multiply(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] * b[0];
  dst[1] = a[1] * b[1];
  dst[2] = a[2] * b[2];
  return dst;
}
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of quotients of entries of a and
 *     b.
 * @memberOf module:twgl/v3
 */


function divide(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] / b[0];
  dst[1] = a[1] / b[1];
  dst[2] = a[2] / b[2];
  return dst;
}

/***/ }),

/***/ "./src/vertex-arrays.js":
/*!******************************!*\
  !*** ./src/vertex-arrays.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.createVertexArrayInfo = createVertexArrayInfo;
exports.createVAOAndSetAttributes = createVAOAndSetAttributes;
exports.createVAOFromBufferInfo = createVAOFromBufferInfo;

var programs = _interopRequireWildcard(__webpack_require__(/*! ./programs.js */ "./src/programs.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * vertex array object related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.attributes` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/vertexArrays
 */
var ELEMENT_ARRAY_BUFFER = 0x8893;
/**
 * @typedef {Object} VertexArrayInfo
 * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.
 * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..
 * @property {WebGLVertexArrayObject} [vertexArrayObject] a vertex array object
 * @memberOf module:twgl
 */

/**
 * Creates a VertexArrayInfo from a BufferInfo and one or more ProgramInfos
 *
 * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to
 * {@link module:twgl:drawBufferInfo}.
 *
 * > **IMPORTANT:** Vertex Array Objects are **not** a direct analog for a BufferInfo. Vertex Array Objects
 *   assign buffers to specific attributes at creation time. That means they can only be used with programs
 *   who's attributes use the same attribute locations for the same purposes.
 *
 * > Bind your attribute locations by passing an array of attribute names to {@link module:twgl.createProgramInfo}
 *   or use WebGL 2's GLSL ES 3's `layout(location = <num>)` to make sure locations match.
 *
 * also
 *
 * > **IMPORTANT:** After calling twgl.setBuffersAndAttribute with a BufferInfo that uses a Vertex Array Object
 *   that Vertex Array Object will be bound. That means **ANY MANIPULATION OF ELEMENT_ARRAY_BUFFER or ATTRIBUTES**
 *   will affect the Vertex Array Object state.
 *
 * > Call `gl.bindVertexArray(null)` to get back manipulating the global attributes and ELEMENT_ARRAY_BUFFER.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.ProgramInfo|module:twgl.ProgramInfo[]} programInfo a programInfo or array of programInfos
 * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...
 *
 *    You need to make sure every attribute that will be used is bound. So for example assume shader 1
 *    uses attributes A, B, C and shader 2 uses attributes A, B, D. If you only pass in the programInfo
 *    for shader 1 then only attributes A, B, and C will have their attributes set because TWGL doesn't
 *    now attribute D's location.
 *
 *    So, you can pass in both shader 1 and shader 2's programInfo
 *
 * @return {module:twgl.VertexArrayInfo} The created VertexArrayInfo
 *
 * @memberOf module:twgl/vertexArrays
 */

function createVertexArrayInfo(gl, programInfos, bufferInfo) {
  var vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  if (!programInfos.length) {
    programInfos = [programInfos];
  }

  programInfos.forEach(function (programInfo) {
    programs.setBuffersAndAttributes(gl, programInfo, bufferInfo);
  });
  gl.bindVertexArray(null);
  return {
    numElements: bufferInfo.numElements,
    elementType: bufferInfo.elementType,
    vertexArrayObject: vao
  };
}
/**
 * Creates a vertex array object and then sets the attributes on it
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters
 * @param {Object.<string, module:twgl.AttribInfo>} attribs AttribInfos mapped by attribute name.
 * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
 * @memberOf module:twgl/vertexArrays
 */


function createVAOAndSetAttributes(gl, setters, attribs, indices) {
  var vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  programs.setAttributes(setters, attribs);

  if (indices) {
    gl.bindBuffer(ELEMENT_ARRAY_BUFFER, indices);
  } // We unbind this because otherwise any change to ELEMENT_ARRAY_BUFFER
  // like when creating buffers for other stuff will mess up this VAO's binding


  gl.bindVertexArray(null);
  return vao;
}
/**
 * Creates a vertex array object and then sets the attributes
 * on it
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {Object.<string, function>| module:twgl.ProgramInfo} programInfo as returned from createProgramInfo or Attribute setters as returned from createAttributeSetters
 * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...
 * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
 * @memberOf module:twgl/vertexArrays
 */


function createVAOFromBufferInfo(gl, programInfo, bufferInfo) {
  return createVAOAndSetAttributes(gl, programInfo.attribSetters || programInfo, bufferInfo.attribs, bufferInfo.indices);
}

/***/ })

/******/ });
});

},{}],31:[function(require,module,exports){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var loadMap = require("./loadMap");
var mat3 = require("gl-matrix/mat3");
var createDrawing = require("./renderer");
var initShapes = require("./shapes");
var initVizCtrl = require("./pathviz");
var twgl = require("twgl.js");

var colors = require("./theme").default;

var canvas = document.createElement("canvas");
document.body.appendChild(canvas);

var gl = canvas.getContext("webgl");
var shapes = initShapes(gl);

var scene = createDrawing(gl);
scene.draw();

// WebGL map data
var nodes = void 0;
var edges = void 0;

// Pathfinding 
var graph = void 0;
var controller = void 0;

loadMap("toronto", updateLoadingText).then(function (res) {
  nodes = res.nodes;
  edges = res.edges;
  graph = res.mapGraph;
  main();
});

function main() {
  // TODO: this, but properly (async for-loop?)
  updateLoadingText({ message: "Creating Quadtree", completed: 14 });

  controller = initVizCtrl(gl, graph, nodes, scene, shapes);

  // TODO: this, but properly (async for-loop?)
  updateLoadingText({ message: "Creating Quadtree", completed: 100 });

  document.getElementById("overlay").style.display = "none";
  // draw map
  scene.addObject(nodes, edges, {
    color: colors.baseMap,
    type: gl.LINES,
    layer: "base"
  });

  attachHandlers();
  scene.draw();
}

function updateLoadingText(progress) {
  var msg = progress.message;
  var pct = progress.completed;
  console.log(pct);
  document.getElementById("progress").innerHTML = msg + ": " + pct + "%";
}

function attachHandlers() {
  window.addEventListener('resize', handleResize);
  canvas.addEventListener('mousedown', handleMouseDown);
  canvas.addEventListener('wheel', handleMouseWheel);

  // handle window resize
  function handleResize(e) {
    scene.draw();
  }

  var camera = scene.camera;
  var viewProjectionMat = scene.viewProjectionMat;
  var updateViewProjection = scene.updateViewProjection;
  var startInvViewProjMat = mat3.create();
  var startCamera = void 0;
  var startPos = void 0;
  var startClipPos = void 0;

  var moved = false;

  function handleMouseDown(e) {
    e.preventDefault();
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);

    mat3.invert(startInvViewProjMat, viewProjectionMat);

    startCamera = Object.assign({}, camera);
    startClipPos = getClipSpaceMousePosition(e);
    startPos = transformPoint(startInvViewProjMat, startClipPos);
    scene.draw();
  };

  function handleMouseWheel(e) {
    e.preventDefault();

    var _getClipSpaceMousePos = getClipSpaceMousePosition(e),
        _getClipSpaceMousePos2 = _slicedToArray(_getClipSpaceMousePos, 2),
        clipX = _getClipSpaceMousePos2[0],
        clipY = _getClipSpaceMousePos2[1];
    // position before zooming


    var temp = mat3.create();
    mat3.invert(temp, viewProjectionMat);

    var _transformPoint = transformPoint(temp, [clipX, clipY]),
        _transformPoint2 = _slicedToArray(_transformPoint, 2),
        preZoomX = _transformPoint2[0],
        preZoomY = _transformPoint2[1];

    // multiply the wheel movement by the current zoom level
    // so we zoom less when zoomed in and more when zoomed out


    var newZoom = camera.zoom * Math.pow(2, e.deltaY * -0.01);
    camera.zoom = Math.max(0.02, Math.min(100, newZoom));

    updateViewProjection();

    // position after zooming
    mat3.invert(temp, viewProjectionMat);

    var _transformPoint3 = transformPoint(temp, [clipX, clipY]),
        _transformPoint4 = _slicedToArray(_transformPoint3, 2),
        postZoomX = _transformPoint4[0],
        postZoomY = _transformPoint4[1];

    // camera needs to be moved the difference of before and after


    camera.x += preZoomX - postZoomX;
    camera.y += preZoomY - postZoomY;

    scene.draw();
  }
  function handleMouseMove(e) {
    moved = true;
    moveCamera(e);
  }

  function handleMouseUp(e) {
    scene.draw();
    window.removeEventListener('mousemove', handleMouseMove);
    window.removeEventListener('mouseup', handleMouseUp);

    // check if mouse click (not drag)
    if (!moved) {
      console.log("mouse tap!");
      handleClick(e);
    }
    moved = false;
  }

  var name = "start";
  function handleClick(e) {
    var pos = transformPoint(startInvViewProjMat, getClipSpaceMousePosition(e));

    controller.setNode(pos, name);
    name = name == "start" ? "target" : "start";
  }

  function moveCamera(e) {
    var pos = transformPoint(startInvViewProjMat, getClipSpaceMousePosition(e));

    camera.x = startCamera.x + startPos[0] - pos[0];
    camera.y = startCamera.y + startPos[1] - pos[1];
    scene.draw();
  }

  function transformPoint(m, v) {
    var v0 = v[0];
    var v1 = v[1];
    var d = v0 * m[0 * 3 + 2] + v1 * m[1 * 3 + 2] + m[2 * 3 + 2];
    return [(v0 * m[0 * 3 + 0] + v1 * m[1 * 3 + 0] + m[2 * 3 + 0]) / d, (v0 * m[0 * 3 + 1] + v1 * m[1 * 3 + 1] + m[2 * 3 + 1]) / d];
  }
}

function getClipSpaceMousePosition(e) {
  // get canvas relative css position
  var rect = canvas.getBoundingClientRect();
  var cssX = e.clientX - rect.left;
  var cssY = e.clientY - rect.top;

  // get normalized 0 to 1 position across and down canvas
  var normalizedX = cssX / canvas.clientWidth;
  var normalizedY = cssY / canvas.clientHeight;

  // convert to clip space
  var clipX = normalizedX * 2 - 1;
  var clipY = normalizedY * -2 + 1;

  return [clipX, clipY];
}

},{"./loadMap":32,"./pathviz":33,"./renderer":34,"./shapes":36,"./theme":37,"gl-matrix/mat3":17,"twgl.js":30}],32:[function(require,module,exports){
"use strict";

var request = require("./request");
var createGraph = require("ngraph.graph");
var endpoint = "./data/";

module.exports = function (name, progress) {
  var nodes = void 0;
  var edges = void 0;
  var mapGraph = createGraph();

  return loadNodes().then(function (res) {
    setNodeCoordinates(res);
    return loadEdges();
  }).then(function (res) {
    setEdgeLinks(res);
    return {
      nodes: nodes, edges: edges, mapGraph: mapGraph
    };
  });

  function loadNodes() {
    return request(endpoint + (name + ".co.bin"), {
      responseType: "arraybuffer",
      progress: reportProgress("Loading map nodes")
    });
  }

  function loadEdges() {
    return request(endpoint + (name + ".gr.bin"), {
      responseType: "arraybuffer",
      progress: reportProgress("Loading map edges")
    });
  }

  function setNodeCoordinates(buffer) {
    nodes = new Int32Array(buffer);
    // add to graph structure
    for (var i = 0; i < nodes.length / 2; ++i) {
      mapGraph.addNode(i, {
        x: nodes[i * 2],
        y: nodes[i * 2 + 1]
      });
    }
  }

  function setEdgeLinks(buffer) {
    edges = new Int32Array(buffer);
    for (var i = 0; i < edges.length / 2; ++i) {
      edges[i * 2] -= 1;
      edges[i * 2 + 1] -= 1;
      mapGraph.addLink(edges[i * 2], edges[i * 2 + 1]);
    }
  }

  function reportProgress(msg) {
    return function (e) {
      var prog = {};
      prog.message = msg;
      prog.completed = Math.round(e.percent * 100);
      progress(prog);
    };
  }
};

},{"./request":35,"ngraph.graph":20}],33:[function(require,module,exports){
"use strict";

var d3 = require("d3-quadtree");
var aStar = require("ngraph.path").aStar;
var colors = require("./theme").default;

module.exports = function (gl, graph, verts, scene, shapes) {
  // init pathfinder
  var pathfinder = aStar(graph, {
    distance: pythagoreanDist,
    heuristic: pythagoreanDist
  });

  // init quadtree
  var quadtree = d3.quadtree().x(function (n) {
    return n.data.x;
  }).y(function (n) {
    return n.data.y;
  });

  graph.forEachNode(function (node) {
    quadtree.add(node);
  });

  var STNodes = {};
  var searchDrawing;

  function reset() {
    delete STNodes.start;
    delete STNodes.target;
    scene.clearLayer("mid");
    scene.clearLayer("top");
  }
  function setNode(pos, name) {
    if (name == "start") reset();

    var node = quadtree.find(pos[0], pos[1]);
    var _ref = [node.data.x, node.data.y],
        x = _ref[0],
        y = _ref[1];


    if (!STNodes[name]) {
      STNodes[name] = {
        node: node,
        sceneObjs: initPin(x, y, name)
      };
    }

    STNodes[name].node = node;
    updatePin(x, y, name);
    scene.draw();

    if (name == "target") startFind();
  }

  function initPin(x, y, name) {
    var elements = shapes[name].elements;
    var sceneObjs = [];

    elements.forEach(function (el) {
      var transforms = {
        x: x,
        y: y,
        scale: el.scale,
        zoom: false
      };

      sceneObjs.push(scene.addObject(el.verts, el.indices, {
        color: el.color,
        type: el.drawType,
        layer: "top",
        transforms: transforms
      }));
    });

    return sceneObjs;
  }

  function updatePin(x, y, name) {
    STNodes[name].sceneObjs.forEach(function (obj) {
      obj.transforms.x = x;
      obj.transforms.y = y;
    });
  }

  function startFind() {
    if (!STNodes.start || !STNodes.target) {
      console.error("Missing start/target node");
      return;
    }

    var a = STNodes.start;
    var b = STNodes.target;
    var searchData = pathfinder.find(a.node.id, b.node.id);
    var animData = new Uint32Array(searchData.visited.reverse());
    searchDrawing = scene.addObject(verts, animData, {
      color: colors.searchPath,
      type: gl.LINES,
      layer: "mid"
    });

    var offset = animData.length * 4;
    animateSearch();

    function animateSearch() {
      offset = offset < 0 ? 0 : offset;
      scene.updateIndexOffset(animData, offset, searchDrawing);
      scene.draw();

      if (offset != 0) {
        offset -= 100 * 4;
        requestAnimationFrame(animateSearch);
      } else {
        drawPath();
      }
    }

    function drawPath() {
      debugger;
    }
  }

  return {
    setNode: setNode,
    startFind: startFind
  };
};

var manhattanDist = function manhattanDist(a, b) {
  var dx = a.data.x - b.data.x;
  var dy = a.data.y - b.data.y;
  return Math.sqrt(dx * dx + dy * dy);
};

var pythagoreanDist = function pythagoreanDist(a, b) {
  var dx = a.data.x - b.data.x;
  var dy = a.data.y - b.data.y;
  return Math.sqrt(dx * dx + dy * dy);
};

},{"./theme":37,"d3-quadtree":6,"ngraph.path":29}],34:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var glsl = require("glslify");
var twgl = require("twgl.js");
var mat3 = require("gl-matrix/mat3");

var vertexShader = glsl(["precision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 position;\n\nuniform mat3 u_matrix;\n\nvoid main() {\n  gl_Position = vec4((u_matrix * vec3(position, 1)).xy, 0, 1);\n}"]);
var fragmentShader = glsl(["precision mediump float;\n#define GLSLIFY 1\n\nuniform vec4 u_color;\n\nvoid main(){\n\n  gl_FragColor = u_color;\n\n}"]);

var colors = require("./theme").default;

module.exports = function (gl) {
  var programInfo = twgl.createProgramInfo(gl, [vertexShader, fragmentShader]);
  var resolution = [gl.canvas.width, gl.canvas.height];
  var viewProjectionMat = mat3.create();
  var sceneLayers = { base: [], mid: [], top: [] };

  var camera = {
    x: -33948,
    y: -17689,
    zoom: 0.0271311
  };

  twgl.addExtensionsToContext(gl);

  function updateViewProjection() {
    mat3.projection(viewProjectionMat, gl.canvas.width, gl.canvas.height);

    // make camera matrix
    var zoomScale = 1 / camera.zoom;
    var cameraMat = mat3.create();
    mat3.translate(cameraMat, cameraMat, [camera.x, camera.y]);
    mat3.scale(cameraMat, cameraMat, [zoomScale, zoomScale]);

    var viewMat = mat3.create();
    mat3.invert(viewMat, cameraMat);
    mat3.multiply(viewProjectionMat, viewProjectionMat, viewMat);
  }

  function computeMatrixUniform(transforms) {
    var mat = mat3.create();
    mat3.identity(mat);
    mat3.translate(mat, mat, [transforms.x, transforms.y]);
    mat3.scale(mat, mat, [transforms.scale, transforms.scale]);

    if (!transforms.zoom) {
      mat3.scale(mat, mat, [1 / camera.zoom, 1 / camera.zoom]);
    }

    mat3.multiply(mat, viewProjectionMat, mat);
    return mat;
  }

  function addObject(verts, inds, props) {
    props.transforms = props.transforms ? props.transforms : { x: 0, y: 0, scale: 1, zoom: true };
    props.layer = props.layer ? props.layer : "mid";
    props.offset = props.offset ? props.offset : 0;

    var bufferData = {
      position: { numComponents: 2, data: new Float32Array(verts) },
      indices: { numComponents: 2, data: new Uint32Array(inds) }
    };
    var bufferInfo = twgl.createBufferInfoFromArrays(gl, bufferData);
    var obj = {
      bufferInfo: bufferInfo,
      color: props.color,
      drawType: props.type,
      transforms: props.transforms,
      offset: props.offset
    };

    if (typeof props.layerIndex !== "undefined") {
      sceneLayers[props.layer] = obj;
    } else {
      sceneLayers[props.layer].push(obj);
    }
    return obj;
  }

  function updateIndexOffset(inds, offset, obj) {
    var bufferData = {
      indices: { numComponents: 2, data: new Uint32Array(inds.buffer, offset) }
    };
    obj.bufferInfo = twgl.createBufferInfoFromArrays(gl, bufferData, obj.bufferInfo);
  }

  function drawObject(obj) {
    var uniforms = {
      u_color: obj.color,
      u_matrix: computeMatrixUniform(obj.transforms)
    };
    gl.useProgram(programInfo.program);
    twgl.setBuffersAndAttributes(gl, programInfo, obj.bufferInfo);
    twgl.setUniforms(programInfo, uniforms);
    twgl.drawBufferInfo(gl, obj.bufferInfo, obj.drawType, obj.bufferInfo.numElements, obj.offset);
  }

  function clearLayer(layer) {
    sceneLayers[layer].length = 0;
  }

  return {
    addObject: addObject,
    updateIndexOffset: updateIndexOffset,
    updateViewProjection: updateViewProjection,
    clearLayer: clearLayer,
    camera: camera,
    viewProjectionMat: viewProjectionMat,

    draw: function draw() {
      resolution[0] = gl.canvas.width;
      resolution[1] = gl.canvas.height;

      twgl.resizeCanvasToDisplaySize(gl.canvas);

      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      gl.clearColor.apply(gl, _toConsumableArray(colors.background));
      gl.clear(gl.COLOR_BUFFER_BIT);

      updateViewProjection();

      sceneLayers.base.forEach(drawObject);
      sceneLayers.mid.forEach(drawObject);
      sceneLayers.top.forEach(drawObject);
    }
  };
};

},{"./theme":37,"gl-matrix/mat3":17,"glslify":18,"twgl.js":30}],35:[function(require,module,exports){
"use strict";

module.exports = request;

function request(url, options) {
  if (!options) options = {};

  return new Promise(download);

  function download(resolve, reject) {
    var req = new XMLHttpRequest();

    if (typeof options.progress === 'function') {
      req.addEventListener("progress", updateProgress, false);
    }

    req.addEventListener("load", transferComplete, false);
    req.addEventListener("error", transferFailed, false);
    req.addEventListener("abort", transferCanceled, false);

    req.open('GET', url);
    if (options.responseType) {
      req.responseType = options.responseType;
    }
    req.send(null);

    function updateProgress(e) {
      if (e.lengthComputable) {
        options.progress({
          loaded: e.loaded,
          total: e.total,
          percent: e.loaded / e.total
        });
      }
    }

    function transferComplete() {
      if (req.status !== 200) {
        reject("Unexpected status code " + req.status + " when calling " + url);
        return;
      }
      var response = req.response;

      if (options.responseType === 'json' && typeof response === 'string') {
        // IE
        response = JSON.parse(response);
      }

      resolve(response);
    }

    function transferFailed() {
      reject("Failed to download " + url);
    }

    function transferCanceled() {
      reject("Cancelled download of " + url);
    }
  }
}

},{}],36:[function(require,module,exports){
"use strict";

var colors = require("./theme").default;

module.exports = function (gl) {
  return {
    target: {
      elements: [{
        verts: primitives.pin.verts,
        indices: primitives.pin.indices,
        color: colors.targetPin,
        scale: 5,
        drawType: gl.TRIANGLE_FAN
      }, {
        verts: primitives.pin1.verts,
        indices: primitives.pin1.indices,
        color: colors.targetPin1,
        scale: 4.3,
        drawType: gl.TRIANGLE_FAN
      }]
    },
    start: {
      elements: [{
        verts: primitives.circle.verts,
        indices: primitives.circle.indices,
        color: colors.startPin,
        scale: 5,
        drawType: gl.TRIANGLE_FAN
      }, {
        verts: primitives.circle.verts,
        indices: primitives.circle.indices,
        color: colors.startPin1,
        scale: 4.5,
        drawType: gl.TRIANGLE_FAN
      }, {
        verts: primitives.circle.verts,
        indices: primitives.circle.indices,
        color: colors.startPin2,
        scale: 2,
        drawType: gl.TRIANGLE_FAN
      }]
    }
  };
};

var primitives = {
  circle: {
    verts: [0, 0, 0, -3.0, 1.04, -2.814, 2.1213, -2.1213, 2.814, -1.04, 3.0, 0, 2.814, 1.04, 2.1213, 2.1213, 1.04, 2.814, 0, 3.0, -1.04, 2.814, -2.1213, 2.1213, -2.814, 1.04, -3.0, -0, -2.814, -1.04, -2.1213, -2.1213, -1.04, -2.814],
    indices: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1]
  },
  pin: {
    verts: [0, -7, -2.6, -6.0, -2.6, -7, -2.0, -8.5, -0.7, -9.4, 0.7, -9.4, 2.0, -8.5, 2.6, -7, 2.6, -6.0, 0, 0],
    indices: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1]
  },
  pin1: {
    verts: [0, -8, -2.6, -7.0, -2.6, -8, -2.0, -9.5, -0.7, -10.4, 0.7, -10.4, 2.0, -9.5, 2.6, -8, 2.6, -7.0, 0, -1],
    indices: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1]
  }
};

},{"./theme":37}],37:[function(require,module,exports){
"use strict";

module.exports = {
  default: {
    background: [0.157, 0.173, 0.204, 1],
    baseMap: [1.0, 1.0, 1.0, 1],
    searchPath: [0.223, 1, 0.07, 1],
    path: [],

    // start pin colors
    startPin: [0.05, 0.30, 0.669, 1],
    startPin1: [0.2, 0.57, 0.969, 1],
    startPin2: [1, 1, 1, 1],

    // target pin colors
    targetPin: [0.45, 0.07, 0.07, 1],
    targetPin1: [0.80, 0.17, 0.17, 1],
    targetPin2: [0.75, 0.17, 0.17, 1]
  }
};

},{}]},{},[31])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2FkZC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvY292ZXIuanMiLCJub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2RhdGEuanMiLCJub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2V4dGVudC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvZmluZC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3F1YWQuanMiLCJub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3F1YWR0cmVlLmpzIiwibm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9yZW1vdmUuanMiLCJub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3Jvb3QuanMiLCJub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3NpemUuanMiLCJub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3Zpc2l0LmpzIiwibm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy92aXNpdEFmdGVyLmpzIiwibm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy94LmpzIiwibm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy95LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9janMvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9janMvbWF0My5qcyIsIm5vZGVfbW9kdWxlcy9nbHNsaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbmdyYXBoLmV2ZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9uZ3JhcGguZ3JhcGgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmdyYXBoLnBhdGgvYS1zdGFyL05vZGVIZWFwLmpzIiwibm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2Etc3Rhci9hLWdyZWVkeS1zdGFyLmpzIiwibm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2Etc3Rhci9hLXN0YXIuanMiLCJub2RlX21vZHVsZXMvbmdyYXBoLnBhdGgvYS1zdGFyL2RlZmF1bHRTZXR0aW5ncy5qcyIsIm5vZGVfbW9kdWxlcy9uZ3JhcGgucGF0aC9hLXN0YXIvaGV1cmlzdGljcy5qcyIsIm5vZGVfbW9kdWxlcy9uZ3JhcGgucGF0aC9hLXN0YXIvbWFrZVNlYXJjaFN0YXRlUG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9uZ3JhcGgucGF0aC9hLXN0YXIvbmJhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2Etc3Rhci9uYmEvbWFrZU5CQVNlYXJjaFN0YXRlUG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9uZ3JhcGgucGF0aC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90d2dsLmpzL2Rpc3QvNC54L3R3Z2wtZnVsbC5qcyIsInNyYy9pbmRleC5qcyIsInNyYy9sb2FkTWFwLmpzIiwic3JjL3BhdGh2aXouanMiLCJzcmMvcmVuZGVyZXIuanMiLCJzcmMvcmVxdWVzdC5qcyIsInNyYy9zaGFwZXMuanMiLCJzcmMvdGhlbWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7a0JDQWUsVUFBUyxDQUFULEVBQVk7QUFDekIsTUFBTSxJQUFJLENBQUMsS0FBSyxFQUFMLENBQVEsSUFBUixDQUFhLElBQWIsRUFBbUIsQ0FBbkIsQ0FBWDtBQUFBLE1BQ0ksSUFBSSxDQUFDLEtBQUssRUFBTCxDQUFRLElBQVIsQ0FBYSxJQUFiLEVBQW1CLENBQW5CLENBRFQ7QUFFQSxTQUFPLElBQUksS0FBSyxLQUFMLENBQVcsQ0FBWCxFQUFjLENBQWQsQ0FBSixFQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QixDQUE1QixDQUFQO0FBQ0QsQzs7UUE2Q2UsTSxHQUFBLE07OztBQTNDaEIsU0FBUyxHQUFULENBQWEsSUFBYixFQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QjtBQUMxQixNQUFJLE1BQU0sQ0FBTixLQUFZLE1BQU0sQ0FBTixDQUFoQixFQUEwQixPQUFPLElBQVAsQ0FEQSxDQUNhOztBQUV2QyxNQUFJLE1BQUo7QUFBQSxNQUNJLE9BQU8sS0FBSyxLQURoQjtBQUFBLE1BRUksT0FBTyxFQUFDLE1BQU0sQ0FBUCxFQUZYO0FBQUEsTUFHSSxLQUFLLEtBQUssR0FIZDtBQUFBLE1BSUksS0FBSyxLQUFLLEdBSmQ7QUFBQSxNQUtJLEtBQUssS0FBSyxHQUxkO0FBQUEsTUFNSSxLQUFLLEtBQUssR0FOZDtBQUFBLE1BT0ksRUFQSjtBQUFBLE1BUUksRUFSSjtBQUFBLE1BU0ksRUFUSjtBQUFBLE1BVUksRUFWSjtBQUFBLE1BV0ksS0FYSjtBQUFBLE1BWUksTUFaSjtBQUFBLE1BYUksQ0FiSjtBQUFBLE1BY0ksQ0FkSjs7QUFnQkE7QUFDQSxNQUFJLENBQUMsSUFBTCxFQUFXLE9BQU8sS0FBSyxLQUFMLEdBQWEsSUFBYixFQUFtQixJQUExQjs7QUFFWDtBQUNBLFNBQU8sS0FBSyxNQUFaLEVBQW9CO0FBQ2xCLFFBQUksUUFBUSxNQUFNLEtBQUssQ0FBQyxLQUFLLEVBQU4sSUFBWSxDQUF2QixDQUFaLEVBQXVDLEtBQUssRUFBTCxDQUF2QyxLQUFxRCxLQUFLLEVBQUw7QUFDckQsUUFBSSxTQUFTLE1BQU0sS0FBSyxDQUFDLEtBQUssRUFBTixJQUFZLENBQXZCLENBQWIsRUFBd0MsS0FBSyxFQUFMLENBQXhDLEtBQXNELEtBQUssRUFBTDtBQUN0RCxRQUFJLFNBQVMsSUFBVCxFQUFlLEVBQUUsT0FBTyxLQUFLLElBQUksVUFBVSxDQUFWLEdBQWMsS0FBdkIsQ0FBVCxDQUFuQixFQUE0RCxPQUFPLE9BQU8sQ0FBUCxJQUFZLElBQVosRUFBa0IsSUFBekI7QUFDN0Q7O0FBRUQ7QUFDQSxPQUFLLENBQUMsS0FBSyxFQUFMLENBQVEsSUFBUixDQUFhLElBQWIsRUFBbUIsS0FBSyxJQUF4QixDQUFOO0FBQ0EsT0FBSyxDQUFDLEtBQUssRUFBTCxDQUFRLElBQVIsQ0FBYSxJQUFiLEVBQW1CLEtBQUssSUFBeEIsQ0FBTjtBQUNBLE1BQUksTUFBTSxFQUFOLElBQVksTUFBTSxFQUF0QixFQUEwQixPQUFPLEtBQUssSUFBTCxHQUFZLElBQVosRUFBa0IsU0FBUyxPQUFPLENBQVAsSUFBWSxJQUFyQixHQUE0QixLQUFLLEtBQUwsR0FBYSxJQUEzRCxFQUFpRSxJQUF4RTs7QUFFMUI7QUFDQSxLQUFHO0FBQ0QsYUFBUyxTQUFTLE9BQU8sQ0FBUCxJQUFZLElBQUksS0FBSixDQUFVLENBQVYsQ0FBckIsR0FBb0MsS0FBSyxLQUFMLEdBQWEsSUFBSSxLQUFKLENBQVUsQ0FBVixDQUExRDtBQUNBLFFBQUksUUFBUSxNQUFNLEtBQUssQ0FBQyxLQUFLLEVBQU4sSUFBWSxDQUF2QixDQUFaLEVBQXVDLEtBQUssRUFBTCxDQUF2QyxLQUFxRCxLQUFLLEVBQUw7QUFDckQsUUFBSSxTQUFTLE1BQU0sS0FBSyxDQUFDLEtBQUssRUFBTixJQUFZLENBQXZCLENBQWIsRUFBd0MsS0FBSyxFQUFMLENBQXhDLEtBQXNELEtBQUssRUFBTDtBQUN2RCxHQUpELFFBSVMsQ0FBQyxJQUFJLFVBQVUsQ0FBVixHQUFjLEtBQW5CLE9BQStCLElBQUksQ0FBQyxNQUFNLEVBQVAsS0FBYyxDQUFkLEdBQW1CLE1BQU0sRUFBNUQsQ0FKVDtBQUtBLFNBQU8sT0FBTyxDQUFQLElBQVksSUFBWixFQUFrQixPQUFPLENBQVAsSUFBWSxJQUE5QixFQUFvQyxJQUEzQztBQUNEOztBQUVNLFNBQVMsTUFBVCxDQUFnQixJQUFoQixFQUFzQjtBQUMzQixNQUFJLENBQUo7QUFBQSxNQUFPLENBQVA7QUFBQSxNQUFVLElBQUksS0FBSyxNQUFuQjtBQUFBLE1BQ0ksQ0FESjtBQUFBLE1BRUksQ0FGSjtBQUFBLE1BR0ksS0FBSyxJQUFJLEtBQUosQ0FBVSxDQUFWLENBSFQ7QUFBQSxNQUlJLEtBQUssSUFBSSxLQUFKLENBQVUsQ0FBVixDQUpUO0FBQUEsTUFLSSxLQUFLLFFBTFQ7QUFBQSxNQU1JLEtBQUssUUFOVDtBQUFBLE1BT0ksS0FBSyxDQUFDLFFBUFY7QUFBQSxNQVFJLEtBQUssQ0FBQyxRQVJWOztBQVVBO0FBQ0EsT0FBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEVBQUUsQ0FBckIsRUFBd0I7QUFDdEIsUUFBSSxNQUFNLElBQUksQ0FBQyxLQUFLLEVBQUwsQ0FBUSxJQUFSLENBQWEsSUFBYixFQUFtQixJQUFJLEtBQUssQ0FBTCxDQUF2QixDQUFYLEtBQStDLE1BQU0sSUFBSSxDQUFDLEtBQUssRUFBTCxDQUFRLElBQVIsQ0FBYSxJQUFiLEVBQW1CLENBQW5CLENBQVgsQ0FBbkQsRUFBc0Y7QUFDdEYsT0FBRyxDQUFILElBQVEsQ0FBUjtBQUNBLE9BQUcsQ0FBSCxJQUFRLENBQVI7QUFDQSxRQUFJLElBQUksRUFBUixFQUFZLEtBQUssQ0FBTDtBQUNaLFFBQUksSUFBSSxFQUFSLEVBQVksS0FBSyxDQUFMO0FBQ1osUUFBSSxJQUFJLEVBQVIsRUFBWSxLQUFLLENBQUw7QUFDWixRQUFJLElBQUksRUFBUixFQUFZLEtBQUssQ0FBTDtBQUNiOztBQUVEO0FBQ0EsTUFBSSxLQUFLLEVBQUwsSUFBVyxLQUFLLEVBQXBCLEVBQXdCLE9BQU8sSUFBUDs7QUFFeEI7QUFDQSxPQUFLLEtBQUwsQ0FBVyxFQUFYLEVBQWUsRUFBZixFQUFtQixLQUFuQixDQUF5QixFQUF6QixFQUE2QixFQUE3Qjs7QUFFQTtBQUNBLE9BQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixFQUFFLENBQXJCLEVBQXdCO0FBQ3RCLFFBQUksSUFBSixFQUFVLEdBQUcsQ0FBSCxDQUFWLEVBQWlCLEdBQUcsQ0FBSCxDQUFqQixFQUF3QixLQUFLLENBQUwsQ0FBeEI7QUFDRDs7QUFFRCxTQUFPLElBQVA7QUFDRDs7Ozs7Ozs7O2tCQ25GYyxVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDNUIsTUFBSSxNQUFNLElBQUksQ0FBQyxDQUFYLEtBQWlCLE1BQU0sSUFBSSxDQUFDLENBQVgsQ0FBckIsRUFBb0MsT0FBTyxJQUFQLENBRFIsQ0FDcUI7O0FBRWpELE1BQUksS0FBSyxLQUFLLEdBQWQ7QUFBQSxNQUNJLEtBQUssS0FBSyxHQURkO0FBQUEsTUFFSSxLQUFLLEtBQUssR0FGZDtBQUFBLE1BR0ksS0FBSyxLQUFLLEdBSGQ7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsTUFBSSxNQUFNLEVBQU4sQ0FBSixFQUFlO0FBQ2IsU0FBSyxDQUFDLEtBQUssS0FBSyxLQUFMLENBQVcsQ0FBWCxDQUFOLElBQXVCLENBQTVCO0FBQ0EsU0FBSyxDQUFDLEtBQUssS0FBSyxLQUFMLENBQVcsQ0FBWCxDQUFOLElBQXVCLENBQTVCO0FBQ0Q7O0FBRUQ7QUFMQSxPQU1LO0FBQ0gsVUFBSSxJQUFJLEtBQUssRUFBTCxJQUFXLENBQW5CO0FBQUEsVUFDSSxPQUFPLEtBQUssS0FEaEI7QUFBQSxVQUVJLE1BRko7QUFBQSxVQUdJLENBSEo7O0FBS0EsYUFBTyxLQUFLLENBQUwsSUFBVSxLQUFLLEVBQWYsSUFBcUIsS0FBSyxDQUExQixJQUErQixLQUFLLEVBQTNDLEVBQStDO0FBQzdDLFlBQUksQ0FBQyxJQUFJLEVBQUwsS0FBWSxDQUFaLEdBQWlCLElBQUksRUFBekI7QUFDQSxpQkFBUyxJQUFJLEtBQUosQ0FBVSxDQUFWLENBQVQsRUFBdUIsT0FBTyxDQUFQLElBQVksSUFBbkMsRUFBeUMsT0FBTyxNQUFoRCxFQUF3RCxLQUFLLENBQTdEO0FBQ0EsZ0JBQVEsQ0FBUjtBQUNFLGVBQUssQ0FBTDtBQUFRLGlCQUFLLEtBQUssQ0FBVixFQUFhLEtBQUssS0FBSyxDQUF2QixDQUEwQjtBQUNsQyxlQUFLLENBQUw7QUFBUSxpQkFBSyxLQUFLLENBQVYsRUFBYSxLQUFLLEtBQUssQ0FBdkIsQ0FBMEI7QUFDbEMsZUFBSyxDQUFMO0FBQVEsaUJBQUssS0FBSyxDQUFWLEVBQWEsS0FBSyxLQUFLLENBQXZCLENBQTBCO0FBQ2xDLGVBQUssQ0FBTDtBQUFRLGlCQUFLLEtBQUssQ0FBVixFQUFhLEtBQUssS0FBSyxDQUF2QixDQUEwQjtBQUpwQztBQU1EOztBQUVELFVBQUksS0FBSyxLQUFMLElBQWMsS0FBSyxLQUFMLENBQVcsTUFBN0IsRUFBcUMsS0FBSyxLQUFMLEdBQWEsSUFBYjtBQUN0Qzs7QUFFRCxPQUFLLEdBQUwsR0FBVyxFQUFYO0FBQ0EsT0FBSyxHQUFMLEdBQVcsRUFBWDtBQUNBLE9BQUssR0FBTCxHQUFXLEVBQVg7QUFDQSxPQUFLLEdBQUwsR0FBVyxFQUFYO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQzs7Ozs7Ozs7O2tCQzFDYyxZQUFXO0FBQ3hCLE1BQUksT0FBTyxFQUFYO0FBQ0EsT0FBSyxLQUFMLENBQVcsVUFBUyxJQUFULEVBQWU7QUFDeEIsUUFBSSxDQUFDLEtBQUssTUFBVixFQUFrQjtBQUFHLFdBQUssSUFBTCxDQUFVLEtBQUssSUFBZjtBQUFILGFBQWdDLE9BQU8sS0FBSyxJQUE1QztBQUNuQixHQUZEO0FBR0EsU0FBTyxJQUFQO0FBQ0QsQzs7Ozs7Ozs7O2tCQ05jLFVBQVMsQ0FBVCxFQUFZO0FBQ3pCLFdBQU8sVUFBVSxNQUFWLEdBQ0QsS0FBSyxLQUFMLENBQVcsQ0FBQyxFQUFFLENBQUYsRUFBSyxDQUFMLENBQVosRUFBcUIsQ0FBQyxFQUFFLENBQUYsRUFBSyxDQUFMLENBQXRCLEVBQStCLEtBQS9CLENBQXFDLENBQUMsRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUF0QyxFQUErQyxDQUFDLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBaEQsQ0FEQyxHQUVELE1BQU0sS0FBSyxHQUFYLElBQWtCLFNBQWxCLEdBQThCLENBQUMsQ0FBQyxLQUFLLEdBQU4sRUFBVyxLQUFLLEdBQWhCLENBQUQsRUFBdUIsQ0FBQyxLQUFLLEdBQU4sRUFBVyxLQUFLLEdBQWhCLENBQXZCLENBRnBDO0FBR0QsQzs7Ozs7Ozs7O2tCQ0ZjLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZSxNQUFmLEVBQXVCO0FBQ3BDLE1BQUksSUFBSjtBQUFBLE1BQ0ksS0FBSyxLQUFLLEdBRGQ7QUFBQSxNQUVJLEtBQUssS0FBSyxHQUZkO0FBQUEsTUFHSSxFQUhKO0FBQUEsTUFJSSxFQUpKO0FBQUEsTUFLSSxFQUxKO0FBQUEsTUFNSSxFQU5KO0FBQUEsTUFPSSxLQUFLLEtBQUssR0FQZDtBQUFBLE1BUUksS0FBSyxLQUFLLEdBUmQ7QUFBQSxNQVNJLFFBQVEsRUFUWjtBQUFBLE1BVUksT0FBTyxLQUFLLEtBVmhCO0FBQUEsTUFXSSxDQVhKO0FBQUEsTUFZSSxDQVpKOztBQWNBLE1BQUksSUFBSixFQUFVLE1BQU0sSUFBTixDQUFXLElBQUksY0FBSixDQUFTLElBQVQsRUFBZSxFQUFmLEVBQW1CLEVBQW5CLEVBQXVCLEVBQXZCLEVBQTJCLEVBQTNCLENBQVg7QUFDVixNQUFJLFVBQVUsSUFBZCxFQUFvQixTQUFTLFFBQVQsQ0FBcEIsS0FDSztBQUNILFNBQUssSUFBSSxNQUFULEVBQWlCLEtBQUssSUFBSSxNQUExQjtBQUNBLFNBQUssSUFBSSxNQUFULEVBQWlCLEtBQUssSUFBSSxNQUExQjtBQUNBLGNBQVUsTUFBVjtBQUNEOztBQUVELFNBQU8sSUFBSSxNQUFNLEdBQU4sRUFBWCxFQUF3Qjs7QUFFdEI7QUFDQSxRQUFJLEVBQUUsT0FBTyxFQUFFLElBQVgsS0FDRyxDQUFDLEtBQUssRUFBRSxFQUFSLElBQWMsRUFEakIsSUFFRyxDQUFDLEtBQUssRUFBRSxFQUFSLElBQWMsRUFGakIsSUFHRyxDQUFDLEtBQUssRUFBRSxFQUFSLElBQWMsRUFIakIsSUFJRyxDQUFDLEtBQUssRUFBRSxFQUFSLElBQWMsRUFKckIsRUFJeUI7O0FBRXpCO0FBQ0EsUUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDZixVQUFJLEtBQUssQ0FBQyxLQUFLLEVBQU4sSUFBWSxDQUFyQjtBQUFBLFVBQ0ksS0FBSyxDQUFDLEtBQUssRUFBTixJQUFZLENBRHJCOztBQUdBLFlBQU0sSUFBTixDQUNFLElBQUksY0FBSixDQUFTLEtBQUssQ0FBTCxDQUFULEVBQWtCLEVBQWxCLEVBQXNCLEVBQXRCLEVBQTBCLEVBQTFCLEVBQThCLEVBQTlCLENBREYsRUFFRSxJQUFJLGNBQUosQ0FBUyxLQUFLLENBQUwsQ0FBVCxFQUFrQixFQUFsQixFQUFzQixFQUF0QixFQUEwQixFQUExQixFQUE4QixFQUE5QixDQUZGLEVBR0UsSUFBSSxjQUFKLENBQVMsS0FBSyxDQUFMLENBQVQsRUFBa0IsRUFBbEIsRUFBc0IsRUFBdEIsRUFBMEIsRUFBMUIsRUFBOEIsRUFBOUIsQ0FIRixFQUlFLElBQUksY0FBSixDQUFTLEtBQUssQ0FBTCxDQUFULEVBQWtCLEVBQWxCLEVBQXNCLEVBQXRCLEVBQTBCLEVBQTFCLEVBQThCLEVBQTlCLENBSkY7O0FBT0E7QUFDQSxVQUFJLElBQUksQ0FBQyxLQUFLLEVBQU4sS0FBYSxDQUFiLEdBQWtCLEtBQUssRUFBL0IsRUFBb0M7QUFDbEMsWUFBSSxNQUFNLE1BQU0sTUFBTixHQUFlLENBQXJCLENBQUo7QUFDQSxjQUFNLE1BQU0sTUFBTixHQUFlLENBQXJCLElBQTBCLE1BQU0sTUFBTSxNQUFOLEdBQWUsQ0FBZixHQUFtQixDQUF6QixDQUExQjtBQUNBLGNBQU0sTUFBTSxNQUFOLEdBQWUsQ0FBZixHQUFtQixDQUF6QixJQUE4QixDQUE5QjtBQUNEO0FBQ0Y7O0FBRUQ7QUFuQkEsU0FvQks7QUFDSCxZQUFJLEtBQUssSUFBSSxDQUFDLEtBQUssRUFBTCxDQUFRLElBQVIsQ0FBYSxJQUFiLEVBQW1CLEtBQUssSUFBeEIsQ0FBZDtBQUFBLFlBQ0ksS0FBSyxJQUFJLENBQUMsS0FBSyxFQUFMLENBQVEsSUFBUixDQUFhLElBQWIsRUFBbUIsS0FBSyxJQUF4QixDQURkO0FBQUEsWUFFSSxLQUFLLEtBQUssRUFBTCxHQUFVLEtBQUssRUFGeEI7QUFHQSxZQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNmLGNBQUksSUFBSSxLQUFLLElBQUwsQ0FBVSxTQUFTLEVBQW5CLENBQVI7QUFDQSxlQUFLLElBQUksQ0FBVCxFQUFZLEtBQUssSUFBSSxDQUFyQjtBQUNBLGVBQUssSUFBSSxDQUFULEVBQVksS0FBSyxJQUFJLENBQXJCO0FBQ0EsaUJBQU8sS0FBSyxJQUFaO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQU8sSUFBUDtBQUNELEM7O0FBckVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7NkNDQVEsTzs7Ozs7Ozs7Ozs7OztrQkNBTyxVQUFTLElBQVQsRUFBZSxFQUFmLEVBQW1CLEVBQW5CLEVBQXVCLEVBQXZCLEVBQTJCLEVBQTNCLEVBQStCO0FBQzVDLE9BQUssSUFBTCxHQUFZLElBQVo7QUFDQSxPQUFLLEVBQUwsR0FBVSxFQUFWO0FBQ0EsT0FBSyxFQUFMLEdBQVUsRUFBVjtBQUNBLE9BQUssRUFBTCxHQUFVLEVBQVY7QUFDQSxPQUFLLEVBQUwsR0FBVSxFQUFWO0FBQ0QsQzs7Ozs7Ozs7a0JDT3VCLFE7O0FBYnhCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRWUsU0FBUyxRQUFULENBQWtCLEtBQWxCLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCO0FBQzVDLE1BQUksT0FBTyxJQUFJLFFBQUosQ0FBYSxLQUFLLElBQUwsR0FBWSxXQUFaLEdBQXVCLENBQXBDLEVBQXVDLEtBQUssSUFBTCxHQUFZLFdBQVosR0FBdUIsQ0FBOUQsRUFBaUUsR0FBakUsRUFBc0UsR0FBdEUsRUFBMkUsR0FBM0UsRUFBZ0YsR0FBaEYsQ0FBWDtBQUNBLFNBQU8sU0FBUyxJQUFULEdBQWdCLElBQWhCLEdBQXVCLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBOUI7QUFDRDs7QUFFRCxTQUFTLFFBQVQsQ0FBa0IsQ0FBbEIsRUFBcUIsQ0FBckIsRUFBd0IsRUFBeEIsRUFBNEIsRUFBNUIsRUFBZ0MsRUFBaEMsRUFBb0MsRUFBcEMsRUFBd0M7QUFDdEMsT0FBSyxFQUFMLEdBQVUsQ0FBVjtBQUNBLE9BQUssRUFBTCxHQUFVLENBQVY7QUFDQSxPQUFLLEdBQUwsR0FBVyxFQUFYO0FBQ0EsT0FBSyxHQUFMLEdBQVcsRUFBWDtBQUNBLE9BQUssR0FBTCxHQUFXLEVBQVg7QUFDQSxPQUFLLEdBQUwsR0FBVyxFQUFYO0FBQ0EsT0FBSyxLQUFMLEdBQWEsU0FBYjtBQUNEOztBQUVELFNBQVMsU0FBVCxDQUFtQixJQUFuQixFQUF5QjtBQUN2QixNQUFJLE9BQU8sRUFBQyxNQUFNLEtBQUssSUFBWixFQUFYO0FBQUEsTUFBOEIsT0FBTyxJQUFyQztBQUNBLFNBQU8sT0FBTyxLQUFLLElBQW5CO0FBQXlCLFdBQU8sS0FBSyxJQUFMLEdBQVksRUFBQyxNQUFNLEtBQUssSUFBWixFQUFuQjtBQUF6QixHQUNBLE9BQU8sSUFBUDtBQUNEOztBQUVELElBQUksWUFBWSxTQUFTLFNBQVQsR0FBcUIsU0FBUyxTQUE5Qzs7QUFFQSxVQUFVLElBQVYsR0FBaUIsWUFBVztBQUMxQixNQUFJLE9BQU8sSUFBSSxRQUFKLENBQWEsS0FBSyxFQUFsQixFQUFzQixLQUFLLEVBQTNCLEVBQStCLEtBQUssR0FBcEMsRUFBeUMsS0FBSyxHQUE5QyxFQUFtRCxLQUFLLEdBQXhELEVBQTZELEtBQUssR0FBbEUsQ0FBWDtBQUFBLE1BQ0ksT0FBTyxLQUFLLEtBRGhCO0FBQUEsTUFFSSxLQUZKO0FBQUEsTUFHSSxLQUhKOztBQUtBLE1BQUksQ0FBQyxJQUFMLEVBQVcsT0FBTyxJQUFQOztBQUVYLE1BQUksQ0FBQyxLQUFLLE1BQVYsRUFBa0IsT0FBTyxLQUFLLEtBQUwsR0FBYSxVQUFVLElBQVYsQ0FBYixFQUE4QixJQUFyQzs7QUFFbEIsVUFBUSxDQUFDLEVBQUMsUUFBUSxJQUFULEVBQWUsUUFBUSxLQUFLLEtBQUwsR0FBYSxJQUFJLEtBQUosQ0FBVSxDQUFWLENBQXBDLEVBQUQsQ0FBUjtBQUNBLFNBQU8sT0FBTyxNQUFNLEdBQU4sRUFBZCxFQUEyQjtBQUN6QixTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsRUFBRSxDQUF6QixFQUE0QjtBQUMxQixVQUFJLFFBQVEsS0FBSyxNQUFMLENBQVksQ0FBWixDQUFaLEVBQTRCO0FBQzFCLFlBQUksTUFBTSxNQUFWLEVBQWtCLE1BQU0sSUFBTixDQUFXLEVBQUMsUUFBUSxLQUFULEVBQWdCLFFBQVEsS0FBSyxNQUFMLENBQVksQ0FBWixJQUFpQixJQUFJLEtBQUosQ0FBVSxDQUFWLENBQXpDLEVBQVgsRUFBbEIsS0FDSyxLQUFLLE1BQUwsQ0FBWSxDQUFaLElBQWlCLFVBQVUsS0FBVixDQUFqQjtBQUNOO0FBQ0Y7QUFDRjs7QUFFRCxTQUFPLElBQVA7QUFDRCxDQXJCRDs7QUF1QkEsVUFBVSxHQUFWLEdBQWdCLGFBQWhCO0FBQ0EsVUFBVSxNQUFWLEdBQW1CLFdBQW5CO0FBQ0EsVUFBVSxLQUFWLEdBQWtCLGVBQWxCO0FBQ0EsVUFBVSxJQUFWLEdBQWlCLGNBQWpCO0FBQ0EsVUFBVSxNQUFWLEdBQW1CLGdCQUFuQjtBQUNBLFVBQVUsSUFBVixHQUFpQixjQUFqQjtBQUNBLFVBQVUsTUFBVixHQUFtQixnQkFBbkI7QUFDQSxVQUFVLFNBQVYsR0FBc0IsaUJBQXRCO0FBQ0EsVUFBVSxJQUFWLEdBQWlCLGNBQWpCO0FBQ0EsVUFBVSxJQUFWLEdBQWlCLGNBQWpCO0FBQ0EsVUFBVSxLQUFWLEdBQWtCLGVBQWxCO0FBQ0EsVUFBVSxVQUFWLEdBQXVCLG9CQUF2QjtBQUNBLFVBQVUsQ0FBVixHQUFjLFdBQWQ7QUFDQSxVQUFVLENBQVYsR0FBYyxXQUFkOzs7Ozs7Ozs7a0JDeEVlLFVBQVMsQ0FBVCxFQUFZO0FBQ3pCLE1BQUksTUFBTSxJQUFJLENBQUMsS0FBSyxFQUFMLENBQVEsSUFBUixDQUFhLElBQWIsRUFBbUIsQ0FBbkIsQ0FBWCxLQUFxQyxNQUFNLElBQUksQ0FBQyxLQUFLLEVBQUwsQ0FBUSxJQUFSLENBQWEsSUFBYixFQUFtQixDQUFuQixDQUFYLENBQXpDLEVBQTRFLE9BQU8sSUFBUCxDQURuRCxDQUNnRTs7QUFFekYsTUFBSSxNQUFKO0FBQUEsTUFDSSxPQUFPLEtBQUssS0FEaEI7QUFBQSxNQUVJLFFBRko7QUFBQSxNQUdJLFFBSEo7QUFBQSxNQUlJLElBSko7QUFBQSxNQUtJLEtBQUssS0FBSyxHQUxkO0FBQUEsTUFNSSxLQUFLLEtBQUssR0FOZDtBQUFBLE1BT0ksS0FBSyxLQUFLLEdBUGQ7QUFBQSxNQVFJLEtBQUssS0FBSyxHQVJkO0FBQUEsTUFTSSxDQVRKO0FBQUEsTUFVSSxDQVZKO0FBQUEsTUFXSSxFQVhKO0FBQUEsTUFZSSxFQVpKO0FBQUEsTUFhSSxLQWJKO0FBQUEsTUFjSSxNQWRKO0FBQUEsTUFlSSxDQWZKO0FBQUEsTUFnQkksQ0FoQko7O0FBa0JBO0FBQ0EsTUFBSSxDQUFDLElBQUwsRUFBVyxPQUFPLElBQVA7O0FBRVg7QUFDQTtBQUNBLE1BQUksS0FBSyxNQUFULEVBQWlCLE9BQU8sSUFBUCxFQUFhO0FBQzVCLFFBQUksUUFBUSxNQUFNLEtBQUssQ0FBQyxLQUFLLEVBQU4sSUFBWSxDQUF2QixDQUFaLEVBQXVDLEtBQUssRUFBTCxDQUF2QyxLQUFxRCxLQUFLLEVBQUw7QUFDckQsUUFBSSxTQUFTLE1BQU0sS0FBSyxDQUFDLEtBQUssRUFBTixJQUFZLENBQXZCLENBQWIsRUFBd0MsS0FBSyxFQUFMLENBQXhDLEtBQXNELEtBQUssRUFBTDtBQUN0RCxRQUFJLEVBQUUsU0FBUyxJQUFULEVBQWUsT0FBTyxLQUFLLElBQUksVUFBVSxDQUFWLEdBQWMsS0FBdkIsQ0FBeEIsQ0FBSixFQUE0RCxPQUFPLElBQVA7QUFDNUQsUUFBSSxDQUFDLEtBQUssTUFBVixFQUFrQjtBQUNsQixRQUFJLE9BQVEsSUFBSSxDQUFMLEdBQVUsQ0FBakIsS0FBdUIsT0FBUSxJQUFJLENBQUwsR0FBVSxDQUFqQixDQUF2QixJQUE4QyxPQUFRLElBQUksQ0FBTCxHQUFVLENBQWpCLENBQWxELEVBQXVFLFdBQVcsTUFBWCxFQUFtQixJQUFJLENBQXZCO0FBQ3hFOztBQUVEO0FBQ0EsU0FBTyxLQUFLLElBQUwsS0FBYyxDQUFyQjtBQUF3QixRQUFJLEVBQUUsV0FBVyxJQUFYLEVBQWlCLE9BQU8sS0FBSyxJQUEvQixDQUFKLEVBQTBDLE9BQU8sSUFBUDtBQUFsRSxHQUNBLElBQUksT0FBTyxLQUFLLElBQWhCLEVBQXNCLE9BQU8sS0FBSyxJQUFaOztBQUV0QjtBQUNBLE1BQUksUUFBSixFQUFjLE9BQVEsT0FBTyxTQUFTLElBQVQsR0FBZ0IsSUFBdkIsR0FBOEIsT0FBTyxTQUFTLElBQS9DLEVBQXNELElBQTdEOztBQUVkO0FBQ0EsTUFBSSxDQUFDLE1BQUwsRUFBYSxPQUFPLEtBQUssS0FBTCxHQUFhLElBQWIsRUFBbUIsSUFBMUI7O0FBRWI7QUFDQSxTQUFPLE9BQU8sQ0FBUCxJQUFZLElBQW5CLEdBQTBCLE9BQU8sT0FBTyxDQUFQLENBQWpDOztBQUVBO0FBQ0EsTUFBSSxDQUFDLE9BQU8sT0FBTyxDQUFQLEtBQWEsT0FBTyxDQUFQLENBQWIsSUFBMEIsT0FBTyxDQUFQLENBQTFCLElBQXVDLE9BQU8sQ0FBUCxDQUEvQyxLQUNHLFVBQVUsT0FBTyxDQUFQLEtBQWEsT0FBTyxDQUFQLENBQWIsSUFBMEIsT0FBTyxDQUFQLENBQTFCLElBQXVDLE9BQU8sQ0FBUCxDQUFqRCxDQURILElBRUcsQ0FBQyxLQUFLLE1BRmIsRUFFcUI7QUFDbkIsUUFBSSxRQUFKLEVBQWMsU0FBUyxDQUFULElBQWMsSUFBZCxDQUFkLEtBQ0ssS0FBSyxLQUFMLEdBQWEsSUFBYjtBQUNOOztBQUVELFNBQU8sSUFBUDtBQUNELEM7O1FBRWUsUyxHQUFBLFM7QUFBVCxTQUFTLFNBQVQsQ0FBbUIsSUFBbkIsRUFBeUI7QUFDOUIsT0FBSyxJQUFJLElBQUksQ0FBUixFQUFXLElBQUksS0FBSyxNQUF6QixFQUFpQyxJQUFJLENBQXJDLEVBQXdDLEVBQUUsQ0FBMUM7QUFBNkMsU0FBSyxNQUFMLENBQVksS0FBSyxDQUFMLENBQVo7QUFBN0MsR0FDQSxPQUFPLElBQVA7QUFDRDs7Ozs7Ozs7O2tCQzdEYyxZQUFXO0FBQ3hCLFNBQU8sS0FBSyxLQUFaO0FBQ0QsQzs7Ozs7Ozs7O2tCQ0ZjLFlBQVc7QUFDeEIsTUFBSSxPQUFPLENBQVg7QUFDQSxPQUFLLEtBQUwsQ0FBVyxVQUFTLElBQVQsRUFBZTtBQUN4QixRQUFJLENBQUMsS0FBSyxNQUFWLEVBQWtCO0FBQUcsUUFBRSxJQUFGO0FBQUgsYUFBa0IsT0FBTyxLQUFLLElBQTlCO0FBQ25CLEdBRkQ7QUFHQSxTQUFPLElBQVA7QUFDRCxDOzs7Ozs7Ozs7a0JDSmMsVUFBUyxRQUFULEVBQW1CO0FBQ2hDLE1BQUksUUFBUSxFQUFaO0FBQUEsTUFBZ0IsQ0FBaEI7QUFBQSxNQUFtQixPQUFPLEtBQUssS0FBL0I7QUFBQSxNQUFzQyxLQUF0QztBQUFBLE1BQTZDLEVBQTdDO0FBQUEsTUFBaUQsRUFBakQ7QUFBQSxNQUFxRCxFQUFyRDtBQUFBLE1BQXlELEVBQXpEO0FBQ0EsTUFBSSxJQUFKLEVBQVUsTUFBTSxJQUFOLENBQVcsSUFBSSxjQUFKLENBQVMsSUFBVCxFQUFlLEtBQUssR0FBcEIsRUFBeUIsS0FBSyxHQUE5QixFQUFtQyxLQUFLLEdBQXhDLEVBQTZDLEtBQUssR0FBbEQsQ0FBWDtBQUNWLFNBQU8sSUFBSSxNQUFNLEdBQU4sRUFBWCxFQUF3QjtBQUN0QixRQUFJLENBQUMsU0FBUyxPQUFPLEVBQUUsSUFBbEIsRUFBd0IsS0FBSyxFQUFFLEVBQS9CLEVBQW1DLEtBQUssRUFBRSxFQUExQyxFQUE4QyxLQUFLLEVBQUUsRUFBckQsRUFBeUQsS0FBSyxFQUFFLEVBQWhFLENBQUQsSUFBd0UsS0FBSyxNQUFqRixFQUF5RjtBQUN2RixVQUFJLEtBQUssQ0FBQyxLQUFLLEVBQU4sSUFBWSxDQUFyQjtBQUFBLFVBQXdCLEtBQUssQ0FBQyxLQUFLLEVBQU4sSUFBWSxDQUF6QztBQUNBLFVBQUksUUFBUSxLQUFLLENBQUwsQ0FBWixFQUFxQixNQUFNLElBQU4sQ0FBVyxJQUFJLGNBQUosQ0FBUyxLQUFULEVBQWdCLEVBQWhCLEVBQW9CLEVBQXBCLEVBQXdCLEVBQXhCLEVBQTRCLEVBQTVCLENBQVg7QUFDckIsVUFBSSxRQUFRLEtBQUssQ0FBTCxDQUFaLEVBQXFCLE1BQU0sSUFBTixDQUFXLElBQUksY0FBSixDQUFTLEtBQVQsRUFBZ0IsRUFBaEIsRUFBb0IsRUFBcEIsRUFBd0IsRUFBeEIsRUFBNEIsRUFBNUIsQ0FBWDtBQUNyQixVQUFJLFFBQVEsS0FBSyxDQUFMLENBQVosRUFBcUIsTUFBTSxJQUFOLENBQVcsSUFBSSxjQUFKLENBQVMsS0FBVCxFQUFnQixFQUFoQixFQUFvQixFQUFwQixFQUF3QixFQUF4QixFQUE0QixFQUE1QixDQUFYO0FBQ3JCLFVBQUksUUFBUSxLQUFLLENBQUwsQ0FBWixFQUFxQixNQUFNLElBQU4sQ0FBVyxJQUFJLGNBQUosQ0FBUyxLQUFULEVBQWdCLEVBQWhCLEVBQW9CLEVBQXBCLEVBQXdCLEVBQXhCLEVBQTRCLEVBQTVCLENBQVg7QUFDdEI7QUFDRjtBQUNELFNBQU8sSUFBUDtBQUNELEM7O0FBZkQ7Ozs7Ozs7Ozs7Ozs7a0JDRWUsVUFBUyxRQUFULEVBQW1CO0FBQ2hDLE1BQUksUUFBUSxFQUFaO0FBQUEsTUFBZ0IsT0FBTyxFQUF2QjtBQUFBLE1BQTJCLENBQTNCO0FBQ0EsTUFBSSxLQUFLLEtBQVQsRUFBZ0IsTUFBTSxJQUFOLENBQVcsSUFBSSxjQUFKLENBQVMsS0FBSyxLQUFkLEVBQXFCLEtBQUssR0FBMUIsRUFBK0IsS0FBSyxHQUFwQyxFQUF5QyxLQUFLLEdBQTlDLEVBQW1ELEtBQUssR0FBeEQsQ0FBWDtBQUNoQixTQUFPLElBQUksTUFBTSxHQUFOLEVBQVgsRUFBd0I7QUFDdEIsUUFBSSxPQUFPLEVBQUUsSUFBYjtBQUNBLFFBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2YsVUFBSSxLQUFKO0FBQUEsVUFBVyxLQUFLLEVBQUUsRUFBbEI7QUFBQSxVQUFzQixLQUFLLEVBQUUsRUFBN0I7QUFBQSxVQUFpQyxLQUFLLEVBQUUsRUFBeEM7QUFBQSxVQUE0QyxLQUFLLEVBQUUsRUFBbkQ7QUFBQSxVQUF1RCxLQUFLLENBQUMsS0FBSyxFQUFOLElBQVksQ0FBeEU7QUFBQSxVQUEyRSxLQUFLLENBQUMsS0FBSyxFQUFOLElBQVksQ0FBNUY7QUFDQSxVQUFJLFFBQVEsS0FBSyxDQUFMLENBQVosRUFBcUIsTUFBTSxJQUFOLENBQVcsSUFBSSxjQUFKLENBQVMsS0FBVCxFQUFnQixFQUFoQixFQUFvQixFQUFwQixFQUF3QixFQUF4QixFQUE0QixFQUE1QixDQUFYO0FBQ3JCLFVBQUksUUFBUSxLQUFLLENBQUwsQ0FBWixFQUFxQixNQUFNLElBQU4sQ0FBVyxJQUFJLGNBQUosQ0FBUyxLQUFULEVBQWdCLEVBQWhCLEVBQW9CLEVBQXBCLEVBQXdCLEVBQXhCLEVBQTRCLEVBQTVCLENBQVg7QUFDckIsVUFBSSxRQUFRLEtBQUssQ0FBTCxDQUFaLEVBQXFCLE1BQU0sSUFBTixDQUFXLElBQUksY0FBSixDQUFTLEtBQVQsRUFBZ0IsRUFBaEIsRUFBb0IsRUFBcEIsRUFBd0IsRUFBeEIsRUFBNEIsRUFBNUIsQ0FBWDtBQUNyQixVQUFJLFFBQVEsS0FBSyxDQUFMLENBQVosRUFBcUIsTUFBTSxJQUFOLENBQVcsSUFBSSxjQUFKLENBQVMsS0FBVCxFQUFnQixFQUFoQixFQUFvQixFQUFwQixFQUF3QixFQUF4QixFQUE0QixFQUE1QixDQUFYO0FBQ3RCO0FBQ0QsU0FBSyxJQUFMLENBQVUsQ0FBVjtBQUNEO0FBQ0QsU0FBTyxJQUFJLEtBQUssR0FBTCxFQUFYLEVBQXVCO0FBQ3JCLGFBQVMsRUFBRSxJQUFYLEVBQWlCLEVBQUUsRUFBbkIsRUFBdUIsRUFBRSxFQUF6QixFQUE2QixFQUFFLEVBQS9CLEVBQW1DLEVBQUUsRUFBckM7QUFDRDtBQUNELFNBQU8sSUFBUDtBQUNELEM7O0FBcEJEOzs7Ozs7Ozs7Ozs7UUNBZ0IsUSxHQUFBLFE7O2tCQUlELFVBQVMsQ0FBVCxFQUFZO0FBQ3pCLFNBQU8sVUFBVSxNQUFWLElBQW9CLEtBQUssRUFBTCxHQUFVLENBQVYsRUFBYSxJQUFqQyxJQUF5QyxLQUFLLEVBQXJEO0FBQ0QsQzs7QUFOTSxTQUFTLFFBQVQsQ0FBa0IsQ0FBbEIsRUFBcUI7QUFDMUIsU0FBTyxFQUFFLENBQUYsQ0FBUDtBQUNEOzs7Ozs7OztRQ0ZlLFEsR0FBQSxROztrQkFJRCxVQUFTLENBQVQsRUFBWTtBQUN6QixTQUFPLFVBQVUsTUFBVixJQUFvQixLQUFLLEVBQUwsR0FBVSxDQUFWLEVBQWEsSUFBakMsSUFBeUMsS0FBSyxFQUFyRDtBQUNELEM7O0FBTk0sU0FBUyxRQUFULENBQWtCLENBQWxCLEVBQXFCO0FBQzFCLFNBQU8sRUFBRSxDQUFGLENBQVA7QUFDRDs7O0FDRkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3AxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2tCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbDJVQTs7OztBQUVBLElBQU0sVUFBVSxRQUFRLFdBQVIsQ0FBaEI7QUFDQSxJQUFNLE9BQU8sUUFBUSxnQkFBUixDQUFiO0FBQ0EsSUFBTSxnQkFBZ0IsUUFBUSxZQUFSLENBQXRCO0FBQ0EsSUFBTSxhQUFhLFFBQVEsVUFBUixDQUFuQjtBQUNBLElBQU0sY0FBYyxRQUFRLFdBQVIsQ0FBcEI7QUFDQSxJQUFNLE9BQU8sUUFBUSxTQUFSLENBQWI7O0FBRUEsSUFBTSxTQUFTLFFBQVEsU0FBUixFQUFtQixPQUFsQzs7QUFFQSxJQUFNLFNBQVMsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBQWY7QUFDQSxTQUFTLElBQVQsQ0FBYyxXQUFkLENBQTBCLE1BQTFCOztBQUVBLElBQU0sS0FBSyxPQUFPLFVBQVAsQ0FBa0IsT0FBbEIsQ0FBWDtBQUNBLElBQU0sU0FBUyxXQUFXLEVBQVgsQ0FBZjs7QUFFQSxJQUFNLFFBQVEsY0FBYyxFQUFkLENBQWQ7QUFDQSxNQUFNLElBQU47O0FBRUE7QUFDQSxJQUFJLGNBQUo7QUFDQSxJQUFJLGNBQUo7O0FBRUE7QUFDQSxJQUFJLGNBQUo7QUFDQSxJQUFJLG1CQUFKOztBQUVBLFFBQVEsU0FBUixFQUFtQixpQkFBbkIsRUFDRyxJQURILENBQ1EsVUFBQyxHQUFELEVBQVM7QUFDYixVQUFRLElBQUksS0FBWjtBQUNBLFVBQVEsSUFBSSxLQUFaO0FBQ0EsVUFBUSxJQUFJLFFBQVo7QUFDQTtBQUNELENBTkg7O0FBUUEsU0FBUyxJQUFULEdBQWU7QUFDYjtBQUNBLG9CQUFrQixFQUFDLFNBQVMsbUJBQVYsRUFBK0IsV0FBVyxFQUExQyxFQUFsQjs7QUFFQSxlQUFhLFlBQVksRUFBWixFQUFnQixLQUFoQixFQUF1QixLQUF2QixFQUE4QixLQUE5QixFQUFxQyxNQUFyQyxDQUFiOztBQUVBO0FBQ0Esb0JBQWtCLEVBQUMsU0FBUyxtQkFBVixFQUErQixXQUFXLEdBQTFDLEVBQWxCOztBQUVBLFdBQVMsY0FBVCxDQUF3QixTQUF4QixFQUFtQyxLQUFuQyxDQUF5QyxPQUF6QyxHQUFtRCxNQUFuRDtBQUNBO0FBQ0EsUUFBTSxTQUFOLENBQWdCLEtBQWhCLEVBQXVCLEtBQXZCLEVBQThCO0FBQzNCLFdBQU8sT0FBTyxPQURhO0FBRTNCLFVBQU0sR0FBRyxLQUZrQjtBQUczQixXQUFPO0FBSG9CLEdBQTlCOztBQU1BO0FBQ0EsUUFBTSxJQUFOO0FBQ0Q7O0FBRUQsU0FBUyxpQkFBVCxDQUEyQixRQUEzQixFQUFxQztBQUNuQyxNQUFJLE1BQU0sU0FBUyxPQUFuQjtBQUNBLE1BQUksTUFBTSxTQUFTLFNBQW5CO0FBQ0EsVUFBUSxHQUFSLENBQVksR0FBWjtBQUNBLFdBQVMsY0FBVCxDQUF3QixVQUF4QixFQUFvQyxTQUFwQyxHQUFtRCxHQUFuRCxVQUEyRCxHQUEzRDtBQUNEOztBQUVELFNBQVMsY0FBVCxHQUEwQjtBQUN4QixTQUFPLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDLFlBQWxDO0FBQ0EsU0FBTyxnQkFBUCxDQUF3QixXQUF4QixFQUFxQyxlQUFyQztBQUNBLFNBQU8sZ0JBQVAsQ0FBd0IsT0FBeEIsRUFBaUMsZ0JBQWpDOztBQUVBO0FBQ0EsV0FBUyxZQUFULENBQXNCLENBQXRCLEVBQXlCO0FBQ3ZCLFVBQU0sSUFBTjtBQUNEOztBQUVELE1BQUksU0FBUyxNQUFNLE1BQW5CO0FBQ0EsTUFBSSxvQkFBb0IsTUFBTSxpQkFBOUI7QUFDQSxNQUFJLHVCQUF1QixNQUFNLG9CQUFqQztBQUNBLE1BQUksc0JBQXNCLEtBQUssTUFBTCxFQUExQjtBQUNBLE1BQUksb0JBQUo7QUFDQSxNQUFJLGlCQUFKO0FBQ0EsTUFBSSxxQkFBSjs7QUFFQSxNQUFJLFFBQVEsS0FBWjs7QUFFQSxXQUFTLGVBQVQsQ0FBeUIsQ0FBekIsRUFBNEI7QUFDMUIsTUFBRSxjQUFGO0FBQ0EsV0FBTyxnQkFBUCxDQUF3QixXQUF4QixFQUFxQyxlQUFyQztBQUNBLFdBQU8sZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUMsYUFBbkM7O0FBRUEsU0FBSyxNQUFMLENBQVksbUJBQVosRUFBaUMsaUJBQWpDOztBQUVBLGtCQUFjLE9BQU8sTUFBUCxDQUFjLEVBQWQsRUFBa0IsTUFBbEIsQ0FBZDtBQUNBLG1CQUFlLDBCQUEwQixDQUExQixDQUFmO0FBQ0EsZUFBVyxlQUNQLG1CQURPLEVBRVAsWUFGTyxDQUFYO0FBR0EsVUFBTSxJQUFOO0FBQ0Q7O0FBRUQsV0FBUyxnQkFBVCxDQUEwQixDQUExQixFQUE2QjtBQUMzQixNQUFFLGNBQUY7O0FBRDJCLGdDQUVKLDBCQUEwQixDQUExQixDQUZJO0FBQUE7QUFBQSxRQUVwQixLQUZvQjtBQUFBLFFBRWIsS0FGYTtBQUczQjs7O0FBQ0EsUUFBSSxPQUFPLEtBQUssTUFBTCxFQUFYO0FBQ0EsU0FBSyxNQUFMLENBQVksSUFBWixFQUFrQixpQkFBbEI7O0FBTDJCLDBCQU1FLGVBQ3pCLElBRHlCLEVBRXpCLENBQUMsS0FBRCxFQUFRLEtBQVIsQ0FGeUIsQ0FORjtBQUFBO0FBQUEsUUFNcEIsUUFOb0I7QUFBQSxRQU1WLFFBTlU7O0FBVTNCO0FBQ0E7OztBQUNBLFFBQU0sVUFBVSxPQUFPLElBQVAsR0FBYyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksRUFBRSxNQUFGLEdBQVcsQ0FBQyxJQUF4QixDQUE5QjtBQUNBLFdBQU8sSUFBUCxHQUFjLEtBQUssR0FBTCxDQUFTLElBQVQsRUFBZSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsT0FBZCxDQUFmLENBQWQ7O0FBRUE7O0FBRUE7QUFDQSxTQUFLLE1BQUwsQ0FBWSxJQUFaLEVBQWtCLGlCQUFsQjs7QUFsQjJCLDJCQW1CSSxlQUMzQixJQUQyQixFQUUzQixDQUFDLEtBQUQsRUFBUSxLQUFSLENBRjJCLENBbkJKO0FBQUE7QUFBQSxRQW1CcEIsU0FuQm9CO0FBQUEsUUFtQlQsU0FuQlM7O0FBdUIzQjs7O0FBQ0EsV0FBTyxDQUFQLElBQVksV0FBVyxTQUF2QjtBQUNBLFdBQU8sQ0FBUCxJQUFZLFdBQVcsU0FBdkI7O0FBRUEsVUFBTSxJQUFOO0FBQ0Q7QUFDRCxXQUFTLGVBQVQsQ0FBeUIsQ0FBekIsRUFBNEI7QUFDMUIsWUFBUSxJQUFSO0FBQ0EsZUFBVyxDQUFYO0FBQ0Q7O0FBRUQsV0FBUyxhQUFULENBQXVCLENBQXZCLEVBQTBCO0FBQ3hCLFVBQU0sSUFBTjtBQUNBLFdBQU8sbUJBQVAsQ0FBMkIsV0FBM0IsRUFBd0MsZUFBeEM7QUFDQSxXQUFPLG1CQUFQLENBQTJCLFNBQTNCLEVBQXNDLGFBQXRDOztBQUVBO0FBQ0EsUUFBSSxDQUFDLEtBQUwsRUFBWTtBQUNWLGNBQVEsR0FBUixDQUFZLFlBQVo7QUFDQSxrQkFBWSxDQUFaO0FBQ0Q7QUFDRCxZQUFRLEtBQVI7QUFDRDs7QUFFRCxNQUFJLE9BQU8sT0FBWDtBQUNBLFdBQVMsV0FBVCxDQUFxQixDQUFyQixFQUF3QjtBQUN0QixRQUFNLE1BQU0sZUFDUixtQkFEUSxFQUVSLDBCQUEwQixDQUExQixDQUZRLENBQVo7O0FBSUEsZUFBVyxPQUFYLENBQW1CLEdBQW5CLEVBQXdCLElBQXhCO0FBQ0EsV0FBTyxRQUFRLE9BQVIsR0FBa0IsUUFBbEIsR0FBNkIsT0FBcEM7QUFDRDs7QUFFRCxXQUFTLFVBQVQsQ0FBb0IsQ0FBcEIsRUFBdUI7QUFDckIsUUFBTSxNQUFNLGVBQ1IsbUJBRFEsRUFFUiwwQkFBMEIsQ0FBMUIsQ0FGUSxDQUFaOztBQUlBLFdBQU8sQ0FBUCxHQUFXLFlBQVksQ0FBWixHQUFnQixTQUFTLENBQVQsQ0FBaEIsR0FBOEIsSUFBSSxDQUFKLENBQXpDO0FBQ0EsV0FBTyxDQUFQLEdBQVcsWUFBWSxDQUFaLEdBQWdCLFNBQVMsQ0FBVCxDQUFoQixHQUE4QixJQUFJLENBQUosQ0FBekM7QUFDQSxVQUFNLElBQU47QUFDRDs7QUFFRCxXQUFTLGNBQVQsQ0FBd0IsQ0FBeEIsRUFBMkIsQ0FBM0IsRUFBOEI7QUFDNUIsUUFBSSxLQUFLLEVBQUUsQ0FBRixDQUFUO0FBQ0EsUUFBSSxLQUFLLEVBQUUsQ0FBRixDQUFUO0FBQ0EsUUFBSSxJQUFJLEtBQUssRUFBRSxJQUFJLENBQUosR0FBUSxDQUFWLENBQUwsR0FBb0IsS0FBSyxFQUFFLElBQUksQ0FBSixHQUFRLENBQVYsQ0FBekIsR0FBd0MsRUFBRSxJQUFJLENBQUosR0FBUSxDQUFWLENBQWhEO0FBQ0EsV0FBTyxDQUNMLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBSixHQUFRLENBQVYsQ0FBTCxHQUFvQixLQUFLLEVBQUUsSUFBSSxDQUFKLEdBQVEsQ0FBVixDQUF6QixHQUF3QyxFQUFFLElBQUksQ0FBSixHQUFRLENBQVYsQ0FBekMsSUFBeUQsQ0FEcEQsRUFFTCxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUosR0FBUSxDQUFWLENBQUwsR0FBb0IsS0FBSyxFQUFFLElBQUksQ0FBSixHQUFRLENBQVYsQ0FBekIsR0FBd0MsRUFBRSxJQUFJLENBQUosR0FBUSxDQUFWLENBQXpDLElBQXlELENBRnBELENBQVA7QUFJRDtBQUNGOztBQUVELFNBQVMseUJBQVQsQ0FBbUMsQ0FBbkMsRUFBc0M7QUFDcEM7QUFDQSxNQUFNLE9BQU8sT0FBTyxxQkFBUCxFQUFiO0FBQ0EsTUFBTSxPQUFPLEVBQUUsT0FBRixHQUFZLEtBQUssSUFBOUI7QUFDQSxNQUFNLE9BQU8sRUFBRSxPQUFGLEdBQVksS0FBSyxHQUE5Qjs7QUFFQTtBQUNBLE1BQU0sY0FBYyxPQUFPLE9BQU8sV0FBbEM7QUFDQSxNQUFNLGNBQWMsT0FBTyxPQUFPLFlBQWxDOztBQUVBO0FBQ0EsTUFBTSxRQUFRLGNBQWUsQ0FBZixHQUFtQixDQUFqQztBQUNBLE1BQU0sUUFBUSxjQUFjLENBQUMsQ0FBZixHQUFtQixDQUFqQzs7QUFFQSxTQUFPLENBQUMsS0FBRCxFQUFRLEtBQVIsQ0FBUDtBQUNEOzs7OztBQ2hNRCxJQUFNLFVBQVUsUUFBUSxXQUFSLENBQWhCO0FBQ0EsSUFBTSxjQUFjLFFBQVEsY0FBUixDQUFwQjtBQUNBLElBQU0sV0FBVyxTQUFqQjs7QUFFQSxPQUFPLE9BQVAsR0FBaUIsVUFBUyxJQUFULEVBQWUsUUFBZixFQUF5QjtBQUN4QyxNQUFJLGNBQUo7QUFDQSxNQUFJLGNBQUo7QUFDQSxNQUFJLFdBQVcsYUFBZjs7QUFFQSxTQUFPLFlBQ0UsSUFERixDQUNPLFVBQUMsR0FBRCxFQUFTO0FBQ2IsdUJBQW1CLEdBQW5CO0FBQ0EsV0FBTyxXQUFQO0FBQ0QsR0FKRixFQUtFLElBTEYsQ0FLTyxVQUFDLEdBQUQsRUFBUztBQUNiLGlCQUFhLEdBQWI7QUFDQSxXQUFPO0FBQ0wsa0JBREssRUFDRSxZQURGLEVBQ1M7QUFEVCxLQUFQO0FBR0QsR0FWRixDQUFQOztBQVlBLFdBQVMsU0FBVCxHQUFxQjtBQUNuQixXQUFPLFFBQVEsWUFBYyxJQUFkLGFBQVIsRUFBcUM7QUFDMUMsb0JBQWMsYUFENEI7QUFFMUMsZ0JBQVUsZUFBZSxtQkFBZjtBQUZnQyxLQUFyQyxDQUFQO0FBSUQ7O0FBRUQsV0FBUyxTQUFULEdBQXFCO0FBQ25CLFdBQU8sUUFBUSxZQUFjLElBQWQsYUFBUixFQUFxQztBQUMxQyxvQkFBYyxhQUQ0QjtBQUUxQyxnQkFBVSxlQUFlLG1CQUFmO0FBRmdDLEtBQXJDLENBQVA7QUFJRDs7QUFFRCxXQUFTLGtCQUFULENBQTRCLE1BQTVCLEVBQW9DO0FBQ2xDLFlBQVEsSUFBSSxVQUFKLENBQWUsTUFBZixDQUFSO0FBQ0E7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksTUFBTSxNQUFOLEdBQWUsQ0FBbkMsRUFBc0MsRUFBRSxDQUF4QyxFQUEyQztBQUN6QyxlQUFTLE9BQVQsQ0FBaUIsQ0FBakIsRUFBb0I7QUFDbEIsV0FBRyxNQUFNLElBQUUsQ0FBUixDQURlO0FBRWxCLFdBQUcsTUFBTSxJQUFFLENBQUYsR0FBTSxDQUFaO0FBRmUsT0FBcEI7QUFJRDtBQUNGOztBQUVELFdBQVMsWUFBVCxDQUFzQixNQUF0QixFQUE4QjtBQUM1QixZQUFRLElBQUksVUFBSixDQUFlLE1BQWYsQ0FBUjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLE1BQU4sR0FBZSxDQUFuQyxFQUFzQyxFQUFFLENBQXhDLEVBQTJDO0FBQ3pDLFlBQU0sSUFBRSxDQUFSLEtBQWMsQ0FBZDtBQUNBLFlBQU0sSUFBRSxDQUFGLEdBQU0sQ0FBWixLQUFrQixDQUFsQjtBQUNBLGVBQVMsT0FBVCxDQUFpQixNQUFNLElBQUUsQ0FBUixDQUFqQixFQUE2QixNQUFNLElBQUUsQ0FBRixHQUFNLENBQVosQ0FBN0I7QUFDRDtBQUNGOztBQUVELFdBQVMsY0FBVCxDQUF3QixHQUF4QixFQUE2QjtBQUMzQixXQUFPLFVBQVMsQ0FBVCxFQUFZO0FBQ2pCLFVBQUksT0FBTyxFQUFYO0FBQ0EsV0FBSyxPQUFMLEdBQWUsR0FBZjtBQUNBLFdBQUssU0FBTCxHQUFpQixLQUFLLEtBQUwsQ0FBVyxFQUFFLE9BQUYsR0FBWSxHQUF2QixDQUFqQjtBQUNBLGVBQVMsSUFBVDtBQUNELEtBTEQ7QUFNRDtBQUNGLENBM0REOzs7OztBQ0pBLElBQU0sS0FBSyxRQUFRLGFBQVIsQ0FBWDtBQUNBLElBQU0sUUFBUSxRQUFRLGFBQVIsRUFBdUIsS0FBckM7QUFDQSxJQUFNLFNBQVMsUUFBUSxTQUFSLEVBQW1CLE9BQWxDOztBQUVBLE9BQU8sT0FBUCxHQUFpQixVQUFTLEVBQVQsRUFBYSxLQUFiLEVBQW9CLEtBQXBCLEVBQTJCLEtBQTNCLEVBQWtDLE1BQWxDLEVBQTBDO0FBQ3pEO0FBQ0EsTUFBTSxhQUFhLE1BQU0sS0FBTixFQUFhO0FBQzlCLGNBQVUsZUFEb0I7QUFFOUIsZUFBVztBQUZtQixHQUFiLENBQW5COztBQUtBO0FBQ0EsTUFBTSxXQUFXLEdBQUcsUUFBSCxHQUNkLENBRGMsQ0FDWixhQUFLO0FBQ04sV0FBTyxFQUFFLElBQUYsQ0FBTyxDQUFkO0FBQ0QsR0FIYyxFQUlkLENBSmMsQ0FJWixhQUFLO0FBQ04sV0FBTyxFQUFFLElBQUYsQ0FBTyxDQUFkO0FBQ0QsR0FOYyxDQUFqQjs7QUFRQSxRQUFNLFdBQU4sQ0FBa0IsVUFBUyxJQUFULEVBQWU7QUFDL0IsYUFBUyxHQUFULENBQWEsSUFBYjtBQUNELEdBRkQ7O0FBSUEsTUFBTSxVQUFVLEVBQWhCO0FBQ0EsTUFBSSxhQUFKOztBQUVBLFdBQVMsS0FBVCxHQUFpQjtBQUNmLFdBQU8sUUFBUSxLQUFmO0FBQ0EsV0FBTyxRQUFRLE1BQWY7QUFDQSxVQUFNLFVBQU4sQ0FBaUIsS0FBakI7QUFDQSxVQUFNLFVBQU4sQ0FBaUIsS0FBakI7QUFDRDtBQUNELFdBQVMsT0FBVCxDQUFpQixHQUFqQixFQUFzQixJQUF0QixFQUE0QjtBQUMxQixRQUFJLFFBQVEsT0FBWixFQUFxQjs7QUFFckIsUUFBTSxPQUFPLFNBQVMsSUFBVCxDQUFjLElBQUksQ0FBSixDQUFkLEVBQXNCLElBQUksQ0FBSixDQUF0QixDQUFiO0FBSDBCLGVBSVgsQ0FBQyxLQUFLLElBQUwsQ0FBVSxDQUFYLEVBQWMsS0FBSyxJQUFMLENBQVUsQ0FBeEIsQ0FKVztBQUFBLFFBSW5CLENBSm1CO0FBQUEsUUFJaEIsQ0FKZ0I7OztBQU0xQixRQUFJLENBQUMsUUFBUSxJQUFSLENBQUwsRUFBb0I7QUFDbEIsY0FBUSxJQUFSLElBQWdCO0FBQ2QsY0FBTSxJQURRO0FBRWQsbUJBQVcsUUFBUSxDQUFSLEVBQVcsQ0FBWCxFQUFjLElBQWQ7QUFGRyxPQUFoQjtBQUlEOztBQUVELFlBQVEsSUFBUixFQUFjLElBQWQsR0FBcUIsSUFBckI7QUFDQSxjQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLElBQWhCO0FBQ0EsVUFBTSxJQUFOOztBQUVBLFFBQUksUUFBUSxRQUFaLEVBQXNCO0FBQ3ZCOztBQUVELFdBQVMsT0FBVCxDQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QixJQUF2QixFQUE2QjtBQUMzQixRQUFNLFdBQVcsT0FBTyxJQUFQLEVBQWEsUUFBOUI7QUFDQSxRQUFNLFlBQVksRUFBbEI7O0FBRUEsYUFBUyxPQUFULENBQWlCLGNBQU07QUFDckIsVUFBSSxhQUFhO0FBQ2YsV0FBRyxDQURZO0FBRWYsV0FBRyxDQUZZO0FBR2YsZUFBTyxHQUFHLEtBSEs7QUFJZixjQUFNO0FBSlMsT0FBakI7O0FBT0EsZ0JBQVUsSUFBVixDQUNFLE1BQU0sU0FBTixDQUFnQixHQUFHLEtBQW5CLEVBQTBCLEdBQUcsT0FBN0IsRUFBc0M7QUFDcEMsZUFBTyxHQUFHLEtBRDBCO0FBRXBDLGNBQU0sR0FBRyxRQUYyQjtBQUdwQyxlQUFPLEtBSDZCO0FBSXBDLG9CQUFZO0FBSndCLE9BQXRDLENBREY7QUFRRCxLQWhCRDs7QUFrQkEsV0FBTyxTQUFQO0FBQ0Q7O0FBRUQsV0FBUyxTQUFULENBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLElBQXpCLEVBQStCO0FBQzdCLFlBQVEsSUFBUixFQUFjLFNBQWQsQ0FBd0IsT0FBeEIsQ0FBZ0MsZUFBTztBQUNyQyxVQUFJLFVBQUosQ0FBZSxDQUFmLEdBQW1CLENBQW5CO0FBQ0EsVUFBSSxVQUFKLENBQWUsQ0FBZixHQUFtQixDQUFuQjtBQUNELEtBSEQ7QUFJRDs7QUFFRCxXQUFTLFNBQVQsR0FBcUI7QUFDbkIsUUFBSSxDQUFDLFFBQVEsS0FBVCxJQUFrQixDQUFDLFFBQVEsTUFBL0IsRUFBdUM7QUFDckMsY0FBUSxLQUFSLENBQWMsMkJBQWQ7QUFDQTtBQUNEOztBQUVELFFBQUksSUFBSSxRQUFRLEtBQWhCO0FBQ0EsUUFBSSxJQUFJLFFBQVEsTUFBaEI7QUFDQSxRQUFNLGFBQWEsV0FBVyxJQUFYLENBQWdCLEVBQUUsSUFBRixDQUFPLEVBQXZCLEVBQTJCLEVBQUUsSUFBRixDQUFPLEVBQWxDLENBQW5CO0FBQ0EsUUFBTSxXQUFXLElBQUksV0FBSixDQUFnQixXQUFXLE9BQVgsQ0FBbUIsT0FBbkIsRUFBaEIsQ0FBakI7QUFDQSxvQkFBZ0IsTUFBTSxTQUFOLENBQWdCLEtBQWhCLEVBQXVCLFFBQXZCLEVBQWlDO0FBQy9DLGFBQU8sT0FBTyxVQURpQztBQUUvQyxZQUFNLEdBQUcsS0FGc0M7QUFHL0MsYUFBTztBQUh3QyxLQUFqQyxDQUFoQjs7QUFNQSxRQUFJLFNBQVMsU0FBUyxNQUFULEdBQW1CLENBQWhDO0FBQ0E7O0FBRUEsYUFBUyxhQUFULEdBQXlCO0FBQ3ZCLGVBQVMsU0FBUyxDQUFULEdBQWEsQ0FBYixHQUFpQixNQUExQjtBQUNBLFlBQU0saUJBQU4sQ0FBd0IsUUFBeEIsRUFBa0MsTUFBbEMsRUFBMEMsYUFBMUM7QUFDQSxZQUFNLElBQU47O0FBRUEsVUFBSSxVQUFVLENBQWQsRUFBaUI7QUFDZixrQkFBVSxNQUFNLENBQWhCO0FBQ0EsOEJBQXNCLGFBQXRCO0FBQ0QsT0FIRCxNQUdPO0FBQ0w7QUFDRDtBQUNGOztBQUVELGFBQVMsUUFBVCxHQUFvQjtBQUNsQjtBQUNEO0FBQ0Y7O0FBR0QsU0FBTztBQUNMLG9CQURLO0FBRUw7QUFGSyxHQUFQO0FBSUQsQ0EzSEQ7O0FBNkhBLElBQU0sZ0JBQWdCLFNBQWhCLGFBQWdCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBVTtBQUM5QixNQUFJLEtBQUssRUFBRSxJQUFGLENBQU8sQ0FBUCxHQUFXLEVBQUUsSUFBRixDQUFPLENBQTNCO0FBQ0EsTUFBSSxLQUFLLEVBQUUsSUFBRixDQUFPLENBQVAsR0FBVyxFQUFFLElBQUYsQ0FBTyxDQUEzQjtBQUNBLFNBQU8sS0FBSyxJQUFMLENBQVUsS0FBSyxFQUFMLEdBQVUsS0FBSyxFQUF6QixDQUFQO0FBQ0QsQ0FKRDs7QUFNQSxJQUFNLGtCQUFrQixTQUFsQixlQUFrQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQVU7QUFDaEMsTUFBSSxLQUFLLEVBQUUsSUFBRixDQUFPLENBQVAsR0FBVyxFQUFFLElBQUYsQ0FBTyxDQUEzQjtBQUNBLE1BQUksS0FBSyxFQUFFLElBQUYsQ0FBTyxDQUFQLEdBQVcsRUFBRSxJQUFGLENBQU8sQ0FBM0I7QUFDQSxTQUFPLEtBQUssSUFBTCxDQUFVLEtBQUssRUFBTCxHQUFVLEtBQUssRUFBekIsQ0FBUDtBQUNELENBSkQ7OztBQ3ZJQTs7OztBQUVBLElBQU0sT0FBTyxRQUFRLFNBQVIsQ0FBYjtBQUNBLElBQU0sT0FBTyxRQUFRLFNBQVIsQ0FBYjtBQUNBLElBQU0sT0FBTyxRQUFRLGdCQUFSLENBQWI7O0FBRUEsSUFBTSxlQUFlLEtBQUssQ0FBQyx1TEFBRCxDQUFMLENBQXJCO0FBQ0EsSUFBTSxpQkFBaUIsS0FBSyxDQUFDLHdIQUFELENBQUwsQ0FBdkI7O0FBRUEsSUFBTSxTQUFTLFFBQVEsU0FBUixFQUFtQixPQUFsQzs7QUFFQSxPQUFPLE9BQVAsR0FBaUIsVUFBUyxFQUFULEVBQWE7QUFDNUIsTUFBTSxjQUFjLEtBQUssaUJBQUwsQ0FBdUIsRUFBdkIsRUFBMkIsQ0FBQyxZQUFELEVBQWUsY0FBZixDQUEzQixDQUFwQjtBQUNBLE1BQU0sYUFBYSxDQUFDLEdBQUcsTUFBSCxDQUFVLEtBQVgsRUFBa0IsR0FBRyxNQUFILENBQVUsTUFBNUIsQ0FBbkI7QUFDQSxNQUFNLG9CQUFvQixLQUFLLE1BQUwsRUFBMUI7QUFDQSxNQUFNLGNBQWMsRUFBRSxNQUFNLEVBQVIsRUFBWSxLQUFLLEVBQWpCLEVBQXFCLEtBQUssRUFBMUIsRUFBcEI7O0FBRUEsTUFBTSxTQUFTO0FBQ2IsT0FBRyxDQUFDLEtBRFM7QUFFYixPQUFHLENBQUMsS0FGUztBQUdiLFVBQU07QUFITyxHQUFmOztBQU1BLE9BQUssc0JBQUwsQ0FBNEIsRUFBNUI7O0FBRUEsV0FBUyxvQkFBVCxHQUFnQztBQUM5QixTQUFLLFVBQUwsQ0FBZ0IsaUJBQWhCLEVBQW1DLEdBQUcsTUFBSCxDQUFVLEtBQTdDLEVBQW9ELEdBQUcsTUFBSCxDQUFVLE1BQTlEOztBQUVBO0FBQ0EsUUFBTSxZQUFZLElBQUksT0FBTyxJQUE3QjtBQUNBLFFBQUksWUFBWSxLQUFLLE1BQUwsRUFBaEI7QUFDQSxTQUFLLFNBQUwsQ0FBZSxTQUFmLEVBQTBCLFNBQTFCLEVBQXFDLENBQUMsT0FBTyxDQUFSLEVBQVcsT0FBTyxDQUFsQixDQUFyQztBQUNBLFNBQUssS0FBTCxDQUFXLFNBQVgsRUFBc0IsU0FBdEIsRUFBaUMsQ0FBQyxTQUFELEVBQVksU0FBWixDQUFqQzs7QUFFQSxRQUFJLFVBQVUsS0FBSyxNQUFMLEVBQWQ7QUFDQSxTQUFLLE1BQUwsQ0FBWSxPQUFaLEVBQXFCLFNBQXJCO0FBQ0EsU0FBSyxRQUFMLENBQWMsaUJBQWQsRUFBaUMsaUJBQWpDLEVBQW9ELE9BQXBEO0FBQ0Q7O0FBRUQsV0FBUyxvQkFBVCxDQUE4QixVQUE5QixFQUEwQztBQUN4QyxRQUFJLE1BQU0sS0FBSyxNQUFMLEVBQVY7QUFDQSxTQUFLLFFBQUwsQ0FBYyxHQUFkO0FBQ0EsU0FBSyxTQUFMLENBQWUsR0FBZixFQUFvQixHQUFwQixFQUF5QixDQUFDLFdBQVcsQ0FBWixFQUFlLFdBQVcsQ0FBMUIsQ0FBekI7QUFDQSxTQUFLLEtBQUwsQ0FBVyxHQUFYLEVBQWdCLEdBQWhCLEVBQXFCLENBQUMsV0FBVyxLQUFaLEVBQW1CLFdBQVcsS0FBOUIsQ0FBckI7O0FBRUEsUUFBSSxDQUFDLFdBQVcsSUFBaEIsRUFBc0I7QUFDcEIsV0FBSyxLQUFMLENBQVcsR0FBWCxFQUFnQixHQUFoQixFQUFxQixDQUFDLElBQUUsT0FBTyxJQUFWLEVBQWdCLElBQUUsT0FBTyxJQUF6QixDQUFyQjtBQUNEOztBQUVELFNBQUssUUFBTCxDQUFjLEdBQWQsRUFBbUIsaUJBQW5CLEVBQXNDLEdBQXRDO0FBQ0EsV0FBTyxHQUFQO0FBQ0Q7O0FBRUQsV0FBUyxTQUFULENBQW1CLEtBQW5CLEVBQTBCLElBQTFCLEVBQWdDLEtBQWhDLEVBQXVDO0FBQ3JDLFVBQU0sVUFBTixHQUFtQixNQUFNLFVBQU4sR0FBbUIsTUFBTSxVQUF6QixHQUFzQyxFQUFFLEdBQUcsQ0FBTCxFQUFRLEdBQUcsQ0FBWCxFQUFjLE9BQU8sQ0FBckIsRUFBd0IsTUFBTSxJQUE5QixFQUF6RDtBQUNBLFVBQU0sS0FBTixHQUFjLE1BQU0sS0FBTixHQUFjLE1BQU0sS0FBcEIsR0FBNEIsS0FBMUM7QUFDQSxVQUFNLE1BQU4sR0FBZSxNQUFNLE1BQU4sR0FBZSxNQUFNLE1BQXJCLEdBQThCLENBQTdDOztBQUVBLFFBQU0sYUFBYTtBQUNqQixnQkFBVSxFQUFFLGVBQWUsQ0FBakIsRUFBb0IsTUFBTSxJQUFJLFlBQUosQ0FBaUIsS0FBakIsQ0FBMUIsRUFETztBQUVqQixlQUFVLEVBQUUsZUFBZSxDQUFqQixFQUFvQixNQUFNLElBQUksV0FBSixDQUFnQixJQUFoQixDQUExQjtBQUZPLEtBQW5CO0FBSUEsUUFBTSxhQUFhLEtBQUssMEJBQUwsQ0FBZ0MsRUFBaEMsRUFBb0MsVUFBcEMsQ0FBbkI7QUFDQSxRQUFNLE1BQU07QUFDVixrQkFBWSxVQURGO0FBRVYsYUFBTyxNQUFNLEtBRkg7QUFHVixnQkFBVSxNQUFNLElBSE47QUFJVixrQkFBWSxNQUFNLFVBSlI7QUFLVixjQUFRLE1BQU07QUFMSixLQUFaOztBQVFBLFFBQUksT0FBTyxNQUFNLFVBQWIsS0FBNEIsV0FBaEMsRUFBNkM7QUFDM0Msa0JBQVksTUFBTSxLQUFsQixJQUEyQixHQUEzQjtBQUNELEtBRkQsTUFFTztBQUNMLGtCQUFZLE1BQU0sS0FBbEIsRUFBeUIsSUFBekIsQ0FBOEIsR0FBOUI7QUFDRDtBQUNELFdBQU8sR0FBUDtBQUNEOztBQUVELFdBQVMsaUJBQVQsQ0FBMkIsSUFBM0IsRUFBaUMsTUFBakMsRUFBeUMsR0FBekMsRUFBOEM7QUFDNUMsUUFBTSxhQUFhO0FBQ2pCLGVBQVUsRUFBRSxlQUFlLENBQWpCLEVBQW9CLE1BQU0sSUFBSSxXQUFKLENBQWdCLEtBQUssTUFBckIsRUFBNkIsTUFBN0IsQ0FBMUI7QUFETyxLQUFuQjtBQUdBLFFBQUksVUFBSixHQUFpQixLQUFLLDBCQUFMLENBQWdDLEVBQWhDLEVBQW9DLFVBQXBDLEVBQWdELElBQUksVUFBcEQsQ0FBakI7QUFDRDs7QUFFRCxXQUFTLFVBQVQsQ0FBb0IsR0FBcEIsRUFBeUI7QUFDdkIsUUFBTSxXQUFXO0FBQ2YsZUFBUyxJQUFJLEtBREU7QUFFZixnQkFBVSxxQkFBcUIsSUFBSSxVQUF6QjtBQUZLLEtBQWpCO0FBSUEsT0FBRyxVQUFILENBQWMsWUFBWSxPQUExQjtBQUNBLFNBQUssdUJBQUwsQ0FBNkIsRUFBN0IsRUFBaUMsV0FBakMsRUFBOEMsSUFBSSxVQUFsRDtBQUNBLFNBQUssV0FBTCxDQUFpQixXQUFqQixFQUE4QixRQUE5QjtBQUNBLFNBQUssY0FBTCxDQUFvQixFQUFwQixFQUF3QixJQUFJLFVBQTVCLEVBQXdDLElBQUksUUFBNUMsRUFBc0QsSUFBSSxVQUFKLENBQWUsV0FBckUsRUFBa0YsSUFBSSxNQUF0RjtBQUNEOztBQUVELFdBQVMsVUFBVCxDQUFvQixLQUFwQixFQUEyQjtBQUN6QixnQkFBWSxLQUFaLEVBQW1CLE1BQW5CLEdBQTRCLENBQTVCO0FBQ0Q7O0FBRUQsU0FBTztBQUNMLHdCQURLO0FBRUwsd0NBRks7QUFHTCw4Q0FISztBQUlMLDBCQUpLO0FBS0wsa0JBTEs7QUFNTCx3Q0FOSzs7QUFRTCxRQVJLLGtCQVFFO0FBQ0wsaUJBQVcsQ0FBWCxJQUFnQixHQUFHLE1BQUgsQ0FBVSxLQUExQjtBQUNBLGlCQUFXLENBQVgsSUFBZ0IsR0FBRyxNQUFILENBQVUsTUFBMUI7O0FBRUEsV0FBSyx5QkFBTCxDQUErQixHQUFHLE1BQWxDOztBQUVBLFNBQUcsUUFBSCxDQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCLEdBQUcsTUFBSCxDQUFVLEtBQTVCLEVBQW1DLEdBQUcsTUFBSCxDQUFVLE1BQTdDO0FBQ0EsU0FBRyxVQUFILDhCQUFpQixPQUFPLFVBQXhCO0FBQ0EsU0FBRyxLQUFILENBQVMsR0FBRyxnQkFBWjs7QUFFQTs7QUFFQSxrQkFBWSxJQUFaLENBQWlCLE9BQWpCLENBQXlCLFVBQXpCO0FBQ0Esa0JBQVksR0FBWixDQUFnQixPQUFoQixDQUF3QixVQUF4QjtBQUNBLGtCQUFZLEdBQVosQ0FBZ0IsT0FBaEIsQ0FBd0IsVUFBeEI7QUFDRDtBQXZCSSxHQUFQO0FBeUJELENBbkhEOzs7OztBQ1hBLE9BQU8sT0FBUCxHQUFpQixPQUFqQjs7QUFFQSxTQUFTLE9BQVQsQ0FBaUIsR0FBakIsRUFBc0IsT0FBdEIsRUFBK0I7QUFDN0IsTUFBSSxDQUFDLE9BQUwsRUFBYyxVQUFVLEVBQVY7O0FBRWQsU0FBTyxJQUFJLE9BQUosQ0FBWSxRQUFaLENBQVA7O0FBRUEsV0FBUyxRQUFULENBQWtCLE9BQWxCLEVBQTJCLE1BQTNCLEVBQW1DO0FBQ2pDLFFBQUksTUFBTSxJQUFJLGNBQUosRUFBVjs7QUFFQSxRQUFJLE9BQU8sUUFBUSxRQUFmLEtBQTRCLFVBQWhDLEVBQTRDO0FBQzFDLFVBQUksZ0JBQUosQ0FBcUIsVUFBckIsRUFBaUMsY0FBakMsRUFBaUQsS0FBakQ7QUFDRDs7QUFFRCxRQUFJLGdCQUFKLENBQXFCLE1BQXJCLEVBQTZCLGdCQUE3QixFQUErQyxLQUEvQztBQUNBLFFBQUksZ0JBQUosQ0FBcUIsT0FBckIsRUFBOEIsY0FBOUIsRUFBOEMsS0FBOUM7QUFDQSxRQUFJLGdCQUFKLENBQXFCLE9BQXJCLEVBQThCLGdCQUE5QixFQUFnRCxLQUFoRDs7QUFFQSxRQUFJLElBQUosQ0FBUyxLQUFULEVBQWdCLEdBQWhCO0FBQ0EsUUFBSSxRQUFRLFlBQVosRUFBMEI7QUFDeEIsVUFBSSxZQUFKLEdBQW1CLFFBQVEsWUFBM0I7QUFDRDtBQUNELFFBQUksSUFBSixDQUFTLElBQVQ7O0FBRUEsYUFBUyxjQUFULENBQXdCLENBQXhCLEVBQTJCO0FBQ3pCLFVBQUksRUFBRSxnQkFBTixFQUF3QjtBQUN0QixnQkFBUSxRQUFSLENBQWlCO0FBQ2Ysa0JBQVEsRUFBRSxNQURLO0FBRWYsaUJBQU8sRUFBRSxLQUZNO0FBR2YsbUJBQVMsRUFBRSxNQUFGLEdBQVcsRUFBRTtBQUhQLFNBQWpCO0FBS0Q7QUFDRjs7QUFFRCxhQUFTLGdCQUFULEdBQTRCO0FBQzFCLFVBQUksSUFBSSxNQUFKLEtBQWUsR0FBbkIsRUFBd0I7QUFDdEIsMkNBQWlDLElBQUksTUFBckMsc0JBQTRELEdBQTVEO0FBQ0E7QUFDRDtBQUNELFVBQUksV0FBVyxJQUFJLFFBQW5COztBQUVBLFVBQUksUUFBUSxZQUFSLEtBQXlCLE1BQXpCLElBQW1DLE9BQU8sUUFBUCxLQUFvQixRQUEzRCxFQUFxRTtBQUNuRTtBQUNBLG1CQUFXLEtBQUssS0FBTCxDQUFXLFFBQVgsQ0FBWDtBQUNEOztBQUVELGNBQVEsUUFBUjtBQUNEOztBQUVELGFBQVMsY0FBVCxHQUEwQjtBQUN4QixxQ0FBNkIsR0FBN0I7QUFDRDs7QUFFRCxhQUFTLGdCQUFULEdBQTRCO0FBQzFCLHdDQUFnQyxHQUFoQztBQUNEO0FBQ0Y7QUFDRjs7Ozs7QUN6REQsSUFBTSxTQUFTLFFBQVEsU0FBUixFQUFtQixPQUFsQzs7QUFFQSxPQUFPLE9BQVAsR0FBaUIsVUFBVSxFQUFWLEVBQWM7QUFDN0IsU0FBTztBQUNMLFlBQVE7QUFDTixnQkFBVSxDQUNSO0FBQ0UsZUFBTyxXQUFXLEdBQVgsQ0FBZSxLQUR4QjtBQUVFLGlCQUFTLFdBQVcsR0FBWCxDQUFlLE9BRjFCO0FBR0UsZUFBTyxPQUFPLFNBSGhCO0FBSUUsZUFBTyxDQUpUO0FBS0Usa0JBQVUsR0FBRztBQUxmLE9BRFEsRUFRUjtBQUNFLGVBQU8sV0FBVyxJQUFYLENBQWdCLEtBRHpCO0FBRUUsaUJBQVMsV0FBVyxJQUFYLENBQWdCLE9BRjNCO0FBR0UsZUFBTyxPQUFPLFVBSGhCO0FBSUUsZUFBTyxHQUpUO0FBS0Usa0JBQVUsR0FBRztBQUxmLE9BUlE7QUFESixLQURIO0FBbUJMLFdBQU87QUFDTCxnQkFBVSxDQUNSO0FBQ0UsZUFBTyxXQUFXLE1BQVgsQ0FBa0IsS0FEM0I7QUFFRSxpQkFBUyxXQUFXLE1BQVgsQ0FBa0IsT0FGN0I7QUFHRSxlQUFPLE9BQU8sUUFIaEI7QUFJRSxlQUFPLENBSlQ7QUFLRSxrQkFBVSxHQUFHO0FBTGYsT0FEUSxFQVFSO0FBQ0UsZUFBTyxXQUFXLE1BQVgsQ0FBa0IsS0FEM0I7QUFFRSxpQkFBUyxXQUFXLE1BQVgsQ0FBa0IsT0FGN0I7QUFHRSxlQUFPLE9BQU8sU0FIaEI7QUFJRSxlQUFPLEdBSlQ7QUFLRSxrQkFBVSxHQUFHO0FBTGYsT0FSUSxFQWVSO0FBQ0UsZUFBTyxXQUFXLE1BQVgsQ0FBa0IsS0FEM0I7QUFFRSxpQkFBUyxXQUFXLE1BQVgsQ0FBa0IsT0FGN0I7QUFHRSxlQUFPLE9BQU8sU0FIaEI7QUFJRSxlQUFPLENBSlQ7QUFLRSxrQkFBVSxHQUFHO0FBTGYsT0FmUTtBQURMO0FBbkJGLEdBQVA7QUE2Q0QsQ0E5Q0Q7O0FBZ0RBLElBQU0sYUFBYTtBQUNqQixVQUFRO0FBQ04sV0FBTyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQ0MsQ0FERCxFQUNJLENBQUMsR0FETCxFQUVDLElBRkQsRUFFTyxDQUFDLEtBRlIsRUFHQyxNQUhELEVBR1MsQ0FBQyxNQUhWLEVBSUMsS0FKRCxFQUlRLENBQUMsSUFKVCxFQUtDLEdBTEQsRUFLTSxDQUxOLEVBTUMsS0FORCxFQU1RLElBTlIsRUFPQyxNQVBELEVBT1MsTUFQVCxFQVFDLElBUkQsRUFRTyxLQVJQLEVBU0MsQ0FURCxFQVNJLEdBVEosRUFVQyxDQUFDLElBVkYsRUFVUSxLQVZSLEVBV0MsQ0FBQyxNQVhGLEVBV1UsTUFYVixFQVlDLENBQUMsS0FaRixFQVlTLElBWlQsRUFhQyxDQUFDLEdBYkYsRUFhTyxDQUFDLENBYlIsRUFjQyxDQUFDLEtBZEYsRUFjUyxDQUFDLElBZFYsRUFlQyxDQUFDLE1BZkYsRUFlVSxDQUFDLE1BZlgsRUFnQkMsQ0FBQyxJQWhCRixFQWdCUSxDQUFDLEtBaEJULENBREQ7QUFrQk4sYUFBUyxDQUFDLENBQUQsRUFBRyxDQUFILEVBQUssQ0FBTCxFQUFPLENBQVAsRUFBUyxDQUFULEVBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZSxDQUFmLEVBQWlCLENBQWpCLEVBQW1CLENBQW5CLEVBQXFCLEVBQXJCLEVBQXdCLEVBQXhCLEVBQTJCLEVBQTNCLEVBQThCLEVBQTlCLEVBQWlDLEVBQWpDLEVBQW9DLEVBQXBDLEVBQXVDLEVBQXZDLEVBQTBDLENBQTFDO0FBbEJILEdBRFM7QUFxQmpCLE9BQUs7QUFDSCxXQUFPLENBQUMsQ0FBRCxFQUFJLENBQUMsQ0FBTCxFQUNDLENBQUMsR0FERixFQUNPLENBQUMsR0FEUixFQUVDLENBQUMsR0FGRixFQUVPLENBQUMsQ0FGUixFQUdDLENBQUMsR0FIRixFQUdPLENBQUMsR0FIUixFQUlDLENBQUMsR0FKRixFQUlPLENBQUMsR0FKUixFQUtDLEdBTEQsRUFLTSxDQUFDLEdBTFAsRUFNQyxHQU5ELEVBTU0sQ0FBQyxHQU5QLEVBT0MsR0FQRCxFQU9NLENBQUMsQ0FQUCxFQVFDLEdBUkQsRUFRTSxDQUFDLEdBUlAsRUFTQyxDQVRELEVBU0ksQ0FUSixDQURKO0FBV0gsYUFBUyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCLENBQS9CO0FBWE4sR0FyQlk7QUFrQ2pCLFFBQU07QUFDSixXQUFPLENBQUMsQ0FBRCxFQUFJLENBQUMsQ0FBTCxFQUNDLENBQUMsR0FERixFQUNPLENBQUMsR0FEUixFQUVDLENBQUMsR0FGRixFQUVPLENBQUMsQ0FGUixFQUdDLENBQUMsR0FIRixFQUdPLENBQUMsR0FIUixFQUlDLENBQUMsR0FKRixFQUlPLENBQUMsSUFKUixFQUtDLEdBTEQsRUFLTSxDQUFDLElBTFAsRUFNQyxHQU5ELEVBTU0sQ0FBQyxHQU5QLEVBT0MsR0FQRCxFQU9NLENBQUMsQ0FQUCxFQVFDLEdBUkQsRUFRTSxDQUFDLEdBUlAsRUFTQyxDQVRELEVBU0ksQ0FBQyxDQVRMLENBREg7QUFXSixhQUFTLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsRUFBK0IsQ0FBL0I7QUFYTDtBQWxDVyxDQUFuQjs7Ozs7QUNsREEsT0FBTyxPQUFQLEdBQWlCO0FBQ2YsV0FBUztBQUNQLGdCQUFZLENBQUMsS0FBRCxFQUFRLEtBQVIsRUFBZSxLQUFmLEVBQXNCLENBQXRCLENBREw7QUFFUCxhQUFTLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLENBQWhCLENBRkY7QUFHUCxnQkFBWSxDQUFDLEtBQUQsRUFBUSxDQUFSLEVBQVcsSUFBWCxFQUFpQixDQUFqQixDQUhMO0FBSVAsVUFBTSxFQUpDOztBQU1QO0FBQ0EsY0FBVSxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsS0FBYixFQUFvQixDQUFwQixDQVBIO0FBUVAsZUFBVyxDQUFDLEdBQUQsRUFBTSxJQUFOLEVBQVksS0FBWixFQUFtQixDQUFuQixDQVJKO0FBU1AsZUFBVyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FUSjs7QUFXUDtBQUNBLGVBQVcsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsQ0FBbkIsQ0FaSjtBQWFQLGdCQUFZLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLENBQW5CLENBYkw7QUFjUCxnQkFBWSxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixDQUFuQjtBQWRMO0FBRE0sQ0FBakIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkKSB7XG4gIGNvbnN0IHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQpLFxuICAgICAgeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCk7XG4gIHJldHVybiBhZGQodGhpcy5jb3Zlcih4LCB5KSwgeCwgeSwgZCk7XG59XG5cbmZ1bmN0aW9uIGFkZCh0cmVlLCB4LCB5LCBkKSB7XG4gIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIHRyZWU7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciBwYXJlbnQsXG4gICAgICBub2RlID0gdHJlZS5fcm9vdCxcbiAgICAgIGxlYWYgPSB7ZGF0YTogZH0sXG4gICAgICB4MCA9IHRyZWUuX3gwLFxuICAgICAgeTAgPSB0cmVlLl95MCxcbiAgICAgIHgxID0gdHJlZS5feDEsXG4gICAgICB5MSA9IHRyZWUuX3kxLFxuICAgICAgeG0sXG4gICAgICB5bSxcbiAgICAgIHhwLFxuICAgICAgeXAsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIGksXG4gICAgICBqO1xuXG4gIC8vIElmIHRoZSB0cmVlIGlzIGVtcHR5LCBpbml0aWFsaXplIHRoZSByb290IGFzIGEgbGVhZi5cbiAgaWYgKCFub2RlKSByZXR1cm4gdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gRmluZCB0aGUgZXhpc3RpbmcgbGVhZiBmb3IgdGhlIG5ldyBwb2ludCwgb3IgYWRkIGl0LlxuICB3aGlsZSAobm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgICBpZiAocGFyZW50ID0gbm9kZSwgIShub2RlID0gbm9kZVtpID0gYm90dG9tIDw8IDEgfCByaWdodF0pKSByZXR1cm4gcGFyZW50W2ldID0gbGVhZiwgdHJlZTtcbiAgfVxuXG4gIC8vIElzIHRoZSBuZXcgcG9pbnQgaXMgZXhhY3RseSBjb2luY2lkZW50IHdpdGggdGhlIGV4aXN0aW5nIHBvaW50P1xuICB4cCA9ICt0cmVlLl94LmNhbGwobnVsbCwgbm9kZS5kYXRhKTtcbiAgeXAgPSArdHJlZS5feS5jYWxsKG51bGwsIG5vZGUuZGF0YSk7XG4gIGlmICh4ID09PSB4cCAmJiB5ID09PSB5cCkgcmV0dXJuIGxlYWYubmV4dCA9IG5vZGUsIHBhcmVudCA/IHBhcmVudFtpXSA9IGxlYWYgOiB0cmVlLl9yb290ID0gbGVhZiwgdHJlZTtcblxuICAvLyBPdGhlcndpc2UsIHNwbGl0IHRoZSBsZWFmIG5vZGUgdW50aWwgdGhlIG9sZCBhbmQgbmV3IHBvaW50IGFyZSBzZXBhcmF0ZWQuXG4gIGRvIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQgPyBwYXJlbnRbaV0gPSBuZXcgQXJyYXkoNCkgOiB0cmVlLl9yb290ID0gbmV3IEFycmF5KDQpO1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICB9IHdoaWxlICgoaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHQpID09PSAoaiA9ICh5cCA+PSB5bSkgPDwgMSB8ICh4cCA+PSB4bSkpKTtcbiAgcmV0dXJuIHBhcmVudFtqXSA9IG5vZGUsIHBhcmVudFtpXSA9IGxlYWYsIHRyZWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRBbGwoZGF0YSkge1xuICB2YXIgZCwgaSwgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4eiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHl6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgeDAgPSBJbmZpbml0eSxcbiAgICAgIHkwID0gSW5maW5pdHksXG4gICAgICB4MSA9IC1JbmZpbml0eSxcbiAgICAgIHkxID0gLUluZmluaXR5O1xuXG4gIC8vIENvbXB1dGUgdGhlIHBvaW50cyBhbmQgdGhlaXIgZXh0ZW50LlxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKGlzTmFOKHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQgPSBkYXRhW2ldKSkgfHwgaXNOYU4oeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCkpKSBjb250aW51ZTtcbiAgICB4eltpXSA9IHg7XG4gICAgeXpbaV0gPSB5O1xuICAgIGlmICh4IDwgeDApIHgwID0geDtcbiAgICBpZiAoeCA+IHgxKSB4MSA9IHg7XG4gICAgaWYgKHkgPCB5MCkgeTAgPSB5O1xuICAgIGlmICh5ID4geTEpIHkxID0geTtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIHdlcmUgbm8gKHZhbGlkKSBwb2ludHMsIGFib3J0LlxuICBpZiAoeDAgPiB4MSB8fCB5MCA+IHkxKSByZXR1cm4gdGhpcztcblxuICAvLyBFeHBhbmQgdGhlIHRyZWUgdG8gY292ZXIgdGhlIG5ldyBwb2ludHMuXG4gIHRoaXMuY292ZXIoeDAsIHkwKS5jb3Zlcih4MSwgeTEpO1xuXG4gIC8vIEFkZCB0aGUgbmV3IHBvaW50cy5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGFkZCh0aGlzLCB4eltpXSwgeXpbaV0sIGRhdGFbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCB5KSB7XG4gIGlmIChpc05hTih4ID0gK3gpIHx8IGlzTmFOKHkgPSAreSkpIHJldHVybiB0aGlzOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSA9IHRoaXMuX3gxLFxuICAgICAgeTEgPSB0aGlzLl95MTtcblxuICAvLyBJZiB0aGUgcXVhZHRyZWUgaGFzIG5vIGV4dGVudCwgaW5pdGlhbGl6ZSB0aGVtLlxuICAvLyBJbnRlZ2VyIGV4dGVudCBhcmUgbmVjZXNzYXJ5IHNvIHRoYXQgaWYgd2UgbGF0ZXIgZG91YmxlIHRoZSBleHRlbnQsXG4gIC8vIHRoZSBleGlzdGluZyBxdWFkcmFudCBib3VuZGFyaWVzIGRvbuKAmXQgY2hhbmdlIGR1ZSB0byBmbG9hdGluZyBwb2ludCBlcnJvciFcbiAgaWYgKGlzTmFOKHgwKSkge1xuICAgIHgxID0gKHgwID0gTWF0aC5mbG9vcih4KSkgKyAxO1xuICAgIHkxID0gKHkwID0gTWF0aC5mbG9vcih5KSkgKyAxO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBkb3VibGUgcmVwZWF0ZWRseSB0byBjb3Zlci5cbiAgZWxzZSB7XG4gICAgdmFyIHogPSB4MSAtIHgwIHx8IDEsXG4gICAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIGk7XG5cbiAgICB3aGlsZSAoeDAgPiB4IHx8IHggPj0geDEgfHwgeTAgPiB5IHx8IHkgPj0geTEpIHtcbiAgICAgIGkgPSAoeSA8IHkwKSA8PCAxIHwgKHggPCB4MCk7XG4gICAgICBwYXJlbnQgPSBuZXcgQXJyYXkoNCksIHBhcmVudFtpXSA9IG5vZGUsIG5vZGUgPSBwYXJlbnQsIHogKj0gMjtcbiAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICBjYXNlIDA6IHgxID0geDAgKyB6LCB5MSA9IHkwICsgejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTogeDAgPSB4MSAtIHosIHkxID0geTAgKyB6OyBicmVhaztcbiAgICAgICAgY2FzZSAyOiB4MSA9IHgwICsgeiwgeTAgPSB5MSAtIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IHgwID0geDEgLSB6LCB5MCA9IHkxIC0gejsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3Jvb3QgJiYgdGhpcy5fcm9vdC5sZW5ndGgpIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgdGhpcy5feDAgPSB4MDtcbiAgdGhpcy5feTAgPSB5MDtcbiAgdGhpcy5feDEgPSB4MTtcbiAgdGhpcy5feTEgPSB5MTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGRhdGEgPSBbXTtcbiAgdGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgZG8gZGF0YS5wdXNoKG5vZGUuZGF0YSk7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuY292ZXIoK19bMF1bMF0sICtfWzBdWzFdKS5jb3ZlcigrX1sxXVswXSwgK19bMV1bMV0pXG4gICAgICA6IGlzTmFOKHRoaXMuX3gwKSA/IHVuZGVmaW5lZCA6IFtbdGhpcy5feDAsIHRoaXMuX3kwXSwgW3RoaXMuX3gxLCB0aGlzLl95MV1dO1xufVxuIiwiaW1wb3J0IFF1YWQgZnJvbSBcIi4vcXVhZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcbiAgdmFyIGRhdGEsXG4gICAgICB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyLFxuICAgICAgeDMgPSB0aGlzLl94MSxcbiAgICAgIHkzID0gdGhpcy5feTEsXG4gICAgICBxdWFkcyA9IFtdLFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICBxLFxuICAgICAgaTtcblxuICBpZiAobm9kZSkgcXVhZHMucHVzaChuZXcgUXVhZChub2RlLCB4MCwgeTAsIHgzLCB5MykpO1xuICBpZiAocmFkaXVzID09IG51bGwpIHJhZGl1cyA9IEluZmluaXR5O1xuICBlbHNlIHtcbiAgICB4MCA9IHggLSByYWRpdXMsIHkwID0geSAtIHJhZGl1cztcbiAgICB4MyA9IHggKyByYWRpdXMsIHkzID0geSArIHJhZGl1cztcbiAgICByYWRpdXMgKj0gcmFkaXVzO1xuICB9XG5cbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuXG4gICAgLy8gU3RvcCBzZWFyY2hpbmcgaWYgdGhpcyBxdWFkcmFudCBjYW7igJl0IGNvbnRhaW4gYSBjbG9zZXIgbm9kZS5cbiAgICBpZiAoIShub2RlID0gcS5ub2RlKVxuICAgICAgICB8fCAoeDEgPSBxLngwKSA+IHgzXG4gICAgICAgIHx8ICh5MSA9IHEueTApID4geTNcbiAgICAgICAgfHwgKHgyID0gcS54MSkgPCB4MFxuICAgICAgICB8fCAoeTIgPSBxLnkxKSA8IHkwKSBjb250aW51ZTtcblxuICAgIC8vIEJpc2VjdCB0aGUgY3VycmVudCBxdWFkcmFudC5cbiAgICBpZiAobm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciB4bSA9ICh4MSArIHgyKSAvIDIsXG4gICAgICAgICAgeW0gPSAoeTEgKyB5MikgLyAyO1xuXG4gICAgICBxdWFkcy5wdXNoKFxuICAgICAgICBuZXcgUXVhZChub2RlWzNdLCB4bSwgeW0sIHgyLCB5MiksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMl0sIHgxLCB5bSwgeG0sIHkyKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVsxXSwgeG0sIHkxLCB4MiwgeW0pLFxuICAgICAgICBuZXcgUXVhZChub2RlWzBdLCB4MSwgeTEsIHhtLCB5bSlcbiAgICAgICk7XG5cbiAgICAgIC8vIFZpc2l0IHRoZSBjbG9zZXN0IHF1YWRyYW50IGZpcnN0LlxuICAgICAgaWYgKGkgPSAoeSA+PSB5bSkgPDwgMSB8ICh4ID49IHhtKSkge1xuICAgICAgICBxID0gcXVhZHNbcXVhZHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHF1YWRzW3F1YWRzLmxlbmd0aCAtIDFdID0gcXVhZHNbcXVhZHMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICBxdWFkc1txdWFkcy5sZW5ndGggLSAxIC0gaV0gPSBxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZpc2l0IHRoaXMgcG9pbnQuIChWaXNpdGluZyBjb2luY2lkZW50IHBvaW50cyBpc27igJl0IG5lY2Vzc2FyeSEpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgZHggPSB4IC0gK3RoaXMuX3guY2FsbChudWxsLCBub2RlLmRhdGEpLFxuICAgICAgICAgIGR5ID0geSAtICt0aGlzLl95LmNhbGwobnVsbCwgbm9kZS5kYXRhKSxcbiAgICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgaWYgKGQyIDwgcmFkaXVzKSB7XG4gICAgICAgIHZhciBkID0gTWF0aC5zcXJ0KHJhZGl1cyA9IGQyKTtcbiAgICAgICAgeDAgPSB4IC0gZCwgeTAgPSB5IC0gZDtcbiAgICAgICAgeDMgPSB4ICsgZCwgeTMgPSB5ICsgZDtcbiAgICAgICAgZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBxdWFkdHJlZX0gZnJvbSBcIi4vcXVhZHRyZWUuanNcIjtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMueDAgPSB4MDtcbiAgdGhpcy55MCA9IHkwO1xuICB0aGlzLngxID0geDE7XG4gIHRoaXMueTEgPSB5MTtcbn1cbiIsImltcG9ydCB0cmVlX2FkZCwge2FkZEFsbCBhcyB0cmVlX2FkZEFsbH0gZnJvbSBcIi4vYWRkLmpzXCI7XG5pbXBvcnQgdHJlZV9jb3ZlciBmcm9tIFwiLi9jb3Zlci5qc1wiO1xuaW1wb3J0IHRyZWVfZGF0YSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgdHJlZV9leHRlbnQgZnJvbSBcIi4vZXh0ZW50LmpzXCI7XG5pbXBvcnQgdHJlZV9maW5kIGZyb20gXCIuL2ZpbmQuanNcIjtcbmltcG9ydCB0cmVlX3JlbW92ZSwge3JlbW92ZUFsbCBhcyB0cmVlX3JlbW92ZUFsbH0gZnJvbSBcIi4vcmVtb3ZlLmpzXCI7XG5pbXBvcnQgdHJlZV9yb290IGZyb20gXCIuL3Jvb3QuanNcIjtcbmltcG9ydCB0cmVlX3NpemUgZnJvbSBcIi4vc2l6ZS5qc1wiO1xuaW1wb3J0IHRyZWVfdmlzaXQgZnJvbSBcIi4vdmlzaXQuanNcIjtcbmltcG9ydCB0cmVlX3Zpc2l0QWZ0ZXIgZnJvbSBcIi4vdmlzaXRBZnRlci5qc1wiO1xuaW1wb3J0IHRyZWVfeCwge2RlZmF1bHRYfSBmcm9tIFwiLi94LmpzXCI7XG5pbXBvcnQgdHJlZV95LCB7ZGVmYXVsdFl9IGZyb20gXCIuL3kuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhZHRyZWUobm9kZXMsIHgsIHkpIHtcbiAgdmFyIHRyZWUgPSBuZXcgUXVhZHRyZWUoeCA9PSBudWxsID8gZGVmYXVsdFggOiB4LCB5ID09IG51bGwgPyBkZWZhdWx0WSA6IHksIE5hTiwgTmFOLCBOYU4sIE5hTik7XG4gIHJldHVybiBub2RlcyA9PSBudWxsID8gdHJlZSA6IHRyZWUuYWRkQWxsKG5vZGVzKTtcbn1cblxuZnVuY3Rpb24gUXVhZHRyZWUoeCwgeSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdGhpcy5feCA9IHg7XG4gIHRoaXMuX3kgPSB5O1xuICB0aGlzLl94MCA9IHgwO1xuICB0aGlzLl95MCA9IHkwO1xuICB0aGlzLl94MSA9IHgxO1xuICB0aGlzLl95MSA9IHkxO1xuICB0aGlzLl9yb290ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBsZWFmX2NvcHkobGVhZikge1xuICB2YXIgY29weSA9IHtkYXRhOiBsZWFmLmRhdGF9LCBuZXh0ID0gY29weTtcbiAgd2hpbGUgKGxlYWYgPSBsZWFmLm5leHQpIG5leHQgPSBuZXh0Lm5leHQgPSB7ZGF0YTogbGVhZi5kYXRhfTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbnZhciB0cmVlUHJvdG8gPSBxdWFkdHJlZS5wcm90b3R5cGUgPSBRdWFkdHJlZS5wcm90b3R5cGU7XG5cbnRyZWVQcm90by5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb3B5ID0gbmV3IFF1YWR0cmVlKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgbm9kZXMsXG4gICAgICBjaGlsZDtcblxuICBpZiAoIW5vZGUpIHJldHVybiBjb3B5O1xuXG4gIGlmICghbm9kZS5sZW5ndGgpIHJldHVybiBjb3B5Ll9yb290ID0gbGVhZl9jb3B5KG5vZGUpLCBjb3B5O1xuXG4gIG5vZGVzID0gW3tzb3VyY2U6IG5vZGUsIHRhcmdldDogY29weS5fcm9vdCA9IG5ldyBBcnJheSg0KX1dO1xuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGUuc291cmNlW2ldKSB7XG4gICAgICAgIGlmIChjaGlsZC5sZW5ndGgpIG5vZGVzLnB1c2goe3NvdXJjZTogY2hpbGQsIHRhcmdldDogbm9kZS50YXJnZXRbaV0gPSBuZXcgQXJyYXkoNCl9KTtcbiAgICAgICAgZWxzZSBub2RlLnRhcmdldFtpXSA9IGxlYWZfY29weShjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59O1xuXG50cmVlUHJvdG8uYWRkID0gdHJlZV9hZGQ7XG50cmVlUHJvdG8uYWRkQWxsID0gdHJlZV9hZGRBbGw7XG50cmVlUHJvdG8uY292ZXIgPSB0cmVlX2NvdmVyO1xudHJlZVByb3RvLmRhdGEgPSB0cmVlX2RhdGE7XG50cmVlUHJvdG8uZXh0ZW50ID0gdHJlZV9leHRlbnQ7XG50cmVlUHJvdG8uZmluZCA9IHRyZWVfZmluZDtcbnRyZWVQcm90by5yZW1vdmUgPSB0cmVlX3JlbW92ZTtcbnRyZWVQcm90by5yZW1vdmVBbGwgPSB0cmVlX3JlbW92ZUFsbDtcbnRyZWVQcm90by5yb290ID0gdHJlZV9yb290O1xudHJlZVByb3RvLnNpemUgPSB0cmVlX3NpemU7XG50cmVlUHJvdG8udmlzaXQgPSB0cmVlX3Zpc2l0O1xudHJlZVByb3RvLnZpc2l0QWZ0ZXIgPSB0cmVlX3Zpc2l0QWZ0ZXI7XG50cmVlUHJvdG8ueCA9IHRyZWVfeDtcbnRyZWVQcm90by55ID0gdHJlZV95O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZCkge1xuICBpZiAoaXNOYU4oeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCkpIHx8IGlzTmFOKHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpKSkgcmV0dXJuIHRoaXM7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciBwYXJlbnQsXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIHJldGFpbmVyLFxuICAgICAgcHJldmlvdXMsXG4gICAgICBuZXh0LFxuICAgICAgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSA9IHRoaXMuX3gxLFxuICAgICAgeTEgPSB0aGlzLl95MSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeG0sXG4gICAgICB5bSxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0aGlzO1xuXG4gIC8vIEZpbmQgdGhlIGxlYWYgbm9kZSBmb3IgdGhlIHBvaW50LlxuICAvLyBXaGlsZSBkZXNjZW5kaW5nLCBhbHNvIHJldGFpbiB0aGUgZGVlcGVzdCBwYXJlbnQgd2l0aCBhIG5vbi1yZW1vdmVkIHNpYmxpbmcuXG4gIGlmIChub2RlLmxlbmd0aCkgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgICBpZiAoIShwYXJlbnQgPSBub2RlLCBub2RlID0gbm9kZVtpID0gYm90dG9tIDw8IDEgfCByaWdodF0pKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBicmVhaztcbiAgICBpZiAocGFyZW50WyhpICsgMSkgJiAzXSB8fCBwYXJlbnRbKGkgKyAyKSAmIDNdIHx8IHBhcmVudFsoaSArIDMpICYgM10pIHJldGFpbmVyID0gcGFyZW50LCBqID0gaTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHBvaW50IHRvIHJlbW92ZS5cbiAgd2hpbGUgKG5vZGUuZGF0YSAhPT0gZCkgaWYgKCEocHJldmlvdXMgPSBub2RlLCBub2RlID0gbm9kZS5uZXh0KSkgcmV0dXJuIHRoaXM7XG4gIGlmIChuZXh0ID0gbm9kZS5uZXh0KSBkZWxldGUgbm9kZS5uZXh0O1xuXG4gIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjb2luY2lkZW50IHBvaW50cywgcmVtb3ZlIGp1c3QgdGhlIHBvaW50LlxuICBpZiAocHJldmlvdXMpIHJldHVybiAobmV4dCA/IHByZXZpb3VzLm5leHQgPSBuZXh0IDogZGVsZXRlIHByZXZpb3VzLm5leHQpLCB0aGlzO1xuXG4gIC8vIElmIHRoaXMgaXMgdGhlIHJvb3QgcG9pbnQsIHJlbW92ZSBpdC5cbiAgaWYgKCFwYXJlbnQpIHJldHVybiB0aGlzLl9yb290ID0gbmV4dCwgdGhpcztcblxuICAvLyBSZW1vdmUgdGhpcyBsZWFmLlxuICBuZXh0ID8gcGFyZW50W2ldID0gbmV4dCA6IGRlbGV0ZSBwYXJlbnRbaV07XG5cbiAgLy8gSWYgdGhlIHBhcmVudCBub3cgY29udGFpbnMgZXhhY3RseSBvbmUgbGVhZiwgY29sbGFwc2Ugc3VwZXJmbHVvdXMgcGFyZW50cy5cbiAgaWYgKChub2RlID0gcGFyZW50WzBdIHx8IHBhcmVudFsxXSB8fCBwYXJlbnRbMl0gfHwgcGFyZW50WzNdKVxuICAgICAgJiYgbm9kZSA9PT0gKHBhcmVudFszXSB8fCBwYXJlbnRbMl0gfHwgcGFyZW50WzFdIHx8IHBhcmVudFswXSlcbiAgICAgICYmICFub2RlLmxlbmd0aCkge1xuICAgIGlmIChyZXRhaW5lcikgcmV0YWluZXJbal0gPSBub2RlO1xuICAgIGVsc2UgdGhpcy5fcm9vdCA9IG5vZGU7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFsbChkYXRhKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGkgPCBuOyArK2kpIHRoaXMucmVtb3ZlKGRhdGFbaV0pO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcm9vdDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgc2l6ZSA9IDA7XG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGRvICsrc2l6ZTsgd2hpbGUgKG5vZGUgPSBub2RlLm5leHQpXG4gIH0pO1xuICByZXR1cm4gc2l6ZTtcbn1cbiIsImltcG9ydCBRdWFkIGZyb20gXCIuL3F1YWQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHF1YWRzID0gW10sIHEsIG5vZGUgPSB0aGlzLl9yb290LCBjaGlsZCwgeDAsIHkwLCB4MSwgeTE7XG4gIGlmIChub2RlKSBxdWFkcy5wdXNoKG5ldyBRdWFkKG5vZGUsIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSk7XG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcbiAgICBpZiAoIWNhbGxiYWNrKG5vZGUgPSBxLm5vZGUsIHgwID0gcS54MCwgeTAgPSBxLnkwLCB4MSA9IHEueDEsIHkxID0gcS55MSkgJiYgbm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciB4bSA9ICh4MCArIHgxKSAvIDIsIHltID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbM10pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5bSwgeDEsIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzJdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeW0sIHhtLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsxXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHkwLCB4MSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMF0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5MCwgeG0sIHltKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiaW1wb3J0IFF1YWQgZnJvbSBcIi4vcXVhZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgcXVhZHMgPSBbXSwgbmV4dCA9IFtdLCBxO1xuICBpZiAodGhpcy5fcm9vdCkgcXVhZHMucHVzaChuZXcgUXVhZCh0aGlzLl9yb290LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpO1xuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG4gICAgdmFyIG5vZGUgPSBxLm5vZGU7XG4gICAgaWYgKG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hpbGQsIHgwID0gcS54MCwgeTAgPSBxLnkwLCB4MSA9IHEueDEsIHkxID0gcS55MSwgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzBdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeTAsIHhtLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsxXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHkwLCB4MSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMl0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5bSwgeG0sIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzNdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeW0sIHgxLCB5MSkpO1xuICAgIH1cbiAgICBuZXh0LnB1c2gocSk7XG4gIH1cbiAgd2hpbGUgKHEgPSBuZXh0LnBvcCgpKSB7XG4gICAgY2FsbGJhY2socS5ub2RlLCBxLngwLCBxLnkwLCBxLngxLCBxLnkxKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0WChkKSB7XG4gIHJldHVybiBkWzBdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX3ggPSBfLCB0aGlzKSA6IHRoaXMuX3g7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZGVmYXVsdFkoZCkge1xuICByZXR1cm4gZFsxXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl95ID0gXywgdGhpcykgOiB0aGlzLl95O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNldE1hdHJpeEFycmF5VHlwZSA9IHNldE1hdHJpeEFycmF5VHlwZTtcbmV4cG9ydHMudG9SYWRpYW4gPSB0b1JhZGlhbjtcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5SQU5ET00gPSBleHBvcnRzLkFSUkFZX1RZUEUgPSBleHBvcnRzLkVQU0lMT04gPSB2b2lkIDA7XG5cbi8qKlxyXG4gKiBDb21tb24gdXRpbGl0aWVzXHJcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcclxuICovXG4vLyBDb25maWd1cmF0aW9uIENvbnN0YW50c1xudmFyIEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydHMuRVBTSUxPTiA9IEVQU0lMT047XG52YXIgQVJSQVlfVFlQRSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5leHBvcnRzLkFSUkFZX1RZUEUgPSBBUlJBWV9UWVBFO1xudmFyIFJBTkRPTSA9IE1hdGgucmFuZG9tO1xuLyoqXHJcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3Rvcn0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxyXG4gKi9cblxuZXhwb3J0cy5SQU5ET00gPSBSQU5ET007XG5cbmZ1bmN0aW9uIHNldE1hdHJpeEFycmF5VHlwZSh0eXBlKSB7XG4gIGV4cG9ydHMuQVJSQVlfVFlQRSA9IEFSUkFZX1RZUEUgPSB0eXBlO1xufVxuXG52YXIgZGVncmVlID0gTWF0aC5QSSAvIDE4MDtcbi8qKlxyXG4gKiBDb252ZXJ0IERlZ3JlZSBUbyBSYWRpYW5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQW5nbGUgaW4gRGVncmVlc1xyXG4gKi9cblxuZnVuY3Rpb24gdG9SYWRpYW4oYSkge1xuICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cbi8qKlxyXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCB0aGUgYXJndW1lbnRzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSB2YWx1ZSwgd2l0aGluIGFuIGFic29sdXRlXHJcbiAqIG9yIHJlbGF0aXZlIHRvbGVyYW5jZSBvZiBnbE1hdHJpeC5FUFNJTE9OIChhbiBhYnNvbHV0ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgdmFsdWVzIGxlc3NcclxuICogdGhhbiBvciBlcXVhbCB0byAxLjAsIGFuZCBhIHJlbGF0aXZlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciBsYXJnZXIgdmFsdWVzKVxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgbnVtYmVyIHRvIHRlc3QuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIHRlc3QuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBudW1iZXJzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYSksIE1hdGguYWJzKGIpKTtcbn1cblxuaWYgKCFNYXRoLmh5cG90KSBNYXRoLmh5cG90ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgeSA9IDAsXG4gICAgICBpID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgeSArPSBhcmd1bWVudHNbaV0gKiBhcmd1bWVudHNbaV07XG4gIH1cblxuICByZXR1cm4gTWF0aC5zcXJ0KHkpO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmZyb21NYXQ0ID0gZnJvbU1hdDQ7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5mcm9tVmFsdWVzID0gZnJvbVZhbHVlcztcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZXhwb3J0cy50cmFuc3Bvc2UgPSB0cmFuc3Bvc2U7XG5leHBvcnRzLmludmVydCA9IGludmVydDtcbmV4cG9ydHMuYWRqb2ludCA9IGFkam9pbnQ7XG5leHBvcnRzLmRldGVybWluYW50ID0gZGV0ZXJtaW5hbnQ7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbmV4cG9ydHMucm90YXRlID0gcm90YXRlO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5mcm9tVHJhbnNsYXRpb24gPSBmcm9tVHJhbnNsYXRpb247XG5leHBvcnRzLmZyb21Sb3RhdGlvbiA9IGZyb21Sb3RhdGlvbjtcbmV4cG9ydHMuZnJvbVNjYWxpbmcgPSBmcm9tU2NhbGluZztcbmV4cG9ydHMuZnJvbU1hdDJkID0gZnJvbU1hdDJkO1xuZXhwb3J0cy5mcm9tUXVhdCA9IGZyb21RdWF0O1xuZXhwb3J0cy5ub3JtYWxGcm9tTWF0NCA9IG5vcm1hbEZyb21NYXQ0O1xuZXhwb3J0cy5wcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcbmV4cG9ydHMuc3RyID0gc3RyO1xuZXhwb3J0cy5mcm9iID0gZnJvYjtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuZXhwb3J0cy5tdWx0aXBseVNjYWxhciA9IG11bHRpcGx5U2NhbGFyO1xuZXhwb3J0cy5tdWx0aXBseVNjYWxhckFuZEFkZCA9IG11bHRpcGx5U2NhbGFyQW5kQWRkO1xuZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4YWN0RXF1YWxzO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5leHBvcnRzLnN1YiA9IGV4cG9ydHMubXVsID0gdm9pZCAwO1xuXG52YXIgZ2xNYXRyaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9jb21tb24uanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKipcclxuICogM3gzIE1hdHJpeFxyXG4gKiBAbW9kdWxlIG1hdDNcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcclxuICpcclxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IDE7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29waWVzIHRoZSB1cHBlci1sZWZ0IDN4MyB2YWx1ZXMgaW50byB0aGUgZ2l2ZW4gbWF0My5cclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyAzeDMgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhICAgdGhlIHNvdXJjZSA0eDQgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbU1hdDQob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbNF07XG4gIG91dFs0XSA9IGFbNV07XG4gIG91dFs1XSA9IGFbNl07XG4gIG91dFs2XSA9IGFbOF07XG4gIG91dFs3XSA9IGFbOV07XG4gIG91dFs4XSA9IGFbMTBdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcclxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDMgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1hdDMgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDUpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDgpXHJcbiAqIEByZXR1cm5zIHttYXQzfSBBIG5ldyBtYXQzXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0xMDtcbiAgb3V0WzRdID0gbTExO1xuICBvdXRbNV0gPSBtMTI7XG4gIG91dFs2XSA9IG0yMDtcbiAgb3V0WzddID0gbTIxO1xuICBvdXRbOF0gPSBtMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MyB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDUpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDgpXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMTA7XG4gIG91dFs0XSA9IG0xMTtcbiAgb3V0WzVdID0gbTEyO1xuICBvdXRbNl0gPSBtMjA7XG4gIG91dFs3XSA9IG0yMTtcbiAgb3V0WzhdID0gbTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgdmFyIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMiA9IGFbNV07XG4gICAgb3V0WzFdID0gYVszXTtcbiAgICBvdXRbMl0gPSBhWzZdO1xuICAgIG91dFszXSA9IGEwMTtcbiAgICBvdXRbNV0gPSBhWzddO1xuICAgIG91dFs2XSA9IGEwMjtcbiAgICBvdXRbN10gPSBhMTI7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzNdO1xuICAgIG91dFsyXSA9IGFbNl07XG4gICAgb3V0WzNdID0gYVsxXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbN107XG4gICAgb3V0WzZdID0gYVsyXTtcbiAgICBvdXRbN10gPSBhWzVdO1xuICAgIG91dFs4XSA9IGFbOF07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICB2YXIgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxO1xuICB2YXIgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMDtcbiAgdmFyIGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMDsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHZhciBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYjAxICogZGV0O1xuICBvdXRbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xuICBvdXRbM10gPSBiMTEgKiBkZXQ7XG4gIG91dFs0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0O1xuICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XG4gIG91dFs2XSA9IGIyMSAqIGRldDtcbiAgb3V0WzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0O1xuICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICBvdXRbMF0gPSBhMTEgKiBhMjIgLSBhMTIgKiBhMjE7XG4gIG91dFsxXSA9IGEwMiAqIGEyMSAtIGEwMSAqIGEyMjtcbiAgb3V0WzJdID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICBvdXRbM10gPSBhMTIgKiBhMjAgLSBhMTAgKiBhMjI7XG4gIG91dFs0XSA9IGEwMCAqIGEyMiAtIGEwMiAqIGEyMDtcbiAgb3V0WzVdID0gYTAyICogYTEwIC0gYTAwICogYTEyO1xuICBvdXRbNl0gPSBhMTAgKiBhMjEgLSBhMTEgKiBhMjA7XG4gIG91dFs3XSA9IGEwMSAqIGEyMCAtIGEwMCAqIGEyMTtcbiAgb3V0WzhdID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICB2YXIgYjAwID0gYlswXSxcbiAgICAgIGIwMSA9IGJbMV0sXG4gICAgICBiMDIgPSBiWzJdO1xuICB2YXIgYjEwID0gYlszXSxcbiAgICAgIGIxMSA9IGJbNF0sXG4gICAgICBiMTIgPSBiWzVdO1xuICB2YXIgYjIwID0gYls2XSxcbiAgICAgIGIyMSA9IGJbN10sXG4gICAgICBiMjIgPSBiWzhdO1xuICBvdXRbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgb3V0WzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gIG91dFs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuICBvdXRbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gIG91dFs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zbGF0ZSBhIG1hdDMgYnkgdGhlIGdpdmVuIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdLFxuICAgICAgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdLFxuICAgICAgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXTtcbiAgb3V0WzBdID0gYTAwO1xuICBvdXRbMV0gPSBhMDE7XG4gIG91dFsyXSA9IGEwMjtcbiAgb3V0WzNdID0gYTEwO1xuICBvdXRbNF0gPSBhMTE7XG4gIG91dFs1XSA9IGExMjtcbiAgb3V0WzZdID0geCAqIGEwMCArIHkgKiBhMTAgKyBhMjA7XG4gIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICBvdXRbOF0gPSB4ICogYTAyICsgeSAqIGExMiArIGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0MyBieSB0aGUgZ2l2ZW4gYW5nbGVcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XSxcbiAgICAgIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XSxcbiAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGMgKiBhMDAgKyBzICogYTEwO1xuICBvdXRbMV0gPSBjICogYTAxICsgcyAqIGExMTtcbiAgb3V0WzJdID0gYyAqIGEwMiArIHMgKiBhMTI7XG4gIG91dFszXSA9IGMgKiBhMTAgLSBzICogYTAwO1xuICBvdXRbNF0gPSBjICogYTExIC0gcyAqIGEwMTtcbiAgb3V0WzVdID0gYyAqIGExMiAtIHMgKiBhMDI7XG4gIG91dFs2XSA9IGEyMDtcbiAgb3V0WzddID0gYTIxO1xuICBvdXRbOF0gPSBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQzIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKiovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdO1xuICBvdXRbMF0gPSB4ICogYVswXTtcbiAgb3V0WzFdID0geCAqIGFbMV07XG4gIG91dFsyXSA9IHggKiBhWzJdO1xuICBvdXRbM10gPSB5ICogYVszXTtcbiAgb3V0WzRdID0geSAqIGFbNF07XG4gIG91dFs1XSA9IHkgKiBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQzLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gdlswXTtcbiAgb3V0WzddID0gdlsxXTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQzLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAtcztcbiAgb3V0WzRdID0gYztcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQzLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gdlsxXTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBmcm9tIGEgbWF0MmQgaW50byBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqKi9cblxuXG5mdW5jdGlvbiBmcm9tTWF0MmQob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IGFbMl07XG4gIG91dFs0XSA9IGFbM107XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IGFbNF07XG4gIG91dFs3XSA9IGFbNV07XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBhIDN4MyBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeXggPSB5ICogeDI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHp4ID0geiAqIHgyO1xuICB2YXIgenkgPSB6ICogeTI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gIG91dFszXSA9IHl4IC0gd3o7XG4gIG91dFs2XSA9IHp4ICsgd3k7XG4gIG91dFsxXSA9IHl4ICsgd3o7XG4gIG91dFs0XSA9IDEgLSB4eCAtIHp6O1xuICBvdXRbN10gPSB6eSAtIHd4O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbNV0gPSB6eSArIHd4O1xuICBvdXRbOF0gPSAxIC0geHggLSB5eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGEgM3gzIG5vcm1hbCBtYXRyaXggKHRyYW5zcG9zZSBpbnZlcnNlKSBmcm9tIHRoZSA0eDQgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgTWF0NCB0byBkZXJpdmUgdGhlIG5vcm1hbCBtYXRyaXggZnJvbVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbEZyb21NYXQ0KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgdmFyIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgdmFyIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgdmFyIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgdmFyIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgdmFyIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgdmFyIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgdmFyIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgdmFyIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgdmFyIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgdmFyIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgdmFyIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgdmFyIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHZhciBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICBvdXRbMl0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFs0XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzZdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gIG91dFs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSAyRCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggb2YgeW91ciBnbCBjb250ZXh0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGdsIGNvbnRleHRcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBwcm9qZWN0aW9uKG91dCwgd2lkdGgsIGhlaWdodCkge1xuICBvdXRbMF0gPSAyIC8gd2lkdGg7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IC0yIC8gaGVpZ2h0O1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAtMTtcbiAgb3V0WzddID0gMTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcIm1hdDMoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIsIFwiICsgYVs0XSArIFwiLCBcIiArIGFbNV0gKyBcIiwgXCIgKyBhWzZdICsgXCIsIFwiICsgYVs3XSArIFwiLCBcIiArIGFbOF0gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguaHlwb3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgYVs2XSwgYVs3XSwgYVs4XSk7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MydzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl0gKiBzY2FsZTtcbiAgb3V0WzddID0gYVs3XSArIGJbN10gKiBzY2FsZTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XSAmJiBhWzhdID09PSBiWzhdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XSxcbiAgICAgIGE2ID0gYVs2XSxcbiAgICAgIGE3ID0gYVs3XSxcbiAgICAgIGE4ID0gYVs4XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXSxcbiAgICAgIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XSxcbiAgICAgIGI2ID0gYls2XSxcbiAgICAgIGI3ID0gYls3XSxcbiAgICAgIGI4ID0gYls4XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJiBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiYgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5tdWwgPSBtdWw7XG52YXIgc3ViID0gc3VidHJhY3Q7XG5leHBvcnRzLnN1YiA9IHN1YjsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0cmluZ3MpIHtcclxuICBpZiAodHlwZW9mIHN0cmluZ3MgPT09ICdzdHJpbmcnKSBzdHJpbmdzID0gW3N0cmluZ3NdXHJcbiAgdmFyIGV4cHJzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSlcclxuICB2YXIgcGFydHMgPSBbXVxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGgtMTsgaSsrKSB7XHJcbiAgICBwYXJ0cy5wdXNoKHN0cmluZ3NbaV0sIGV4cHJzW2ldIHx8ICcnKVxyXG4gIH1cclxuICBwYXJ0cy5wdXNoKHN0cmluZ3NbaV0pXHJcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBldmVudGlmeShzdWJqZWN0KSB7XG4gIHZhbGlkYXRlU3ViamVjdChzdWJqZWN0KTtcblxuICB2YXIgZXZlbnRzU3RvcmFnZSA9IGNyZWF0ZUV2ZW50c1N0b3JhZ2Uoc3ViamVjdCk7XG4gIHN1YmplY3Qub24gPSBldmVudHNTdG9yYWdlLm9uO1xuICBzdWJqZWN0Lm9mZiA9IGV2ZW50c1N0b3JhZ2Uub2ZmO1xuICBzdWJqZWN0LmZpcmUgPSBldmVudHNTdG9yYWdlLmZpcmU7XG4gIHJldHVybiBzdWJqZWN0O1xufTtcblxuZnVuY3Rpb24gY3JlYXRlRXZlbnRzU3RvcmFnZShzdWJqZWN0KSB7XG4gIC8vIFN0b3JlIGFsbCBldmVudCBsaXN0ZW5lcnMgdG8gdGhpcyBoYXNoLiBLZXkgaXMgZXZlbnQgbmFtZSwgdmFsdWUgaXMgYXJyYXlcbiAgLy8gb2YgY2FsbGJhY2sgcmVjb3Jkcy5cbiAgLy9cbiAgLy8gQSBjYWxsYmFjayByZWNvcmQgY29uc2lzdHMgb2YgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIGl0cyBvcHRpb25hbCBjb250ZXh0OlxuICAvLyB7ICdldmVudE5hbWUnID0+IFt7Y2FsbGJhY2s6IGZ1bmN0aW9uLCBjdHg6IG9iamVjdH1dIH1cbiAgdmFyIHJlZ2lzdGVyZWRFdmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJldHVybiB7XG4gICAgb246IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBpcyBleHBlY3RlZCB0byBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgICB2YXIgaGFuZGxlcnMgPSByZWdpc3RlcmVkRXZlbnRzW2V2ZW50TmFtZV07XG4gICAgICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgICAgIGhhbmRsZXJzID0gcmVnaXN0ZXJlZEV2ZW50c1tldmVudE5hbWVdID0gW107XG4gICAgICB9XG4gICAgICBoYW5kbGVycy5wdXNoKHtjYWxsYmFjazogY2FsbGJhY2ssIGN0eDogY3R4fSk7XG5cbiAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH0sXG5cbiAgICBvZmY6IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgd2FudFRvUmVtb3ZlQWxsID0gKHR5cGVvZiBldmVudE5hbWUgPT09ICd1bmRlZmluZWQnKTtcbiAgICAgIGlmICh3YW50VG9SZW1vdmVBbGwpIHtcbiAgICAgICAgLy8gS2lsbGluZyBvbGQgZXZlbnRzIHN0b3JhZ2Ugc2hvdWxkIGJlIGVub3VnaCBpbiB0aGlzIGNhc2U6XG4gICAgICAgIHJlZ2lzdGVyZWRFdmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZ2lzdGVyZWRFdmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICB2YXIgZGVsZXRlQWxsQ2FsbGJhY2tzRm9yRXZlbnQgPSAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKTtcbiAgICAgICAgaWYgKGRlbGV0ZUFsbENhbGxiYWNrc0ZvckV2ZW50KSB7XG4gICAgICAgICAgZGVsZXRlIHJlZ2lzdGVyZWRFdmVudHNbZXZlbnROYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gcmVnaXN0ZXJlZEV2ZW50c1tldmVudE5hbWVdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tzW2ldLmNhbGxiYWNrID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3ViamVjdDtcbiAgICB9LFxuXG4gICAgZmlyZTogZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgdmFyIGNhbGxiYWNrcyA9IHJlZ2lzdGVyZWRFdmVudHNbZXZlbnROYW1lXTtcbiAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyZUFyZ3VtZW50cztcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmaXJlQXJndW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICB9XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjYWxsYmFja0luZm8gPSBjYWxsYmFja3NbaV07XG4gICAgICAgIGNhbGxiYWNrSW5mby5jYWxsYmFjay5hcHBseShjYWxsYmFja0luZm8uY3R4LCBmaXJlQXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN1YmplY3Qoc3ViamVjdCkge1xuICBpZiAoIXN1YmplY3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50aWZ5IGNhbm5vdCB1c2UgZmFsc3kgb2JqZWN0IGFzIGV2ZW50cyBzdWJqZWN0Jyk7XG4gIH1cbiAgdmFyIHJlc2VydmVkV29yZHMgPSBbJ29uJywgJ2ZpcmUnLCAnb2ZmJ107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzZXJ2ZWRXb3Jkcy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChzdWJqZWN0Lmhhc093blByb3BlcnR5KHJlc2VydmVkV29yZHNbaV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJqZWN0IGNhbm5vdCBiZSBldmVudGlmaWVkLCBzaW5jZSBpdCBhbHJlYWR5IGhhcyBwcm9wZXJ0eSAnXCIgKyByZXNlcnZlZFdvcmRzW2ldICsgXCInXCIpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IENvbnRhaW5zIGRlZmluaXRpb24gb2YgdGhlIGNvcmUgZ3JhcGggb2JqZWN0LlxuICovXG5cbi8vIFRPRE86IG5lZWQgdG8gY2hhbmdlIHN0b3JhZ2UgbGF5ZXI6XG4vLyAxLiBCZSBhYmxlIHRvIGdldCBhbGwgbm9kZXMgTygxKVxuLy8gMi4gQmUgYWJsZSB0byBnZXQgbnVtYmVyIG9mIGxpbmtzIE8oMSlcblxuLyoqXG4gKiBAZXhhbXBsZVxuICogIHZhciBncmFwaCA9IHJlcXVpcmUoJ25ncmFwaC5ncmFwaCcpKCk7XG4gKiAgZ3JhcGguYWRkTm9kZSgxKTsgICAgIC8vIGdyYXBoIGhhcyBvbmUgbm9kZS5cbiAqICBncmFwaC5hZGRMaW5rKDIsIDMpOyAgLy8gbm93IGdyYXBoIGNvbnRhaW5zIHRocmVlIG5vZGVzIGFuZCBvbmUgbGluay5cbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlR3JhcGg7XG5cbnZhciBldmVudGlmeSA9IHJlcXVpcmUoJ25ncmFwaC5ldmVudHMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGdyYXBoXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUdyYXBoKG9wdGlvbnMpIHtcbiAgLy8gR3JhcGggc3RydWN0dXJlIGlzIG1haW50YWluZWQgYXMgZGljdGlvbmFyeSBvZiBub2Rlc1xuICAvLyBhbmQgYXJyYXkgb2YgbGlua3MuIEVhY2ggbm9kZSBoYXMgJ2xpbmtzJyBwcm9wZXJ0eSB3aGljaFxuICAvLyBob2xkIGFsbCBsaW5rcyByZWxhdGVkIHRvIHRoYXQgbm9kZS4gQW5kIGdlbmVyYWwgbGlua3NcbiAgLy8gYXJyYXkgaXMgdXNlZCB0byBzcGVlZCB1cCBhbGwgbGlua3MgZW51bWVyYXRpb24uIFRoaXMgaXMgaW5lZmZpY2llbnRcbiAgLy8gaW4gdGVybXMgb2YgbWVtb3J5LCBidXQgc2ltcGxpZmllcyBjb2RpbmcuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoJ3VuaXF1ZUxpbmtJZCcgaW4gb3B0aW9ucykge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICduZ3JhcGguZ3JhcGg6IFN0YXJ0aW5nIGZyb20gdmVyc2lvbiAwLjE0IGB1bmlxdWVMaW5rSWRgIGlzIGRlcHJlY2F0ZWQuXFxuJyArXG4gICAgICAnVXNlIGBtdWx0aWdyYXBoYCBvcHRpb24gaW5zdGVhZFxcbicsXG4gICAgICAnXFxuJyxcbiAgICAgICdOb3RlOiB0aGVyZSBpcyBhbHNvIGNoYW5nZSBpbiBkZWZhdWx0IGJlaGF2aW9yOiBGcm9tIG5vdyBvbiBlYWNoIGdyYXBoXFxuJytcbiAgICAgICdpcyBjb25zaWRlcmVkIHRvIGJlIG5vdCBhIG11bHRpZ3JhcGggYnkgZGVmYXVsdCAoZWFjaCBlZGdlIGlzIHVuaXF1ZSkuJ1xuICAgICk7XG5cbiAgICBvcHRpb25zLm11bHRpZ3JhcGggPSBvcHRpb25zLnVuaXF1ZUxpbmtJZDtcbiAgfVxuXG4gIC8vIERlYXIgcmVhZGVyLCB0aGUgbm9uLW11bHRpZ3JhcGhzIGRvIG5vdCBndWFyYW50ZWUgdGhhdCB0aGVyZSBpcyBvbmx5XG4gIC8vIG9uZSBsaW5rIGZvciBhIGdpdmVuIHBhaXIgb2Ygbm9kZS4gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQgdG8gZmFsc2VcbiAgLy8gd2UgY2FuIHNhdmUgc29tZSBtZW1vcnkgYW5kIENQVSAoMTglIGZhc3RlciBmb3Igbm9uLW11bHRpZ3JhcGgpO1xuICBpZiAob3B0aW9ucy5tdWx0aWdyYXBoID09PSB1bmRlZmluZWQpIG9wdGlvbnMubXVsdGlncmFwaCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgTWFwICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVE9ETzogU2hvdWxkIHdlIHBvbHlmaWxsIGl0IG91cnNlbHZlcz8gV2UgZG9uJ3QgdXNlIG11Y2ggb3BlcmF0aW9ucyB0aGVyZS4uXG4gICAgdGhyb3cgbmV3IEVycm9yKCduZ3JhcGguZ3JhcGggcmVxdWlyZXMgYE1hcGAgdG8gYmUgZGVmaW5lZC4gUGxlYXNlIHBvbHlmaWxsIGl0IGJlZm9yZSB1c2luZyBuZ3JhcGgnKTtcbiAgfSBcblxuICB2YXIgbm9kZXMgPSBuZXcgTWFwKCk7XG4gIHZhciBsaW5rcyA9IFtdLFxuICAgIC8vIEhhc2ggb2YgbXVsdGktZWRnZXMuIFVzZWQgdG8gdHJhY2sgaWRzIG9mIGVkZ2VzIGJldHdlZW4gc2FtZSBub2Rlc1xuICAgIG11bHRpRWRnZXMgPSB7fSxcbiAgICBzdXNwZW5kRXZlbnRzID0gMCxcblxuICAgIGNyZWF0ZUxpbmsgPSBvcHRpb25zLm11bHRpZ3JhcGggPyBjcmVhdGVVbmlxdWVMaW5rIDogY3JlYXRlU2luZ2xlTGluayxcblxuICAgIC8vIE91ciBncmFwaCBBUEkgcHJvdmlkZXMgbWVhbnMgdG8gbGlzdGVuIHRvIGdyYXBoIGNoYW5nZXMuIFVzZXJzIGNhbiBzdWJzY3JpYmVcbiAgICAvLyB0byBiZSBub3RpZmllZCBhYm91dCBjaGFuZ2VzIGluIHRoZSBncmFwaCBieSB1c2luZyBgb25gIG1ldGhvZC4gSG93ZXZlclxuICAgIC8vIGluIHNvbWUgY2FzZXMgdGhleSBkb24ndCB1c2UgaXQuIFRvIGF2b2lkIHVubmVjZXNzYXJ5IG1lbW9yeSBjb25zdW1wdGlvblxuICAgIC8vIHdlIHdpbGwgbm90IHJlY29yZCBncmFwaCBjaGFuZ2VzIHVudGlsIHdlIGhhdmUgYXQgbGVhc3Qgb25lIHN1YnNjcmliZXIuXG4gICAgLy8gQ29kZSBiZWxvdyBzdXBwb3J0cyB0aGlzIG9wdGltaXphdGlvbi5cbiAgICAvL1xuICAgIC8vIEFjY3VtdWxhdGVzIGFsbCBjaGFuZ2VzIG1hZGUgZHVyaW5nIGdyYXBoIHVwZGF0ZXMuXG4gICAgLy8gRWFjaCBjaGFuZ2UgZWxlbWVudCBjb250YWluczpcbiAgICAvLyAgY2hhbmdlVHlwZSAtIG9uZSBvZiB0aGUgc3RyaW5nczogJ2FkZCcsICdyZW1vdmUnIG9yICd1cGRhdGUnO1xuICAgIC8vICBub2RlIC0gaWYgY2hhbmdlIGlzIHJlbGF0ZWQgdG8gbm9kZSB0aGlzIHByb3BlcnR5IGlzIHNldCB0byBjaGFuZ2VkIGdyYXBoJ3Mgbm9kZTtcbiAgICAvLyAgbGluayAtIGlmIGNoYW5nZSBpcyByZWxhdGVkIHRvIGxpbmsgdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gY2hhbmdlZCBncmFwaCdzIGxpbms7XG4gICAgY2hhbmdlcyA9IFtdLFxuICAgIHJlY29yZExpbmtDaGFuZ2UgPSBub29wLFxuICAgIHJlY29yZE5vZGVDaGFuZ2UgPSBub29wLFxuICAgIGVudGVyTW9kaWZpY2F0aW9uID0gbm9vcCxcbiAgICBleGl0TW9kaWZpY2F0aW9uID0gbm9vcDtcblxuICAvLyB0aGlzIGlzIG91ciBwdWJsaWMgQVBJOlxuICB2YXIgZ3JhcGhQYXJ0ID0ge1xuICAgIC8qKlxuICAgICAqIEFkZHMgbm9kZSB0byB0aGUgZ3JhcGguIElmIG5vZGUgd2l0aCBnaXZlbiBpZCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZ3JhcGhcbiAgICAgKiBpdHMgZGF0YSBpcyBleHRlbmRlZCB3aXRoIHdoYXRldmVyIGNvbWVzIGluICdkYXRhJyBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlSWQgdGhlIG5vZGUncyBpZGVudGlmaWVyLiBBIHN0cmluZyBvciBudW1iZXIgaXMgcHJlZmVycmVkLlxuICAgICAqIEBwYXJhbSBbZGF0YV0gYWRkaXRpb25hbCBkYXRhIGZvciB0aGUgbm9kZSBiZWluZyBhZGRlZC4gSWYgbm9kZSBhbHJlYWR5XG4gICAgICogICBleGlzdHMgaXRzIGRhdGEgb2JqZWN0IGlzIGF1Z21lbnRlZCB3aXRoIHRoZSBuZXcgb25lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7bm9kZX0gVGhlIG5ld2x5IGFkZGVkIG5vZGUgb3Igbm9kZSB3aXRoIGdpdmVuIGlkIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgICAqL1xuICAgIGFkZE5vZGU6IGFkZE5vZGUsXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGluayB0byB0aGUgZ3JhcGguIFRoZSBmdW5jdGlvbiBhbHdheXMgY3JlYXRlIGEgbmV3XG4gICAgICogbGluayBiZXR3ZWVuIHR3byBub2Rlcy4gSWYgb25lIG9mIHRoZSBub2RlcyBkb2VzIG5vdCBleGlzdHNcbiAgICAgKiBhIG5ldyBub2RlIGlzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbUlkIGxpbmsgc3RhcnQgbm9kZSBpZDtcbiAgICAgKiBAcGFyYW0gdG9JZCBsaW5rIGVuZCBub2RlIGlkO1xuICAgICAqIEBwYXJhbSBbZGF0YV0gYWRkaXRpb25hbCBkYXRhIHRvIGJlIHNldCBvbiB0aGUgbmV3IGxpbms7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtsaW5rfSBUaGUgbmV3bHkgY3JlYXRlZCBsaW5rXG4gICAgICovXG4gICAgYWRkTGluazogYWRkTGluayxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGluayBmcm9tIHRoZSBncmFwaC4gSWYgbGluayBkb2VzIG5vdCBleGlzdCBkb2VzIG5vdGhpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGluayAtIG9iamVjdCByZXR1cm5lZCBieSBhZGRMaW5rKCkgb3IgZ2V0TGlua3MoKSBtZXRob2RzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBsaW5rIHdhcyByZW1vdmVkOyBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVtb3ZlTGluazogcmVtb3ZlTGluayxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbm9kZSB3aXRoIGdpdmVuIGlkIGZyb20gdGhlIGdyYXBoLiBJZiBub2RlIGRvZXMgbm90IGV4aXN0IGluIHRoZSBncmFwaFxuICAgICAqIGRvZXMgbm90aGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlSWQgbm9kZSdzIGlkZW50aWZpZXIgcGFzc2VkIHRvIGFkZE5vZGUoKSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgbm9kZSB3YXMgcmVtb3ZlZDsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlbW92ZU5vZGU6IHJlbW92ZU5vZGUsXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG5vZGUgd2l0aCBnaXZlbiBpZGVudGlmaWVyLiBJZiBub2RlIGRvZXMgbm90IGV4aXN0IHVuZGVmaW5lZCB2YWx1ZSBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlSWQgcmVxdWVzdGVkIG5vZGUgaWRlbnRpZmllcjtcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge25vZGV9IGluIHdpdGggcmVxdWVzdGVkIGlkZW50aWZpZXIgb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2ggbm9kZSBleGlzdHMuXG4gICAgICovXG4gICAgZ2V0Tm9kZTogZ2V0Tm9kZSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgbnVtYmVyIG9mIG5vZGVzIGluIHRoaXMgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBub2RlcyBpbiB0aGUgZ3JhcGguXG4gICAgICovXG4gICAgZ2V0Tm9kZUNvdW50OiBnZXROb2RlQ291bnQsXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRvdGFsIG51bWJlciBvZiBsaW5rcyBpbiB0aGUgZ3JhcGguXG4gICAgICovXG4gICAgZ2V0TGlua0NvdW50OiBnZXRMaW5rQ291bnQsXG5cbiAgICAvKipcbiAgICAgKiBTeW5vbnltIGZvciBgZ2V0TGlua0NvdW50KClgXG4gICAgICovXG4gICAgZ2V0TGlua3NDb3VudDogZ2V0TGlua0NvdW50LFxuICAgIFxuICAgIC8qKlxuICAgICAqIFN5bm9ueW0gZm9yIGBnZXROb2RlQ291bnQoKWBcbiAgICAgKi9cbiAgICBnZXROb2Rlc0NvdW50OiBnZXROb2RlQ291bnQsXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBsaW5rcyAoaW5ib3VuZCBhbmQgb3V0Ym91bmQpIGZyb20gdGhlIG5vZGUgd2l0aCBnaXZlbiBpZC5cbiAgICAgKiBJZiBub2RlIHdpdGggZ2l2ZW4gaWQgaXMgbm90IGZvdW5kIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZUlkIHJlcXVlc3RlZCBub2RlIGlkZW50aWZpZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFycmF5IG9mIGxpbmtzIGZyb20gYW5kIHRvIHJlcXVlc3RlZCBub2RlIGlmIHN1Y2ggbm9kZSBleGlzdHM7XG4gICAgICogICBvdGhlcndpc2UgbnVsbCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXRMaW5rczogZ2V0TGlua3MsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGNhbGxiYWNrIG9uIGVhY2ggbm9kZSBvZiB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uKG5vZGUpfSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBpbnZva2VkLiBUaGUgZnVuY3Rpb25cbiAgICAgKiAgIGlzIHBhc3NlZCBvbmUgYXJndW1lbnQ6IHZpc2l0ZWQgbm9kZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoTm9kZTogZm9yRWFjaE5vZGUsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGNhbGxiYWNrIG9uIGV2ZXJ5IGxpbmtlZCAoYWRqYWNlbnQpIG5vZGUgdG8gdGhlIGdpdmVuIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlSWQgSWRlbnRpZmllciBvZiB0aGUgcmVxdWVzdGVkIG5vZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbihub2RlLCBsaW5rKX0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGFsbCBsaW5rZWQgbm9kZXMuXG4gICAgICogICBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkIHR3byBwYXJhbWV0ZXJzOiBhZGphY2VudCBub2RlIGFuZCBsaW5rIG9iamVjdCBpdHNlbGYuXG4gICAgICogQHBhcmFtIG9yaWVudGVkIGlmIHRydWUgZ3JhcGggdHJlYXRlZCBhcyBvcmllbnRlZC5cbiAgICAgKi9cbiAgICBmb3JFYWNoTGlua2VkTm9kZTogZm9yRWFjaExpbmtlZE5vZGUsXG5cbiAgICAvKipcbiAgICAgKiBFbnVtZXJhdGVzIGFsbCBsaW5rcyBpbiB0aGUgZ3JhcGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb24obGluayl9IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhbGwgbGlua3MgaW4gdGhlIGdyYXBoLlxuICAgICAqICAgVGhlIGZ1bmN0aW9uIGlzIHBhc3NlZCBvbmUgcGFyYW1ldGVyOiBncmFwaCdzIGxpbmsgb2JqZWN0LlxuICAgICAqXG4gICAgICogTGluayBvYmplY3QgY29udGFpbnMgYXQgbGVhc3QgdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gICAgICogIGZyb21JZCAtIG5vZGUgaWQgd2hlcmUgbGluayBzdGFydHM7XG4gICAgICogIHRvSWQgLSBub2RlIGlkIHdoZXJlIGxpbmsgZW5kcyxcbiAgICAgKiAgZGF0YSAtIGFkZGl0aW9uYWwgZGF0YSBwYXNzZWQgdG8gZ3JhcGguYWRkTGluaygpIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmb3JFYWNoTGluazogZm9yRWFjaExpbmssXG5cbiAgICAvKipcbiAgICAgKiBTdXNwZW5kIGFsbCBub3RpZmljYXRpb25zIGFib3V0IGdyYXBoIGNoYW5nZXMgdW50aWxcbiAgICAgKiBlbmRVcGRhdGUgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIGJlZ2luVXBkYXRlOiBlbnRlck1vZGlmaWNhdGlvbixcblxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgYWxsIG5vdGlmaWNhdGlvbnMgYWJvdXQgZ3JhcGggY2hhbmdlcyBhbmQgZmlyZXNcbiAgICAgKiBncmFwaCAnY2hhbmdlZCcgZXZlbnQgaW4gY2FzZSB0aGVyZSBhcmUgYW55IHBlbmRpbmcgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBlbmRVcGRhdGU6IGV4aXRNb2RpZmljYXRpb24sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBub2RlcyBhbmQgbGlua3MgZnJvbSB0aGUgZ3JhcGguXG4gICAgICovXG4gICAgY2xlYXI6IGNsZWFyLFxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyB3aGV0aGVyIHRoZXJlIGlzIGEgbGluayBiZXR3ZWVuIHR3byBub2Rlcy5cbiAgICAgKiBPcGVyYXRpb24gY29tcGxleGl0eSBpcyBPKG4pIHdoZXJlIG4gLSBudW1iZXIgb2YgbGlua3Mgb2YgYSBub2RlLlxuICAgICAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gaXMgc3lub25pbSBmb3IgZ2V0TGluaygpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBsaW5rIGlmIHRoZXJlIGlzIG9uZS4gbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaGFzTGluazogZ2V0TGluayxcblxuICAgIC8qKlxuICAgICAqIERldGVjdHMgd2hldGhlciB0aGVyZSBpcyBhIG5vZGUgd2l0aCBnaXZlbiBpZFxuICAgICAqIFxuICAgICAqIE9wZXJhdGlvbiBjb21wbGV4aXR5IGlzIE8oMSlcbiAgICAgKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIGlzIHN5bm9uaW0gZm9yIGdldE5vZGUoKVxuICAgICAqXG4gICAgICogQHJldHVybnMgbm9kZSBpZiB0aGVyZSBpcyBvbmU7IEZhbHN5IHZhbHVlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBoYXNOb2RlOiBnZXROb2RlLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBlZGdlIGJldHdlZW4gdHdvIG5vZGVzLlxuICAgICAqIE9wZXJhdGlvbiBjb21wbGV4aXR5IGlzIE8obikgd2hlcmUgbiAtIG51bWJlciBvZiBsaW5rcyBvZiBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbUlkIGxpbmsgc3RhcnQgaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b0lkIGxpbmsgZW5kIGlkZW50aWZpZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGxpbmsgaWYgdGhlcmUgaXMgb25lLiBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXRMaW5rOiBnZXRMaW5rXG4gIH07XG5cbiAgLy8gdGhpcyB3aWxsIGFkZCBgb24oKWAgYW5kIGBmaXJlKClgIG1ldGhvZHMuXG4gIGV2ZW50aWZ5KGdyYXBoUGFydCk7XG5cbiAgbW9uaXRvclN1YnNjcmliZXJzKCk7XG5cbiAgcmV0dXJuIGdyYXBoUGFydDtcblxuICBmdW5jdGlvbiBtb25pdG9yU3Vic2NyaWJlcnMoKSB7XG4gICAgdmFyIHJlYWxPbiA9IGdyYXBoUGFydC5vbjtcblxuICAgIC8vIHJlcGxhY2UgcmVhbCBgb25gIHdpdGggb3VyIHRlbXBvcmFyeSBvbiwgd2hpY2ggd2lsbCB0cmlnZ2VyIGNoYW5nZVxuICAgIC8vIG1vZGlmaWNhdGlvbiBtb25pdG9yaW5nOlxuICAgIGdyYXBoUGFydC5vbiA9IG9uO1xuXG4gICAgZnVuY3Rpb24gb24oKSB7XG4gICAgICAvLyBub3cgaXQncyB0aW1lIHRvIHN0YXJ0IHRyYWNraW5nIHN0dWZmOlxuICAgICAgZ3JhcGhQYXJ0LmJlZ2luVXBkYXRlID0gZW50ZXJNb2RpZmljYXRpb24gPSBlbnRlck1vZGlmaWNhdGlvblJlYWw7XG4gICAgICBncmFwaFBhcnQuZW5kVXBkYXRlID0gZXhpdE1vZGlmaWNhdGlvbiA9IGV4aXRNb2RpZmljYXRpb25SZWFsO1xuICAgICAgcmVjb3JkTGlua0NoYW5nZSA9IHJlY29yZExpbmtDaGFuZ2VSZWFsO1xuICAgICAgcmVjb3JkTm9kZUNoYW5nZSA9IHJlY29yZE5vZGVDaGFuZ2VSZWFsO1xuXG4gICAgICAvLyB0aGlzIHdpbGwgcmVwbGFjZSBjdXJyZW50IGBvbmAgbWV0aG9kIHdpdGggcmVhbCBwdWIvc3ViIGZyb20gYGV2ZW50aWZ5YC5cbiAgICAgIGdyYXBoUGFydC5vbiA9IHJlYWxPbjtcbiAgICAgIC8vIGRlbGVnYXRlIHRvIHJlYWwgYG9uYCBoYW5kbGVyOlxuICAgICAgcmV0dXJuIHJlYWxPbi5hcHBseShncmFwaFBhcnQsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkTGlua0NoYW5nZVJlYWwobGluaywgY2hhbmdlVHlwZSkge1xuICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICBsaW5rOiBsaW5rLFxuICAgICAgY2hhbmdlVHlwZTogY2hhbmdlVHlwZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkTm9kZUNoYW5nZVJlYWwobm9kZSwgY2hhbmdlVHlwZSkge1xuICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICBub2RlOiBub2RlLFxuICAgICAgY2hhbmdlVHlwZTogY2hhbmdlVHlwZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTm9kZShub2RlSWQsIGRhdGEpIHtcbiAgICBpZiAobm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBub2RlIGlkZW50aWZpZXInKTtcbiAgICB9XG5cbiAgICBlbnRlck1vZGlmaWNhdGlvbigpO1xuXG4gICAgdmFyIG5vZGUgPSBnZXROb2RlKG5vZGVJZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICBub2RlID0gbmV3IE5vZGUobm9kZUlkLCBkYXRhKTtcbiAgICAgIHJlY29yZE5vZGVDaGFuZ2Uobm9kZSwgJ2FkZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRhdGEgPSBkYXRhO1xuICAgICAgcmVjb3JkTm9kZUNoYW5nZShub2RlLCAndXBkYXRlJyk7XG4gICAgfVxuXG4gICAgbm9kZXMuc2V0KG5vZGVJZCwgbm9kZSk7XG5cbiAgICBleGl0TW9kaWZpY2F0aW9uKCk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROb2RlKG5vZGVJZCkge1xuICAgIHJldHVybiBub2Rlcy5nZXQobm9kZUlkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZUlkKSB7XG4gICAgdmFyIG5vZGUgPSBnZXROb2RlKG5vZGVJZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZW50ZXJNb2RpZmljYXRpb24oKTtcblxuICAgIHZhciBwcmV2TGlua3MgPSBub2RlLmxpbmtzO1xuICAgIGlmIChwcmV2TGlua3MpIHtcbiAgICAgIG5vZGUubGlua3MgPSBudWxsO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHByZXZMaW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICByZW1vdmVMaW5rKHByZXZMaW5rc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZXMuZGVsZXRlKG5vZGVJZClcblxuICAgIHJlY29yZE5vZGVDaGFuZ2Uobm9kZSwgJ3JlbW92ZScpO1xuXG4gICAgZXhpdE1vZGlmaWNhdGlvbigpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGFkZExpbmsoZnJvbUlkLCB0b0lkLCBkYXRhKSB7XG4gICAgZW50ZXJNb2RpZmljYXRpb24oKTtcblxuICAgIHZhciBmcm9tTm9kZSA9IGdldE5vZGUoZnJvbUlkKSB8fCBhZGROb2RlKGZyb21JZCk7XG4gICAgdmFyIHRvTm9kZSA9IGdldE5vZGUodG9JZCkgfHwgYWRkTm9kZSh0b0lkKTtcblxuICAgIHZhciBsaW5rID0gY3JlYXRlTGluayhmcm9tSWQsIHRvSWQsIGRhdGEpO1xuXG4gICAgbGlua3MucHVzaChsaW5rKTtcblxuICAgIC8vIFRPRE86IHRoaXMgaXMgbm90IGNvb2wuIE9uIGxhcmdlIGdyYXBocyBwb3RlbnRpYWxseSB3b3VsZCBjb25zdW1lIG1vcmUgbWVtb3J5LlxuICAgIGFkZExpbmtUb05vZGUoZnJvbU5vZGUsIGxpbmspO1xuICAgIGlmIChmcm9tSWQgIT09IHRvSWQpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBhcmUgbm90IGR1cGxpY2F0aW5nIGxpbmtzIGZvciBzZWxmLWxvb3BzXG4gICAgICBhZGRMaW5rVG9Ob2RlKHRvTm9kZSwgbGluayk7XG4gICAgfVxuXG4gICAgcmVjb3JkTGlua0NoYW5nZShsaW5rLCAnYWRkJyk7XG5cbiAgICBleGl0TW9kaWZpY2F0aW9uKCk7XG5cbiAgICByZXR1cm4gbGluaztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNpbmdsZUxpbmsoZnJvbUlkLCB0b0lkLCBkYXRhKSB7XG4gICAgdmFyIGxpbmtJZCA9IG1ha2VMaW5rSWQoZnJvbUlkLCB0b0lkKTtcbiAgICByZXR1cm4gbmV3IExpbmsoZnJvbUlkLCB0b0lkLCBkYXRhLCBsaW5rSWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pcXVlTGluayhmcm9tSWQsIHRvSWQsIGRhdGEpIHtcbiAgICAvLyBUT0RPOiBHZXQgcmlkIG9mIHRoaXMgbWV0aG9kLlxuICAgIHZhciBsaW5rSWQgPSBtYWtlTGlua0lkKGZyb21JZCwgdG9JZCk7XG4gICAgdmFyIGlzTXVsdGlFZGdlID0gbXVsdGlFZGdlcy5oYXNPd25Qcm9wZXJ0eShsaW5rSWQpO1xuICAgIGlmIChpc011bHRpRWRnZSB8fCBnZXRMaW5rKGZyb21JZCwgdG9JZCkpIHtcbiAgICAgIGlmICghaXNNdWx0aUVkZ2UpIHtcbiAgICAgICAgbXVsdGlFZGdlc1tsaW5rSWRdID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciBzdWZmaXggPSAnQCcgKyAoKyttdWx0aUVkZ2VzW2xpbmtJZF0pO1xuICAgICAgbGlua0lkID0gbWFrZUxpbmtJZChmcm9tSWQgKyBzdWZmaXgsIHRvSWQgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTGluayhmcm9tSWQsIHRvSWQsIGRhdGEsIGxpbmtJZCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROb2RlQ291bnQoKSB7XG4gICAgcmV0dXJuIG5vZGVzLnNpemU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5rQ291bnQoKSB7XG4gICAgcmV0dXJuIGxpbmtzLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExpbmtzKG5vZGVJZCkge1xuICAgIHZhciBub2RlID0gZ2V0Tm9kZShub2RlSWQpO1xuICAgIHJldHVybiBub2RlID8gbm9kZS5saW5rcyA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaW5rKGxpbmspIHtcbiAgICBpZiAoIWxpbmspIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGlkeCA9IGluZGV4T2ZFbGVtZW50SW5BcnJheShsaW5rLCBsaW5rcyk7XG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBlbnRlck1vZGlmaWNhdGlvbigpO1xuXG4gICAgbGlua3Muc3BsaWNlKGlkeCwgMSk7XG5cbiAgICB2YXIgZnJvbU5vZGUgPSBnZXROb2RlKGxpbmsuZnJvbUlkKTtcbiAgICB2YXIgdG9Ob2RlID0gZ2V0Tm9kZShsaW5rLnRvSWQpO1xuXG4gICAgaWYgKGZyb21Ob2RlKSB7XG4gICAgICBpZHggPSBpbmRleE9mRWxlbWVudEluQXJyYXkobGluaywgZnJvbU5vZGUubGlua3MpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIGZyb21Ob2RlLmxpbmtzLnNwbGljZShpZHgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b05vZGUpIHtcbiAgICAgIGlkeCA9IGluZGV4T2ZFbGVtZW50SW5BcnJheShsaW5rLCB0b05vZGUubGlua3MpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHRvTm9kZS5saW5rcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWNvcmRMaW5rQ2hhbmdlKGxpbmssICdyZW1vdmUnKTtcblxuICAgIGV4aXRNb2RpZmljYXRpb24oKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGluayhmcm9tTm9kZUlkLCB0b05vZGVJZCkge1xuICAgIC8vIFRPRE86IFVzZSBzb3J0ZWQgbGlua3MgdG8gc3BlZWQgdGhpcyB1cFxuICAgIHZhciBub2RlID0gZ2V0Tm9kZShmcm9tTm9kZUlkKSxcbiAgICAgIGk7XG4gICAgaWYgKCFub2RlIHx8ICFub2RlLmxpbmtzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5saW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmsgPSBub2RlLmxpbmtzW2ldO1xuICAgICAgaWYgKGxpbmsuZnJvbUlkID09PSBmcm9tTm9kZUlkICYmIGxpbmsudG9JZCA9PT0gdG9Ob2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7IC8vIG5vIGxpbmsuXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBlbnRlck1vZGlmaWNhdGlvbigpO1xuICAgIGZvckVhY2hOb2RlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJlbW92ZU5vZGUobm9kZS5pZCk7XG4gICAgfSk7XG4gICAgZXhpdE1vZGlmaWNhdGlvbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9yRWFjaExpbmsoY2FsbGJhY2spIHtcbiAgICB2YXIgaSwgbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGxpbmtzLmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNhbGxiYWNrKGxpbmtzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3JFYWNoTGlua2VkTm9kZShub2RlSWQsIGNhbGxiYWNrLCBvcmllbnRlZCkge1xuICAgIHZhciBub2RlID0gZ2V0Tm9kZShub2RlSWQpO1xuXG4gICAgaWYgKG5vZGUgJiYgbm9kZS5saW5rcyAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChvcmllbnRlZCkge1xuICAgICAgICByZXR1cm4gZm9yRWFjaE9yaWVudGVkTGluayhub2RlLmxpbmtzLCBub2RlSWQsIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmb3JFYWNoTm9uT3JpZW50ZWRMaW5rKG5vZGUubGlua3MsIG5vZGVJZCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvckVhY2hOb25PcmllbnRlZExpbmsobGlua3MsIG5vZGVJZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcXVpdEZhc3Q7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmsgPSBsaW5rc1tpXTtcbiAgICAgIHZhciBsaW5rZWROb2RlSWQgPSBsaW5rLmZyb21JZCA9PT0gbm9kZUlkID8gbGluay50b0lkIDogbGluay5mcm9tSWQ7XG5cbiAgICAgIHF1aXRGYXN0ID0gY2FsbGJhY2sobm9kZXMuZ2V0KGxpbmtlZE5vZGVJZCksIGxpbmspO1xuICAgICAgaWYgKHF1aXRGYXN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBDbGllbnQgZG9lcyBub3QgbmVlZCBtb3JlIGl0ZXJhdGlvbnMuIEJyZWFrIG5vdy5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3JFYWNoT3JpZW50ZWRMaW5rKGxpbmtzLCBub2RlSWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHF1aXRGYXN0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5rID0gbGlua3NbaV07XG4gICAgICBpZiAobGluay5mcm9tSWQgPT09IG5vZGVJZCkge1xuICAgICAgICBxdWl0RmFzdCA9IGNhbGxiYWNrKG5vZGVzLmdldChsaW5rLnRvSWQpLCBsaW5rKVxuICAgICAgICBpZiAocXVpdEZhc3QpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gQ2xpZW50IGRvZXMgbm90IG5lZWQgbW9yZSBpdGVyYXRpb25zLiBCcmVhayBub3cuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyB3ZSB3aWxsIG5vdCBmaXJlIGFueXRoaW5nIHVudGlsIHVzZXJzIG9mIHRoaXMgbGlicmFyeSBleHBsaWNpdGx5IGNhbGwgYG9uKClgXG4gIC8vIG1ldGhvZC5cbiAgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbiAgLy8gRW50ZXIsIEV4aXQgbW9kaWZpY2F0aW9uIGFsbG93cyBidWxrIGdyYXBoIHVwZGF0ZXMgd2l0aG91dCBmaXJpbmcgZXZlbnRzLlxuICBmdW5jdGlvbiBlbnRlck1vZGlmaWNhdGlvblJlYWwoKSB7XG4gICAgc3VzcGVuZEV2ZW50cyArPSAxO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhpdE1vZGlmaWNhdGlvblJlYWwoKSB7XG4gICAgc3VzcGVuZEV2ZW50cyAtPSAxO1xuICAgIGlmIChzdXNwZW5kRXZlbnRzID09PSAwICYmIGNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgZ3JhcGhQYXJ0LmZpcmUoJ2NoYW5nZWQnLCBjaGFuZ2VzKTtcbiAgICAgIGNoYW5nZXMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3JFYWNoTm9kZShjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gaXRlcmF0ZSBvdmVyIGdyYXBoIG5vZGVzLiBZb3UgcGFzc2VkICcgKyBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlc0l0ZXJhdG9yID0gbm9kZXMudmFsdWVzKCk7XG4gICAgdmFyIG5leHRWYWx1ZSA9IHZhbHVlc0l0ZXJhdG9yLm5leHQoKTtcbiAgICB3aGlsZSAoIW5leHRWYWx1ZS5kb25lKSB7XG4gICAgICBpZiAoY2FsbGJhY2sobmV4dFZhbHVlLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gY2xpZW50IGRvZXNuJ3Qgd2FudCB0byBwcm9jZWVkLiBSZXR1cm4uXG4gICAgICB9XG4gICAgICBuZXh0VmFsdWUgPSB2YWx1ZXNJdGVyYXRvci5uZXh0KCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG5lZWQgdGhpcyBmb3Igb2xkIGJyb3dzZXJzLiBTaG91bGQgdGhpcyBiZSBhIHNlcGFyYXRlIG1vZHVsZT9cbmZ1bmN0aW9uIGluZGV4T2ZFbGVtZW50SW5BcnJheShlbGVtZW50LCBhcnJheSkge1xuICBpZiAoIWFycmF5KSByZXR1cm4gLTE7XG5cbiAgaWYgKGFycmF5LmluZGV4T2YpIHtcbiAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBsZW4gPSBhcnJheS5sZW5ndGgsXG4gICAgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBzdHJ1Y3R1cmUgdG8gcmVwcmVzZW50IG5vZGU7XG4gKi9cbmZ1bmN0aW9uIE5vZGUoaWQsIGRhdGEpIHtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmxpbmtzID0gbnVsbDtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbn1cblxuZnVuY3Rpb24gYWRkTGlua1RvTm9kZShub2RlLCBsaW5rKSB7XG4gIGlmIChub2RlLmxpbmtzKSB7XG4gICAgbm9kZS5saW5rcy5wdXNoKGxpbmspO1xuICB9IGVsc2Uge1xuICAgIG5vZGUubGlua3MgPSBbbGlua107XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBzdHJ1Y3R1cmUgdG8gcmVwcmVzZW50IGxpbmtzO1xuICovXG5mdW5jdGlvbiBMaW5rKGZyb21JZCwgdG9JZCwgZGF0YSwgaWQpIHtcbiAgdGhpcy5mcm9tSWQgPSBmcm9tSWQ7XG4gIHRoaXMudG9JZCA9IHRvSWQ7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuaWQgPSBpZDtcbn1cblxuZnVuY3Rpb24gbWFrZUxpbmtJZChmcm9tSWQsIHRvSWQpIHtcbiAgcmV0dXJuIGZyb21JZC50b1N0cmluZygpICsgJ/CfkYkgJyArIHRvSWQudG9TdHJpbmcoKTtcbn1cbiIsIi8qKlxuICogQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvdGlueXF1ZXVlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcsIFZsYWRpbWlyIEFnYWZvbmtpbiBodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci90aW55cXVldWUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogXG4gKiBBZGFwdGVkIGZvciBQYXRoRmluZGluZyBuZWVkcyBieSBAYW52YWthXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcsIEFuZHJlaSBLYXNoY2hhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTm9kZUhlYXA7XG5cbmZ1bmN0aW9uIE5vZGVIZWFwKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGVIZWFwKSkgcmV0dXJuIG5ldyBOb2RlSGVhcChkYXRhLCBvcHRpb25zKTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAvLyBhc3N1bWUgZmlyc3QgYXJndW1lbnQgaXMgb3VyIGNvbmZpZyBvYmplY3Q7XG4gICAgb3B0aW9ucyA9IGRhdGE7XG4gICAgZGF0YSA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5kYXRhID0gZGF0YSB8fCBbXTtcbiAgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoO1xuICB0aGlzLmNvbXBhcmUgPSBvcHRpb25zLmNvbXBhcmUgfHwgZGVmYXVsdENvbXBhcmU7XG4gIHRoaXMuc2V0Tm9kZUlkID0gb3B0aW9ucy5zZXROb2RlSWQgfHwgbm9vcDtcblxuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9ICh0aGlzLmxlbmd0aCA+PiAxKTsgaSA+PSAwOyBpLS0pIHRoaXMuX2Rvd24oaSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5zZXROb2RlSWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRoaXMuc2V0Tm9kZUlkKHRoaXMuZGF0YVtpXSwgaSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cblxuTm9kZUhlYXAucHJvdG90eXBlID0ge1xuXG4gIHB1c2g6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdGhpcy5kYXRhLnB1c2goaXRlbSk7XG4gICAgdGhpcy5zZXROb2RlSWQoaXRlbSwgdGhpcy5sZW5ndGgpO1xuICAgIHRoaXMubGVuZ3RoKys7XG4gICAgdGhpcy5fdXAodGhpcy5sZW5ndGggLSAxKTtcbiAgfSxcblxuICBwb3A6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgdG9wID0gdGhpcy5kYXRhWzBdO1xuICAgIHRoaXMubGVuZ3RoLS07XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmRhdGFbdGhpcy5sZW5ndGhdO1xuICAgICAgdGhpcy5zZXROb2RlSWQodGhpcy5kYXRhWzBdLCAwKTtcbiAgICAgIHRoaXMuX2Rvd24oMCk7XG4gICAgfVxuICAgIHRoaXMuZGF0YS5wb3AoKTtcblxuICAgIHJldHVybiB0b3A7XG4gIH0sXG5cbiAgcGVlazogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbMF07XG4gIH0sXG5cbiAgdXBkYXRlSXRlbTogZnVuY3Rpb24gKHBvcykge1xuICAgIHRoaXMuX2Rvd24ocG9zKTtcbiAgICB0aGlzLl91cChwb3MpO1xuICB9LFxuXG4gIF91cDogZnVuY3Rpb24gKHBvcykge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBjb21wYXJlID0gdGhpcy5jb21wYXJlO1xuICAgIHZhciBzZXROb2RlSWQgPSB0aGlzLnNldE5vZGVJZDtcbiAgICB2YXIgaXRlbSA9IGRhdGFbcG9zXTtcblxuICAgIHdoaWxlIChwb3MgPiAwKSB7XG4gICAgICB2YXIgcGFyZW50ID0gKHBvcyAtIDEpID4+IDE7XG4gICAgICB2YXIgY3VycmVudCA9IGRhdGFbcGFyZW50XTtcbiAgICAgIGlmIChjb21wYXJlKGl0ZW0sIGN1cnJlbnQpID49IDApIGJyZWFrO1xuICAgICAgICBkYXRhW3Bvc10gPSBjdXJyZW50O1xuXG4gICAgICAgc2V0Tm9kZUlkKGN1cnJlbnQsIHBvcyk7XG4gICAgICAgcG9zID0gcGFyZW50O1xuICAgIH1cblxuICAgIGRhdGFbcG9zXSA9IGl0ZW07XG4gICAgc2V0Tm9kZUlkKGl0ZW0sIHBvcyk7XG4gIH0sXG5cbiAgX2Rvd246IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgY29tcGFyZSA9IHRoaXMuY29tcGFyZTtcbiAgICB2YXIgaGFsZkxlbmd0aCA9IHRoaXMubGVuZ3RoID4+IDE7XG4gICAgdmFyIGl0ZW0gPSBkYXRhW3Bvc107XG4gICAgdmFyIHNldE5vZGVJZCA9IHRoaXMuc2V0Tm9kZUlkO1xuXG4gICAgd2hpbGUgKHBvcyA8IGhhbGZMZW5ndGgpIHtcbiAgICAgIHZhciBsZWZ0ID0gKHBvcyA8PCAxKSArIDE7XG4gICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgIHZhciBiZXN0ID0gZGF0YVtsZWZ0XTtcblxuICAgICAgaWYgKHJpZ2h0IDwgdGhpcy5sZW5ndGggJiYgY29tcGFyZShkYXRhW3JpZ2h0XSwgYmVzdCkgPCAwKSB7XG4gICAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgICAgYmVzdCA9IGRhdGFbcmlnaHRdO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmUoYmVzdCwgaXRlbSkgPj0gMCkgYnJlYWs7XG5cbiAgICAgIGRhdGFbcG9zXSA9IGJlc3Q7XG4gICAgICBzZXROb2RlSWQoYmVzdCwgcG9zKTtcbiAgICAgIHBvcyA9IGxlZnQ7XG4gICAgfVxuXG4gICAgZGF0YVtwb3NdID0gaXRlbTtcbiAgICBzZXROb2RlSWQoaXRlbSwgcG9zKTtcbiAgfVxufTsiLCIvKipcbiAqIFBlcmZvcm1zIHN1Ym9wdGltYWwsIGdyZWVkIEEgU3RhciBwYXRoIGZpbmRpbmcuXG4gKiBUaGlzIGZpbmRlciBkb2VzIG5vdCBuZWNlc3NhcnkgZmluZHMgdGhlIHNob3J0ZXN0IHBhdGguIFRoZSBwYXRoXG4gKiB0aGF0IGl0IGZpbmRzIGlzIHZlcnkgY2xvc2UgdG8gdGhlIHNob3J0ZXN0IG9uZS4gSXQgaXMgdmVyeSBmYXN0IHRob3VnaC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBhU3RhckJpO1xuXG52YXIgTm9kZUhlYXAgPSByZXF1aXJlKCcuL05vZGVIZWFwJyk7XG52YXIgbWFrZVNlYXJjaFN0YXRlUG9vbCA9IHJlcXVpcmUoJy4vbWFrZVNlYXJjaFN0YXRlUG9vbCcpO1xudmFyIGhldXJpc3RpY3MgPSByZXF1aXJlKCcuL2hldXJpc3RpY3MnKTtcbnZhciBkZWZhdWx0U2V0dGluZ3MgPSByZXF1aXJlKCcuL2RlZmF1bHRTZXR0aW5ncycpO1xuXG52YXIgQllfRlJPTSA9IDE7XG52YXIgQllfVE8gPSAyO1xudmFyIE5PX1BBVEggPSBkZWZhdWx0U2V0dGluZ3MuTk9fUEFUSDtcblxubW9kdWxlLmV4cG9ydHMubDIgPSBoZXVyaXN0aWNzLmwyO1xubW9kdWxlLmV4cG9ydHMubDEgPSBoZXVyaXN0aWNzLmwxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgcGF0aGZpbmRlci4gQSBwYXRoZmluZGVyIGhhcyBqdXN0IG9uZSBtZXRob2Q6XG4gKiBgZmluZChmcm9tSWQsIHRvSWQpYCwgaXQgbWF5IGJlIGV4dGVuZGVkIGluIGZ1dHVyZS5cbiAqIFxuICogTk9URTogQWxnb3JpdGhtIGltcGxlbWVudGVkIGluIHRoaXMgY29kZSBET0VTIE5PVCBmaW5kIG9wdGltYWwgcGF0aC5cbiAqIFlldCB0aGUgcGF0aCB0aGF0IGl0IGZpbmRzIGlzIGFsd2F5cyBuZWFyIG9wdGltYWwsIGFuZCBpdCBmaW5kcyBpdCB2ZXJ5IGZhc3QuXG4gKiBcbiAqIEBwYXJhbSB7bmdyYXBoLmdyYXBofSBncmFwaCBpbnN0YW5jZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnZha2EvbmdyYXBoLmdyYXBoXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoYXQgY29uZmlndXJlcyBzZWFyY2hcbiAqIEBwYXJhbSB7RnVuY3Rpb24oYSwgYil9IG9wdGlvbnMuaGV1cmlzdGljIC0gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgZXN0aW1hdGVkIGRpc3RhbmNlIGJldHdlZW5cbiAqIG5vZGVzIGBhYCBhbmQgYGJgLiAgRGVmYXVsdHMgZnVuY3Rpb24gcmV0dXJucyAwLCB3aGljaCBtYWtlcyB0aGlzIHNlYXJjaCBlcXVpdmFsZW50IHRvIERpamtzdHJhIHNlYXJjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb24oYSwgYil9IG9wdGlvbnMuZGlzdGFuY2UgLSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhY3R1YWwgZGlzdGFuY2UgYmV0d2VlbiB0d29cbiAqIG5vZGVzIGBhYCBhbmQgYGJgLiBCeSBkZWZhdWx0IHRoaXMgaXMgc2V0IHRvIHJldHVybiBncmFwaC10aGVvcmV0aWNhbCBkaXN0YW5jZSAoYWx3YXlzIDEpO1xuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm9yaWVudGVkIC0gd2hldGhlciBncmFwaCBzaG91bGQgYmUgY29uc2lkZXJlZCBvcmllbnRlZCBvciBub3QuXG4gKiBcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgcGF0aGZpbmRlciB3aXRoIHNpbmdsZSBtZXRob2QgYGZpbmQoKWAuXG4gKi9cbmZ1bmN0aW9uIGFTdGFyQmkoZ3JhcGgsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIC8vIHdoZXRoZXIgdHJhdmVyc2FsIHNob3VsZCBiZSBjb25zaWRlcmVkIG92ZXIgb3JpZW50ZWQgZ3JhcGguXG4gIHZhciBvcmllbnRlZCA9IG9wdGlvbnMub3JpZW50ZWQ7XG5cbiAgdmFyIGhldXJpc3RpYyA9IG9wdGlvbnMuaGV1cmlzdGljO1xuICBpZiAoIWhldXJpc3RpYykgaGV1cmlzdGljID0gZGVmYXVsdFNldHRpbmdzLmhldXJpc3RpYztcblxuICB2YXIgZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlO1xuICBpZiAoIWRpc3RhbmNlKSBkaXN0YW5jZSA9IGRlZmF1bHRTZXR0aW5ncy5kaXN0YW5jZTtcbiAgdmFyIHBvb2wgPSBtYWtlU2VhcmNoU3RhdGVQb29sKCk7XG5cbiAgcmV0dXJuIHtcbiAgICBmaW5kOiBmaW5kXG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZChmcm9tSWQsIHRvSWQpIHtcbiAgICAvLyBOb3Qgc3VyZSBpZiB3ZSBzaG91bGQgcmV0dXJuIE5PX1BBVEggb3IgdGhyb3cuIFRocm93IHNlZW0gdG8gYmUgbW9yZVxuICAgIC8vIGhlbHBmdWwgdG8gZGVidWcgZXJyb3JzLiBTbywgdGhyb3dpbmcuXG4gICAgdmFyIGZyb20gPSBncmFwaC5nZXROb2RlKGZyb21JZCk7XG4gICAgaWYgKCFmcm9tKSB0aHJvdyBuZXcgRXJyb3IoJ2Zyb21JZCBpcyBub3QgZGVmaW5lZCBpbiB0aGlzIGdyYXBoOiAnICsgZnJvbUlkKTtcbiAgICB2YXIgdG8gPSBncmFwaC5nZXROb2RlKHRvSWQpO1xuICAgIGlmICghdG8pIHRocm93IG5ldyBFcnJvcigndG9JZCBpcyBub3QgZGVmaW5lZCBpbiB0aGlzIGdyYXBoOiAnICsgdG9JZCk7XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHJldHVybiBbZnJvbV07IC8vIHRyaXZpYWwgY2FzZS5cblxuICAgIHBvb2wucmVzZXQoKTtcblxuICAgIHZhciBjYWxsVmlzaXRvciA9IG9yaWVudGVkID8gb3JpZW50ZWRWaXNpdG9yIDogbm9uT3JpZW50ZWRWaXNpdG9yO1xuXG4gICAgLy8gTWFwcyBub2RlSWQgdG8gTm9kZVNlYXJjaFN0YXRlLlxuICAgIHZhciBub2RlU3RhdGUgPSBuZXcgTWFwKCk7XG5cbiAgICB2YXIgb3BlblNldEZyb20gPSBuZXcgTm9kZUhlYXAoe1xuICAgICAgY29tcGFyZTogZGVmYXVsdFNldHRpbmdzLmNvbXBhcmVGU2NvcmUsXG4gICAgICBzZXROb2RlSWQ6IGRlZmF1bHRTZXR0aW5ncy5zZXRIZWFwSW5kZXhcbiAgICB9KTtcblxuICAgIHZhciBvcGVuU2V0VG8gPSBuZXcgTm9kZUhlYXAoe1xuICAgICAgY29tcGFyZTogZGVmYXVsdFNldHRpbmdzLmNvbXBhcmVGU2NvcmUsXG4gICAgICBzZXROb2RlSWQ6IGRlZmF1bHRTZXR0aW5ncy5zZXRIZWFwSW5kZXhcbiAgICB9KTtcblxuXG4gICAgdmFyIHN0YXJ0Tm9kZSA9IHBvb2wuY3JlYXRlTmV3U3RhdGUoZnJvbSk7XG4gICAgbm9kZVN0YXRlLnNldChmcm9tSWQsIHN0YXJ0Tm9kZSk7XG5cbiAgICAvLyBGb3IgdGhlIGZpcnN0IG5vZGUsIGZTY29yZSBpcyBjb21wbGV0ZWx5IGhldXJpc3RpYy5cbiAgICBzdGFydE5vZGUuZlNjb3JlID0gaGV1cmlzdGljKGZyb20sIHRvKTtcbiAgICAvLyBUaGUgY29zdCBvZiBnb2luZyBmcm9tIHN0YXJ0IHRvIHN0YXJ0IGlzIHplcm8uXG4gICAgc3RhcnROb2RlLmRpc3RhbmNlVG9Tb3VyY2UgPSAwO1xuICAgIG9wZW5TZXRGcm9tLnB1c2goc3RhcnROb2RlKTtcbiAgICBzdGFydE5vZGUub3BlbiA9IEJZX0ZST007XG5cbiAgICB2YXIgZW5kTm9kZSA9IHBvb2wuY3JlYXRlTmV3U3RhdGUodG8pO1xuICAgIGVuZE5vZGUuZlNjb3JlID0gaGV1cmlzdGljKHRvLCBmcm9tKTtcbiAgICBlbmROb2RlLmRpc3RhbmNlVG9Tb3VyY2UgPSAwO1xuICAgIG9wZW5TZXRUby5wdXNoKGVuZE5vZGUpO1xuICAgIGVuZE5vZGUub3BlbiA9IEJZX1RPO1xuXG4gICAgLy8gQ29zdCBvZiB0aGUgYmVzdCBzb2x1dGlvbiBmb3VuZCBzbyBmYXIuIFVzZWQgZm9yIGFjY3VyYXRlIHRlcm1pbmF0aW9uXG4gICAgdmFyIGxNaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1pbkZyb207XG4gICAgdmFyIG1pblRvO1xuXG4gICAgdmFyIGN1cnJlbnRTZXQgPSBvcGVuU2V0RnJvbTtcbiAgICB2YXIgY3VycmVudE9wZW5lciA9IEJZX0ZST007XG5cbiAgICB3aGlsZSAob3BlblNldEZyb20ubGVuZ3RoID4gMCAmJiBvcGVuU2V0VG8ubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKG9wZW5TZXRGcm9tLmxlbmd0aCA8IG9wZW5TZXRUby5sZW5ndGgpIHtcbiAgICAgICAgLy8gd2UgcGljayBhIHNldCB3aXRoIGxlc3MgZWxlbWVudHNcbiAgICAgICAgY3VycmVudE9wZW5lciA9IEJZX0ZST007XG4gICAgICAgIGN1cnJlbnRTZXQgPSBvcGVuU2V0RnJvbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRPcGVuZXIgPSBCWV9UTztcbiAgICAgICAgY3VycmVudFNldCA9IG9wZW5TZXRUbztcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50U2V0LnBvcCgpO1xuXG4gICAgICAvLyBubyBuZWVkIHRvIHZpc2l0IHRoaXMgbm9kZSBhbnltb3JlXG4gICAgICBjdXJyZW50LmNsb3NlZCA9IHRydWU7XG5cbiAgICAgIGlmIChjdXJyZW50LmRpc3RhbmNlVG9Tb3VyY2UgPiBsTWluKSBjb250aW51ZTtcblxuICAgICAgZ3JhcGguZm9yRWFjaExpbmtlZE5vZGUoY3VycmVudC5ub2RlLmlkLCBjYWxsVmlzaXRvcik7XG5cbiAgICAgIGlmIChtaW5Gcm9tICYmIG1pblRvKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgbm90IG5lY2Vzc2FyeSB0aGUgYmVzdCBwYXRoLCBidXQgd2UgYXJlIHNvIGdyZWVkeSB0aGF0IHdlXG4gICAgICAgIC8vIGNhbid0IHJlc2lzdDpcbiAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0QmlEaXJlY3Rpb25hbFBhdGgobWluRnJvbSwgbWluVG8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBOT19QQVRIOyAvLyBObyBwYXRoLlxuXG4gICAgZnVuY3Rpb24gbm9uT3JpZW50ZWRWaXNpdG9yKG90aGVyTm9kZSwgbGluaykge1xuICAgICAgcmV0dXJuIHZpc2l0Tm9kZShvdGhlck5vZGUsIGxpbmssIGN1cnJlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9yaWVudGVkVmlzaXRvcihvdGhlck5vZGUsIGxpbmspIHtcbiAgICAgIC8vIEZvciBvcml0bmVkIGdyYXBocyB3ZSBuZWVkIHRvIHJldmVyc2UgZ3JhcGgsIHdoZW4gdHJhdmVsaW5nXG4gICAgICAvLyBiYWNrd2FyZHMuIFNvLCB3ZSB1c2Ugbm9uLW9yaWVudGVkIG5ncmFwaCdzIHRyYXZlcnNhbCwgYW5kIFxuICAgICAgLy8gZmlsdGVyIGxpbmsgb3JpZW50YXRpb24gaGVyZS5cbiAgICAgIGlmIChjdXJyZW50T3BlbmVyID09PSBCWV9GUk9NKSB7XG4gICAgICAgIGlmIChsaW5rLmZyb21JZCA9PT0gY3VycmVudC5ub2RlLmlkKSByZXR1cm4gdmlzaXROb2RlKG90aGVyTm9kZSwgbGluaywgY3VycmVudClcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudE9wZW5lciA9PT0gQllfVE8pIHtcbiAgICAgICAgaWYgKGxpbmsudG9JZCA9PT0gY3VycmVudC5ub2RlLmlkKSByZXR1cm4gdmlzaXROb2RlKG90aGVyTm9kZSwgbGluaywgY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuRXhpdChjdXJyZW50Tm9kZSkge1xuICAgICAgdmFyIG9wZW5lciA9IGN1cnJlbnROb2RlLm9wZW5cbiAgICAgIGlmIChvcGVuZXIgJiYgb3BlbmVyICE9PSBjdXJyZW50T3BlbmVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVjb25zdHJ1Y3RCaURpcmVjdGlvbmFsUGF0aChhLCBiKSB7XG4gICAgICB2YXIgcGF0aE9mTm9kZXMgPSBbXTtcbiAgICAgIHZhciBhUGFyZW50ID0gYTtcbiAgICAgIHdoaWxlKGFQYXJlbnQpIHtcbiAgICAgICAgcGF0aE9mTm9kZXMucHVzaChhUGFyZW50Lm5vZGUpO1xuICAgICAgICBhUGFyZW50ID0gYVBhcmVudC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICB2YXIgYlBhcmVudCA9IGI7XG4gICAgICB3aGlsZSAoYlBhcmVudCkge1xuICAgICAgICBwYXRoT2ZOb2Rlcy51bnNoaWZ0KGJQYXJlbnQubm9kZSk7XG4gICAgICAgIGJQYXJlbnQgPSBiUGFyZW50LnBhcmVudFxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhPZk5vZGVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZpc2l0Tm9kZShvdGhlck5vZGUsIGxpbmssIGNhbWVGcm9tKSB7XG4gICAgICB2YXIgb3RoZXJTZWFyY2hTdGF0ZSA9IG5vZGVTdGF0ZS5nZXQob3RoZXJOb2RlLmlkKTtcbiAgICAgIGlmICghb3RoZXJTZWFyY2hTdGF0ZSkge1xuICAgICAgICBvdGhlclNlYXJjaFN0YXRlID0gcG9vbC5jcmVhdGVOZXdTdGF0ZShvdGhlck5vZGUpO1xuICAgICAgICBub2RlU3RhdGUuc2V0KG90aGVyTm9kZS5pZCwgb3RoZXJTZWFyY2hTdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdGhlclNlYXJjaFN0YXRlLmNsb3NlZCkge1xuICAgICAgICAvLyBBbHJlYWR5IHByb2Nlc3NlZCB0aGlzIG5vZGUuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbkV4aXQob3RoZXJTZWFyY2hTdGF0ZSwgY2FtZUZyb20pKSB7XG4gICAgICAgIC8vIHRoaXMgbm9kZSB3YXMgb3BlbmVkIGJ5IGFsdGVybmF0aXZlIG9wZW5lci4gVGhlIHNldHMgaW50ZXJzZWN0IG5vdyxcbiAgICAgICAgLy8gd2UgZm91bmQgYW4gb3B0aW1hbCBwYXRoLCB0aGF0IGdvZXMgdGhyb3VnaCAqdGhpcyogbm9kZS4gSG93ZXZlciwgdGhlcmVcbiAgICAgICAgLy8gaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhpcyBpcyB0aGUgZ2xvYmFsIG9wdGltYWwgc29sdXRpb24gcGF0aC5cblxuICAgICAgICB2YXIgcG90ZW50aWFsTE1pbiA9IG90aGVyU2VhcmNoU3RhdGUuZGlzdGFuY2VUb1NvdXJjZSArIGNhbWVGcm9tLmRpc3RhbmNlVG9Tb3VyY2U7XG4gICAgICAgIGlmIChwb3RlbnRpYWxMTWluIDwgbE1pbikge1xuICAgICAgICAgIG1pbkZyb20gPSBvdGhlclNlYXJjaFN0YXRlO1xuICAgICAgICAgIG1pblRvID0gY2FtZUZyb21cbiAgICAgICAgICBsTWluID0gcG90ZW50aWFsTE1pbjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBhcmUgZG9uZSB3aXRoIHRoaXMgbm9kZS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGVudGF0aXZlRGlzdGFuY2UgPSBjYW1lRnJvbS5kaXN0YW5jZVRvU291cmNlICsgZGlzdGFuY2Uob3RoZXJTZWFyY2hTdGF0ZS5ub2RlLCBjYW1lRnJvbS5ub2RlLCBsaW5rKTtcblxuICAgICAgaWYgKHRlbnRhdGl2ZURpc3RhbmNlID49IG90aGVyU2VhcmNoU3RhdGUuZGlzdGFuY2VUb1NvdXJjZSkge1xuICAgICAgICAvLyBUaGlzIHdvdWxkIG9ubHkgbWFrZSBvdXIgcGF0aCBsb25nZXIuIElnbm9yZSB0aGlzIHJvdXRlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENob29zZSB0YXJnZXQgYmFzZWQgb24gY3VycmVudCB3b3JraW5nIHNldDpcbiAgICAgIHZhciB0YXJnZXQgPSAoY3VycmVudE9wZW5lciA9PT0gQllfRlJPTSkgPyB0byA6IGZyb207XG4gICAgICB2YXIgbmV3RlNjb3JlID0gdGVudGF0aXZlRGlzdGFuY2UgKyBoZXVyaXN0aWMob3RoZXJTZWFyY2hTdGF0ZS5ub2RlLCB0YXJnZXQpO1xuICAgICAgaWYgKG5ld0ZTY29yZSA+PSBsTWluKSB7XG4gICAgICAgIC8vIHRoaXMgY2FuJ3QgYmUgb3B0aW1hbCBwYXRoLCBhcyB3ZSBoYXZlIGFscmVhZHkgZm91bmQgYSBzaG9ydGVyIHBhdGguXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG90aGVyU2VhcmNoU3RhdGUuZlNjb3JlID0gbmV3RlNjb3JlO1xuXG4gICAgICBpZiAob3RoZXJTZWFyY2hTdGF0ZS5vcGVuID09PSAwKSB7XG4gICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgbm9kZSBpbiB0aGUgY3VycmVudCBzZXRcbiAgICAgICAgY3VycmVudFNldC5wdXNoKG90aGVyU2VhcmNoU3RhdGUpO1xuICAgICAgICBjdXJyZW50U2V0LnVwZGF0ZUl0ZW0ob3RoZXJTZWFyY2hTdGF0ZS5oZWFwSW5kZXgpO1xuXG4gICAgICAgIG90aGVyU2VhcmNoU3RhdGUub3BlbiA9IGN1cnJlbnRPcGVuZXI7XG4gICAgICB9XG5cbiAgICAgIC8vIGJpbmdvISB3ZSBmb3VuZCBzaG9ydGVyIHBhdGg6XG4gICAgICBvdGhlclNlYXJjaFN0YXRlLnBhcmVudCA9IGNhbWVGcm9tO1xuICAgICAgb3RoZXJTZWFyY2hTdGF0ZS5kaXN0YW5jZVRvU291cmNlID0gdGVudGF0aXZlRGlzdGFuY2U7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIFBlcmZvcm1zIGEgdW5pLWRpcmVjdGlvbmFsIEEgU3RhciBzZWFyY2ggb24gZ3JhcGguXG4gKiBcbiAqIFdlIHdpbGwgdHJ5IHRvIG1pbmltaXplIGYobikgPSBnKG4pICsgaChuKSwgd2hlcmVcbiAqIGcobikgaXMgYWN0dWFsIGRpc3RhbmNlIGZyb20gc291cmNlIG5vZGUgdG8gYG5gLCBhbmRcbiAqIGgobikgaXMgaGV1cmlzdGljIGRpc3RhbmNlIGZyb20gYG5gIHRvIHRhcmdldCBub2RlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGFTdGFyUGF0aFNlYXJjaDtcblxudmFyIE5vZGVIZWFwID0gcmVxdWlyZSgnLi9Ob2RlSGVhcCcpO1xudmFyIG1ha2VTZWFyY2hTdGF0ZVBvb2wgPSByZXF1aXJlKCcuL21ha2VTZWFyY2hTdGF0ZVBvb2wnKTtcbnZhciBoZXVyaXN0aWNzID0gcmVxdWlyZSgnLi9oZXVyaXN0aWNzJyk7XG52YXIgZGVmYXVsdFNldHRpbmdzID0gcmVxdWlyZSgnLi9kZWZhdWx0U2V0dGluZ3MuanMnKTtcblxudmFyIE5PX1BBVEggPSBkZWZhdWx0U2V0dGluZ3MuTk9fUEFUSDtcblxubW9kdWxlLmV4cG9ydHMubDIgPSBoZXVyaXN0aWNzLmwyO1xubW9kdWxlLmV4cG9ydHMubDEgPSBoZXVyaXN0aWNzLmwxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgcGF0aGZpbmRlci4gQSBwYXRoZmluZGVyIGhhcyBqdXN0IG9uZSBtZXRob2Q6XG4gKiBgZmluZChmcm9tSWQsIHRvSWQpYCwgaXQgbWF5IGJlIGV4dGVuZGVkIGluIGZ1dHVyZS5cbiAqIFxuICogQHBhcmFtIHtuZ3JhcGguZ3JhcGh9IGdyYXBoIGluc3RhbmNlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FudmFrYS9uZ3JhcGguZ3JhcGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoYXQgY29uZmlndXJlcyBzZWFyY2hcbiAqIEBwYXJhbSB7RnVuY3Rpb24oYSwgYil9IG9wdGlvbnMuaGV1cmlzdGljIC0gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgZXN0aW1hdGVkIGRpc3RhbmNlIGJldHdlZW5cbiAqIG5vZGVzIGBhYCBhbmQgYGJgLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBuZXZlciBvdmVyZXN0aW1hdGUgYWN0dWFsIGRpc3RhbmNlIGJldHdlZW4gdHdvXG4gKiBub2RlcyAob3RoZXJ3aXNlIHRoZSBmb3VuZCBwYXRoIHdpbGwgbm90IGJlIHRoZSBzaG9ydGVzdCkuIERlZmF1bHRzIGZ1bmN0aW9uIHJldHVybnMgMCxcbiAqIHdoaWNoIG1ha2VzIHRoaXMgc2VhcmNoIGVxdWl2YWxlbnQgdG8gRGlqa3N0cmEgc2VhcmNoLlxuICogQHBhcmFtIHtGdW5jdGlvbihhLCBiKX0gb3B0aW9ucy5kaXN0YW5jZSAtIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFjdHVhbCBkaXN0YW5jZSBiZXR3ZWVuIHR3b1xuICogbm9kZXMgYGFgIGFuZCBgYmAuIEJ5IGRlZmF1bHQgdGhpcyBpcyBzZXQgdG8gcmV0dXJuIGdyYXBoLXRoZW9yZXRpY2FsIGRpc3RhbmNlIChhbHdheXMgMSk7XG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMub3JpZW50ZWQgLSB3aGV0aGVyIGdyYXBoIHNob3VsZCBiZSBjb25zaWRlcmVkIG9yaWVudGVkIG9yIG5vdC5cbiAqIFxuICogQHJldHVybnMge09iamVjdH0gQSBwYXRoZmluZGVyIHdpdGggc2luZ2xlIG1ldGhvZCBgZmluZCgpYC5cbiAqL1xuZnVuY3Rpb24gYVN0YXJQYXRoU2VhcmNoKGdyYXBoLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAvLyB3aGV0aGVyIHRyYXZlcnNhbCBzaG91bGQgYmUgY29uc2lkZXJlZCBvdmVyIG9yaWVudGVkIGdyYXBoLlxuICB2YXIgb3JpZW50ZWQgPSBvcHRpb25zLm9yaWVudGVkO1xuXG4gIHZhciBoZXVyaXN0aWMgPSBvcHRpb25zLmhldXJpc3RpYztcbiAgaWYgKCFoZXVyaXN0aWMpIGhldXJpc3RpYyA9IGRlZmF1bHRTZXR0aW5ncy5oZXVyaXN0aWM7XG5cbiAgdmFyIGRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZTtcbiAgaWYgKCFkaXN0YW5jZSkgZGlzdGFuY2UgPSBkZWZhdWx0U2V0dGluZ3MuZGlzdGFuY2U7XG4gIHZhciBwb29sID0gbWFrZVNlYXJjaFN0YXRlUG9vbCgpO1xuXG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogRmluZHMgYSBwYXRoIGJldHdlZW4gbm9kZSBgZnJvbUlkYCBhbmQgYHRvSWRgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gb2Ygbm9kZXMgYmV0d2VlbiBgdG9JZGAgYW5kIGBmcm9tSWRgLiBFbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuICAgICAqIGlmIG5vIHBhdGggaXMgZm91bmQuXG4gICAgICovXG4gICAgZmluZDogZmluZFxuICB9O1xuXG4gIGZ1bmN0aW9uIGZpbmQoZnJvbUlkLCB0b0lkKSB7XG4gICAgdmFyIGZyb20gPSBncmFwaC5nZXROb2RlKGZyb21JZCk7XG4gICAgaWYgKCFmcm9tKSB0aHJvdyBuZXcgRXJyb3IoJ2Zyb21JZCBpcyBub3QgZGVmaW5lZCBpbiB0aGlzIGdyYXBoOiAnICsgZnJvbUlkKTtcbiAgICB2YXIgdG8gPSBncmFwaC5nZXROb2RlKHRvSWQpO1xuICAgIGlmICghdG8pIHRocm93IG5ldyBFcnJvcigndG9JZCBpcyBub3QgZGVmaW5lZCBpbiB0aGlzIGdyYXBoOiAnICsgdG9JZCk7XG4gICAgcG9vbC5yZXNldCgpO1xuXG4gICAgLy8gTWFwcyBub2RlSWQgdG8gTm9kZVNlYXJjaFN0YXRlLlxuICAgIHZhciBub2RlU3RhdGUgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyB0aGUgbm9kZXMgdGhhdCB3ZSBzdGlsbCBuZWVkIHRvIGV2YWx1YXRlXG4gICAgdmFyIG9wZW5TZXQgPSBuZXcgTm9kZUhlYXAoe1xuICAgICAgY29tcGFyZTogZGVmYXVsdFNldHRpbmdzLmNvbXBhcmVGU2NvcmUsXG4gICAgICBzZXROb2RlSWQ6IGRlZmF1bHRTZXR0aW5ncy5zZXRIZWFwSW5kZXhcbiAgICB9KTtcblxuICAgIHZhciBzdGFydE5vZGUgPSBwb29sLmNyZWF0ZU5ld1N0YXRlKGZyb20pO1xuICAgIG5vZGVTdGF0ZS5zZXQoZnJvbUlkLCBzdGFydE5vZGUpO1xuICAgIFxuICAgIHZhciB2aXNpdGVkTGlua3MgPSBbXTtcblxuICAgIC8vIEZvciB0aGUgZmlyc3Qgbm9kZSwgZlNjb3JlIGlzIGNvbXBsZXRlbHkgaGV1cmlzdGljLlxuICAgIHN0YXJ0Tm9kZS5mU2NvcmUgPSBoZXVyaXN0aWMoZnJvbSwgdG8pO1xuXG4gICAgLy8gVGhlIGNvc3Qgb2YgZ29pbmcgZnJvbSBzdGFydCB0byBzdGFydCBpcyB6ZXJvLlxuICAgIHN0YXJ0Tm9kZS5kaXN0YW5jZVRvU291cmNlID0gMDtcbiAgICBvcGVuU2V0LnB1c2goc3RhcnROb2RlKTtcbiAgICBzdGFydE5vZGUub3BlbiA9IDE7XG5cbiAgICB2YXIgY2FtZUZyb207XG5cbiAgICB3aGlsZSAob3BlblNldC5sZW5ndGggPiAwKSB7XG4gICAgICBjYW1lRnJvbSA9IG9wZW5TZXQucG9wKCk7XG4gICAgICBpZiAoZ29hbFJlYWNoZWQoY2FtZUZyb20sIHRvKSkgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogcmVjb25zdHJ1Y3RQYXRoKGNhbWVGcm9tKSxcbiAgICAgICAgdmlzaXRlZDogdmlzaXRlZExpbmtzXG4gICAgICB9XG5cbiAgICAgIC8vIG5vIG5lZWQgdG8gdmlzaXQgdGhpcyBub2RlIGFueW1vcmVcbiAgICAgIGNhbWVGcm9tLmNsb3NlZCA9IHRydWU7XG4gICAgICBncmFwaC5mb3JFYWNoTGlua2VkTm9kZShjYW1lRnJvbS5ub2RlLmlkLCB2aXNpdE5laWdoYm91ciwgb3JpZW50ZWQpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGdvdCBoZXJlLCB0aGVuIHRoZXJlIGlzIG5vIHBhdGguXG4gICAgcmV0dXJuIE5PX1BBVEg7XG5cbiAgICBmdW5jdGlvbiB2aXNpdE5laWdoYm91cihvdGhlck5vZGUsIGxpbmspIHtcbiAgICAgIHZhciBvdGhlclNlYXJjaFN0YXRlID0gbm9kZVN0YXRlLmdldChvdGhlck5vZGUuaWQpO1xuICAgICAgaWYgKCFvdGhlclNlYXJjaFN0YXRlKSB7XG4gICAgICAgIG90aGVyU2VhcmNoU3RhdGUgPSBwb29sLmNyZWF0ZU5ld1N0YXRlKG90aGVyTm9kZSk7XG4gICAgICAgIG5vZGVTdGF0ZS5zZXQob3RoZXJOb2RlLmlkLCBvdGhlclNlYXJjaFN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG90aGVyU2VhcmNoU3RhdGUuY2xvc2VkKSB7XG4gICAgICAgIC8vIEFscmVhZHkgcHJvY2Vzc2VkIHRoaXMgbm9kZS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyU2VhcmNoU3RhdGUub3BlbiA9PT0gMCkge1xuICAgICAgICAvLyBSZW1lbWJlciB0aGlzIG5vZGUuXG4gICAgICAgIG9wZW5TZXQucHVzaChvdGhlclNlYXJjaFN0YXRlKTtcbiAgICAgICAgb3RoZXJTZWFyY2hTdGF0ZS5vcGVuID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRlbnRhdGl2ZURpc3RhbmNlID0gY2FtZUZyb20uZGlzdGFuY2VUb1NvdXJjZSArIGRpc3RhbmNlKG90aGVyTm9kZSwgY2FtZUZyb20ubm9kZSwgbGluayk7XG4gICAgICBpZiAodGVudGF0aXZlRGlzdGFuY2UgPj0gb3RoZXJTZWFyY2hTdGF0ZS5kaXN0YW5jZVRvU291cmNlKSB7XG4gICAgICAgIC8vIFRoaXMgd291bGQgb25seSBtYWtlIG91ciBwYXRoIGxvbmdlci4gSWdub3JlIHRoaXMgcm91dGUuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYmluZ28hIHdlIGZvdW5kIHNob3J0ZXIgcGF0aDpcbiAgICAgIG90aGVyU2VhcmNoU3RhdGUucGFyZW50ID0gY2FtZUZyb207XG4gICAgICBvdGhlclNlYXJjaFN0YXRlLmRpc3RhbmNlVG9Tb3VyY2UgPSB0ZW50YXRpdmVEaXN0YW5jZTtcbiAgICAgIG90aGVyU2VhcmNoU3RhdGUuZlNjb3JlID0gdGVudGF0aXZlRGlzdGFuY2UgKyBoZXVyaXN0aWMob3RoZXJTZWFyY2hTdGF0ZS5ub2RlLCB0byk7XG5cbiAgICAgIHZpc2l0ZWRMaW5rcy5wdXNoKGNhbWVGcm9tLm5vZGUuaWQpO1xuICAgICAgdmlzaXRlZExpbmtzLnB1c2gob3RoZXJOb2RlLmlkKTtcblxuICAgICAgb3BlblNldC51cGRhdGVJdGVtKG90aGVyU2VhcmNoU3RhdGUuaGVhcEluZGV4KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ29hbFJlYWNoZWQoc2VhcmNoU3RhdGUsIHRhcmdldE5vZGUpIHtcbiAgcmV0dXJuIHNlYXJjaFN0YXRlLm5vZGUgPT09IHRhcmdldE5vZGU7XG59XG5cbmZ1bmN0aW9uIHJlY29uc3RydWN0UGF0aChzZWFyY2hTdGF0ZSkge1xuICB2YXIgcGF0aCA9IFtzZWFyY2hTdGF0ZS5ub2RlXTtcbiAgdmFyIHBhcmVudCA9IHNlYXJjaFN0YXRlLnBhcmVudDtcblxuICB3aGlsZSAocGFyZW50KSB7XG4gICAgcGF0aC5wdXNoKHBhcmVudC5ub2RlKTtcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuIiwiLy8gV2UgcmV1c2UgaW5zdGFuY2Ugb2YgYXJyYXksIGJ1dCB3ZSB0cmllIHRvIGZyZWV6ZSBpdCBhcyB3ZWxsLFxuLy8gc28gdGhhdCBjb25zdW1lcnMgZG9uJ3QgbW9kaWZ5IGl0LiBNYXliZSBpdCdzIGEgYmFkIGlkZWEuXG52YXIgTk9fUEFUSCA9IFtdO1xuaWYgKHR5cGVvZiBPYmplY3QuZnJlZXplID09PSAnZnVuY3Rpb24nKSBPYmplY3QuZnJlZXplKE5PX1BBVEgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gUGF0aCBzZWFyY2ggc2V0dGluZ3NcbiAgaGV1cmlzdGljOiBibGluZEhldXJpc3RpYyxcbiAgZGlzdGFuY2U6IGNvbnN0YW50RGlzdGFuY2UsXG4gIGNvbXBhcmVGU2NvcmU6IGNvbXBhcmVGU2NvcmUsXG4gIE5PX1BBVEg6IE5PX1BBVEgsXG5cbiAgLy8gaGVhcCBzZXR0aW5nc1xuICBzZXRIZWFwSW5kZXg6IHNldEhlYXBJbmRleCxcblxuICAvLyBuYmE6XG4gIHNldEgxOiBzZXRIMSxcbiAgc2V0SDI6IHNldEgyLFxuICBjb21wYXJlRjFTY29yZTogY29tcGFyZUYxU2NvcmUsXG4gIGNvbXBhcmVGMlNjb3JlOiBjb21wYXJlRjJTY29yZSxcbn1cblxuZnVuY3Rpb24gYmxpbmRIZXVyaXN0aWMoLyogYSwgYiAqLykge1xuICAvLyBibGluZCBoZXVyaXN0aWMgbWFrZXMgdGhpcyBzZWFyY2ggZXF1YWwgdG8gcGxhaW4gRGlqa3N0cmEgcGF0aCBzZWFyY2guXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjb25zdGFudERpc3RhbmNlKC8qIGEsIGIgKi8pIHtcbiAgcmV0dXJuIDE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVGU2NvcmUoYSwgYikge1xuICB2YXIgcmVzdWx0ID0gYS5mU2NvcmUgLSBiLmZTY29yZTtcbiAgLy8gVE9ETzogQ2FuIEkgaW1wcm92ZSBzcGVlZCB3aXRoIHNtYXJ0ZXIgdGllcy1icmVha2luZz9cbiAgLy8gSSB0cmllZCBkaXN0YW5jZVRvU291cmNlLCBidXQgaXQgZGlkbid0IHNlZW0gdG8gaGF2ZSBtdWNoIGVmZmVjdFxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzZXRIZWFwSW5kZXgobm9kZVNlYXJjaFN0YXRlLCBoZWFwSW5kZXgpIHtcbiAgbm9kZVNlYXJjaFN0YXRlLmhlYXBJbmRleCA9IGhlYXBJbmRleDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUYxU2NvcmUoYSwgYikge1xuICByZXR1cm4gYS5mMSAtIGIuZjE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVGMlNjb3JlKGEsIGIpIHtcbiAgcmV0dXJuIGEuZjIgLSBiLmYyO1xufVxuXG5mdW5jdGlvbiBzZXRIMShub2RlLCBoZWFwSW5kZXgpIHtcbiAgbm9kZS5oMSA9IGhlYXBJbmRleDtcbn1cblxuZnVuY3Rpb24gc2V0SDIobm9kZSwgaGVhcEluZGV4KSB7XG4gIG5vZGUuaDIgPSBoZWFwSW5kZXg7XG59IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGwyOiBsMixcbiAgbDE6IGwxXG59O1xuXG4vKipcbiAqIEV1Y2xpZCBkaXN0YW5jZSAobDIgbm9ybSk7XG4gKiBcbiAqIEBwYXJhbSB7Kn0gYSBcbiAqIEBwYXJhbSB7Kn0gYiBcbiAqL1xuZnVuY3Rpb24gbDIoYSwgYikge1xuICB2YXIgZHggPSBhLnggLSBiLng7XG4gIHZhciBkeSA9IGEueSAtIGIueTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59XG5cbi8qKlxuICogTWFuaGF0dGFuIGRpc3RhbmNlIChsMSBub3JtKTtcbiAqIEBwYXJhbSB7Kn0gYSBcbiAqIEBwYXJhbSB7Kn0gYiBcbiAqL1xuZnVuY3Rpb24gbDEoYSwgYikge1xuICB2YXIgZHggPSBhLnggLSBiLng7XG4gIHZhciBkeSA9IGEueSAtIGIueTtcbiAgcmV0dXJuIE1hdGguYWJzKGR4KSArIE1hdGguYWJzKGR5KTtcbn1cbiIsIi8qKlxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgc2luZ2xlIHNlYXJjaCBub2RlIGluIHRoZSBleHBsb3JhdGlvbiB0cmVlIGZvclxuICogQSogYWxnb3JpdGhtLlxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSAgb3JpZ2luYWwgbm9kZSBpbiB0aGUgZ3JhcGhcbiAqL1xuZnVuY3Rpb24gTm9kZVNlYXJjaFN0YXRlKG5vZGUpIHtcbiAgdGhpcy5ub2RlID0gbm9kZTtcblxuICAvLyBIb3cgd2UgY2FtZSB0byB0aGlzIG5vZGU/XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcblxuICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICB0aGlzLm9wZW4gPSAwO1xuXG4gIHRoaXMuZGlzdGFuY2VUb1NvdXJjZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgLy8gdGhlIGYobikgPSBnKG4pICsgaChuKSB2YWx1ZVxuICB0aGlzLmZTY29yZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAvLyB1c2VkIHRvIHJlY29uc3RydWN0IGhlYXAgd2hlbiBmU2NvcmUgaXMgdXBkYXRlZC5cbiAgdGhpcy5oZWFwSW5kZXggPSAtMTtcbn07XG5cbmZ1bmN0aW9uIG1ha2VTZWFyY2hTdGF0ZVBvb2woKSB7XG4gIHZhciBjdXJyZW50SW5DYWNoZSA9IDA7XG4gIHZhciBub2RlQ2FjaGUgPSBbXTtcblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZU5ld1N0YXRlOiBjcmVhdGVOZXdTdGF0ZSxcbiAgICByZXNldDogcmVzZXRcbiAgfTtcblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjdXJyZW50SW5DYWNoZSA9IDA7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOZXdTdGF0ZShub2RlKSB7XG4gICAgdmFyIGNhY2hlZCA9IG5vZGVDYWNoZVtjdXJyZW50SW5DYWNoZV07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgLy8gVE9ETzogVGhpcyBhbG1vc3QgZHVwbGljYXRlcyBjb25zdHJ1Y3RvciBjb2RlLiBOb3Qgc3VyZSBpZlxuICAgICAgLy8gaXQgd291bGQgaW1wYWN0IHBlcmZvcm1hbmNlIGlmIEkgbW92ZSB0aGlzIGNvZGUgaW50byBhIGZ1bmN0aW9uXG4gICAgICBjYWNoZWQubm9kZSA9IG5vZGU7XG4gICAgICAvLyBIb3cgd2UgY2FtZSB0byB0aGlzIG5vZGU/XG4gICAgICBjYWNoZWQucGFyZW50ID0gbnVsbDtcblxuICAgICAgY2FjaGVkLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgY2FjaGVkLm9wZW4gPSAwO1xuXG4gICAgICBjYWNoZWQuZGlzdGFuY2VUb1NvdXJjZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIC8vIHRoZSBmKG4pID0gZyhuKSArIGgobikgdmFsdWVcbiAgICAgIGNhY2hlZC5mU2NvcmUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgICAgIC8vIHVzZWQgdG8gcmVjb25zdHJ1Y3QgaGVhcCB3aGVuIGZTY29yZSBpcyB1cGRhdGVkLlxuICAgICAgY2FjaGVkLmhlYXBJbmRleCA9IC0xO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlZCA9IG5ldyBOb2RlU2VhcmNoU3RhdGUobm9kZSk7XG4gICAgICBub2RlQ2FjaGVbY3VycmVudEluQ2FjaGVdID0gY2FjaGVkO1xuICAgIH1cbiAgICBjdXJyZW50SW5DYWNoZSsrO1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gbWFrZVNlYXJjaFN0YXRlUG9vbDsiLCJtb2R1bGUuZXhwb3J0cyA9IG5iYTtcblxudmFyIE5vZGVIZWFwID0gcmVxdWlyZSgnLi4vTm9kZUhlYXAnKTtcbnZhciBoZXVyaXN0aWNzID0gcmVxdWlyZSgnLi4vaGV1cmlzdGljcycpO1xudmFyIGRlZmF1bHRTZXR0aW5ncyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRTZXR0aW5ncy5qcycpO1xudmFyIG1ha2VOQkFTZWFyY2hTdGF0ZVBvb2wgPSByZXF1aXJlKCcuL21ha2VOQkFTZWFyY2hTdGF0ZVBvb2wuanMnKTtcblxudmFyIE5PX1BBVEggPSBkZWZhdWx0U2V0dGluZ3MuTk9fUEFUSDtcblxubW9kdWxlLmV4cG9ydHMubDIgPSBoZXVyaXN0aWNzLmwyO1xubW9kdWxlLmV4cG9ydHMubDEgPSBoZXVyaXN0aWNzLmwxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgcGF0aGZpbmRlci4gQSBwYXRoZmluZGVyIGhhcyBqdXN0IG9uZSBtZXRob2Q6XG4gKiBgZmluZChmcm9tSWQsIHRvSWQpYC5cbiAqIFxuICogVGhpcyBpcyBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgTkJBKiBhbGdvcml0aG0gZGVzY3JpYmVkIGluIFxuICogXG4gKiAgXCJZZXQgYW5vdGhlciBiaWRpcmVjdGlvbmFsIGFsZ29yaXRobSBmb3Igc2hvcnRlc3QgcGF0aHNcIiBwYXBlciBieSBXaW0gUGlqbHMgYW5kIEhlbmsgUG9zdFxuICogXG4gKiBUaGUgcGFwZXIgaXMgYXZhaWxhYmxlIGhlcmU6IGh0dHBzOi8vcmVwdWIuZXVyLm5sL3B1Yi8xNjEwMC9laTIwMDktMTAucGRmXG4gKiBcbiAqIEBwYXJhbSB7bmdyYXBoLmdyYXBofSBncmFwaCBpbnN0YW5jZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnZha2EvbmdyYXBoLmdyYXBoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGF0IGNvbmZpZ3VyZXMgc2VhcmNoXG4gKiBAcGFyYW0ge0Z1bmN0aW9uKGEsIGIpfSBvcHRpb25zLmhldXJpc3RpYyAtIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGVzdGltYXRlZCBkaXN0YW5jZSBiZXR3ZWVuXG4gKiBub2RlcyBgYWAgYW5kIGBiYC4gVGhpcyBmdW5jdGlvbiBzaG91bGQgbmV2ZXIgb3ZlcmVzdGltYXRlIGFjdHVhbCBkaXN0YW5jZSBiZXR3ZWVuIHR3b1xuICogbm9kZXMgKG90aGVyd2lzZSB0aGUgZm91bmQgcGF0aCB3aWxsIG5vdCBiZSB0aGUgc2hvcnRlc3QpLiBEZWZhdWx0cyBmdW5jdGlvbiByZXR1cm5zIDAsXG4gKiB3aGljaCBtYWtlcyB0aGlzIHNlYXJjaCBlcXVpdmFsZW50IHRvIERpamtzdHJhIHNlYXJjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb24oYSwgYil9IG9wdGlvbnMuZGlzdGFuY2UgLSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhY3R1YWwgZGlzdGFuY2UgYmV0d2VlbiB0d29cbiAqIG5vZGVzIGBhYCBhbmQgYGJgLiBCeSBkZWZhdWx0IHRoaXMgaXMgc2V0IHRvIHJldHVybiBncmFwaC10aGVvcmV0aWNhbCBkaXN0YW5jZSAoYWx3YXlzIDEpO1xuICogXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIHBhdGhmaW5kZXIgd2l0aCBzaW5nbGUgbWV0aG9kIGBmaW5kKClgLlxuICovXG5mdW5jdGlvbiBuYmEoZ3JhcGgsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIC8vIHdoZXRoZXIgdHJhdmVyc2FsIHNob3VsZCBiZSBjb25zaWRlcmVkIG92ZXIgb3JpZW50ZWQgZ3JhcGguXG4gIHZhciBvcmllbnRlZCA9IG9wdGlvbnMub3JpZW50ZWQ7XG4gIHZhciBxdWl0RmFzdCA9IG9wdGlvbnMucXVpdEZhc3Q7XG5cbiAgdmFyIGhldXJpc3RpYyA9IG9wdGlvbnMuaGV1cmlzdGljO1xuICBpZiAoIWhldXJpc3RpYykgaGV1cmlzdGljID0gZGVmYXVsdFNldHRpbmdzLmhldXJpc3RpYztcblxuICB2YXIgZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlO1xuICBpZiAoIWRpc3RhbmNlKSBkaXN0YW5jZSA9IGRlZmF1bHRTZXR0aW5ncy5kaXN0YW5jZTtcblxuICAvLyBEdXJpbmcgc3RyZXNzIHRlc3RzIEkgbm90aWNlZCB0aGF0IGdhcmJhZ2UgY29sbGVjdGlvbiB3YXMgb25lIG9mIHRoZSBoZWF2aWVzdFxuICAvLyBjb250cmlidXRvcnMgdG8gdGhlIGFsZ29yaXRobSdzIHNwZWVkLiBTbyBJJ20gdXNpbmcgYW4gb2JqZWN0IHBvb2wgdG8gcmVjeWNsZSBub2Rlcy5cbiAgdmFyIHBvb2wgPSBtYWtlTkJBU2VhcmNoU3RhdGVQb29sKCk7XG5cbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIHBhdGggYmV0d2VlbiBub2RlIGBmcm9tSWRgIGFuZCBgdG9JZGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBvZiBub2RlcyBiZXR3ZWVuIGB0b0lkYCBhbmQgYGZyb21JZGAuIEVtcHR5IGFycmF5IGlzIHJldHVybmVkXG4gICAgICogaWYgbm8gcGF0aCBpcyBmb3VuZC5cbiAgICAgKi9cbiAgICBmaW5kOiBmaW5kXG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZChmcm9tSWQsIHRvSWQpIHtcbiAgICAvLyBJIG11c3QgYXBvbG9naXplIGZvciB0aGUgY29kZSBkdXBsaWNhdGlvbi4gVGhpcyB3YXMgdGhlIGVhc2llc3Qgd2F5IGZvciBtZSB0b1xuICAgIC8vIGltcGxlbWVudCB0aGUgYWxnb3JpdGhtIGZhc3QuXG4gICAgdmFyIGZyb20gPSBncmFwaC5nZXROb2RlKGZyb21JZCk7XG4gICAgaWYgKCFmcm9tKSB0aHJvdyBuZXcgRXJyb3IoJ2Zyb21JZCBpcyBub3QgZGVmaW5lZCBpbiB0aGlzIGdyYXBoOiAnICsgZnJvbUlkKTtcbiAgICB2YXIgdG8gPSBncmFwaC5nZXROb2RlKHRvSWQpO1xuICAgIGlmICghdG8pIHRocm93IG5ldyBFcnJvcigndG9JZCBpcyBub3QgZGVmaW5lZCBpbiB0aGlzIGdyYXBoOiAnICsgdG9JZCk7XG5cbiAgICBwb29sLnJlc2V0KCk7XG5cbiAgICAvLyBJIG11c3QgYWxzbyBhcG9sb2dpemUgZm9yIHNvbWV3aGF0IGNyeXB0aWMgbmFtZXMuIFRoZSBOQkEqIGlzIGJpLWRpcmVjdGlvbmFsXG4gICAgLy8gc2VhcmNoIGFsZ29yaXRobSwgd2hpY2ggbWVhbnMgaXQgcnVucyB0d28gc2VhcmNoZXMgaW4gcGFyYWxsZWwuIE9uZSBpcyBjYWxsZWRcbiAgICAvLyBmb3J3YXJkIHNlYXJjaCBhbmQgaXQgcnVucyBmcm9tIHNvdXJjZSBub2RlIHRvIHRhcmdldCwgd2hpbGUgdGhlIG90aGVyIG9uZVxuICAgIC8vIChiYWNrd2FyZCBzZWFyY2gpIHJ1bnMgZnJvbSB0YXJnZXQgdG8gc291cmNlLlxuXG4gICAgLy8gRXZlcnl3aGVyZSB3aGVyZSB5b3Ugc2VlIGAxYCBpdCBtZWFucyBpdCdzIGZvciB0aGUgZm9yd2FyZCBzZWFyY2guIGAyYCBpcyBmb3IgXG4gICAgLy8gYmFja3dhcmQgc2VhcmNoLlxuXG4gICAgLy8gRm9yIG9yaWVudGVkIGdyYXBoIHBhdGggZmluZGluZywgd2UgbmVlZCB0byByZXZlcnNlIHRoZSBncmFwaCwgc28gdGhhdFxuICAgIC8vIGJhY2t3YXJkIHNlYXJjaCB2aXNpdHMgY29ycmVjdCBsaW5rLiBPYnZpb3VzbHkgd2UgZG9uJ3Qgd2FudCB0byBkdXBsaWNhdGVcbiAgICAvLyB0aGUgZ3JhcGgsIGluc3RlYWQgd2UgYWx3YXlzIHRyYXZlcnNlIHRoZSBncmFwaCBhcyBub24tb3JpZW50ZWQsIGFuZCBmaWx0ZXJcbiAgICAvLyBlZGdlcyBpbiBgdmlzaXROMU9yaWVudGVkL3Zpc2l0TjJPcml0ZW50ZWRgXG4gICAgdmFyIGZvcndhcmRWaXNpdG9yID0gb3JpZW50ZWQgPyB2aXNpdE4xT3JpZW50ZWQgOiB2aXNpdE4xO1xuICAgIHZhciByZXZlcnNlVmlzaXRvciA9IG9yaWVudGVkID8gdmlzaXROMk9yaWVudGVkIDogdmlzaXROMjtcblxuICAgIC8vIE1hcHMgbm9kZUlkIHRvIE5CQVNlYXJjaFN0YXRlLlxuICAgIHZhciBub2RlU3RhdGUgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBUaGVzZSB0d28gaGVhcHMgc3RvcmUgbm9kZXMgYnkgdGhlaXIgdW5kZXJlc3RpbWF0ZWQgdmFsdWVzLlxuICAgIHZhciBvcGVuMVNldCA9IG5ldyBOb2RlSGVhcCh7XG4gICAgICBjb21wYXJlOiBkZWZhdWx0U2V0dGluZ3MuY29tcGFyZUYxU2NvcmUsXG4gICAgICBzZXROb2RlSWQ6IGRlZmF1bHRTZXR0aW5ncy5zZXRIMVxuICAgIH0pO1xuICAgIHZhciBvcGVuMlNldCA9IG5ldyBOb2RlSGVhcCh7XG4gICAgICBjb21wYXJlOiBkZWZhdWx0U2V0dGluZ3MuY29tcGFyZUYyU2NvcmUsXG4gICAgICBzZXROb2RlSWQ6IGRlZmF1bHRTZXR0aW5ncy5zZXRIMlxuICAgIH0pO1xuXG4gICAgLy8gVGhpcyBpcyB3aGVyZSBib3RoIHNlYXJjaGVzIHdpbGwgbWVldC5cbiAgICB2YXIgbWluTm9kZTtcblxuICAgIC8vIFRoZSBzbWFsbGVzdCBwYXRoIGxlbmd0aCBzZWVuIHNvIGZhciBpcyBzdG9yZWQgaGVyZTpcbiAgICB2YXIgbE1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgIC8vIFdlIHN0YXJ0IGJ5IHB1dHRpbmcgc3RhcnQvZW5kIG5vZGVzIHRvIHRoZSBjb3JyZXNwb25kaW5nIGhlYXBzXG4gICAgLy8gSWYgdmFyaWFibGUgbmFtZXMgbGlrZSBgZjFgLCBgZzFgIGFyZSB0b28gY29uZnVzaW5nLCBwbGVhc2UgcmVmZXJcbiAgICAvLyB0byBtYWtlTkJBU2VhcmNoU3RhdGVQb29sLmpzIGZpbGUsIHdoaWNoIGhhcyBkZXRhaWxlZCBkZXNjcmlwdGlvbi5cbiAgICB2YXIgc3RhcnROb2RlID0gcG9vbC5jcmVhdGVOZXdTdGF0ZShmcm9tKTtcbiAgICBub2RlU3RhdGUuc2V0KGZyb21JZCwgc3RhcnROb2RlKTsgXG4gICAgc3RhcnROb2RlLmcxID0gMDtcbiAgICB2YXIgZjEgPSBoZXVyaXN0aWMoZnJvbSwgdG8pO1xuICAgIHN0YXJ0Tm9kZS5mMSA9IGYxO1xuICAgIG9wZW4xU2V0LnB1c2goc3RhcnROb2RlKTtcblxuICAgIHZhciBlbmROb2RlID0gcG9vbC5jcmVhdGVOZXdTdGF0ZSh0byk7XG4gICAgbm9kZVN0YXRlLnNldCh0b0lkLCBlbmROb2RlKTtcbiAgICBlbmROb2RlLmcyID0gMDtcbiAgICB2YXIgZjIgPSBmMTsgLy8gdGhleSBzaG91bGQgYWdyZWUgb3JpZ2luYWxseVxuICAgIGVuZE5vZGUuZjIgPSBmMjtcbiAgICBvcGVuMlNldC5wdXNoKGVuZE5vZGUpXG5cbiAgICAvLyB0aGUgYGNhbWVGcm9tYCB2YXJpYWJsZSBpcyBhY2Nlc3NlZCBieSBib3RoIHNlYXJjaGVzLCBzbyB0aGF0IHdlIGNhbiBzdG9yZSBwYXJlbnRzLlxuICAgIHZhciBjYW1lRnJvbTtcblxuICAgIC8vIHRoaXMgaXMgdGhlIG1haW4gYWxnb3JpdGhtIGxvb3A6XG4gICAgd2hpbGUgKG9wZW4yU2V0Lmxlbmd0aCAmJiBvcGVuMVNldC5sZW5ndGgpIHtcbiAgICAgIGlmIChvcGVuMVNldC5sZW5ndGggPCBvcGVuMlNldC5sZW5ndGgpIHtcbiAgICAgICAgZm9yd2FyZFNlYXJjaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZVNlYXJjaCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocXVpdEZhc3QgJiYgbWluTm9kZSkgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSByZWNvbnN0cnVjdFBhdGgobWluTm9kZSk7XG4gICAgcmV0dXJuIHBhdGg7IC8vIHRoZSBwdWJsaWMgQVBJIGlzIG92ZXJcblxuICAgIGZ1bmN0aW9uIGZvcndhcmRTZWFyY2goKSB7XG4gICAgICBjYW1lRnJvbSA9IG9wZW4xU2V0LnBvcCgpO1xuICAgICAgaWYgKGNhbWVGcm9tLmNsb3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNhbWVGcm9tLmNsb3NlZCA9IHRydWU7XG5cbiAgICAgIGlmIChjYW1lRnJvbS5mMSA8IGxNaW4gJiYgKGNhbWVGcm9tLmcxICsgZjIgLSBoZXVyaXN0aWMoZnJvbSwgY2FtZUZyb20ubm9kZSkpIDwgbE1pbikge1xuICAgICAgICBncmFwaC5mb3JFYWNoTGlua2VkTm9kZShjYW1lRnJvbS5ub2RlLmlkLCBmb3J3YXJkVmlzaXRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVuMVNldC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHRoaXMgd2lsbCBiZSB1c2VkIGluIHJldmVyc2Ugc2VhcmNoXG4gICAgICAgIGYxID0gb3BlbjFTZXQucGVlaygpLmYxO1xuICAgICAgfSBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXZlcnNlU2VhcmNoKCkge1xuICAgICAgY2FtZUZyb20gPSBvcGVuMlNldC5wb3AoKTtcbiAgICAgIGlmIChjYW1lRnJvbS5jbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FtZUZyb20uY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgaWYgKGNhbWVGcm9tLmYyIDwgbE1pbiAmJiAoY2FtZUZyb20uZzIgKyBmMSAtIGhldXJpc3RpYyhjYW1lRnJvbS5ub2RlLCB0bykpIDwgbE1pbikge1xuICAgICAgICBncmFwaC5mb3JFYWNoTGlua2VkTm9kZShjYW1lRnJvbS5ub2RlLmlkLCByZXZlcnNlVmlzaXRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVuMlNldC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHRoaXMgd2lsbCBiZSB1c2VkIGluIGZvcndhcmQgc2VhcmNoXG4gICAgICAgIGYyID0gb3BlbjJTZXQucGVlaygpLmYyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZpc2l0TjEob3RoZXJOb2RlLCBsaW5rKSB7XG4gICAgICB2YXIgb3RoZXJTZWFyY2hTdGF0ZSA9IG5vZGVTdGF0ZS5nZXQob3RoZXJOb2RlLmlkKTtcbiAgICAgIGlmICghb3RoZXJTZWFyY2hTdGF0ZSkge1xuICAgICAgICBvdGhlclNlYXJjaFN0YXRlID0gcG9vbC5jcmVhdGVOZXdTdGF0ZShvdGhlck5vZGUpO1xuICAgICAgICBub2RlU3RhdGUuc2V0KG90aGVyTm9kZS5pZCwgb3RoZXJTZWFyY2hTdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdGhlclNlYXJjaFN0YXRlLmNsb3NlZCkgcmV0dXJuO1xuXG4gICAgICB2YXIgdGVudGF0aXZlRGlzdGFuY2UgPSBjYW1lRnJvbS5nMSArIGRpc3RhbmNlKGNhbWVGcm9tLm5vZGUsIG90aGVyTm9kZSwgbGluayk7XG5cbiAgICAgIGlmICh0ZW50YXRpdmVEaXN0YW5jZSA8IG90aGVyU2VhcmNoU3RhdGUuZzEpIHtcbiAgICAgICAgb3RoZXJTZWFyY2hTdGF0ZS5nMSA9IHRlbnRhdGl2ZURpc3RhbmNlO1xuICAgICAgICBvdGhlclNlYXJjaFN0YXRlLmYxID0gdGVudGF0aXZlRGlzdGFuY2UgKyBoZXVyaXN0aWMob3RoZXJTZWFyY2hTdGF0ZS5ub2RlLCB0byk7XG4gICAgICAgIG90aGVyU2VhcmNoU3RhdGUucDEgPSBjYW1lRnJvbTtcbiAgICAgICAgaWYgKG90aGVyU2VhcmNoU3RhdGUuaDEgPCAwKSB7XG4gICAgICAgICAgb3BlbjFTZXQucHVzaChvdGhlclNlYXJjaFN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcGVuMVNldC51cGRhdGVJdGVtKG90aGVyU2VhcmNoU3RhdGUuaDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcG90ZW50aWFsTWluID0gb3RoZXJTZWFyY2hTdGF0ZS5nMSArIG90aGVyU2VhcmNoU3RhdGUuZzI7XG4gICAgICBpZiAocG90ZW50aWFsTWluIDwgbE1pbikgeyBcbiAgICAgICAgbE1pbiA9IHBvdGVudGlhbE1pbjtcbiAgICAgICAgbWluTm9kZSA9IG90aGVyU2VhcmNoU3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmlzaXROMihvdGhlck5vZGUsIGxpbmspIHtcbiAgICAgIHZhciBvdGhlclNlYXJjaFN0YXRlID0gbm9kZVN0YXRlLmdldChvdGhlck5vZGUuaWQpO1xuICAgICAgaWYgKCFvdGhlclNlYXJjaFN0YXRlKSB7XG4gICAgICAgIG90aGVyU2VhcmNoU3RhdGUgPSBwb29sLmNyZWF0ZU5ld1N0YXRlKG90aGVyTm9kZSk7XG4gICAgICAgIG5vZGVTdGF0ZS5zZXQob3RoZXJOb2RlLmlkLCBvdGhlclNlYXJjaFN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG90aGVyU2VhcmNoU3RhdGUuY2xvc2VkKSByZXR1cm47XG5cbiAgICAgIHZhciB0ZW50YXRpdmVEaXN0YW5jZSA9IGNhbWVGcm9tLmcyICsgZGlzdGFuY2UoY2FtZUZyb20ubm9kZSwgb3RoZXJOb2RlLCBsaW5rKTtcblxuICAgICAgaWYgKHRlbnRhdGl2ZURpc3RhbmNlIDwgb3RoZXJTZWFyY2hTdGF0ZS5nMikge1xuICAgICAgICBvdGhlclNlYXJjaFN0YXRlLmcyID0gdGVudGF0aXZlRGlzdGFuY2U7XG4gICAgICAgIG90aGVyU2VhcmNoU3RhdGUuZjIgPSB0ZW50YXRpdmVEaXN0YW5jZSArIGhldXJpc3RpYyhmcm9tLCBvdGhlclNlYXJjaFN0YXRlLm5vZGUpO1xuICAgICAgICBvdGhlclNlYXJjaFN0YXRlLnAyID0gY2FtZUZyb207XG4gICAgICAgIGlmIChvdGhlclNlYXJjaFN0YXRlLmgyIDwgMCkge1xuICAgICAgICAgIG9wZW4yU2V0LnB1c2gob3RoZXJTZWFyY2hTdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BlbjJTZXQudXBkYXRlSXRlbShvdGhlclNlYXJjaFN0YXRlLmgyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHBvdGVudGlhbE1pbiA9IG90aGVyU2VhcmNoU3RhdGUuZzEgKyBvdGhlclNlYXJjaFN0YXRlLmcyO1xuICAgICAgaWYgKHBvdGVudGlhbE1pbiA8IGxNaW4pIHtcbiAgICAgICAgbE1pbiA9IHBvdGVudGlhbE1pbjtcbiAgICAgICAgbWluTm9kZSA9IG90aGVyU2VhcmNoU3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmlzaXROMk9yaWVudGVkKG90aGVyTm9kZSwgbGluaykge1xuICAgICAgLy8gd2UgYXJlIGdvaW5nIGJhY2t3YXJkcywgZ3JhcGggbmVlZHMgdG8gYmUgcmV2ZXJzZWQuIFxuICAgICAgaWYgKGxpbmsudG9JZCA9PT0gY2FtZUZyb20ubm9kZS5pZCkgcmV0dXJuIHZpc2l0TjIob3RoZXJOb2RlLCBsaW5rKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmlzaXROMU9yaWVudGVkKG90aGVyTm9kZSwgbGluaykge1xuICAgICAgLy8gdGhpcyBpcyBmb3J3YXJkIGRpcmVjdGlvbiwgc28gd2Ugc2hvdWxkIGJlIGNvbWluZyBGUk9NOlxuICAgICAgaWYgKGxpbmsuZnJvbUlkID09PSBjYW1lRnJvbS5ub2RlLmlkKSByZXR1cm4gdmlzaXROMShvdGhlck5vZGUsIGxpbmspO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvbnN0cnVjdFBhdGgoc2VhcmNoU3RhdGUpIHtcbiAgaWYgKCFzZWFyY2hTdGF0ZSkgcmV0dXJuIE5PX1BBVEg7XG5cbiAgdmFyIHBhdGggPSBbc2VhcmNoU3RhdGUubm9kZV07XG4gIHZhciBwYXJlbnQgPSBzZWFyY2hTdGF0ZS5wMTtcblxuICB3aGlsZSAocGFyZW50KSB7XG4gICAgcGF0aC5wdXNoKHBhcmVudC5ub2RlKTtcbiAgICBwYXJlbnQgPSBwYXJlbnQucDE7XG4gIH1cblxuICB2YXIgY2hpbGQgPSBzZWFyY2hTdGF0ZS5wMjtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBwYXRoLnVuc2hpZnQoY2hpbGQubm9kZSk7XG4gICAgY2hpbGQgPSBjaGlsZC5wMjtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbWFrZU5CQVNlYXJjaFN0YXRlUG9vbDtcblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiBOQkFTZWFyY2hTdGF0ZS4gVGhlIGluc3RhbmNlIHN0b3JlcyBpbmZvcm1hdGlvblxuICogYWJvdXQgc2VhcmNoIHN0YXRlLCBhbmQgaXMgdXNlZCBieSBOQkEqIGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSAtIG9yaWdpbmFsIGdyYXBoIG5vZGVcbiAqL1xuZnVuY3Rpb24gTkJBU2VhcmNoU3RhdGUobm9kZSkge1xuICAvKipcbiAgICogT3JpZ2luYWwgZ3JhcGggbm9kZS5cbiAgICovXG4gIHRoaXMubm9kZSA9IG5vZGU7XG5cbiAgLyoqXG4gICAqIFBhcmVudCBvZiB0aGlzIG5vZGUgaW4gZm9yd2FyZCBzZWFyY2hcbiAgICovXG4gIHRoaXMucDEgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBQYXJlbnQgb2YgdGhpcyBub2RlIGluIHJldmVyc2Ugc2VhcmNoXG4gICAqL1xuICB0aGlzLnAyID0gbnVsbDtcblxuICAvKipcbiAgICogSWYgdGhpcyBpcyBzZXQgdG8gdHJ1ZSwgdGhlbiB0aGUgbm9kZSB3YXMgYWxyZWFkeSBwcm9jZXNzZWRcbiAgICogYW5kIHdlIHNob3VsZCBub3QgdG91Y2ggaXQgYW55bW9yZS5cbiAgICovXG4gIHRoaXMuY2xvc2VkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEFjdHVhbCBkaXN0YW5jZSBmcm9tIHRoaXMgbm9kZSB0byBpdHMgcGFyZW50IGluIGZvcndhcmQgc2VhcmNoXG4gICAqL1xuICB0aGlzLmcxID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gIC8qKlxuICAgKiBBY3R1YWwgZGlzdGFuY2UgZnJvbSB0aGlzIG5vZGUgdG8gaXRzIHBhcmVudCBpbiByZXZlcnNlIHNlYXJjaFxuICAgKi9cbiAgdGhpcy5nMiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuXG4gIC8qKlxuICAgKiBVbmRlcmVzdGltYXRlZCBkaXN0YW5jZSBmcm9tIHRoaXMgbm9kZSB0byB0aGUgcGF0aC1maW5kaW5nIHNvdXJjZS5cbiAgICovXG4gIHRoaXMuZjEgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgLyoqXG4gICAqIFVuZGVyZXN0aW1hdGVkIGRpc3RhbmNlIGZyb20gdGhpcyBub2RlIHRvIHRoZSBwYXRoLWZpbmRpbmcgdGFyZ2V0LlxuICAgKi9cbiAgdGhpcy5mMiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAvLyB1c2VkIHRvIHJlY29uc3RydWN0IGhlYXAgd2hlbiBmU2NvcmUgaXMgdXBkYXRlZC4gVE9ETzogZG8gSSBuZWVkIHRoZW0gYm90aD9cblxuICAvKipcbiAgICogSW5kZXggb2YgdGhpcyBub2RlIGluIHRoZSBmb3J3YXJkIGhlYXAuXG4gICAqL1xuICB0aGlzLmgxID0gLTE7XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoaXMgbm9kZSBpbiB0aGUgcmV2ZXJzZSBoZWFwLlxuICAgKi9cbiAgdGhpcy5oMiA9IC0xO1xufVxuXG4vKipcbiAqIEFzIHBhdGgtZmluZGluZyBpcyBtZW1vcnktaW50ZW5zaXZlIHByb2Nlc3MsIHdlIHdhbnQgdG8gcmVkdWNlIHByZXNzdXJlIG9uXG4gKiBnYXJiYWdlIGNvbGxlY3Rvci4gVGhpcyBjbGFzcyBoZWxwcyB1cyB0byByZWN5Y2xlIHBhdGgtZmluZGluZyBub2RlcyBhbmQgc2lnbmlmaWNhbnRseVxuICogcmVkdWNlcyB0aGUgc2VhcmNoIHRpbWUgKH4yMCUgZmFzdGVyIHRoYW4gd2l0aG91dCBpdCkuXG4gKi9cbmZ1bmN0aW9uIG1ha2VOQkFTZWFyY2hTdGF0ZVBvb2woKSB7XG4gIHZhciBjdXJyZW50SW5DYWNoZSA9IDA7XG4gIHZhciBub2RlQ2FjaGUgPSBbXTtcblxuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTkJBU2VhcmNoU3RhdGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjcmVhdGVOZXdTdGF0ZTogY3JlYXRlTmV3U3RhdGUsXG5cbiAgICAvKipcbiAgICAgKiBNYXJrcyBhbGwgY3JlYXRlZCBpbnN0YW5jZXMgYXZhaWxhYmxlIGZvciByZWN5Y2xpbmcuXG4gICAgICovXG4gICAgcmVzZXQ6IHJlc2V0XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY3VycmVudEluQ2FjaGUgPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTmV3U3RhdGUobm9kZSkge1xuICAgIHZhciBjYWNoZWQgPSBub2RlQ2FjaGVbY3VycmVudEluQ2FjaGVdO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIC8vIFRPRE86IFRoaXMgYWxtb3N0IGR1cGxpY2F0ZXMgY29uc3RydWN0b3IgY29kZS4gTm90IHN1cmUgaWZcbiAgICAgIC8vIGl0IHdvdWxkIGltcGFjdCBwZXJmb3JtYW5jZSBpZiBJIG1vdmUgdGhpcyBjb2RlIGludG8gYSBmdW5jdGlvblxuICAgICAgY2FjaGVkLm5vZGUgPSBub2RlO1xuXG4gICAgICAvLyBIb3cgd2UgY2FtZSB0byB0aGlzIG5vZGU/XG4gICAgICBjYWNoZWQucDEgPSBudWxsO1xuICAgICAgY2FjaGVkLnAyID0gbnVsbDtcblxuICAgICAgY2FjaGVkLmNsb3NlZCA9IGZhbHNlO1xuXG4gICAgICBjYWNoZWQuZzEgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICBjYWNoZWQuZzIgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICBjYWNoZWQuZjEgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICBjYWNoZWQuZjIgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgICAgIC8vIHVzZWQgdG8gcmVjb25zdHJ1Y3QgaGVhcCB3aGVuIGZTY29yZSBpcyB1cGRhdGVkLlxuICAgICAgY2FjaGVkLmgxID0gLTE7XG4gICAgICBjYWNoZWQuaDIgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVkID0gbmV3IE5CQVNlYXJjaFN0YXRlKG5vZGUpO1xuICAgICAgbm9kZUNhY2hlW2N1cnJlbnRJbkNhY2hlXSA9IGNhY2hlZDtcbiAgICB9XG4gICAgY3VycmVudEluQ2FjaGUrKztcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYVN0YXI6IHJlcXVpcmUoJy4vYS1zdGFyL2Etc3Rhci5qcycpLFxuICBhR3JlZWR5OiByZXF1aXJlKCcuL2Etc3Rhci9hLWdyZWVkeS1zdGFyJyksXG4gIG5iYTogcmVxdWlyZSgnLi9hLXN0YXIvbmJhL2luZGV4LmpzJyksXG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlIHR3Z2wuanMgNC4xOS4xIENvcHlyaWdodCAoYykgMjAxNSwgR3JlZ2cgVGF2YXJlcyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogQXZhaWxhYmxlIHZpYSB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBzZWU6IGh0dHA6Ly9naXRodWIuY29tL2dyZWdnbWFuL3R3Z2wuanMgZm9yIGRldGFpbHNcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widHdnbFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJ0d2dsXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy90d2dsLWZ1bGwuanNcIik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIFwiLi9zcmMvYXR0cmlidXRlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2F0dHJpYnV0ZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNyZWF0ZUF0dHJpYnNGcm9tQXJyYXlzID0gY3JlYXRlQXR0cmlic0Zyb21BcnJheXM7XG5leHBvcnRzLmNyZWF0ZUJ1ZmZlcnNGcm9tQXJyYXlzID0gY3JlYXRlQnVmZmVyc0Zyb21BcnJheXM7XG5leHBvcnRzLmNyZWF0ZUJ1ZmZlckZyb21BcnJheSA9IGNyZWF0ZUJ1ZmZlckZyb21BcnJheTtcbmV4cG9ydHMuY3JlYXRlQnVmZmVyRnJvbVR5cGVkQXJyYXkgPSBjcmVhdGVCdWZmZXJGcm9tVHlwZWRBcnJheTtcbmV4cG9ydHMuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMgPSBjcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cztcbmV4cG9ydHMuc2V0QXR0cmliSW5mb0J1ZmZlckZyb21BcnJheSA9IHNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXk7XG5leHBvcnRzLnNldEF0dHJpYnV0ZVByZWZpeCA9IHNldEF0dHJpYnV0ZVByZWZpeDtcbmV4cG9ydHMuc2V0QXR0cmlidXRlRGVmYXVsdHNfID0gc2V0RGVmYXVsdHM7XG5leHBvcnRzLmdldE51bUNvbXBvbmVudHNfID0gZ2V0TnVtQ29tcG9uZW50cztcbmV4cG9ydHMuZ2V0QXJyYXlfID0gZ2V0QXJyYXk7XG5cbnZhciB0eXBlZEFycmF5cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHlwZWRhcnJheXMuanMgKi8gXCIuL3NyYy90eXBlZGFycmF5cy5qc1wiKSk7XG5cbnZhciBoZWxwZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hlbHBlci5qcyAqLyBcIi4vc3JjL2hlbHBlci5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbnZhciBTVEFUSUNfRFJBVyA9IDB4ODhlNDtcbnZhciBBUlJBWV9CVUZGRVIgPSAweDg4OTI7XG52YXIgRUxFTUVOVF9BUlJBWV9CVUZGRVIgPSAweDg4OTM7XG52YXIgQlVGRkVSX1NJWkUgPSAweDg3NjQ7XG52YXIgQllURSA9IDB4MTQwMDtcbnZhciBVTlNJR05FRF9CWVRFID0gMHgxNDAxO1xudmFyIFNIT1JUID0gMHgxNDAyO1xudmFyIFVOU0lHTkVEX1NIT1JUID0gMHgxNDAzO1xudmFyIElOVCA9IDB4MTQwNDtcbnZhciBVTlNJR05FRF9JTlQgPSAweDE0MDU7XG52YXIgRkxPQVQgPSAweDE0MDY7XG4vKipcbiAqIExvdyBsZXZlbCBhdHRyaWJ1dGUgYW5kIGJ1ZmZlciByZWxhdGVkIGZ1bmN0aW9uc1xuICpcbiAqIFlvdSBzaG91bGQgZ2VuZXJhbGx5IG5vdCBuZWVkIHRvIHVzZSB0aGVzZSBmdW5jdGlvbnMuIFRoZXkgYXJlIHByb3ZpZGVkXG4gKiBmb3IgdGhvc2UgY2FzZXMgd2hlcmUgeW91J3JlIGRvaW5nIHNvbWV0aGluZyBvdXQgb2YgdGhlIG9yZGluYXJ5XG4gKiBhbmQgeW91IG5lZWQgbG93ZXIgbGV2ZWwgYWNjZXNzLlxuICpcbiAqIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHRoZXkgYXJlIGF2YWlsYWJsZSBhdCBib3RoIGB0d2dsLmF0dHJpYnV0ZXNgIGFuZCBgdHdnbGBcbiAqIGl0c2VsZlxuICpcbiAqIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2x9IGZvciBjb3JlIGZ1bmN0aW9uc1xuICpcbiAqIEBtb2R1bGUgdHdnbC9hdHRyaWJ1dGVzXG4gKi9cbi8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBzZWUgYSBnbG9iYWwgZ2xcblxudmFyIGdsID0gdW5kZWZpbmVkO1xuLyogZXNsaW50LWRpc2FibGUtbGluZSAqL1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGF0dHJpYlByZWZpeDogXCJcIlxufTtcbi8qKlxuICogU2V0cyB0aGUgZGVmYXVsdCBhdHRyaWIgcHJlZml4XG4gKlxuICogV2hlbiB3cml0aW5nIHNoYWRlcnMgSSBwcmVmZXIgdG8gbmFtZSBhdHRyaWJ1dGVzIHdpdGggYGFfYCwgdW5pZm9ybXMgd2l0aCBgdV9gIGFuZCB2YXJ5aW5ncyB3aXRoIGB2X2BcbiAqIGFzIGl0IG1ha2VzIGl0IGNsZWFyIHdoZXJlIHRoZXkgY2FtZSBmcm9tLiBCdXQsIHdoZW4gYnVpbGRpbmcgZ2VvbWV0cnkgSSBwcmVmZXIgdXNpbmcgdW4tcHJlZml4ZWQgbmFtZXMuXG4gKlxuICogSW4gb3RoZXIgd29yZHMgSSdsbCBjcmVhdGUgYXJyYXlzIG9mIGdlb21ldHJ5IGxpa2UgdGhpc1xuICpcbiAqICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgcG9zaXRpb246IC4uLlxuICogICAgICAgbm9ybWFsOiAuLi5cbiAqICAgICAgIHRleGNvb3JkOiAuLi5cbiAqICAgICB9O1xuICpcbiAqIEJ1dCBuZWVkIHRob3NlIG1hcHBlZCB0byBhdHRyaWJ1dGVzIGFuZCBteSBhdHRyaWJ1dGVzIHN0YXJ0IHdpdGggYGFfYC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLnNldERlZmF1bHRzfVxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBwcmVmaXggZm9yIGF0dHJpYnNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9hdHRyaWJ1dGVzXG4gKi9cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlUHJlZml4KHByZWZpeCkge1xuICBkZWZhdWx0cy5hdHRyaWJQcmVmaXggPSBwcmVmaXg7XG59XG5cbmZ1bmN0aW9uIHNldERlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gIGhlbHBlci5jb3B5RXhpc3RpbmdQcm9wZXJ0aWVzKG5ld0RlZmF1bHRzLCBkZWZhdWx0cyk7XG59XG5cbmZ1bmN0aW9uIHNldEJ1ZmZlckZyb21UeXBlZEFycmF5KGdsLCB0eXBlLCBidWZmZXIsIGFycmF5LCBkcmF3VHlwZSkge1xuICBnbC5iaW5kQnVmZmVyKHR5cGUsIGJ1ZmZlcik7XG4gIGdsLmJ1ZmZlckRhdGEodHlwZSwgYXJyYXksIGRyYXdUeXBlIHx8IFNUQVRJQ19EUkFXKTtcbn1cbi8qKlxuICogR2l2ZW4gdHlwZWQgYXJyYXkgY3JlYXRlcyBhIFdlYkdMQnVmZmVyIGFuZCBjb3BpZXMgdGhlIHR5cGVkIGFycmF5XG4gKiBpbnRvIGl0LlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxTaGFyZWRBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd8V2ViR0xCdWZmZXJ9IHR5cGVkQXJyYXkgdGhlIHR5cGVkIGFycmF5LiBOb3RlOiBJZiBhIFdlYkdMQnVmZmVyIGlzIHBhc3NlZCBpbiBpdCB3aWxsIGp1c3QgYmUgcmV0dXJuZWQuIE5vIGFjdGlvbiB3aWxsIGJlIHRha2VuXG4gKiBAcGFyYW0ge251bWJlcn0gW3R5cGVdIHRoZSBHTCBiaW5kIHR5cGUgZm9yIHRoZSBidWZmZXIuIERlZmF1bHQgPSBgZ2wuQVJSQVlfQlVGRkVSYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZHJhd1R5cGVdIHRoZSBHTCBkcmF3IHR5cGUgZm9yIHRoZSBidWZmZXIuIERlZmF1bHQgPSAnZ2wuU1RBVElDX0RSQVdgLlxuICogQHJldHVybiB7V2ViR0xCdWZmZXJ9IHRoZSBjcmVhdGVkIFdlYkdMQnVmZmVyXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvYXR0cmlidXRlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIHR5cGVkQXJyYXksIHR5cGUsIGRyYXdUeXBlKSB7XG4gIGlmIChoZWxwZXIuaXNCdWZmZXIoZ2wsIHR5cGVkQXJyYXkpKSB7XG4gICAgcmV0dXJuIHR5cGVkQXJyYXk7XG4gIH1cblxuICB0eXBlID0gdHlwZSB8fCBBUlJBWV9CVUZGRVI7XG4gIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgc2V0QnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIHR5cGUsIGJ1ZmZlciwgdHlwZWRBcnJheSwgZHJhd1R5cGUpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBpc0luZGljZXMobmFtZSkge1xuICByZXR1cm4gbmFtZSA9PT0gXCJpbmRpY2VzXCI7XG59IC8vIFRoaXMgaXMgcmVhbGx5IGp1c3QgYSBndWVzcy4gVGhvdWdoIEkgY2FuJ3QgcmVhbGx5IGltYWdpbmUgdXNpbmdcbi8vIGFueXRoaW5nIGVsc2U/IE1heWJlIGZvciBzb21lIGNvbXByZXNzaW9uP1xuXG5cbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25Gb3JUeXBlZEFycmF5KHR5cGVkQXJyYXkpIHtcbiAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIFRoaXMgaXMgcmVhbGx5IGp1c3QgYSBndWVzcy4gVGhvdWdoIEkgY2FuJ3QgcmVhbGx5IGltYWdpbmUgdXNpbmdcbi8vIGFueXRoaW5nIGVsc2U/IE1heWJlIGZvciBzb21lIGNvbXByZXNzaW9uP1xuXG5cbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25Gb3JUeXBlZEFycmF5VHlwZSh0eXBlZEFycmF5VHlwZSkge1xuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IEludDhBcnJheSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5VHlwZSA9PT0gVWludDhBcnJheSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXkoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5Lmxlbmd0aCA/IGFycmF5IDogYXJyYXkuZGF0YTtcbn1cblxudmFyIHRleGNvb3JkUkUgPSAvY29vcmR8dGV4dHVyZS9pO1xudmFyIGNvbG9yUkUgPSAvY29sb3J8Y29sb3VyL2k7XG5cbmZ1bmN0aW9uIGd1ZXNzTnVtQ29tcG9uZW50c0Zyb21OYW1lKG5hbWUsIGxlbmd0aCkge1xuICB2YXIgbnVtQ29tcG9uZW50cztcblxuICBpZiAodGV4Y29vcmRSRS50ZXN0KG5hbWUpKSB7XG4gICAgbnVtQ29tcG9uZW50cyA9IDI7XG4gIH0gZWxzZSBpZiAoY29sb3JSRS50ZXN0KG5hbWUpKSB7XG4gICAgbnVtQ29tcG9uZW50cyA9IDQ7XG4gIH0gZWxzZSB7XG4gICAgbnVtQ29tcG9uZW50cyA9IDM7IC8vIHBvc2l0aW9uLCBub3JtYWxzLCBpbmRpY2VzIC4uLlxuICB9XG5cbiAgaWYgKGxlbmd0aCAlIG51bUNvbXBvbmVudHMgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBndWVzcyBudW1Db21wb25lbnRzIGZvciBhdHRyaWJ1dGUgJ1wiLmNvbmNhdChuYW1lLCBcIicuIFRyaWVkIFwiKS5jb25jYXQobnVtQ29tcG9uZW50cywgXCIgYnV0IFwiKS5jb25jYXQobGVuZ3RoLCBcIiB2YWx1ZXMgaXMgbm90IGV2ZW5seSBkaXZpc2libGUgYnkgXCIpLmNvbmNhdChudW1Db21wb25lbnRzLCBcIi4gWW91IHNob3VsZCBzcGVjaWZ5IGl0LlwiKSk7XG4gIH1cblxuICByZXR1cm4gbnVtQ29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gZ2V0TnVtQ29tcG9uZW50cyhhcnJheSwgYXJyYXlOYW1lKSB7XG4gIHJldHVybiBhcnJheS5udW1Db21wb25lbnRzIHx8IGFycmF5LnNpemUgfHwgZ3Vlc3NOdW1Db21wb25lbnRzRnJvbU5hbWUoYXJyYXlOYW1lLCBnZXRBcnJheShhcnJheSkubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gbWFrZVR5cGVkQXJyYXkoYXJyYXksIG5hbWUpIHtcbiAgaWYgKHR5cGVkQXJyYXlzLmlzQXJyYXlCdWZmZXIoYXJyYXkpKSB7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgaWYgKHR5cGVkQXJyYXlzLmlzQXJyYXlCdWZmZXIoYXJyYXkuZGF0YSkpIHtcbiAgICByZXR1cm4gYXJyYXkuZGF0YTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgIGFycmF5ID0ge1xuICAgICAgZGF0YTogYXJyYXlcbiAgICB9O1xuICB9XG5cbiAgdmFyIFR5cGUgPSBhcnJheS50eXBlO1xuXG4gIGlmICghVHlwZSkge1xuICAgIGlmIChpc0luZGljZXMobmFtZSkpIHtcbiAgICAgIFR5cGUgPSBVaW50MTZBcnJheTtcbiAgICB9IGVsc2Uge1xuICAgICAgVHlwZSA9IEZsb2F0MzJBcnJheTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFR5cGUoYXJyYXkuZGF0YSk7XG59XG4vKipcbiAqIFRoZSBpbmZvIGZvciBhbiBhdHRyaWJ1dGUuIFRoaXMgaXMgZWZmZWN0aXZlbHkganVzdCB0aGUgYXJndW1lbnRzIHRvIGBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyYCBwbHVzIHRoZSBXZWJHTEJ1ZmZlclxuICogZm9yIHRoZSBhdHRyaWJ1dGUuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQXR0cmliSW5mb1xuICogQHByb3BlcnR5IHtudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd9IFt2YWx1ZV0gYSBjb25zdGFudCB2YWx1ZSBmb3IgdGhlIGF0dHJpYnV0ZS4gTm90ZTogaWYgdGhpcyBpcyBzZXQgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlXG4gKiAgICBkaXNhYmxlZCBhbmQgc2V0IHRvIHRoaXMgY29uc3RhbnQgdmFsdWUgYW5kIGFsbCBvdGhlciB2YWx1ZXMgd2lsbCBiZSBpZ25vcmVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtudW1Db21wb25lbnRzXSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgZm9yIHRoaXMgYXR0cmlidXRlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplXSBzeW5vbnltIGZvciBgbnVtQ29tcG9uZW50c2AuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3R5cGVdIHRoZSB0eXBlIG9mIHRoZSBhdHRyaWJ1dGUgKGVnLiBgZ2wuRkxPQVRgLCBgZ2wuVU5TSUdORURfQllURWAsIGV0Yy4uLikgRGVmYXVsdCA9IGBnbC5GTE9BVGBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW25vcm1hbGl6ZV0gd2hldGhlciBvciBub3QgdG8gbm9ybWFsaXplIHRoZSBkYXRhLiBEZWZhdWx0ID0gZmFsc2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb2Zmc2V0XSBvZmZzZXQgaW50byBidWZmZXIgaW4gYnl0ZXMuIERlZmF1bHQgPSAwXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N0cmlkZV0gdGhlIHN0cmlkZSBpbiBieXRlcyBwZXIgZWxlbWVudC4gRGVmYXVsdCA9IDBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGl2aXNvcl0gdGhlIGRpdmlzb3IgaW4gaW5zdGFuY2VzLiBEZWZhdWx0ID0gdW5kZWZpbmVkLiBOb3RlOiB1bmRlZmluZWQgPSBkb24ndCBjYWxsIGdsLnZlcnRleEF0dHJpYkRpdmlzb3JcbiAqICAgIHdoZXJlIGFzIGFueXRoaW5nIGVsc2UgPSBkbyBjYWxsIGl0IHdpdGggdGhpcyB2YWx1ZVxuICogQHByb3BlcnR5IHtXZWJHTEJ1ZmZlcn0gYnVmZmVyIHRoZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgZGF0YSBmb3IgdGhpcyBhdHRyaWJ1dGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHJhd1R5cGVdIHRoZSBkcmF3IHR5cGUgcGFzc2VkIHRvIGdsLmJ1ZmZlckRhdGEuIERlZmF1bHQgPSBnbC5TVEFUSUNfRFJBV1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBVc2UgdGhpcyB0eXBlIG9mIGFycmF5IHNwZWMgd2hlbiBUV0dMIGNhbid0IGd1ZXNzIHRoZSB0eXBlIG9yIG51bWJlciBvZiBjb21wb25lbnRzIG9mIGFuIGFycmF5XG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGdWxsQXJyYXlTcGVjXG4gKiBAcHJvcGVydHkge251bWJlcltdfEFycmF5QnVmZmVyVmlld30gW3ZhbHVlXSBhIGNvbnN0YW50IHZhbHVlIGZvciB0aGUgYXR0cmlidXRlLiBOb3RlOiBpZiB0aGlzIGlzIHNldCB0aGUgYXR0cmlidXRlIHdpbGwgYmVcbiAqICAgIGRpc2FibGVkIGFuZCBzZXQgdG8gdGhpcyBjb25zdGFudCB2YWx1ZSBhbmQgYWxsIG90aGVyIHZhbHVlcyB3aWxsIGJlIGlnbm9yZWQuXG4gKiBAcHJvcGVydHkgeyhudW1iZXJ8bnVtYmVyW118QXJyYXlCdWZmZXJWaWV3KX0gZGF0YSBUaGUgZGF0YSBvZiB0aGUgYXJyYXkuIEEgbnVtYmVyIGFsb25lIGJlY29tZXMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiB0eXBlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtudW1Db21wb25lbnRzXSBudW1iZXIgb2YgY29tcG9uZW50cyBmb3IgYHZlcnRleEF0dHJpYlBvaW50ZXJgLiBEZWZhdWx0IGlzIGJhc2VkIG9uIHRoZSBuYW1lIG9mIHRoZSBhcnJheS5cbiAqICAgIElmIGBjb29yZGAgaXMgaW4gdGhlIG5hbWUgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDJgLlxuICogICAgSWYgYGNvbG9yYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gNGAuXG4gKiAgICBvdGhlcndpc2UgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDNgXG4gKiBAcHJvcGVydHkge2NvbnN0cnVjdG9yfSBbdHlwZV0gdHlwZS4gVGhpcyBpcyBvbmx5IHVzZWQgaWYgYGRhdGFgIGlzIGEgSmF2YVNjcmlwdCBhcnJheS4gSXQgaXMgdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZWRhcnJheS4gKGVnLiBgVWludDhBcnJheWApLlxuICogRm9yIGV4YW1wbGUgaWYgeW91IHdhbnQgY29sb3JzIGluIGEgYFVpbnQ4QXJyYXlgIHlvdSBtaWdodCBoYXZlIGEgYEZ1bGxBcnJheVNwZWNgIGxpa2UgYHsgdHlwZTogVWludDhBcnJheSwgZGF0YTogWzI1NSwwLDI1NSwyNTUsIC4uLl0sIH1gLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplXSBzeW5vbnltIGZvciBgbnVtQ29tcG9uZW50c2AuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtub3JtYWxpemVdIG5vcm1hbGl6ZSBmb3IgYHZlcnRleEF0dHJpYlBvaW50ZXJgLiBEZWZhdWx0IGlzIHRydWUgaWYgdHlwZSBpcyBgSW50OEFycmF5YCBvciBgVWludDhBcnJheWAgb3RoZXJ3aXNlIGZhbHNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzdHJpZGVdIHN0cmlkZSBmb3IgYHZlcnRleEF0dHJpYlBvaW50ZXJgLiBEZWZhdWx0ID0gMFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvZmZzZXRdIG9mZnNldCBmb3IgYHZlcnRleEF0dHJpYlBvaW50ZXJgLiBEZWZhdWx0ID0gMFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkaXZpc29yXSBkaXZpc29yIGZvciBgdmVydGV4QXR0cmliRGl2aXNvcmAuIERlZmF1bHQgPSB1bmRlZmluZWQuIE5vdGU6IHVuZGVmaW5lZCA9IGRvbid0IGNhbGwgZ2wudmVydGV4QXR0cmliRGl2aXNvclxuICogICAgd2hlcmUgYXMgYW55dGhpbmcgZWxzZSA9IGRvIGNhbGwgaXQgd2l0aCB0aGlzIHZhbHVlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2F0dHJpYl0gbmFtZSBvZiBhdHRyaWJ1dGUgdGhpcyBhcnJheSBtYXBzIHRvLiBEZWZhdWx0cyB0byBzYW1lIG5hbWUgYXMgYXJyYXkgcHJlZml4ZWQgYnkgdGhlIGRlZmF1bHQgYXR0cmliUHJlZml4LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBzeW5vbnltIGZvciBgYXR0cmliYC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXR0cmliTmFtZV0gc3lub255bSBmb3IgYGF0dHJpYmAuXG4gKiBAcHJvcGVydHkge1dlYkdMQnVmZmVyfSBbYnVmZmVyXSBCdWZmZXIgdG8gdXNlIGZvciB0aGlzIGF0dHJpYnV0ZS4gVGhpcyBsZXRzIHlvdSB1c2UgeW91ciBvd24gYnVmZmVyXG4gKiAgICBidXQgeW91IHdpbGwgbmVlZCB0byBzdXBwbHkgYG51bUNvbXBvbmVudHNgIGFuZCBgdHlwZWAuIFlvdSBjYW4gZWZmZWN0aXZlbHkgcGFzcyBhbiBgQXR0cmliSW5mb2BcbiAqICAgIHRvIHByb3ZpZGUgdGhpcy4gRXhhbXBsZTpcbiAqXG4gKiAgICAgICAgIGNvbnN0IGJ1ZmZlckluZm8xID0gdHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwge1xuICogICAgICAgICAgIHBvc2l0aW9uOiBbMSwgMiwgMywgLi4uIF0sXG4gKiAgICAgICAgIH0pO1xuICogICAgICAgICBjb25zdCBidWZmZXJJbmZvMiA9IHR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMoZ2wsIHtcbiAqICAgICAgICAgICBwb3NpdGlvbjogYnVmZmVySW5mbzEuYXR0cmlicy5wb3NpdGlvbiwgIC8vIHVzZSB0aGUgc2FtZSBidWZmZXIgZnJvbSBidWZmZXJJbmZvMVxuICogICAgICAgICB9KTtcbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEFuIGluZGl2aWR1YWwgYXJyYXkgaW4ge0BsaW5rIG1vZHVsZTp0d2dsLkFycmF5c31cbiAqXG4gKiBXaGVuIHBhc3NlZCB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXN9IGlmIGFuIEFycmF5U3BlYyBpcyBgbnVtYmVyW11gIG9yIGBBcnJheUJ1ZmZlclZpZXdgXG4gKiB0aGUgdHlwZXMgd2lsbCBiZSBndWVzc2VkIGJhc2VkIG9uIHRoZSBuYW1lLiBgaW5kaWNlc2Agd2lsbCBiZSBgVWludDE2QXJyYXlgLCBldmVyeXRoaW5nIGVsc2Ugd2lsbFxuICogYmUgYEZsb2F0MzJBcnJheWAuIElmIGFuIEFycmF5U3BlYyBpcyBhIG51bWJlciBpdCdzIHRoZSBudW1iZXIgb2YgZmxvYXRzIGZvciBhbiBlbXB0eSAoemVyb2VkKSBidWZmZXIuXG4gKlxuICogQHR5cGVkZWYgeyhudW1iZXJ8bnVtYmVyW118QXJyYXlCdWZmZXJWaWV3fG1vZHVsZTp0d2dsLkZ1bGxBcnJheVNwZWMpfSBBcnJheVNwZWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogVGhpcyBpcyBhIEphdmFTY3JpcHQgb2JqZWN0IG9mIGFycmF5cyBieSBuYW1lLiBUaGUgbmFtZXMgc2hvdWxkIG1hdGNoIHlvdXIgc2hhZGVyJ3MgYXR0cmlidXRlcy4gSWYgeW91clxuICogYXR0cmlidXRlcyBoYXZlIGEgY29tbW9uIHByZWZpeCB5b3UgY2FuIHNwZWNpZnkgaXQgYnkgY2FsbGluZyB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QXR0cmlidXRlUHJlZml4fS5cbiAqXG4gKiAgICAgQmFyZSBKYXZhU2NyaXB0IEFycmF5c1xuICpcbiAqICAgICAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICAgICAgcG9zaXRpb246IFstMSwgMSwgMF0sXG4gKiAgICAgICAgICAgIG5vcm1hbDogWzAsIDEsIDBdLFxuICogICAgICAgICAgICAuLi5cbiAqICAgICAgICAgfVxuICpcbiAqICAgICBCYXJlIFR5cGVkQXJyYXlzXG4gKlxuICogICAgICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgICAgICBwb3NpdGlvbjogbmV3IEZsb2F0MzJBcnJheShbLTEsIDEsIDBdKSxcbiAqICAgICAgICAgICAgY29sb3I6IG5ldyBVaW50OEFycmF5KFsyNTUsIDEyOCwgNjQsIDI1NV0pLFxuICogICAgICAgICAgICAuLi5cbiAqICAgICAgICAgfVxuICpcbiAqICogICBXaWxsIGd1ZXNzIGF0IGBudW1Db21wb25lbnRzYCBpZiBub3Qgc3BlY2lmaWVkIGJhc2VkIG9uIG5hbWUuXG4gKlxuICogICAgIElmIGBjb29yZGAgaXMgaW4gdGhlIG5hbWUgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDJgXG4gKlxuICogICAgIElmIGBjb2xvcmAgaXMgaW4gdGhlIG5hbWUgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDRgXG4gKlxuICogICAgIG90aGVyd2lzZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gM2BcbiAqXG4gKiBPYmplY3RzIHdpdGggdmFyaW91cyBmaWVsZHMuIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2wuRnVsbEFycmF5U3BlY30uXG4gKlxuICogICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICBwb3NpdGlvbjogeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdLCB9LFxuICogICAgICAgdGV4Y29vcmQ6IHsgbnVtQ29tcG9uZW50czogMiwgZGF0YTogWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdLCAgICAgICAgICAgICAgICAgfSxcbiAqICAgICAgIG5vcm1hbDogICB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSwgICAgIH0sXG4gKiAgICAgICBpbmRpY2VzOiAgeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMSwgMiwgMSwgMiwgM10sICAgICAgICAgICAgICAgICAgICAgICB9LFxuICogICAgIH07XG4gKlxuICogQHR5cGVkZWYge09iamVjdC48c3RyaW5nLCBtb2R1bGU6dHdnbC5BcnJheVNwZWM+fSBBcnJheXNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvZiBhdHRyaWJ1dGUgZGF0YSBhbmQgV2ViR0xCdWZmZXJzIGZyb20gc2V0IG9mIGFycmF5c1xuICpcbiAqIEdpdmVuXG4gKlxuICogICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgIHBvc2l0aW9uOiB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAwLCAwLCAxMCwgMCwgMCwgMCwgMTAsIDAsIDEwLCAxMCwgMF0sIH0sXG4gKiAgICAgICAgdGV4Y29vcmQ6IHsgbnVtQ29tcG9uZW50czogMiwgZGF0YTogWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdLCAgICAgICAgICAgICAgICAgfSxcbiAqICAgICAgICBub3JtYWw6ICAgeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMV0sICAgICB9LFxuICogICAgICAgIGNvbG9yOiAgICB7IG51bUNvbXBvbmVudHM6IDQsIGRhdGE6IFsyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMCwgMCwgMjU1LCAwLCAwLCAyNTUsIDI1NV0sIHR5cGU6IFVpbnQ4QXJyYXksIH0sXG4gKiAgICAgICAgaW5kaWNlczogIHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDEsIDIsIDEsIDIsIDNdLCAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAqICAgICAgfTtcbiAqXG4gKiByZXR1cm5zIHNvbWV0aGluZyBsaWtlXG4gKlxuICogICAgICB2YXIgYXR0cmlicyA9IHtcbiAqICAgICAgICBwb3NpdGlvbjogeyBudW1Db21wb25lbnRzOiAzLCB0eXBlOiBnbC5GTE9BVCwgICAgICAgICBub3JtYWxpemU6IGZhbHNlLCBidWZmZXI6IFdlYkdMQnVmZmVyLCB9LFxuICogICAgICAgIHRleGNvb3JkOiB7IG51bUNvbXBvbmVudHM6IDIsIHR5cGU6IGdsLkZMT0FULCAgICAgICAgIG5vcm1hbGl6ZTogZmFsc2UsIGJ1ZmZlcjogV2ViR0xCdWZmZXIsIH0sXG4gKiAgICAgICAgbm9ybWFsOiAgIHsgbnVtQ29tcG9uZW50czogMywgdHlwZTogZ2wuRkxPQVQsICAgICAgICAgbm9ybWFsaXplOiBmYWxzZSwgYnVmZmVyOiBXZWJHTEJ1ZmZlciwgfSxcbiAqICAgICAgICBjb2xvcjogICAgeyBudW1Db21wb25lbnRzOiA0LCB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLCBub3JtYWxpemU6IHRydWUsICBidWZmZXI6IFdlYkdMQnVmZmVyLCB9LFxuICogICAgICB9O1xuICpcbiAqIG5vdGVzOlxuICpcbiAqICogICBBcnJheXMgY2FuIHRha2UgdmFyaW91cyBmb3Jtc1xuICpcbiAqICAgICBCYXJlIEphdmFTY3JpcHQgQXJyYXlzXG4gKlxuICogICAgICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgICAgICBwb3NpdGlvbjogWy0xLCAxLCAwXSxcbiAqICAgICAgICAgICAgbm9ybWFsOiBbMCwgMSwgMF0sXG4gKiAgICAgICAgICAgIC4uLlxuICogICAgICAgICB9XG4gKlxuICogICAgIEJhcmUgVHlwZWRBcnJheXNcbiAqXG4gKiAgICAgICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgRmxvYXQzMkFycmF5KFstMSwgMSwgMF0pLFxuICogICAgICAgICAgICBjb2xvcjogbmV3IFVpbnQ4QXJyYXkoWzI1NSwgMTI4LCA2NCwgMjU1XSksXG4gKiAgICAgICAgICAgIC4uLlxuICogICAgICAgICB9XG4gKlxuICogKiAgIFdpbGwgZ3Vlc3MgYXQgYG51bUNvbXBvbmVudHNgIGlmIG5vdCBzcGVjaWZpZWQgYmFzZWQgb24gbmFtZS5cbiAqXG4gKiAgICAgSWYgYGNvb3JkYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gMmBcbiAqXG4gKiAgICAgSWYgYGNvbG9yYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gNGBcbiAqXG4gKiAgICAgb3RoZXJ3aXNlIGFzc3VtZXMgYG51bUNvbXBvbmVudHMgPSAzYFxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgd2ViZ2wgcmVuZGVyaW5nIGNvbnRleHQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkFycmF5c30gYXJyYXlzIFRoZSBhcnJheXNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gW3NyY0J1ZmZlckluZm9dIGEgQnVmZmVySW5mbyB0byBjb3B5IGZyb21cbiAqICAgVGhpcyBsZXRzIHlvdSBzaGFyZSBidWZmZXJzLiBBbnkgYXJyYXlzIHlvdSBzdXBwbHkgd2lsbCBvdmVycmlkZVxuICogICB0aGUgYnVmZmVycyBmcm9tIHNyY0J1ZmZlckluZm8uXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnR3Z2wuQXR0cmliSW5mbz59IHRoZSBhdHRyaWJzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvYXR0cmlidXRlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQXR0cmlic0Zyb21BcnJheXMoZ2wsIGFycmF5cykge1xuICB2YXIgYXR0cmlicyA9IHt9O1xuICBPYmplY3Qua2V5cyhhcnJheXMpLmZvckVhY2goZnVuY3Rpb24gKGFycmF5TmFtZSkge1xuICAgIGlmICghaXNJbmRpY2VzKGFycmF5TmFtZSkpIHtcbiAgICAgIHZhciBhcnJheSA9IGFycmF5c1thcnJheU5hbWVdO1xuICAgICAgdmFyIGF0dHJpYk5hbWUgPSBhcnJheS5hdHRyaWIgfHwgYXJyYXkubmFtZSB8fCBhcnJheS5hdHRyaWJOYW1lIHx8IGRlZmF1bHRzLmF0dHJpYlByZWZpeCArIGFycmF5TmFtZTtcblxuICAgICAgaWYgKGFycmF5LnZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheS52YWx1ZSkgJiYgIXR5cGVkQXJyYXlzLmlzQXJyYXlCdWZmZXIoYXJyYXkudmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheS52YWx1ZSBpcyBub3QgYXJyYXkgb3IgdHlwZWRhcnJheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlic1thdHRyaWJOYW1lXSA9IHtcbiAgICAgICAgICB2YWx1ZTogYXJyYXkudmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgIHZhciB0eXBlO1xuICAgICAgICB2YXIgbm9ybWFsaXphdGlvbjtcbiAgICAgICAgdmFyIG51bUNvbXBvbmVudHM7XG5cbiAgICAgICAgaWYgKGFycmF5LmJ1ZmZlciAmJiBhcnJheS5idWZmZXIgaW5zdGFuY2VvZiBXZWJHTEJ1ZmZlcikge1xuICAgICAgICAgIGJ1ZmZlciA9IGFycmF5LmJ1ZmZlcjtcbiAgICAgICAgICBudW1Db21wb25lbnRzID0gYXJyYXkubnVtQ29tcG9uZW50cyB8fCBhcnJheS5zaXplO1xuICAgICAgICAgIHR5cGUgPSBhcnJheS50eXBlO1xuICAgICAgICAgIG5vcm1hbGl6YXRpb24gPSBhcnJheS5ub3JtYWxpemU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFycmF5ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBhcnJheS5kYXRhID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdmFyIG51bVZhbHVlcyA9IGFycmF5LmRhdGEgfHwgYXJyYXk7XG4gICAgICAgICAgdmFyIGFycmF5VHlwZSA9IGFycmF5LnR5cGUgfHwgRmxvYXQzMkFycmF5O1xuICAgICAgICAgIHZhciBudW1CeXRlcyA9IG51bVZhbHVlcyAqIGFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgICB0eXBlID0gdHlwZWRBcnJheXMuZ2V0R0xUeXBlRm9yVHlwZWRBcnJheVR5cGUoYXJyYXlUeXBlKTtcbiAgICAgICAgICBub3JtYWxpemF0aW9uID0gYXJyYXkubm9ybWFsaXplICE9PSB1bmRlZmluZWQgPyBhcnJheS5ub3JtYWxpemUgOiBnZXROb3JtYWxpemF0aW9uRm9yVHlwZWRBcnJheVR5cGUoYXJyYXlUeXBlKTtcbiAgICAgICAgICBudW1Db21wb25lbnRzID0gYXJyYXkubnVtQ29tcG9uZW50cyB8fCBhcnJheS5zaXplIHx8IGd1ZXNzTnVtQ29tcG9uZW50c0Zyb21OYW1lKGFycmF5TmFtZSwgbnVtVmFsdWVzKTtcbiAgICAgICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICBnbC5iaW5kQnVmZmVyKEFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgICAgICBnbC5idWZmZXJEYXRhKEFSUkFZX0JVRkZFUiwgbnVtQnl0ZXMsIGFycmF5LmRyYXdUeXBlIHx8IFNUQVRJQ19EUkFXKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZWRBcnJheSA9IG1ha2VUeXBlZEFycmF5KGFycmF5LCBhcnJheU5hbWUpO1xuICAgICAgICAgIGJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlckZyb21UeXBlZEFycmF5KGdsLCB0eXBlZEFycmF5LCB1bmRlZmluZWQsIGFycmF5LmRyYXdUeXBlKTtcbiAgICAgICAgICB0eXBlID0gdHlwZWRBcnJheXMuZ2V0R0xUeXBlRm9yVHlwZWRBcnJheSh0eXBlZEFycmF5KTtcbiAgICAgICAgICBub3JtYWxpemF0aW9uID0gYXJyYXkubm9ybWFsaXplICE9PSB1bmRlZmluZWQgPyBhcnJheS5ub3JtYWxpemUgOiBnZXROb3JtYWxpemF0aW9uRm9yVHlwZWRBcnJheSh0eXBlZEFycmF5KTtcbiAgICAgICAgICBudW1Db21wb25lbnRzID0gZ2V0TnVtQ29tcG9uZW50cyhhcnJheSwgYXJyYXlOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnNbYXR0cmliTmFtZV0gPSB7XG4gICAgICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICAgICAgbnVtQ29tcG9uZW50czogbnVtQ29tcG9uZW50cyxcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIG5vcm1hbGl6ZTogbm9ybWFsaXphdGlvbixcbiAgICAgICAgICBzdHJpZGU6IGFycmF5LnN0cmlkZSB8fCAwLFxuICAgICAgICAgIG9mZnNldDogYXJyYXkub2Zmc2V0IHx8IDAsXG4gICAgICAgICAgZGl2aXNvcjogYXJyYXkuZGl2aXNvciA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogYXJyYXkuZGl2aXNvcixcbiAgICAgICAgICBkcmF3VHlwZTogYXJyYXkuZHJhd1R5cGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBnbC5iaW5kQnVmZmVyKEFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gIHJldHVybiBhdHRyaWJzO1xufVxuLyoqXG4gKiBTZXRzIHRoZSBjb250ZW50cyBvZiBhIGJ1ZmZlciBhdHRhY2hlZCB0byBhbiBhdHRyaWJJbmZvXG4gKlxuICogVGhpcyBpcyBoZWxwZXIgZnVuY3Rpb24gdG8gZHluYW1pY2FsbHkgdXBkYXRlIGEgYnVmZmVyLlxuICpcbiAqIExldCdzIHNheSB5b3UgbWFrZSBhIGJ1ZmZlckluZm9cbiAqXG4gKiAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICBwb3NpdGlvbjogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdKSxcbiAqICAgICAgICB0ZXhjb29yZDogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0pLFxuICogICAgICAgIG5vcm1hbDogICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSksXG4gKiAgICAgICAgaW5kaWNlczogIG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMSwgMiwgM10pLFxuICogICAgIH07XG4gKiAgICAgdmFyIGJ1ZmZlckluZm8gPSB0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzKGdsLCBhcnJheXMpO1xuICpcbiAqICBBbmQgeW91IHdhbnQgdG8gZHluYW1pY2FsbHkgdXBkYXRlIHRoZSBwb3NpdGlvbnMuIFlvdSBjb3VsZCBkbyB0aGlzXG4gKlxuICogICAgIC8vIGFzc3VtaW5nIGFycmF5cy5wb3NpdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWQgd2l0aCBuZXcgZGF0YS5cbiAqICAgICB0d2dsLnNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXkoZ2wsIGJ1ZmZlckluZm8uYXR0cmlicy5wb3NpdGlvbiwgYXJyYXlzLnBvc2l0aW9uKTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAqIEBwYXJhbSB7QXR0cmliSW5mb30gYXR0cmliSW5mbyBUaGUgYXR0cmliSW5mbyB3aG8ncyBidWZmZXIgY29udGVudHMgdG8gc2V0LiBOT1RFOiBJZiB5b3UgaGF2ZSBhbiBhdHRyaWJ1dGUgcHJlZml4XG4gKiAgIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgd2lsbCBpbmNsdWRlIHRoZSBwcmVmaXguXG4gKiBAcGFyYW0ge0FycmF5U3BlY30gYXJyYXkgTm90ZTogaXQgaXMgYXJndWFibHkgaW5lZmZpY2llbnQgdG8gcGFzcyBpbiBhbnl0aGluZyBidXQgYSB0eXBlZCBhcnJheSBiZWNhdXNlIGFueXRoaW5nXG4gKiAgICBlbHNlIHdpbGwgaGF2ZSB0byBiZSBjb252ZXJ0ZWQgdG8gYSB0eXBlZCBhcnJheSBiZWZvcmUgaXQgY2FuIGJlIHVzZWQgYnkgV2ViR0wuIER1cmluZyBpbml0IHRpbWUgdGhhdFxuICogICAgaW5lZmZpY2llbmN5IGlzIHVzdWFsbHkgbm90IGltcG9ydGFudCBidXQgaWYgeW91J3JlIHVwZGF0aW5nIGRhdGEgZHluYW1pY2FsbHkgYmVzdCB0byBiZSBlZmZpY2llbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29mZnNldF0gYW4gb3B0aW9uYWwgb2Zmc2V0IGludG8gdGhlIGJ1ZmZlci4gVGhpcyBpcyBvbmx5IGFuIG9mZnNldCBpbnRvIHRoZSBXZWJHTCBidWZmZXJcbiAqICAgIG5vdCB0aGUgYXJyYXkuIFRvIHBhc3MgaW4gYW4gb2Zmc2V0IGludG8gdGhlIGFycmF5IGl0c2VsZiB1c2UgYSB0eXBlZCBhcnJheSBhbmQgY3JlYXRlIGFuIGBBcnJheUJ1ZmZlclZpZXdgXG4gKiAgICBmb3IgdGhlIHBvcnRpb24gb2YgdGhlIGFycmF5IHlvdSB3YW50IHRvIHVzZS5cbiAqXG4gKiAgICAgICAgdmFyIHNvbWVBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMTAwMCk7IC8vIGFuIGFycmF5IHdpdGggMTAwMCBmbG9hdHNcbiAqICAgICAgICB2YXIgc29tZVN1YkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShzb21lQXJyYXkuYnVmZmVyLCBvZmZzZXRJbkJ5dGVzLCBzaXplSW5Vbml0cyk7IC8vIGEgdmlldyBpbnRvIHNvbWVBcnJheVxuICpcbiAqICAgIE5vdyB5b3UgY2FuIHBhc3MgYHNvbWVTdWJBcnJheWAgaW50byBzZXRBdHRyaWJJbmZvQnVmZmVyRnJvbUFycmF5YFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXkoZ2wsIGF0dHJpYkluZm8sIGFycmF5LCBvZmZzZXQpIHtcbiAgYXJyYXkgPSBtYWtlVHlwZWRBcnJheShhcnJheSk7XG5cbiAgaWYgKG9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2wuYmluZEJ1ZmZlcihBUlJBWV9CVUZGRVIsIGF0dHJpYkluZm8uYnVmZmVyKTtcbiAgICBnbC5idWZmZXJTdWJEYXRhKEFSUkFZX0JVRkZFUiwgb2Zmc2V0LCBhcnJheSk7XG4gIH0gZWxzZSB7XG4gICAgc2V0QnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIEFSUkFZX0JVRkZFUiwgYXR0cmliSW5mby5idWZmZXIsIGFycmF5LCBhdHRyaWJJbmZvLmRyYXdUeXBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCeXRlc1BlclZhbHVlRm9yR0xUeXBlKGdsLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSBCWVRFKSByZXR1cm4gMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlID09PSBVTlNJR05FRF9CWVRFKSByZXR1cm4gMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlID09PSBTSE9SVCkgcmV0dXJuIDI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZSA9PT0gVU5TSUdORURfU0hPUlQpIHJldHVybiAyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKHR5cGUgPT09IElOVCkgcmV0dXJuIDQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZSA9PT0gVU5TSUdORURfSU5UKSByZXR1cm4gNDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlID09PSBGTE9BVCkgcmV0dXJuIDQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICByZXR1cm4gMDtcbn0gLy8gVHJpZXMgdG8gZ2V0IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSBhIHNldCBvZiBhcnJheXMuXG5cblxudmFyIHBvc2l0aW9uS2V5cyA9IFsncG9zaXRpb24nLCAncG9zaXRpb25zJywgJ2FfcG9zaXRpb24nXTtcblxuZnVuY3Rpb24gZ2V0TnVtRWxlbWVudHNGcm9tTm9uSW5kZXhlZEFycmF5cyhhcnJheXMpIHtcbiAgdmFyIGtleTtcbiAgdmFyIGlpO1xuXG4gIGZvciAoaWkgPSAwOyBpaSA8IHBvc2l0aW9uS2V5cy5sZW5ndGg7ICsraWkpIHtcbiAgICBrZXkgPSBwb3NpdGlvbktleXNbaWldO1xuXG4gICAgaWYgKGtleSBpbiBhcnJheXMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpaSA9PT0gcG9zaXRpb25LZXlzLmxlbmd0aCkge1xuICAgIGtleSA9IE9iamVjdC5rZXlzKGFycmF5cylbMF07XG4gIH1cblxuICB2YXIgYXJyYXkgPSBhcnJheXNba2V5XTtcbiAgdmFyIGxlbmd0aCA9IGdldEFycmF5KGFycmF5KS5sZW5ndGg7XG4gIHZhciBudW1Db21wb25lbnRzID0gZ2V0TnVtQ29tcG9uZW50cyhhcnJheSwga2V5KTtcbiAgdmFyIG51bUVsZW1lbnRzID0gbGVuZ3RoIC8gbnVtQ29tcG9uZW50cztcblxuICBpZiAobGVuZ3RoICUgbnVtQ29tcG9uZW50cyA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJudW1Db21wb25lbnRzIFwiLmNvbmNhdChudW1Db21wb25lbnRzLCBcIiBub3QgY29ycmVjdCBmb3IgbGVuZ3RoIFwiKS5jb25jYXQobGVuZ3RoKSk7XG4gIH1cblxuICByZXR1cm4gbnVtRWxlbWVudHM7XG59XG5cbmZ1bmN0aW9uIGdldE51bUVsZW1lbnRzRnJvbUF0dHJpYnV0ZXMoZ2wsIGF0dHJpYnMpIHtcbiAgdmFyIGtleTtcbiAgdmFyIGlpO1xuXG4gIGZvciAoaWkgPSAwOyBpaSA8IHBvc2l0aW9uS2V5cy5sZW5ndGg7ICsraWkpIHtcbiAgICBrZXkgPSBwb3NpdGlvbktleXNbaWldO1xuXG4gICAgaWYgKGtleSBpbiBhdHRyaWJzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBrZXkgPSBkZWZhdWx0cy5hdHRyaWJQcmVmaXggKyBrZXk7XG5cbiAgICBpZiAoa2V5IGluIGF0dHJpYnMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpaSA9PT0gcG9zaXRpb25LZXlzLmxlbmd0aCkge1xuICAgIGtleSA9IE9iamVjdC5rZXlzKGF0dHJpYnMpWzBdO1xuICB9XG5cbiAgdmFyIGF0dHJpYiA9IGF0dHJpYnNba2V5XTtcbiAgZ2wuYmluZEJ1ZmZlcihBUlJBWV9CVUZGRVIsIGF0dHJpYi5idWZmZXIpO1xuICB2YXIgbnVtQnl0ZXMgPSBnbC5nZXRCdWZmZXJQYXJhbWV0ZXIoQVJSQVlfQlVGRkVSLCBCVUZGRVJfU0laRSk7XG4gIGdsLmJpbmRCdWZmZXIoQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgdmFyIGJ5dGVzUGVyVmFsdWUgPSBnZXRCeXRlc1BlclZhbHVlRm9yR0xUeXBlKGdsLCBhdHRyaWIudHlwZSk7XG4gIHZhciB0b3RhbEVsZW1lbnRzID0gbnVtQnl0ZXMgLyBieXRlc1BlclZhbHVlO1xuICB2YXIgbnVtQ29tcG9uZW50cyA9IGF0dHJpYi5udW1Db21wb25lbnRzIHx8IGF0dHJpYi5zaXplOyAvLyBUT0RPOiBjaGVjayBzdHJpZGVcblxuICB2YXIgbnVtRWxlbWVudHMgPSB0b3RhbEVsZW1lbnRzIC8gbnVtQ29tcG9uZW50cztcblxuICBpZiAobnVtRWxlbWVudHMgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibnVtQ29tcG9uZW50cyBcIi5jb25jYXQobnVtQ29tcG9uZW50cywgXCIgbm90IGNvcnJlY3QgZm9yIGxlbmd0aCBcIikuY29uY2F0KGxlbmd0aCkpO1xuICB9XG5cbiAgcmV0dXJuIG51bUVsZW1lbnRzO1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCdWZmZXJJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gbnVtRWxlbWVudHMgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBwYXNzIHRvIGBnbC5kcmF3QXJyYXlzYCBvciBgZ2wuZHJhd0VsZW1lbnRzYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZWxlbWVudFR5cGVdIFRoZSB0eXBlIG9mIGluZGljZXMgYFVOU0lHTkVEX0JZVEVgLCBgVU5TSUdORURfU0hPUlRgIGV0Yy4uXG4gKiBAcHJvcGVydHkge1dlYkdMQnVmZmVyfSBbaW5kaWNlc10gVGhlIGluZGljZXMgYEVMRU1FTlRfQVJSQVlfQlVGRkVSYCBpZiBhbnkgaW5kaWNlcyBleGlzdC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkF0dHJpYkluZm8+fSBbYXR0cmlic10gVGhlIGF0dHJpYnMgYXBwcm9wcmlhdGUgdG8gY2FsbCBgc2V0QXR0cmlidXRlc2BcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIEJ1ZmZlckluZm8gZnJvbSBhbiBvYmplY3Qgb2YgYXJyYXlzLlxuICpcbiAqIFRoaXMgY2FuIGJlIHBhc3NlZCB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXN9IGFuZCB0b1xuICoge0BsaW5rIG1vZHVsZTp0d2dsOmRyYXdCdWZmZXJJbmZvfS5cbiAqXG4gKiBHaXZlbiBhbiBvYmplY3QgbGlrZVxuICpcbiAqICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgcG9zaXRpb246IHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDAsIDAsIDEwLCAwLCAwLCAwLCAxMCwgMCwgMTAsIDEwLCAwXSwgfSxcbiAqICAgICAgIHRleGNvb3JkOiB7IG51bUNvbXBvbmVudHM6IDIsIGRhdGE6IFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSwgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgICBub3JtYWw6ICAgeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMV0sICAgICB9LFxuICogICAgICAgaW5kaWNlczogIHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDEsIDIsIDEsIDIsIDNdLCAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAqICAgICB9O1xuICpcbiAqICBDcmVhdGVzIGFuIEJ1ZmZlckluZm8gbGlrZSB0aGlzXG4gKlxuICogICAgIGJ1ZmZlckluZm8gPSB7XG4gKiAgICAgICBudW1FbGVtZW50czogNCwgICAgICAgIC8vIG9yIHdoYXRldmVyIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaXNcbiAqICAgICAgIGluZGljZXM6IFdlYkdMQnVmZmVyLCAgLy8gdGhpcyBwcm9wZXJ0eSB3aWxsIG5vdCBleGlzdCBpZiB0aGVyZSBhcmUgbm8gaW5kaWNlc1xuICogICAgICAgYXR0cmliczoge1xuICogICAgICAgICBwb3NpdGlvbjogeyBidWZmZXI6IFdlYkdMQnVmZmVyLCBudW1Db21wb25lbnRzOiAzLCB9LFxuICogICAgICAgICBub3JtYWw6ICAgeyBidWZmZXI6IFdlYkdMQnVmZmVyLCBudW1Db21wb25lbnRzOiAzLCB9LFxuICogICAgICAgICB0ZXhjb29yZDogeyBidWZmZXI6IFdlYkdMQnVmZmVyLCBudW1Db21wb25lbnRzOiAyLCB9LFxuICogICAgICAgfSxcbiAqICAgICB9O1xuICpcbiAqICBUaGUgcHJvcGVydGllcyBvZiBhcnJheXMgY2FuIGJlIEphdmFTY3JpcHQgYXJyYXlzIGluIHdoaWNoIGNhc2UgdGhlIG51bWJlciBvZiBjb21wb25lbnRzXG4gKiAgd2lsbCBiZSBndWVzc2VkLlxuICpcbiAqICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgIHBvc2l0aW9uOiBbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdLFxuICogICAgICAgIHRleGNvb3JkOiBbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0sXG4gKiAgICAgICAgbm9ybWFsOiAgIFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSxcbiAqICAgICAgICBpbmRpY2VzOiAgWzAsIDEsIDIsIDEsIDIsIDNdLFxuICogICAgIH07XG4gKlxuICogIFRoZXkgY2FuIGFsc28gYmUgVHlwZWRBcnJheXNcbiAqXG4gKiAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICBwb3NpdGlvbjogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdKSxcbiAqICAgICAgICB0ZXhjb29yZDogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0pLFxuICogICAgICAgIG5vcm1hbDogICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSksXG4gKiAgICAgICAgaW5kaWNlczogIG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMSwgMiwgM10pLFxuICogICAgIH07XG4gKlxuICogIE9yIEF1Z21lbnRlZFR5cGVkQXJyYXlzXG4gKlxuICogICAgIHZhciBwb3NpdGlvbnMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIDQpO1xuICogICAgIHZhciB0ZXhjb29yZHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsIDQpO1xuICogICAgIHZhciBub3JtYWxzICAgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIDQpO1xuICogICAgIHZhciBpbmRpY2VzICAgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIDIsIFVpbnQxNkFycmF5KTtcbiAqXG4gKiAgICAgcG9zaXRpb25zLnB1c2goWzAsIDAsIDAsIDEwLCAwLCAwLCAwLCAxMCwgMCwgMTAsIDEwLCAwXSk7XG4gKiAgICAgdGV4Y29vcmRzLnB1c2goWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdKTtcbiAqICAgICBub3JtYWxzLnB1c2goWzAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdKTtcbiAqICAgICBpbmRpY2VzLnB1c2goWzAsIDEsIDIsIDEsIDIsIDNdKTtcbiAqXG4gKiAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICogICAgICAgIHRleGNvb3JkOiB0ZXhjb29yZHMsXG4gKiAgICAgICAgbm9ybWFsOiAgIG5vcm1hbHMsXG4gKiAgICAgICAgaW5kaWNlczogIGluZGljZXMsXG4gKiAgICAgfTtcbiAqXG4gKiBGb3IgdGhlIGxhc3QgZXhhbXBsZSBpdCBpcyBlcXVpdmFsZW50IHRvXG4gKlxuICogICAgIHZhciBidWZmZXJJbmZvID0ge1xuICogICAgICAgYXR0cmliczoge1xuICogICAgICAgICBwb3NpdGlvbjogeyBudW1Db21wb25lbnRzOiAzLCBidWZmZXI6IGdsLmNyZWF0ZUJ1ZmZlcigpLCB9LFxuICogICAgICAgICB0ZXhjb29yZDogeyBudW1Db21wb25lbnRzOiAyLCBidWZmZXI6IGdsLmNyZWF0ZUJ1ZmZlcigpLCB9LFxuICogICAgICAgICBub3JtYWw6IHsgbnVtQ29tcG9uZW50czogMywgYnVmZmVyOiBnbC5jcmVhdGVCdWZmZXIoKSwgfSxcbiAqICAgICAgIH0sXG4gKiAgICAgICBpbmRpY2VzOiBnbC5jcmVhdGVCdWZmZXIoKSxcbiAqICAgICAgIG51bUVsZW1lbnRzOiA2LFxuICogICAgIH07XG4gKlxuICogICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJJbmZvLmF0dHJpYnMucG9zaXRpb24uYnVmZmVyKTtcbiAqICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYXJyYXlzLnBvc2l0aW9uLCBnbC5TVEFUSUNfRFJBVyk7XG4gKiAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlckluZm8uYXR0cmlicy50ZXhjb29yZC5idWZmZXIpO1xuICogICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhcnJheXMudGV4Y29vcmQsIGdsLlNUQVRJQ19EUkFXKTtcbiAqICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVySW5mby5hdHRyaWJzLm5vcm1hbC5idWZmZXIpO1xuICogICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhcnJheXMubm9ybWFsLCBnbC5TVEFUSUNfRFJBVyk7XG4gKiAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnVmZmVySW5mby5pbmRpY2VzKTtcbiAqICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBhcnJheXMuaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5BcnJheXN9IGFycmF5cyBZb3VyIGRhdGFcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gW3NyY0J1ZmZlckluZm9dIEFuIGV4aXN0aW5nXG4gKiAgICAgICAgYnVmZmVyIGluZm8gdG8gc3RhcnQgZnJvbS4gV2ViR0xCdWZmZXJzIGV0YyBzcGVjaWZpZWRcbiAqICAgICAgICBpbiB0aGUgc3JjQnVmZmVySW5mbyB3aWxsIGJlIHVzZWQgaW4gYSBuZXcgQnVmZmVySW5mb1xuICogICAgICAgIHdpdGggYW55IGFycmF5cyBzcGVjaWZpZWQgb3ZlcnJpZGluZyB0aGUgb25lcyBpblxuICogICAgICAgIHNyY0J1ZmZlckluZm8uXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBBIEJ1ZmZlckluZm9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9hdHRyaWJ1dGVzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwgYXJyYXlzLCBzcmNCdWZmZXJJbmZvKSB7XG4gIHZhciBuZXdBdHRyaWJzID0gY3JlYXRlQXR0cmlic0Zyb21BcnJheXMoZ2wsIGFycmF5cyk7XG4gIHZhciBidWZmZXJJbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgc3JjQnVmZmVySW5mbyA/IHNyY0J1ZmZlckluZm8gOiB7fSk7XG4gIGJ1ZmZlckluZm8uYXR0cmlicyA9IE9iamVjdC5hc3NpZ24oe30sIHNyY0J1ZmZlckluZm8gPyBzcmNCdWZmZXJJbmZvLmF0dHJpYnMgOiB7fSwgbmV3QXR0cmlicyk7XG4gIHZhciBpbmRpY2VzID0gYXJyYXlzLmluZGljZXM7XG5cbiAgaWYgKGluZGljZXMpIHtcbiAgICB2YXIgbmV3SW5kaWNlcyA9IG1ha2VUeXBlZEFycmF5KGluZGljZXMsIFwiaW5kaWNlc1wiKTtcbiAgICBidWZmZXJJbmZvLmluZGljZXMgPSBjcmVhdGVCdWZmZXJGcm9tVHlwZWRBcnJheShnbCwgbmV3SW5kaWNlcywgRUxFTUVOVF9BUlJBWV9CVUZGRVIpO1xuICAgIGJ1ZmZlckluZm8ubnVtRWxlbWVudHMgPSBuZXdJbmRpY2VzLmxlbmd0aDtcbiAgICBidWZmZXJJbmZvLmVsZW1lbnRUeXBlID0gdHlwZWRBcnJheXMuZ2V0R0xUeXBlRm9yVHlwZWRBcnJheShuZXdJbmRpY2VzKTtcbiAgfSBlbHNlIGlmICghYnVmZmVySW5mby5udW1FbGVtZW50cykge1xuICAgIGJ1ZmZlckluZm8ubnVtRWxlbWVudHMgPSBnZXROdW1FbGVtZW50c0Zyb21BdHRyaWJ1dGVzKGdsLCBidWZmZXJJbmZvLmF0dHJpYnMpO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlckluZm87XG59XG4vKipcbiAqIENyZWF0ZXMgYSBidWZmZXIgZnJvbSBhbiBhcnJheSwgdHlwZWQgYXJyYXksIG9yIGFycmF5IHNwZWNcbiAqXG4gKiBHaXZlbiBzb21ldGhpbmcgbGlrZSB0aGlzXG4gKlxuICogICAgIFsxLCAyLCAzXSxcbiAqXG4gKiBvclxuICpcbiAqICAgICBuZXcgVWludDE2QXJyYXkoWzEsMiwzXSk7XG4gKlxuICogb3JcbiAqXG4gKiAgICAge1xuICogICAgICAgIGRhdGE6IFsxLCAyLCAzXSxcbiAqICAgICAgICB0eXBlOiBVaW50OEFycmF5LFxuICogICAgIH1cbiAqXG4gKiByZXR1cm5zIGEgV2ViR0xCdWZmZXIgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkFycmF5U3BlY30gYXJyYXkgYW4gYXJyYXksIHR5cGVkIGFycmF5LCBvciBhcnJheSBzcGVjLlxuICogQHBhcmFtIHtzdHJpbmd9IGFycmF5TmFtZSBuYW1lIG9mIGFycmF5LiBVc2VkIHRvIGd1ZXNzIHRoZSB0eXBlIGlmIHR5cGUgY2FuIG5vdCBiZSBkZXJpdmVkIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge1dlYkdMQnVmZmVyfSBhIFdlYkdMQnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRhdGEgaW4gYXJyYXkuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvYXR0cmlidXRlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyRnJvbUFycmF5KGdsLCBhcnJheSwgYXJyYXlOYW1lKSB7XG4gIHZhciB0eXBlID0gYXJyYXlOYW1lID09PSBcImluZGljZXNcIiA/IEVMRU1FTlRfQVJSQVlfQlVGRkVSIDogQVJSQVlfQlVGRkVSO1xuICB2YXIgdHlwZWRBcnJheSA9IG1ha2VUeXBlZEFycmF5KGFycmF5LCBhcnJheU5hbWUpO1xuICByZXR1cm4gY3JlYXRlQnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIHR5cGVkQXJyYXksIHR5cGUpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGJ1ZmZlcnMgZnJvbSBhcnJheXMgb3IgdHlwZWQgYXJyYXlzXG4gKlxuICogR2l2ZW4gc29tZXRoaW5nIGxpa2UgdGhpc1xuICpcbiAqICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgIHBvc2l0aW9uczogWzEsIDIsIDNdLFxuICogICAgICAgIG5vcm1hbHM6IFswLCAwLCAxXSxcbiAqICAgICB9XG4gKlxuICogcmV0dXJucyBzb21ldGhpbmcgbGlrZVxuICpcbiAqICAgICBidWZmZXJzID0ge1xuICogICAgICAgcG9zaXRpb25zOiBXZWJHTEJ1ZmZlcixcbiAqICAgICAgIG5vcm1hbHM6IFdlYkdMQnVmZmVyLFxuICogICAgIH1cbiAqXG4gKiBJZiB0aGUgYnVmZmVyIGlzIG5hbWVkICdpbmRpY2VzJyBpdCB3aWxsIGJlIG1hZGUgYW4gRUxFTUVOVF9BUlJBWV9CVUZGRVIuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5BcnJheXN9IGFycmF5c1xuICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgV2ViR0xCdWZmZXI+fSByZXR1cm5zIGFuIG9iamVjdCB3aXRoIG9uZSBXZWJHTEJ1ZmZlciBwZXIgYXJyYXlcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9hdHRyaWJ1dGVzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXJzRnJvbUFycmF5cyhnbCwgYXJyYXlzKSB7XG4gIHZhciBidWZmZXJzID0ge307XG4gIE9iamVjdC5rZXlzKGFycmF5cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgYnVmZmVyc1trZXldID0gY3JlYXRlQnVmZmVyRnJvbUFycmF5KGdsLCBhcnJheXNba2V5XSwga2V5KTtcbiAgfSk7IC8vIFVnaCFcblxuICBpZiAoYXJyYXlzLmluZGljZXMpIHtcbiAgICBidWZmZXJzLm51bUVsZW1lbnRzID0gYXJyYXlzLmluZGljZXMubGVuZ3RoO1xuICAgIGJ1ZmZlcnMuZWxlbWVudFR5cGUgPSB0eXBlZEFycmF5cy5nZXRHTFR5cGVGb3JUeXBlZEFycmF5KG1ha2VUeXBlZEFycmF5KGFycmF5cy5pbmRpY2VzKSwgJ2luZGljZXMnKTtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXJzLm51bUVsZW1lbnRzID0gZ2V0TnVtRWxlbWVudHNGcm9tTm9uSW5kZXhlZEFycmF5cyhhcnJheXMpO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcnM7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RyYXcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kcmF3LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kcmF3QnVmZmVySW5mbyA9IGRyYXdCdWZmZXJJbmZvO1xuZXhwb3J0cy5kcmF3T2JqZWN0TGlzdCA9IGRyYXdPYmplY3RMaXN0O1xuXG52YXIgcHJvZ3JhbXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Byb2dyYW1zLmpzICovIFwiLi9zcmMvcHJvZ3JhbXMuanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG52YXIgVFJJQU5HTEVTID0gMHgwMDA0O1xudmFyIFVOU0lHTkVEX1NIT1JUID0gMHgxNDAzO1xuLyoqXG4gKiBEcmF3aW5nIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgdGhleSBhcmUgYXZhaWxhYmxlIGF0IGJvdGggYHR3Z2wuZHJhd2AgYW5kIGB0d2dsYFxuICogaXRzZWxmXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6dHdnbH0gZm9yIGNvcmUgZnVuY3Rpb25zXG4gKlxuICogQG1vZHVsZSB0d2dsL2RyYXdcbiAqL1xuXG4vKipcbiAqIENhbGxzIGBnbC5kcmF3RWxlbWVudHNgIG9yIGBnbC5kcmF3QXJyYXlzYCwgd2hpY2hldmVyIGlzIGFwcHJvcHJpYXRlXG4gKlxuICogbm9ybWFsbHkgeW91J2QgY2FsbCBgZ2wuZHJhd0VsZW1lbnRzYCBvciBgZ2wuZHJhd0FycmF5c2AgeW91cnNlbGZcbiAqIGJ1dCBjYWxsaW5nIHRoaXMgbWVhbnMgaWYgeW91IHN3aXRjaCBmcm9tIGluZGV4ZWQgZGF0YSB0byBub24taW5kZXhlZFxuICogZGF0YSB5b3UgZG9uJ3QgaGF2ZSB0byByZW1lbWJlciB0byB1cGRhdGUgeW91ciBkcmF3IGNhbGwuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5CdWZmZXJJbmZvfG1vZHVsZTp0d2dsLlZlcnRleEFycmF5SW5mbyl9IGJ1ZmZlckluZm8gQSBCdWZmZXJJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzfSBvclxuICogICBhIFZlcnRleEFycmF5SW5mbyBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVWZXJ0ZXhBcnJheUluZm99XG4gKiBAcGFyYW0ge251bWJlcn0gW3R5cGVdIGVnIChnbC5UUklBTkdMRVMsIGdsLkxJTkVTLCBnbC5QT0lOVFMsIGdsLlRSSUFOR0xFX1NUUklQLCAuLi4pLiBEZWZhdWx0cyB0byBgZ2wuVFJJQU5HTEVTYFxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF0gQW4gb3B0aW9uYWwgY291bnQuIERlZmF1bHRzIHRvIGJ1ZmZlckluZm8ubnVtRWxlbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0XSBBbiBvcHRpb25hbCBvZmZzZXQuIERlZmF1bHRzIHRvIDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2luc3RhbmNlQ291bnRdIEFuIG9wdGlvbmFsIGluc3RhbmNlQ291bnQuIGlmIHNldCB0aGVuIGBkcmF3QXJyYXlzSW5zdGFuY2VkYCBvciBgZHJhd0VsZW1lbnRzSW5zdGFuY2VkYCB3aWxsIGJlIGNhbGxlZFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2RyYXdcbiAqL1xuXG5mdW5jdGlvbiBkcmF3QnVmZmVySW5mbyhnbCwgYnVmZmVySW5mbywgdHlwZSwgY291bnQsIG9mZnNldCwgaW5zdGFuY2VDb3VudCkge1xuICB0eXBlID0gdHlwZSA9PT0gdW5kZWZpbmVkID8gVFJJQU5HTEVTIDogdHlwZTtcbiAgdmFyIGluZGljZXMgPSBidWZmZXJJbmZvLmluZGljZXM7XG4gIHZhciBlbGVtZW50VHlwZSA9IGJ1ZmZlckluZm8uZWxlbWVudFR5cGU7XG4gIHZhciBudW1FbGVtZW50cyA9IGNvdW50ID09PSB1bmRlZmluZWQgPyBidWZmZXJJbmZvLm51bUVsZW1lbnRzIDogY291bnQ7XG4gIG9mZnNldCA9IG9mZnNldCA9PT0gdW5kZWZpbmVkID8gMCA6IG9mZnNldDtcblxuICBpZiAoZWxlbWVudFR5cGUgfHwgaW5kaWNlcykge1xuICAgIGlmIChpbnN0YW5jZUNvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZCh0eXBlLCBudW1FbGVtZW50cywgZWxlbWVudFR5cGUgPT09IHVuZGVmaW5lZCA/IFVOU0lHTkVEX1NIT1JUIDogYnVmZmVySW5mby5lbGVtZW50VHlwZSwgb2Zmc2V0LCBpbnN0YW5jZUNvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuZHJhd0VsZW1lbnRzKHR5cGUsIG51bUVsZW1lbnRzLCBlbGVtZW50VHlwZSA9PT0gdW5kZWZpbmVkID8gVU5TSUdORURfU0hPUlQgOiBidWZmZXJJbmZvLmVsZW1lbnRUeXBlLCBvZmZzZXQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaW5zdGFuY2VDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkKHR5cGUsIG9mZnNldCwgbnVtRWxlbWVudHMsIGluc3RhbmNlQ291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC5kcmF3QXJyYXlzKHR5cGUsIG9mZnNldCwgbnVtRWxlbWVudHMpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBBIERyYXdPYmplY3QgaXMgdXNlZnVsIGZvciBwdXR0aW5nIG9iamVjdHMgaW4gdG8gYW4gYXJyYXkgYW5kIHBhc3NpbmcgdGhlbSB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuZHJhd09iamVjdExpc3R9LlxuICpcbiAqIFlvdSBuZWVkIGVpdGhlciBhIGBCdWZmZXJJbmZvYCBvciBhIGBWZXJ0ZXhBcnJheUluZm9gLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERyYXdPYmplY3RcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FjdGl2ZV0gd2hldGhlciBvciBub3QgdG8gZHJhdy4gRGVmYXVsdCA9IGB0cnVlYCAobXVzdCBiZSBgZmFsc2VgIHRvIGJlIG5vdCB0cnVlKS4gSW4gb3RoZXIgd29yZHMgYHVuZGVmaW5lZGAgPSBgdHJ1ZWBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHlwZV0gdHlwZSB0byBkcmF3IGVnLiBgZ2wuVFJJQU5HTEVTYCwgYGdsLkxJTkVTYCwgZXRjLi4uXG4gKiBAcHJvcGVydHkge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfSBwcm9ncmFtSW5mbyBBIFByb2dyYW1JbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVByb2dyYW1JbmZvfVxuICogQHByb3BlcnR5IHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBbYnVmZmVySW5mb10gQSBCdWZmZXJJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzfVxuICogQHByb3BlcnR5IHttb2R1bGU6dHdnbC5WZXJ0ZXhBcnJheUluZm99IFt2ZXJ0ZXhBcnJheUluZm9dIEEgVmVydGV4QXJyYXlJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVZlcnRleEFycmF5SW5mb31cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgPz59IHVuaWZvcm1zIFRoZSB2YWx1ZXMgZm9yIHRoZSB1bmlmb3Jtcy5cbiAqICAgWW91IGNhbiBwYXNzIG11bHRpcGxlIG9iamVjdHMgYnkgcHV0dGluZyB0aGVtIGluIGFuIGFycmF5LiBGb3IgZXhhbXBsZVxuICpcbiAqICAgICB2YXIgc2hhcmVkVW5pZm9ybXMgPSB7XG4gKiAgICAgICB1X2ZvZ05lYXI6IDEwLFxuICogICAgICAgdV9wcm9qZWN0aW9uOiAuLi5cbiAqICAgICAgIC4uLlxuICogICAgIH07XG4gKlxuICogICAgIHZhciBsb2NhbFVuaWZvcm1zID0ge1xuICogICAgICAgdV93b3JsZDogLi4uXG4gKiAgICAgICB1X2RpZmZ1c2VDb2xvcjogLi4uXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgdmFyIGRyYXdPYmogPSB7XG4gKiAgICAgICAuLi5cbiAqICAgICAgIHVuaWZvcm1zOiBbc2hhcmVkVW5pZm9ybXMsIGxvY2FsVW5pZm9ybXNdLFxuICogICAgIH07XG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvZmZzZXRdIHRoZSBvZmZzZXQgdG8gcGFzcyB0byBgZ2wuZHJhd0FycmF5c2Agb3IgYGdsLmRyYXdFbGVtZW50c2AuIERlZmF1bHRzIHRvIDAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NvdW50XSB0aGUgY291bnQgdG8gcGFzcyB0byBgZ2wuZHJhd0FycmF5c2Agb3IgYGdsLmRyYXdFbGVtZW50c2AuIERlZmF1bHRzIHRvIGJ1ZmZlckluZm8ubnVtRWxlbWVudHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2luc3RhbmNlQ291bnRdIHRoZSBudW1iZXIgb2YgaW5zdGFuY2VzLiBEZWZhdWx0cyB0byB1bmRlZmluZWQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIERyYXdzIGEgbGlzdCBvZiBvYmplY3RzXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7RHJhd09iamVjdFtdfSBvYmplY3RzVG9EcmF3IGFuIGFycmF5IG9mIG9iamVjdHMgdG8gZHJhdy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9kcmF3XG4gKi9cblxuXG5mdW5jdGlvbiBkcmF3T2JqZWN0TGlzdChnbCwgb2JqZWN0c1RvRHJhdykge1xuICB2YXIgbGFzdFVzZWRQcm9ncmFtSW5mbyA9IG51bGw7XG4gIHZhciBsYXN0VXNlZEJ1ZmZlckluZm8gPSBudWxsO1xuICBvYmplY3RzVG9EcmF3LmZvckVhY2goZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuYWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9ncmFtSW5mbyA9IG9iamVjdC5wcm9ncmFtSW5mbztcbiAgICB2YXIgYnVmZmVySW5mbyA9IG9iamVjdC52ZXJ0ZXhBcnJheUluZm8gfHwgb2JqZWN0LmJ1ZmZlckluZm87XG4gICAgdmFyIGJpbmRCdWZmZXJzID0gZmFsc2U7XG4gICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZSA9PT0gdW5kZWZpbmVkID8gVFJJQU5HTEVTIDogb2JqZWN0LnR5cGU7XG5cbiAgICBpZiAocHJvZ3JhbUluZm8gIT09IGxhc3RVc2VkUHJvZ3JhbUluZm8pIHtcbiAgICAgIGxhc3RVc2VkUHJvZ3JhbUluZm8gPSBwcm9ncmFtSW5mbztcbiAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbUluZm8ucHJvZ3JhbSk7IC8vIFdlIGhhdmUgdG8gcmViaW5kIGJ1ZmZlcnMgd2hlbiBjaGFuZ2luZyBwcm9ncmFtcyBiZWNhdXNlIHdlXG4gICAgICAvLyBvbmx5IGJpbmQgYnVmZmVycyB0aGUgcHJvZ3JhbSB1c2VzLiBTbyBpZiAyIHByb2dyYW1zIHVzZSB0aGUgc2FtZVxuICAgICAgLy8gYnVmZmVySW5mbyBidXQgdGhlIDFzdCBvbmUgdXNlcyBvbmx5IHBvc2l0aW9ucyB0aGUgd2hlbiB0aGVcbiAgICAgIC8vIHdlIHN3aXRjaCB0byB0aGUgMm5kIG9uZSBzb21lIG9mIHRoZSBhdHRyaWJ1dGVzIHdpbGwgbm90IGJlIG9uLlxuXG4gICAgICBiaW5kQnVmZmVycyA9IHRydWU7XG4gICAgfSAvLyBTZXR1cCBhbGwgdGhlIG5lZWRlZCBhdHRyaWJ1dGVzLlxuXG5cbiAgICBpZiAoYmluZEJ1ZmZlcnMgfHwgYnVmZmVySW5mbyAhPT0gbGFzdFVzZWRCdWZmZXJJbmZvKSB7XG4gICAgICBpZiAobGFzdFVzZWRCdWZmZXJJbmZvICYmIGxhc3RVc2VkQnVmZmVySW5mby52ZXJ0ZXhBcnJheU9iamVjdCAmJiAhYnVmZmVySW5mby52ZXJ0ZXhBcnJheU9iamVjdCkge1xuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGxhc3RVc2VkQnVmZmVySW5mbyA9IGJ1ZmZlckluZm87XG4gICAgICBwcm9ncmFtcy5zZXRCdWZmZXJzQW5kQXR0cmlidXRlcyhnbCwgcHJvZ3JhbUluZm8sIGJ1ZmZlckluZm8pO1xuICAgIH0gLy8gU2V0IHRoZSB1bmlmb3Jtcy5cblxuXG4gICAgcHJvZ3JhbXMuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIG9iamVjdC51bmlmb3Jtcyk7IC8vIERyYXdcblxuICAgIGRyYXdCdWZmZXJJbmZvKGdsLCBidWZmZXJJbmZvLCB0eXBlLCBvYmplY3QuY291bnQsIG9iamVjdC5vZmZzZXQsIG9iamVjdC5pbnN0YW5jZUNvdW50KTtcbiAgfSk7XG5cbiAgaWYgKGxhc3RVc2VkQnVmZmVySW5mbyAmJiBsYXN0VXNlZEJ1ZmZlckluZm8udmVydGV4QXJyYXlPYmplY3QpIHtcbiAgICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZnJhbWVidWZmZXJzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9mcmFtZWJ1ZmZlcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuYmluZEZyYW1lYnVmZmVySW5mbyA9IGJpbmRGcmFtZWJ1ZmZlckluZm87XG5leHBvcnRzLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyA9IGNyZWF0ZUZyYW1lYnVmZmVySW5mbztcbmV4cG9ydHMucmVzaXplRnJhbWVidWZmZXJJbmZvID0gcmVzaXplRnJhbWVidWZmZXJJbmZvO1xuXG52YXIgdGV4dHVyZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RleHR1cmVzLmpzICovIFwiLi9zcmMvdGV4dHVyZXMuanNcIikpO1xuXG52YXIgaGVscGVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9oZWxwZXIuanMgKi8gXCIuL3NyYy9oZWxwZXIuanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogRnJhbWVidWZmZXIgcmVsYXRlZCBmdW5jdGlvbnNcbiAqXG4gKiBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB0aGV5IGFyZSBhdmFpbGFibGUgYXQgYm90aCBgdHdnbC5mcmFtZWJ1ZmZlcmAgYW5kIGB0d2dsYFxuICogaXRzZWxmXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6dHdnbH0gZm9yIGNvcmUgZnVuY3Rpb25zXG4gKlxuICogQG1vZHVsZSB0d2dsL2ZyYW1lYnVmZmVyc1xuICovXG4vLyBtYWtlIHN1cmUgd2UgZG9uJ3Qgc2VlIGEgZ2xvYmFsIGdsXG52YXIgZ2wgPSB1bmRlZmluZWQ7XG4vKiBlc2xpbnQtZGlzYWJsZS1saW5lICovXG5cbnZhciBGUkFNRUJVRkZFUiA9IDB4OGQ0MDtcbnZhciBSRU5ERVJCVUZGRVIgPSAweDhkNDE7XG52YXIgVEVYVFVSRV8yRCA9IDB4MGRlMTtcbnZhciBVTlNJR05FRF9CWVRFID0gMHgxNDAxO1xuLyogUGl4ZWxGb3JtYXQgKi9cblxudmFyIERFUFRIX0NPTVBPTkVOVCA9IDB4MTkwMjtcbnZhciBSR0JBID0gMHgxOTA4O1xudmFyIERFUFRIX0NPTVBPTkVOVDI0ID0gMHg4MWE2O1xudmFyIERFUFRIX0NPTVBPTkVOVDMyRiA9IDB4OGNhYztcbnZhciBERVBUSDI0X1NURU5DSUw4ID0gMHg4OGYwO1xudmFyIERFUFRIMzJGX1NURU5DSUw4ID0gMHg4Y2FkO1xuLyogRnJhbWVidWZmZXIgT2JqZWN0LiAqL1xuXG52YXIgUkdCQTQgPSAweDgwNTY7XG52YXIgUkdCNV9BMSA9IDB4ODA1NztcbnZhciBSR0I1NjUgPSAweDhENjI7XG52YXIgREVQVEhfQ09NUE9ORU5UMTYgPSAweDgxQTU7XG52YXIgU1RFTkNJTF9JTkRFWCA9IDB4MTkwMTtcbnZhciBTVEVOQ0lMX0lOREVYOCA9IDB4OEQ0ODtcbnZhciBERVBUSF9TVEVOQ0lMID0gMHg4NEY5O1xudmFyIENPTE9SX0FUVEFDSE1FTlQwID0gMHg4Q0UwO1xudmFyIERFUFRIX0FUVEFDSE1FTlQgPSAweDhEMDA7XG52YXIgU1RFTkNJTF9BVFRBQ0hNRU5UID0gMHg4RDIwO1xudmFyIERFUFRIX1NURU5DSUxfQVRUQUNITUVOVCA9IDB4ODIxQTtcbi8qIFRleHR1cmVXcmFwTW9kZSAqL1xuXG52YXIgQ0xBTVBfVE9fRURHRSA9IDB4ODEyRjtcbi8qIFRleHR1cmVNYWdGaWx0ZXIgKi9cblxudmFyIExJTkVBUiA9IDB4MjYwMTtcbi8qKlxuICogVGhlIG9wdGlvbnMgZm9yIGEgZnJhbWVidWZmZXIgYXR0YWNobWVudC5cbiAqXG4gKiBOb3RlOiBGb3IgYSBgZm9ybWF0YCB0aGF0IGlzIGEgdGV4dHVyZSBpbmNsdWRlIGFsbCB0aGUgdGV4dHVyZVxuICogb3B0aW9ucyBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gZm9yIGV4YW1wbGVcbiAqIGBtaW5gLCBgbWFnYCwgYGNsYW1wYCwgZXRjLi4uIE5vdGUgdGhhdCB1bmxpa2Uge0BsaW5rIG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfVxuICogYGF1dG9gIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIGF0dGFjaG1lbnQgdGV4dHVyZXMgYnV0IGBtaW5gIGFuZCBgbWFnYCBkZWZhdWx0XG4gKiB0byBgZ2wuTElORUFSYCBhbmQgYHdyYXBgIGRlZmF1bHRzIHRvIGBDTEFNUF9UT19FREdFYFxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEF0dGFjaG1lbnRPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2F0dGFjaG1lbnRQb2ludF0gVGhlIGF0dGFjaG1lbnQgcG9pbnQuIERlZmF1bHRzXG4gKiAgIHRvIGBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIG5keGAgdW5sZXNzIHR5cGUgaXMgYSBkZXB0aCBvciBzdGVuY2lsIHR5cGVcbiAqICAgdGhlbiBpdCdzIGdsLkRFUFRIX0FUVEFDSE1FTlQgb3IgYGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVGAgZGVwZW5kaW5nXG4gKiAgIG9uIHRoZSBmb3JtYXQgb3IgYXR0YWNobWVudCB0eXBlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmb3JtYXRdIFRoZSBmb3JtYXQuIElmIG9uZSBvZiBgZ2wuUkdCQTRgLFxuICogICBgZ2wuUkdCNTY1YCwgYGdsLlJHQjVfQTFgLCBgZ2wuREVQVEhfQ09NUE9ORU5UMTZgLFxuICogICBgZ2wuU1RFTkNJTF9JTkRFWDhgIG9yIGBnbC5ERVBUSF9TVEVOQ0lMYCB0aGVuIHdpbGwgY3JlYXRlIGFcbiAqICAgcmVuZGVyYnVmZmVyLiBPdGhlcndpc2Ugd2lsbCBjcmVhdGUgYSB0ZXh0dXJlLiBEZWZhdWx0ID0gYGdsLlJHQkFgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3R5cGVdIFRoZSB0eXBlLiBVc2VkIGZvciB0ZXh0dXJlLiBEZWZhdWx0ID0gYGdsLlVOU0lHTkVEX0JZVEVgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YXJnZXRdIFRoZSB0ZXh0dXJlIHRhcmdldCBmb3IgYGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEYC5cbiAqICAgRGVmYXVsdHMgdG8gYGdsLlRFWFRVUkVfMkRgLiBTZXQgdG8gYXBwcm9wcmlhdGUgZmFjZSBmb3IgY3ViZSBtYXBzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsZXZlbF0gbGV2ZWwgZm9yIGBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRGAuIERlZmF1bHRzIHRvIDAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xheWVyXSBsYXllciBmb3IgYGdsLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyYC4gRGVmYXVsdHMgdG8gdW5kZWZpbmVkLlxuICogICBJZiBzZXQgdGhlbiBgZ2wuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXJgIGlzIGNhbGxlZCwgaWYgbm90IHRoZW4gYGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEYFxuICogQHByb3BlcnR5IHtXZWJHTE9iamVjdH0gW2F0dGFjaG1lbnRdIEFuIGV4aXN0aW5nIHJlbmRlcmJ1ZmZlciBvciB0ZXh0dXJlLlxuICogICAgSWYgcHJvdmlkZWQgd2lsbCBhdHRhY2ggdGhpcyBPYmplY3QuIFRoaXMgYWxsb3dzIHlvdSB0byBzaGFyZVxuICogICAgYXR0YWNobWVudHMgYWNyb3NzIGZyYW1lYnVmZmVycy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICogQG1peGVzIG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zXG4gKi9cblxudmFyIGRlZmF1bHRBdHRhY2htZW50cyA9IFt7XG4gIGZvcm1hdDogUkdCQSxcbiAgdHlwZTogVU5TSUdORURfQllURSxcbiAgbWluOiBMSU5FQVIsXG4gIHdyYXA6IENMQU1QX1RPX0VER0Vcbn0sIHtcbiAgZm9ybWF0OiBERVBUSF9TVEVOQ0lMXG59XTtcbnZhciBhdHRhY2htZW50c0J5Rm9ybWF0ID0ge307XG5hdHRhY2htZW50c0J5Rm9ybWF0W0RFUFRIX1NURU5DSUxdID0gREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UO1xuYXR0YWNobWVudHNCeUZvcm1hdFtTVEVOQ0lMX0lOREVYXSA9IFNURU5DSUxfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbU1RFTkNJTF9JTkRFWDhdID0gU1RFTkNJTF9BVFRBQ0hNRU5UO1xuYXR0YWNobWVudHNCeUZvcm1hdFtERVBUSF9DT01QT05FTlRdID0gREVQVEhfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbREVQVEhfQ09NUE9ORU5UMTZdID0gREVQVEhfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbREVQVEhfQ09NUE9ORU5UMjRdID0gREVQVEhfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbREVQVEhfQ09NUE9ORU5UMzJGXSA9IERFUFRIX0FUVEFDSE1FTlQ7XG5hdHRhY2htZW50c0J5Rm9ybWF0W0RFUFRIMjRfU1RFTkNJTDhdID0gREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UO1xuYXR0YWNobWVudHNCeUZvcm1hdFtERVBUSDMyRl9TVEVOQ0lMOF0gPSBERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQ7XG5cbmZ1bmN0aW9uIGdldEF0dGFjaG1lbnRQb2ludEZvckZvcm1hdChmb3JtYXQsIGludGVybmFsRm9ybWF0KSB7XG4gIHJldHVybiBhdHRhY2htZW50c0J5Rm9ybWF0W2Zvcm1hdF0gfHwgYXR0YWNobWVudHNCeUZvcm1hdFtpbnRlcm5hbEZvcm1hdF07XG59XG5cbnZhciByZW5kZXJidWZmZXJGb3JtYXRzID0ge307XG5yZW5kZXJidWZmZXJGb3JtYXRzW1JHQkE0XSA9IHRydWU7XG5yZW5kZXJidWZmZXJGb3JtYXRzW1JHQjVfQTFdID0gdHJ1ZTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbUkdCNTY1XSA9IHRydWU7XG5yZW5kZXJidWZmZXJGb3JtYXRzW0RFUFRIX1NURU5DSUxdID0gdHJ1ZTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbREVQVEhfQ09NUE9ORU5UMTZdID0gdHJ1ZTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbU1RFTkNJTF9JTkRFWF0gPSB0cnVlO1xucmVuZGVyYnVmZmVyRm9ybWF0c1tTVEVOQ0lMX0lOREVYOF0gPSB0cnVlO1xuXG5mdW5jdGlvbiBpc1JlbmRlcmJ1ZmZlckZvcm1hdChmb3JtYXQpIHtcbiAgcmV0dXJuIHJlbmRlcmJ1ZmZlckZvcm1hdHNbZm9ybWF0XTtcbn1cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRnJhbWVidWZmZXJJbmZvXG4gKiBAcHJvcGVydHkge1dlYkdMRnJhbWVidWZmZXJ9IGZyYW1lYnVmZmVyIFRoZSBXZWJHTEZyYW1lYnVmZmVyIGZvciB0aGlzIGZyYW1lYnVmZmVySW5mb1xuICogQHByb3BlcnR5IHtXZWJHTE9iamVjdFtdfSBhdHRhY2htZW50cyBUaGUgY3JlYXRlZCBhdHRhY2htZW50cyBpbiB0aGUgc2FtZSBvcmRlciBhcyBwYXNzZWQgaW4gdG8ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mb30uXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBmcmFtZWJ1ZmZlciBhbmQgaXRzIGF0dGFjaG1lbnRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IFRoZSB3aWR0aCBvZiB0aGUgZnJhbWVidWZmZXIgYW5kIGl0cyBhdHRhY2htZW50c1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnJhbWVidWZmZXIgYW5kIGF0dGFjaG1lbnRzLlxuICpcbiAqIFRoaXMgcmV0dXJucyBhIHtAbGluayBtb2R1bGU6dHdnbC5GcmFtZWJ1ZmZlckluZm99IGJlY2F1c2UgaXQgbmVlZHMgdG8gcmV0dXJuIHRoZSBhdHRhY2htZW50cyBhcyB3ZWxsIGFzIHRoZSBmcmFtZWJ1ZmZlci5cbiAqXG4gKiBUaGUgc2ltcGxlc3QgdXNhZ2VcbiAqXG4gKiAgICAgLy8gY3JlYXRlIGFuIFJHQkEvVU5TSUdORURfQllURSB0ZXh0dXJlIGFuZCBERVBUSF9TVEVOQ0lMIHJlbmRlcmJ1ZmZlclxuICogICAgIGNvbnN0IGZiaSA9IHR3Z2wuY3JlYXRlRnJhbWVidWZmZXJJbmZvKGdsKTtcbiAqXG4gKiBNb3JlIGNvbXBsZXggdXNhZ2VcbiAqXG4gKiAgICAgLy8gY3JlYXRlIGFuIFJHQjU2NSByZW5kZXJidWZmZXIgYW5kIGEgU1RFTkNJTF9JTkRFWDggcmVuZGVyYnVmZmVyXG4gKiAgICAgY29uc3QgYXR0YWNobWVudHMgPSBbXG4gKiAgICAgICB7IGZvcm1hdDogUkdCNTY1LCBtYWc6IE5FQVJFU1QgfSxcbiAqICAgICAgIHsgZm9ybWF0OiBTVEVOQ0lMX0lOREVYOCB9LFxuICogICAgIF1cbiAqICAgICBjb25zdCBmYmkgPSB0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCwgYXR0YWNobWVudHMpO1xuICpcbiAqIFBhc3NpbmcgaW4gYSBzcGVjaWZpYyBzaXplXG4gKlxuICogICAgIGNvbnN0IHdpZHRoID0gMjU2O1xuICogICAgIGNvbnN0IGhlaWdodCA9IDI1NjtcbiAqICAgICBjb25zdCBmYmkgPSB0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCwgYXR0YWNobWVudHMsIHdpZHRoLCBoZWlnaHQpO1xuICpcbiAqICoqTm90ZSEhKiogSXQgaXMgdXAgdG8geW91IHRvIGNoZWNrIGlmIHRoZSBmcmFtZWJ1ZmZlciBpcyByZW5kZXJhYmxlIGJ5IGNhbGxpbmcgYGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXNgLlxuICogW1dlYkdMMSBvbmx5IGd1YXJhbnRlZXMgMyBjb21iaW5hdGlvbnMgb2YgYXR0YWNobWVudHMgd29ya10oaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvc3BlY3MvbGF0ZXN0LzEuMC8jNi42KS5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5BdHRhY2htZW50T3B0aW9uc1tdfSBbYXR0YWNobWVudHNdIHdoaWNoIGF0dGFjaG1lbnRzIHRvIGNyZWF0ZS4gSWYgbm90IHByb3ZpZGVkIHRoZSBkZWZhdWx0IGlzIGEgZnJhbWVidWZmZXIgd2l0aCBhblxuICogICAgYFJHQkFgLCBgVU5TSUdORURfQllURWAgdGV4dHVyZSBgQ09MT1JfQVRUQUNITUVOVDBgIGFuZCBhIGBERVBUSF9TVEVOQ0lMYCByZW5kZXJidWZmZXIgYERFUFRIX1NURU5DSUxfQVRUQUNITUVOVGAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSB0aGUgd2lkdGggZm9yIHRoZSBhdHRhY2htZW50cy4gRGVmYXVsdCA9IHNpemUgb2YgZHJhd2luZ0J1ZmZlclxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIHRoZSBoZWlnaHQgZm9yIHRoZSBhdHRhY2htZW50cy4gRGVmYXVsdCA9IHNpemUgb2YgZHJhd2luZ0J1ZmZlclxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuRnJhbWVidWZmZXJJbmZvfSB0aGUgZnJhbWVidWZmZXIgYW5kIGF0dGFjaG1lbnRzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2ZyYW1lYnVmZmVyc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRnJhbWVidWZmZXJJbmZvKGdsLCBhdHRhY2htZW50cywgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgdGFyZ2V0ID0gRlJBTUVCVUZGRVI7XG4gIHZhciBmYiA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gIGdsLmJpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIGZiKTtcbiAgd2lkdGggPSB3aWR0aCB8fCBnbC5kcmF3aW5nQnVmZmVyV2lkdGg7XG4gIGhlaWdodCA9IGhlaWdodCB8fCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xuICBhdHRhY2htZW50cyA9IGF0dGFjaG1lbnRzIHx8IGRlZmF1bHRBdHRhY2htZW50cztcbiAgdmFyIGNvbG9yQXR0YWNobWVudENvdW50ID0gMDtcbiAgdmFyIGZyYW1lYnVmZmVySW5mbyA9IHtcbiAgICBmcmFtZWJ1ZmZlcjogZmIsXG4gICAgYXR0YWNobWVudHM6IFtdLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuICBhdHRhY2htZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRhY2htZW50T3B0aW9ucykge1xuICAgIHZhciBhdHRhY2htZW50ID0gYXR0YWNobWVudE9wdGlvbnMuYXR0YWNobWVudDtcbiAgICB2YXIgZm9ybWF0ID0gYXR0YWNobWVudE9wdGlvbnMuZm9ybWF0O1xuICAgIHZhciBhdHRhY2htZW50UG9pbnQgPSBhdHRhY2htZW50T3B0aW9ucy5hdHRhY2htZW50UG9pbnQgfHwgZ2V0QXR0YWNobWVudFBvaW50Rm9yRm9ybWF0KGZvcm1hdCwgYXR0YWNobWVudE9wdGlvbnMuaW50ZXJuYWxGb3JtYXQpO1xuXG4gICAgaWYgKCFhdHRhY2htZW50UG9pbnQpIHtcbiAgICAgIGF0dGFjaG1lbnRQb2ludCA9IENPTE9SX0FUVEFDSE1FTlQwICsgY29sb3JBdHRhY2htZW50Q291bnQrKztcbiAgICB9XG5cbiAgICBpZiAoIWF0dGFjaG1lbnQpIHtcbiAgICAgIGlmIChpc1JlbmRlcmJ1ZmZlckZvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIGF0dGFjaG1lbnQgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihSRU5ERVJCVUZGRVIsIGF0dGFjaG1lbnQpO1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKFJFTkRFUkJVRkZFUiwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0dXJlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGF0dGFjaG1lbnRPcHRpb25zKTtcbiAgICAgICAgdGV4dHVyZU9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGV4dHVyZU9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIGlmICh0ZXh0dXJlT3B0aW9ucy5hdXRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0ZXh0dXJlT3B0aW9ucy5hdXRvID0gZmFsc2U7XG4gICAgICAgICAgdGV4dHVyZU9wdGlvbnMubWluID0gdGV4dHVyZU9wdGlvbnMubWluIHx8IHRleHR1cmVPcHRpb25zLm1pbk1hZyB8fCBMSU5FQVI7XG4gICAgICAgICAgdGV4dHVyZU9wdGlvbnMubWFnID0gdGV4dHVyZU9wdGlvbnMubWFnIHx8IHRleHR1cmVPcHRpb25zLm1pbk1hZyB8fCBMSU5FQVI7XG4gICAgICAgICAgdGV4dHVyZU9wdGlvbnMud3JhcFMgPSB0ZXh0dXJlT3B0aW9ucy53cmFwUyB8fCB0ZXh0dXJlT3B0aW9ucy53cmFwIHx8IENMQU1QX1RPX0VER0U7XG4gICAgICAgICAgdGV4dHVyZU9wdGlvbnMud3JhcFQgPSB0ZXh0dXJlT3B0aW9ucy53cmFwVCB8fCB0ZXh0dXJlT3B0aW9ucy53cmFwIHx8IENMQU1QX1RPX0VER0U7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRhY2htZW50ID0gdGV4dHVyZXMuY3JlYXRlVGV4dHVyZShnbCwgdGV4dHVyZU9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoZWxwZXIuaXNSZW5kZXJidWZmZXIoZ2wsIGF0dGFjaG1lbnQpKSB7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0YXJnZXQsIGF0dGFjaG1lbnRQb2ludCwgUkVOREVSQlVGRkVSLCBhdHRhY2htZW50KTtcbiAgICB9IGVsc2UgaWYgKGhlbHBlci5pc1RleHR1cmUoZ2wsIGF0dGFjaG1lbnQpKSB7XG4gICAgICBpZiAoYXR0YWNobWVudE9wdGlvbnMubGF5ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmVMYXllcih0YXJnZXQsIGF0dGFjaG1lbnRQb2ludCwgYXR0YWNobWVudCwgYXR0YWNobWVudE9wdGlvbnMubGV2ZWwgfHwgMCwgYXR0YWNobWVudE9wdGlvbnMubGF5ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGFyZ2V0LCBhdHRhY2htZW50UG9pbnQsIGF0dGFjaG1lbnRPcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJELCBhdHRhY2htZW50LCBhdHRhY2htZW50T3B0aW9ucy5sZXZlbCB8fCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGF0dGFjaG1lbnQgdHlwZScpO1xuICAgIH1cblxuICAgIGZyYW1lYnVmZmVySW5mby5hdHRhY2htZW50cy5wdXNoKGF0dGFjaG1lbnQpO1xuICB9KTtcbiAgcmV0dXJuIGZyYW1lYnVmZmVySW5mbztcbn1cbi8qKlxuICogUmVzaXplcyB0aGUgYXR0YWNobWVudHMgb2YgYSBmcmFtZWJ1ZmZlci5cbiAqXG4gKiBZb3UgbmVlZCB0byBwYXNzIGluIHRoZSBzYW1lIGBhdHRhY2htZW50c2AgYXMgeW91IHBhc3NlZCBpbiB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlRnJhbWVidWZmZXJJbmZvfVxuICogYmVjYXVzZSBUV0dMIGhhcyBubyBpZGVhIHRoZSBmb3JtYXQvdHlwZSBvZiBlYWNoIGF0dGFjaG1lbnQuXG4gKlxuICogVGhlIHNpbXBsZXN0IHVzYWdlXG4gKlxuICogICAgIC8vIGNyZWF0ZSBhbiBSR0JBL1VOU0lHTkVEX0JZVEUgdGV4dHVyZSBhbmQgREVQVEhfU1RFTkNJTCByZW5kZXJidWZmZXJcbiAqICAgICBjb25zdCBmYmkgPSB0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCk7XG4gKlxuICogICAgIC4uLlxuICpcbiAqICAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gKiAgICAgICBpZiAodHdnbC5yZXNpemVDYW52YXNUb0Rpc3BsYXlTaXplKGdsLmNhbnZhcykpIHtcbiAqICAgICAgICAgLy8gcmVzaXplIHRoZSBhdHRhY2htZW50c1xuICogICAgICAgICB0d2dsLnJlc2l6ZUZyYW1lYnVmZmVySW5mbyhnbCwgZmJpKTtcbiAqICAgICAgIH1cbiAqXG4gKiBNb3JlIGNvbXBsZXggdXNhZ2VcbiAqXG4gKiAgICAgLy8gY3JlYXRlIGFuIFJHQjU2NSByZW5kZXJidWZmZXIgYW5kIGEgU1RFTkNJTF9JTkRFWDggcmVuZGVyYnVmZmVyXG4gKiAgICAgY29uc3QgYXR0YWNobWVudHMgPSBbXG4gKiAgICAgICB7IGZvcm1hdDogUkdCNTY1LCBtYWc6IE5FQVJFU1QgfSxcbiAqICAgICAgIHsgZm9ybWF0OiBTVEVOQ0lMX0lOREVYOCB9LFxuICogICAgIF1cbiAqICAgICBjb25zdCBmYmkgPSB0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCwgYXR0YWNobWVudHMpO1xuICpcbiAqICAgICAuLi5cbiAqXG4gKiAgICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICogICAgICAgaWYgKHR3Z2wucmVzaXplQ2FudmFzVG9EaXNwbGF5U2l6ZShnbC5jYW52YXMpKSB7XG4gKiAgICAgICAgIC8vIHJlc2l6ZSB0aGUgYXR0YWNobWVudHMgdG8gbWF0Y2hcbiAqICAgICAgICAgdHdnbC5yZXNpemVGcmFtZWJ1ZmZlckluZm8oZ2wsIGZiaSwgYXR0YWNobWVudHMpO1xuICogICAgICAgfVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkZyYW1lYnVmZmVySW5mb30gZnJhbWVidWZmZXJJbmZvIGEgZnJhbWVidWZmZXJJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mb30uXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkF0dGFjaG1lbnRPcHRpb25zW119IFthdHRhY2htZW50c10gdGhlIHNhbWUgYXR0YWNobWVudHMgb3B0aW9ucyBhcyBwYXNzZWQgdG8ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mb30uXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSB0aGUgd2lkdGggZm9yIHRoZSBhdHRhY2htZW50cy4gRGVmYXVsdCA9IHNpemUgb2YgZHJhd2luZ0J1ZmZlclxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIHRoZSBoZWlnaHQgZm9yIHRoZSBhdHRhY2htZW50cy4gRGVmYXVsdCA9IHNpemUgb2YgZHJhd2luZ0J1ZmZlclxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2ZyYW1lYnVmZmVyc1xuICovXG5cblxuZnVuY3Rpb24gcmVzaXplRnJhbWVidWZmZXJJbmZvKGdsLCBmcmFtZWJ1ZmZlckluZm8sIGF0dGFjaG1lbnRzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHdpZHRoID0gd2lkdGggfHwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoO1xuICBoZWlnaHQgPSBoZWlnaHQgfHwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodDtcbiAgZnJhbWVidWZmZXJJbmZvLndpZHRoID0gd2lkdGg7XG4gIGZyYW1lYnVmZmVySW5mby5oZWlnaHQgPSBoZWlnaHQ7XG4gIGF0dGFjaG1lbnRzID0gYXR0YWNobWVudHMgfHwgZGVmYXVsdEF0dGFjaG1lbnRzO1xuICBhdHRhY2htZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRhY2htZW50T3B0aW9ucywgbmR4KSB7XG4gICAgdmFyIGF0dGFjaG1lbnQgPSBmcmFtZWJ1ZmZlckluZm8uYXR0YWNobWVudHNbbmR4XTtcbiAgICB2YXIgZm9ybWF0ID0gYXR0YWNobWVudE9wdGlvbnMuZm9ybWF0O1xuXG4gICAgaWYgKGhlbHBlci5pc1JlbmRlcmJ1ZmZlcihnbCwgYXR0YWNobWVudCkpIHtcbiAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoUkVOREVSQlVGRkVSLCBhdHRhY2htZW50KTtcbiAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoUkVOREVSQlVGRkVSLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoaGVscGVyLmlzVGV4dHVyZShnbCwgYXR0YWNobWVudCkpIHtcbiAgICAgIHRleHR1cmVzLnJlc2l6ZVRleHR1cmUoZ2wsIGF0dGFjaG1lbnQsIGF0dGFjaG1lbnRPcHRpb25zLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGF0dGFjaG1lbnQgdHlwZScpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEJpbmRzIGEgZnJhbWVidWZmZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHByZXR0eSBtdWNoIHNvbGVseSBleGlzdHMgYmVjYXVzZSBJIHNwZW50IGhvdXJzXG4gKiB0cnlpbmcgdG8gZmlndXJlIG91dCB3aHkgc29tZXRoaW5nIEkgd3JvdGUgd2Fzbid0IHdvcmtpbmcgb25seVxuICogdG8gcmVhbGl6ZSBJIGZvcmdldCB0byBzZXQgdGhlIHZpZXdwb3J0IGRpbWVuc2lvbnMuXG4gKiBNeSBob3BlIGlzIHRoaXMgZnVuY3Rpb24gd2lsbCBmaXggdGhhdC5cbiAqXG4gKiBJdCBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSBhc1xuICpcbiAqICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHNvbWVGcmFtZWJ1ZmZlckluZm8uZnJhbWVidWZmZXIpO1xuICogICAgIGdsLnZpZXdwb3J0KDAsIDAsIHNvbWVGcmFtZWJ1ZmZlckluZm8ud2lkdGgsIHNvbWVGcmFtZWJ1ZmZlckluZm8uaGVpZ2h0KTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5GcmFtZWJ1ZmZlckluZm98bnVsbH0gW2ZyYW1lYnVmZmVySW5mb10gYSBmcmFtZWJ1ZmZlckluZm8gYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlRnJhbWVidWZmZXJJbmZvfS5cbiAqICAgSWYgZmFsc3kgd2lsbCBiaW5kIHRoZSBjYW52YXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW3RhcmdldF0gVGhlIHRhcmdldC4gSWYgbm90IHBhc3NlZCBgZ2wuRlJBTUVCVUZGRVJgIHdpbGwgYmUgdXNlZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9mcmFtZWJ1ZmZlcnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGJpbmRGcmFtZWJ1ZmZlckluZm8oZ2wsIGZyYW1lYnVmZmVySW5mbywgdGFyZ2V0KSB7XG4gIHRhcmdldCA9IHRhcmdldCB8fCBGUkFNRUJVRkZFUjtcblxuICBpZiAoZnJhbWVidWZmZXJJbmZvKSB7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgZnJhbWVidWZmZXJJbmZvLmZyYW1lYnVmZmVyKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBmcmFtZWJ1ZmZlckluZm8ud2lkdGgsIGZyYW1lYnVmZmVySW5mby5oZWlnaHQpO1xuICB9IGVsc2Uge1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIG51bGwpO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvaGVscGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9oZWxwZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvcHlFeGlzdGluZ1Byb3BlcnRpZXMgPSBjb3B5RXhpc3RpbmdQcm9wZXJ0aWVzO1xuZXhwb3J0cy5jb3B5TmFtZWRQcm9wZXJ0aWVzID0gY29weU5hbWVkUHJvcGVydGllcztcbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmV4cG9ydHMud2FybiA9IHdhcm47XG5leHBvcnRzLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5leHBvcnRzLmlzUmVuZGVyYnVmZmVyID0gaXNSZW5kZXJidWZmZXI7XG5leHBvcnRzLmlzU2hhZGVyID0gaXNTaGFkZXI7XG5leHBvcnRzLmlzVGV4dHVyZSA9IGlzVGV4dHVyZTtcbmV4cG9ydHMuaXNTYW1wbGVyID0gaXNTYW1wbGVyO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby1jb25zb2xlOiBcIm9mZlwiICovXG5cbi8qKlxuICogQ29weSBuYW1lZCBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gbmFtZXMgbmFtZXMgb2YgcHJvcGVydGllcyB0byBjb3B5XG4gKiBAcGFyYW0ge29iamVjdH0gc3JjIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtvYmplY3R9IGRzdCBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb3B5TmFtZWRQcm9wZXJ0aWVzKG5hbWVzLCBzcmMsIGRzdCkge1xuICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gc3JjW25hbWVdO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRzdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIGRlc3Qgb25seSBpZiBhIG1hdGNoaW5nIGtleSBpcyBpbiBkZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgPz59IHNyYyB0aGUgc291cmNlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCA/Pn0gZHN0IHRoZSBkZXN0XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gY29weUV4aXN0aW5nUHJvcGVydGllcyhzcmMsIGRzdCkge1xuICBPYmplY3Qua2V5cyhkc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChkc3QuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLyogZXNsaW50IG5vLXByb3RvdHlwZS1idWlsdGluczogMCAqL1xuICAgICAgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlcnJvcigpIHtcbiAgdmFyIF9jb25zb2xlO1xuXG4gIChfY29uc29sZSA9IGNvbnNvbGUpLmVycm9yLmFwcGx5KF9jb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiB3YXJuKCkge1xuICB2YXIgX2NvbnNvbGUyO1xuXG4gIChfY29uc29sZTIgPSBjb25zb2xlKS53YXJuLmFwcGx5KF9jb25zb2xlMiwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIoZ2wsIHQpIHtcbiAgcmV0dXJuIHR5cGVvZiBXZWJHTEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdCBpbnN0YW5jZW9mIFdlYkdMQnVmZmVyO1xufVxuXG5mdW5jdGlvbiBpc1JlbmRlcmJ1ZmZlcihnbCwgdCkge1xuICByZXR1cm4gdHlwZW9mIFdlYkdMUmVuZGVyYnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0IGluc3RhbmNlb2YgV2ViR0xSZW5kZXJidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGlzU2hhZGVyKGdsLCB0KSB7XG4gIHJldHVybiB0eXBlb2YgV2ViR0xTaGFkZXIgIT09ICd1bmRlZmluZWQnICYmIHQgaW5zdGFuY2VvZiBXZWJHTFNoYWRlcjtcbn1cblxuZnVuY3Rpb24gaXNUZXh0dXJlKGdsLCB0KSB7XG4gIHJldHVybiB0eXBlb2YgV2ViR0xUZXh0dXJlICE9PSAndW5kZWZpbmVkJyAmJiB0IGluc3RhbmNlb2YgV2ViR0xUZXh0dXJlO1xufVxuXG5mdW5jdGlvbiBpc1NhbXBsZXIoZ2wsIHQpIHtcbiAgcmV0dXJuIHR5cGVvZiBXZWJHTFNhbXBsZXIgIT09ICd1bmRlZmluZWQnICYmIHQgaW5zdGFuY2VvZiBXZWJHTFNhbXBsZXI7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL200LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL200LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuYXhpc1JvdGF0ZSA9IGF4aXNSb3RhdGU7XG5leHBvcnRzLmF4aXNSb3RhdGlvbiA9IGF4aXNSb3RhdGlvbjtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmZydXN0dW0gPSBmcnVzdHVtO1xuZXhwb3J0cy5nZXRBeGlzID0gZ2V0QXhpcztcbmV4cG9ydHMuZ2V0VHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbjtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuaW52ZXJzZSA9IGludmVyc2U7XG5leHBvcnRzLmxvb2tBdCA9IGxvb2tBdDtcbmV4cG9ydHMubXVsdGlwbHkgPSBtdWx0aXBseTtcbmV4cG9ydHMubmVnYXRlID0gbmVnYXRlO1xuZXhwb3J0cy5vcnRobyA9IG9ydGhvO1xuZXhwb3J0cy5wZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlO1xuZXhwb3J0cy5yb3RhdGVYID0gcm90YXRlWDtcbmV4cG9ydHMucm90YXRlWSA9IHJvdGF0ZVk7XG5leHBvcnRzLnJvdGF0ZVogPSByb3RhdGVaO1xuZXhwb3J0cy5yb3RhdGlvblggPSByb3RhdGlvblg7XG5leHBvcnRzLnJvdGF0aW9uWSA9IHJvdGF0aW9uWTtcbmV4cG9ydHMucm90YXRpb25aID0gcm90YXRpb25aO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5zY2FsaW5nID0gc2NhbGluZztcbmV4cG9ydHMuc2V0QXhpcyA9IHNldEF4aXM7XG5leHBvcnRzLnNldERlZmF1bHRUeXBlID0gc2V0RGVmYXVsdFR5cGU7XG5leHBvcnRzLnNldFRyYW5zbGF0aW9uID0gc2V0VHJhbnNsYXRpb247XG5leHBvcnRzLnRyYW5zZm9ybURpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbjtcbmV4cG9ydHMudHJhbnNmb3JtTm9ybWFsID0gdHJhbnNmb3JtTm9ybWFsO1xuZXhwb3J0cy50cmFuc2Zvcm1Qb2ludCA9IHRyYW5zZm9ybVBvaW50O1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb247XG5leHBvcnRzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZTtcblxudmFyIHYzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92My5qcyAqLyBcIi4vc3JjL3YzLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIDR4NCBNYXRyaXggbWF0aCBtYXRoIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbG1vc3QgYWxsIGZ1bmN0aW9ucyB0YWtlIGFuIG9wdGlvbmFsIGBkc3RgIGFyZ3VtZW50LiBJZiBpdCBpcyBub3QgcGFzc2VkIGluIHRoZVxuICogZnVuY3Rpb25zIHdpbGwgY3JlYXRlIGEgbmV3IG1hdHJpeC4gSW4gb3RoZXIgd29yZHMgeW91IGNhbiBkbyB0aGlzXG4gKlxuICogICAgIGNvbnN0IG1hdCA9IG00LnRyYW5zbGF0aW9uKFsxLCAyLCAzXSk7ICAvLyBDcmVhdGVzIGEgbmV3IHRyYW5zbGF0aW9uIG1hdHJpeFxuICpcbiAqIG9yXG4gKlxuICogICAgIGNvbnN0IG1hdCA9IG00LmNyZWF0ZSgpO1xuICogICAgIG00LnRyYW5zbGF0aW9uKFsxLCAyLCAzXSwgbWF0KTsgIC8vIFB1dHMgdHJhbnNsYXRpb24gbWF0cml4IGluIG1hdC5cbiAqXG4gKiBUaGUgZmlyc3Qgc3R5bGUgaXMgb2Z0ZW4gZWFzaWVyIGJ1dCBkZXBlbmRpbmcgb24gd2hlcmUgaXQncyB1c2VkIGl0IGdlbmVyYXRlcyBnYXJiYWdlIHdoZXJlXG4gKiBhcyB0aGVyZSBpcyBhbG1vc3QgbmV2ZXIgYWxsb2NhdGlvbiB3aXRoIHRoZSBzZWNvbmQgc3R5bGUuXG4gKlxuICogSXQgaXMgYWx3YXlzIHNhdmUgdG8gcGFzcyBhbnkgbWF0cml4IGFzIHRoZSBkZXN0aW5hdGlvbi4gU28gZm9yIGV4YW1wbGVcbiAqXG4gKiAgICAgY29uc3QgbWF0ID0gbTQuaWRlbnRpdHkoKTtcbiAqICAgICBjb25zdCB0cmFucyA9IG00LnRyYW5zbGF0aW9uKFsxLCAyLCAzXSk7XG4gKiAgICAgbTQubXVsdGlwbHkobWF0LCB0cmFucywgbWF0KTsgIC8vIE11bHRpcGxpZXMgbWF0ICogdHJhbnMgYW5kIHB1dHMgcmVzdWx0IGluIG1hdC5cbiAqXG4gKiBAbW9kdWxlIHR3Z2wvbTRcbiAqL1xudmFyIE1hdFR5cGUgPSBGbG9hdDMyQXJyYXk7XG4vKipcbiAqIEEgSmF2YVNjcmlwdCBhcnJheSB3aXRoIDE2IHZhbHVlcyBvciBhIEZsb2F0MzJBcnJheSB3aXRoIDE2IHZhbHVlcy5cbiAqIFdoZW4gY3JlYXRlZCBieSB0aGUgbGlicmFyeSB3aWxsIGNyZWF0ZSB0aGUgZGVmYXVsdCB0eXBlIHdoaWNoIGlzIGBGbG9hdDMyQXJyYXlgXG4gKiBidXQgY2FuIGJlIHNldCBieSBjYWxsaW5nIHtAbGluayBtb2R1bGU6dHdnbC9tNC5zZXREZWZhdWx0VHlwZX0uXG4gKiBAdHlwZWRlZiB7KG51bWJlcltdfEZsb2F0MzJBcnJheSl9IE1hdDRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cbi8qKlxuICogU2V0cyB0aGUgdHlwZSB0aGlzIGxpYnJhcnkgY3JlYXRlcyBmb3IgYSBNYXQ0XG4gKiBAcGFyYW0ge2NvbnN0cnVjdG9yfSBjdG9yIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHR5cGUuIEVpdGhlciBgRmxvYXQzMkFycmF5YCBvciBgQXJyYXlgXG4gKiBAcmV0dXJuIHtjb25zdHJ1Y3Rvcn0gcHJldmlvdXMgY29uc3RydWN0b3IgZm9yIE1hdDRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cbmZ1bmN0aW9uIHNldERlZmF1bHRUeXBlKGN0b3IpIHtcbiAgdmFyIG9sZFR5cGUgPSBNYXRUeXBlO1xuICBNYXRUeXBlID0gY3RvcjtcbiAgcmV0dXJuIG9sZFR5cGU7XG59XG4vKipcbiAqIE5lZ2F0ZXMgYSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gLW0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIG5lZ2F0ZShtLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgZHN0WzBdID0gLW1bMF07XG4gIGRzdFsxXSA9IC1tWzFdO1xuICBkc3RbMl0gPSAtbVsyXTtcbiAgZHN0WzNdID0gLW1bM107XG4gIGRzdFs0XSA9IC1tWzRdO1xuICBkc3RbNV0gPSAtbVs1XTtcbiAgZHN0WzZdID0gLW1bNl07XG4gIGRzdFs3XSA9IC1tWzddO1xuICBkc3RbOF0gPSAtbVs4XTtcbiAgZHN0WzldID0gLW1bOV07XG4gIGRzdFsxMF0gPSAtbVsxMF07XG4gIGRzdFsxMV0gPSAtbVsxMV07XG4gIGRzdFsxMl0gPSAtbVsxMl07XG4gIGRzdFsxM10gPSAtbVsxM107XG4gIGRzdFsxNF0gPSAtbVsxNF07XG4gIGRzdFsxNV0gPSAtbVsxNV07XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENvcGllcyBhIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBUaGUgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gQSBjb3B5IG9mIG0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkobSwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIGRzdFswXSA9IG1bMF07XG4gIGRzdFsxXSA9IG1bMV07XG4gIGRzdFsyXSA9IG1bMl07XG4gIGRzdFszXSA9IG1bM107XG4gIGRzdFs0XSA9IG1bNF07XG4gIGRzdFs1XSA9IG1bNV07XG4gIGRzdFs2XSA9IG1bNl07XG4gIGRzdFs3XSA9IG1bN107XG4gIGRzdFs4XSA9IG1bOF07XG4gIGRzdFs5XSA9IG1bOV07XG4gIGRzdFsxMF0gPSBtWzEwXTtcbiAgZHN0WzExXSA9IG1bMTFdO1xuICBkc3RbMTJdID0gbVsxMl07XG4gIGRzdFsxM10gPSBtWzEzXTtcbiAgZHN0WzE0XSA9IG1bMTRdO1xuICBkc3RbMTVdID0gbVsxNV07XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gbi1ieS1uIGlkZW50aXR5IG1hdHJpeC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IEFuIG4tYnktbiBpZGVudGl0eSBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICBkc3RbMF0gPSAxO1xuICBkc3RbMV0gPSAwO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAwO1xuICBkc3RbNV0gPSAxO1xuICBkc3RbNl0gPSAwO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSAwO1xuICBkc3RbOV0gPSAwO1xuICBkc3RbMTBdID0gMTtcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSAwO1xuICBkc3RbMTNdID0gMDtcbiAgZHN0WzE0XSA9IDA7XG4gIGRzdFsxNV0gPSAxO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBUYWtlcyB0aGUgdHJhbnNwb3NlIG9mIGEgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSB0cmFuc3Bvc2Ugb2YgbS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNwb3NlKG0sIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGlmIChkc3QgPT09IG0pIHtcbiAgICB2YXIgdDtcbiAgICB0ID0gbVsxXTtcbiAgICBtWzFdID0gbVs0XTtcbiAgICBtWzRdID0gdDtcbiAgICB0ID0gbVsyXTtcbiAgICBtWzJdID0gbVs4XTtcbiAgICBtWzhdID0gdDtcbiAgICB0ID0gbVszXTtcbiAgICBtWzNdID0gbVsxMl07XG4gICAgbVsxMl0gPSB0O1xuICAgIHQgPSBtWzZdO1xuICAgIG1bNl0gPSBtWzldO1xuICAgIG1bOV0gPSB0O1xuICAgIHQgPSBtWzddO1xuICAgIG1bN10gPSBtWzEzXTtcbiAgICBtWzEzXSA9IHQ7XG4gICAgdCA9IG1bMTFdO1xuICAgIG1bMTFdID0gbVsxNF07XG4gICAgbVsxNF0gPSB0O1xuICAgIHJldHVybiBkc3Q7XG4gIH1cblxuICB2YXIgbTAwID0gbVswICogNCArIDBdO1xuICB2YXIgbTAxID0gbVswICogNCArIDFdO1xuICB2YXIgbTAyID0gbVswICogNCArIDJdO1xuICB2YXIgbTAzID0gbVswICogNCArIDNdO1xuICB2YXIgbTEwID0gbVsxICogNCArIDBdO1xuICB2YXIgbTExID0gbVsxICogNCArIDFdO1xuICB2YXIgbTEyID0gbVsxICogNCArIDJdO1xuICB2YXIgbTEzID0gbVsxICogNCArIDNdO1xuICB2YXIgbTIwID0gbVsyICogNCArIDBdO1xuICB2YXIgbTIxID0gbVsyICogNCArIDFdO1xuICB2YXIgbTIyID0gbVsyICogNCArIDJdO1xuICB2YXIgbTIzID0gbVsyICogNCArIDNdO1xuICB2YXIgbTMwID0gbVszICogNCArIDBdO1xuICB2YXIgbTMxID0gbVszICogNCArIDFdO1xuICB2YXIgbTMyID0gbVszICogNCArIDJdO1xuICB2YXIgbTMzID0gbVszICogNCArIDNdO1xuICBkc3RbMF0gPSBtMDA7XG4gIGRzdFsxXSA9IG0xMDtcbiAgZHN0WzJdID0gbTIwO1xuICBkc3RbM10gPSBtMzA7XG4gIGRzdFs0XSA9IG0wMTtcbiAgZHN0WzVdID0gbTExO1xuICBkc3RbNl0gPSBtMjE7XG4gIGRzdFs3XSA9IG0zMTtcbiAgZHN0WzhdID0gbTAyO1xuICBkc3RbOV0gPSBtMTI7XG4gIGRzdFsxMF0gPSBtMjI7XG4gIGRzdFsxMV0gPSBtMzI7XG4gIGRzdFsxMl0gPSBtMDM7XG4gIGRzdFsxM10gPSBtMTM7XG4gIGRzdFsxNF0gPSBtMjM7XG4gIGRzdFsxNV0gPSBtMzM7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBpbnZlcnNlIG9mIGEgNC1ieS00IG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgaW52ZXJzZSBvZiBtLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnNlKG0sIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICB2YXIgbTAwID0gbVswICogNCArIDBdO1xuICB2YXIgbTAxID0gbVswICogNCArIDFdO1xuICB2YXIgbTAyID0gbVswICogNCArIDJdO1xuICB2YXIgbTAzID0gbVswICogNCArIDNdO1xuICB2YXIgbTEwID0gbVsxICogNCArIDBdO1xuICB2YXIgbTExID0gbVsxICogNCArIDFdO1xuICB2YXIgbTEyID0gbVsxICogNCArIDJdO1xuICB2YXIgbTEzID0gbVsxICogNCArIDNdO1xuICB2YXIgbTIwID0gbVsyICogNCArIDBdO1xuICB2YXIgbTIxID0gbVsyICogNCArIDFdO1xuICB2YXIgbTIyID0gbVsyICogNCArIDJdO1xuICB2YXIgbTIzID0gbVsyICogNCArIDNdO1xuICB2YXIgbTMwID0gbVszICogNCArIDBdO1xuICB2YXIgbTMxID0gbVszICogNCArIDFdO1xuICB2YXIgbTMyID0gbVszICogNCArIDJdO1xuICB2YXIgbTMzID0gbVszICogNCArIDNdO1xuICB2YXIgdG1wXzAgPSBtMjIgKiBtMzM7XG4gIHZhciB0bXBfMSA9IG0zMiAqIG0yMztcbiAgdmFyIHRtcF8yID0gbTEyICogbTMzO1xuICB2YXIgdG1wXzMgPSBtMzIgKiBtMTM7XG4gIHZhciB0bXBfNCA9IG0xMiAqIG0yMztcbiAgdmFyIHRtcF81ID0gbTIyICogbTEzO1xuICB2YXIgdG1wXzYgPSBtMDIgKiBtMzM7XG4gIHZhciB0bXBfNyA9IG0zMiAqIG0wMztcbiAgdmFyIHRtcF84ID0gbTAyICogbTIzO1xuICB2YXIgdG1wXzkgPSBtMjIgKiBtMDM7XG4gIHZhciB0bXBfMTAgPSBtMDIgKiBtMTM7XG4gIHZhciB0bXBfMTEgPSBtMTIgKiBtMDM7XG4gIHZhciB0bXBfMTIgPSBtMjAgKiBtMzE7XG4gIHZhciB0bXBfMTMgPSBtMzAgKiBtMjE7XG4gIHZhciB0bXBfMTQgPSBtMTAgKiBtMzE7XG4gIHZhciB0bXBfMTUgPSBtMzAgKiBtMTE7XG4gIHZhciB0bXBfMTYgPSBtMTAgKiBtMjE7XG4gIHZhciB0bXBfMTcgPSBtMjAgKiBtMTE7XG4gIHZhciB0bXBfMTggPSBtMDAgKiBtMzE7XG4gIHZhciB0bXBfMTkgPSBtMzAgKiBtMDE7XG4gIHZhciB0bXBfMjAgPSBtMDAgKiBtMjE7XG4gIHZhciB0bXBfMjEgPSBtMjAgKiBtMDE7XG4gIHZhciB0bXBfMjIgPSBtMDAgKiBtMTE7XG4gIHZhciB0bXBfMjMgPSBtMTAgKiBtMDE7XG4gIHZhciB0MCA9IHRtcF8wICogbTExICsgdG1wXzMgKiBtMjEgKyB0bXBfNCAqIG0zMSAtICh0bXBfMSAqIG0xMSArIHRtcF8yICogbTIxICsgdG1wXzUgKiBtMzEpO1xuICB2YXIgdDEgPSB0bXBfMSAqIG0wMSArIHRtcF82ICogbTIxICsgdG1wXzkgKiBtMzEgLSAodG1wXzAgKiBtMDEgKyB0bXBfNyAqIG0yMSArIHRtcF84ICogbTMxKTtcbiAgdmFyIHQyID0gdG1wXzIgKiBtMDEgKyB0bXBfNyAqIG0xMSArIHRtcF8xMCAqIG0zMSAtICh0bXBfMyAqIG0wMSArIHRtcF82ICogbTExICsgdG1wXzExICogbTMxKTtcbiAgdmFyIHQzID0gdG1wXzUgKiBtMDEgKyB0bXBfOCAqIG0xMSArIHRtcF8xMSAqIG0yMSAtICh0bXBfNCAqIG0wMSArIHRtcF85ICogbTExICsgdG1wXzEwICogbTIxKTtcbiAgdmFyIGQgPSAxLjAgLyAobTAwICogdDAgKyBtMTAgKiB0MSArIG0yMCAqIHQyICsgbTMwICogdDMpO1xuICBkc3RbMF0gPSBkICogdDA7XG4gIGRzdFsxXSA9IGQgKiB0MTtcbiAgZHN0WzJdID0gZCAqIHQyO1xuICBkc3RbM10gPSBkICogdDM7XG4gIGRzdFs0XSA9IGQgKiAodG1wXzEgKiBtMTAgKyB0bXBfMiAqIG0yMCArIHRtcF81ICogbTMwIC0gKHRtcF8wICogbTEwICsgdG1wXzMgKiBtMjAgKyB0bXBfNCAqIG0zMCkpO1xuICBkc3RbNV0gPSBkICogKHRtcF8wICogbTAwICsgdG1wXzcgKiBtMjAgKyB0bXBfOCAqIG0zMCAtICh0bXBfMSAqIG0wMCArIHRtcF82ICogbTIwICsgdG1wXzkgKiBtMzApKTtcbiAgZHN0WzZdID0gZCAqICh0bXBfMyAqIG0wMCArIHRtcF82ICogbTEwICsgdG1wXzExICogbTMwIC0gKHRtcF8yICogbTAwICsgdG1wXzcgKiBtMTAgKyB0bXBfMTAgKiBtMzApKTtcbiAgZHN0WzddID0gZCAqICh0bXBfNCAqIG0wMCArIHRtcF85ICogbTEwICsgdG1wXzEwICogbTIwIC0gKHRtcF81ICogbTAwICsgdG1wXzggKiBtMTAgKyB0bXBfMTEgKiBtMjApKTtcbiAgZHN0WzhdID0gZCAqICh0bXBfMTIgKiBtMTMgKyB0bXBfMTUgKiBtMjMgKyB0bXBfMTYgKiBtMzMgLSAodG1wXzEzICogbTEzICsgdG1wXzE0ICogbTIzICsgdG1wXzE3ICogbTMzKSk7XG4gIGRzdFs5XSA9IGQgKiAodG1wXzEzICogbTAzICsgdG1wXzE4ICogbTIzICsgdG1wXzIxICogbTMzIC0gKHRtcF8xMiAqIG0wMyArIHRtcF8xOSAqIG0yMyArIHRtcF8yMCAqIG0zMykpO1xuICBkc3RbMTBdID0gZCAqICh0bXBfMTQgKiBtMDMgKyB0bXBfMTkgKiBtMTMgKyB0bXBfMjIgKiBtMzMgLSAodG1wXzE1ICogbTAzICsgdG1wXzE4ICogbTEzICsgdG1wXzIzICogbTMzKSk7XG4gIGRzdFsxMV0gPSBkICogKHRtcF8xNyAqIG0wMyArIHRtcF8yMCAqIG0xMyArIHRtcF8yMyAqIG0yMyAtICh0bXBfMTYgKiBtMDMgKyB0bXBfMjEgKiBtMTMgKyB0bXBfMjIgKiBtMjMpKTtcbiAgZHN0WzEyXSA9IGQgKiAodG1wXzE0ICogbTIyICsgdG1wXzE3ICogbTMyICsgdG1wXzEzICogbTEyIC0gKHRtcF8xNiAqIG0zMiArIHRtcF8xMiAqIG0xMiArIHRtcF8xNSAqIG0yMikpO1xuICBkc3RbMTNdID0gZCAqICh0bXBfMjAgKiBtMzIgKyB0bXBfMTIgKiBtMDIgKyB0bXBfMTkgKiBtMjIgLSAodG1wXzE4ICogbTIyICsgdG1wXzIxICogbTMyICsgdG1wXzEzICogbTAyKSk7XG4gIGRzdFsxNF0gPSBkICogKHRtcF8xOCAqIG0xMiArIHRtcF8yMyAqIG0zMiArIHRtcF8xNSAqIG0wMiAtICh0bXBfMjIgKiBtMzIgKyB0bXBfMTQgKiBtMDIgKyB0bXBfMTkgKiBtMTIpKTtcbiAgZHN0WzE1XSA9IGQgKiAodG1wXzIyICogbTIyICsgdG1wXzE2ICogbTAyICsgdG1wXzIxICogbTEyIC0gKHRtcF8yMCAqIG0xMiArIHRtcF8yMyAqIG0yMiArIHRtcF8xNyAqIG0wMikpO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byA0LWJ5LTQgbWF0cmljZXMgd2l0aCBhIG9uIHRoZSBsZWZ0IGFuZCBiIG9uIHRoZSByaWdodFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBhIFRoZSBtYXRyaXggb24gdGhlIGxlZnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IGIgVGhlIG1hdHJpeCBvbiB0aGUgcmlnaHQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBtYXRyaXggcHJvZHVjdCBvZiBhIGFuZCBiLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseShhLCBiLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzQgKyAwXTtcbiAgdmFyIGExMSA9IGFbNCArIDFdO1xuICB2YXIgYTEyID0gYVs0ICsgMl07XG4gIHZhciBhMTMgPSBhWzQgKyAzXTtcbiAgdmFyIGEyMCA9IGFbOCArIDBdO1xuICB2YXIgYTIxID0gYVs4ICsgMV07XG4gIHZhciBhMjIgPSBhWzggKyAyXTtcbiAgdmFyIGEyMyA9IGFbOCArIDNdO1xuICB2YXIgYTMwID0gYVsxMiArIDBdO1xuICB2YXIgYTMxID0gYVsxMiArIDFdO1xuICB2YXIgYTMyID0gYVsxMiArIDJdO1xuICB2YXIgYTMzID0gYVsxMiArIDNdO1xuICB2YXIgYjAwID0gYlswXTtcbiAgdmFyIGIwMSA9IGJbMV07XG4gIHZhciBiMDIgPSBiWzJdO1xuICB2YXIgYjAzID0gYlszXTtcbiAgdmFyIGIxMCA9IGJbNCArIDBdO1xuICB2YXIgYjExID0gYls0ICsgMV07XG4gIHZhciBiMTIgPSBiWzQgKyAyXTtcbiAgdmFyIGIxMyA9IGJbNCArIDNdO1xuICB2YXIgYjIwID0gYls4ICsgMF07XG4gIHZhciBiMjEgPSBiWzggKyAxXTtcbiAgdmFyIGIyMiA9IGJbOCArIDJdO1xuICB2YXIgYjIzID0gYls4ICsgM107XG4gIHZhciBiMzAgPSBiWzEyICsgMF07XG4gIHZhciBiMzEgPSBiWzEyICsgMV07XG4gIHZhciBiMzIgPSBiWzEyICsgMl07XG4gIHZhciBiMzMgPSBiWzEyICsgM107XG4gIGRzdFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMiArIGEzMCAqIGIwMztcbiAgZHN0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyICsgYTMxICogYjAzO1xuICBkc3RbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDIgKyBhMzIgKiBiMDM7XG4gIGRzdFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMiArIGEzMyAqIGIwMztcbiAgZHN0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyICsgYTMwICogYjEzO1xuICBkc3RbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTIgKyBhMzEgKiBiMTM7XG4gIGRzdFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMiArIGEzMiAqIGIxMztcbiAgZHN0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyICsgYTMzICogYjEzO1xuICBkc3RbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjIgKyBhMzAgKiBiMjM7XG4gIGRzdFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMiArIGEzMSAqIGIyMztcbiAgZHN0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMiArIGEzMiAqIGIyMztcbiAgZHN0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMiArIGEzMyAqIGIyMztcbiAgZHN0WzEyXSA9IGEwMCAqIGIzMCArIGExMCAqIGIzMSArIGEyMCAqIGIzMiArIGEzMCAqIGIzMztcbiAgZHN0WzEzXSA9IGEwMSAqIGIzMCArIGExMSAqIGIzMSArIGEyMSAqIGIzMiArIGEzMSAqIGIzMztcbiAgZHN0WzE0XSA9IGEwMiAqIGIzMCArIGExMiAqIGIzMSArIGEyMiAqIGIzMiArIGEzMiAqIGIzMztcbiAgZHN0WzE1XSA9IGEwMyAqIGIzMCArIGExMyAqIGIzMSArIGEyMyAqIGIzMiArIGEzMyAqIGIzMztcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogU2V0cyB0aGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIGEgNC1ieS00IG1hdHJpeCB0byB0aGUgZ2l2ZW5cbiAqIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gYSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IFRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBtYXRyaXggd2l0aCB0cmFuc2xhdGlvbiBzZXQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRyYW5zbGF0aW9uKGEsIHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgaWRlbnRpdHkoKTtcblxuICBpZiAoYSAhPT0gZHN0KSB7XG4gICAgZHN0WzBdID0gYVswXTtcbiAgICBkc3RbMV0gPSBhWzFdO1xuICAgIGRzdFsyXSA9IGFbMl07XG4gICAgZHN0WzNdID0gYVszXTtcbiAgICBkc3RbNF0gPSBhWzRdO1xuICAgIGRzdFs1XSA9IGFbNV07XG4gICAgZHN0WzZdID0gYVs2XTtcbiAgICBkc3RbN10gPSBhWzddO1xuICAgIGRzdFs4XSA9IGFbOF07XG4gICAgZHN0WzldID0gYVs5XTtcbiAgICBkc3RbMTBdID0gYVsxMF07XG4gICAgZHN0WzExXSA9IGFbMTFdO1xuICB9XG5cbiAgZHN0WzEyXSA9IHZbMF07XG4gIGRzdFsxM10gPSB2WzFdO1xuICBkc3RbMTRdID0gdlsyXTtcbiAgZHN0WzE1XSA9IDE7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiBhIDQtYnktNCBtYXRyaXggYXMgYSB2ZWN0b3Igd2l0aCAzXG4gKiBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnQgb2YgbS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24obSwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCB2My5jcmVhdGUoKTtcbiAgZHN0WzBdID0gbVsxMl07XG4gIGRzdFsxXSA9IG1bMTNdO1xuICBkc3RbMl0gPSBtWzE0XTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBheGlzIG9mIGEgNHg0IG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDMgZW50cmllc1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge251bWJlcn0gYXhpcyBUaGUgYXhpcyAwID0geCwgMSA9IHksIDIgPSB6O1xuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIGF4aXMgY29tcG9uZW50IG9mIG0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEF4aXMobSwgYXhpcywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCB2My5jcmVhdGUoKTtcbiAgdmFyIG9mZiA9IGF4aXMgKiA0O1xuICBkc3RbMF0gPSBtW29mZiArIDBdO1xuICBkc3RbMV0gPSBtW29mZiArIDFdO1xuICBkc3RbMl0gPSBtW29mZiArIDJdO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBTZXRzIGFuIGF4aXMgb2YgYSA0eDQgbWF0cml4IGFzIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiB0aGUgYXhpcyB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBheGlzIFRoZSBheGlzICAwID0geCwgMSA9IHksIDIgPSB6O1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBUaGUgbWF0cml4IHRvIHNldC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBtYXRyaXggd2l0aCBheGlzIHNldC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gc2V0QXhpcyhhLCB2LCBheGlzLCBkc3QpIHtcbiAgaWYgKGRzdCAhPT0gYSkge1xuICAgIGRzdCA9IGNvcHkoYSwgZHN0KTtcbiAgfVxuXG4gIHZhciBvZmYgPSBheGlzICogNDtcbiAgZHN0W29mZiArIDBdID0gdlswXTtcbiAgZHN0W29mZiArIDFdID0gdlsxXTtcbiAgZHN0W29mZiArIDJdID0gdlsyXTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgYSA0LWJ5LTQgcGVyc3BlY3RpdmUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGdpdmVuIHRoZSBhbmd1bGFyIGhlaWdodFxuICogb2YgdGhlIGZydXN0dW0sIHRoZSBhc3BlY3QgcmF0aW8sIGFuZCB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gIFRoZVxuICogYXJndW1lbnRzIGRlZmluZSBhIGZydXN0dW0gZXh0ZW5kaW5nIGluIHRoZSBuZWdhdGl2ZSB6IGRpcmVjdGlvbi4gIFRoZSBnaXZlblxuICogYW5nbGUgaXMgdGhlIHZlcnRpY2FsIGFuZ2xlIG9mIHRoZSBmcnVzdHVtLCBhbmQgdGhlIGhvcml6b250YWwgYW5nbGUgaXNcbiAqIGRldGVybWluZWQgdG8gcHJvZHVjZSB0aGUgZ2l2ZW4gYXNwZWN0IHJhdGlvLiAgVGhlIGFyZ3VtZW50cyBuZWFyIGFuZCBmYXIgYXJlXG4gKiB0aGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiAgTm90ZSB0aGF0IG5lYXIgYW5kIGZhclxuICogYXJlIG5vdCB6IGNvb3JkaW5hdGVzLCBidXQgcmF0aGVyIHRoZXkgYXJlIGRpc3RhbmNlcyBhbG9uZyB0aGUgbmVnYXRpdmVcbiAqIHotYXhpcy4gIFRoZSBtYXRyaXggZ2VuZXJhdGVkIHNlbmRzIHRoZSB2aWV3aW5nIGZydXN0dW0gdG8gdGhlIHVuaXQgYm94LlxuICogV2UgYXNzdW1lIGEgdW5pdCBib3ggZXh0ZW5kaW5nIGZyb20gLTEgdG8gMSBpbiB0aGUgeCBhbmQgeSBkaW1lbnNpb25zIGFuZFxuICogZnJvbSAwIHRvIDEgaW4gdGhlIHogZGltZW5zaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkT2ZWaWV3WUluUmFkaWFucyBUaGUgY2FtZXJhIGFuZ2xlIGZyb20gdG9wIHRvIGJvdHRvbSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IFRoZSBhc3BlY3QgcmF0aW8gd2lkdGggLyBoZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0gek5lYXIgVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gKiAgICAgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gekZhciBUaGUgZGVwdGggKG5lZ2F0aXZlIHogY29vcmRpbmF0ZSlcbiAqICAgICBvZiB0aGUgZmFyIGNsaXBwaW5nIHBsYW5lLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgcGVyc3BlY3RpdmUgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBwZXJzcGVjdGl2ZShmaWVsZE9mVmlld1lJblJhZGlhbnMsIGFzcGVjdCwgek5lYXIsIHpGYXIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICB2YXIgZiA9IE1hdGgudGFuKE1hdGguUEkgKiAwLjUgLSAwLjUgKiBmaWVsZE9mVmlld1lJblJhZGlhbnMpO1xuICB2YXIgcmFuZ2VJbnYgPSAxLjAgLyAoek5lYXIgLSB6RmFyKTtcbiAgZHN0WzBdID0gZiAvIGFzcGVjdDtcbiAgZHN0WzFdID0gMDtcbiAgZHN0WzJdID0gMDtcbiAgZHN0WzNdID0gMDtcbiAgZHN0WzRdID0gMDtcbiAgZHN0WzVdID0gZjtcbiAgZHN0WzZdID0gMDtcbiAgZHN0WzddID0gMDtcbiAgZHN0WzhdID0gMDtcbiAgZHN0WzldID0gMDtcbiAgZHN0WzEwXSA9ICh6TmVhciArIHpGYXIpICogcmFuZ2VJbnY7XG4gIGRzdFsxMV0gPSAtMTtcbiAgZHN0WzEyXSA9IDA7XG4gIGRzdFsxM10gPSAwO1xuICBkc3RbMTRdID0gek5lYXIgKiB6RmFyICogcmFuZ2VJbnYgKiAyO1xuICBkc3RbMTVdID0gMDtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgYSA0LWJ5LTQgb3J0aG9nb25hbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZ2l2ZW4gdGhlIGxlZnQsIHJpZ2h0LFxuICogYm90dG9tLCBhbmQgdG9wIGRpbWVuc2lvbnMgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgYXMgd2VsbCBhcyB0aGVcbiAqIG5lYXIgYW5kIGZhciBjbGlwcGluZyBwbGFuZSBkaXN0YW5jZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IHNpZGUgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgdmlld3BvcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgc2lkZSBvZiB0aGUgbmVhciBjbGlwcGluZyBwbGFuZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIHZpZXdwb3J0LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3Agb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgdmlld3BvcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBUaGUgZGVwdGggKG5lZ2F0aXZlIHogY29vcmRpbmF0ZSlcbiAqICAgICBvZiB0aGUgbmVhciBjbGlwcGluZyBwbGFuZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gKiAgICAgb2YgdGhlIGZhciBjbGlwcGluZyBwbGFuZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gT3V0cHV0IG1hdHJpeC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBwZXJzcGVjdGl2ZSBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIG9ydGhvKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgZHN0WzBdID0gMiAvIChyaWdodCAtIGxlZnQpO1xuICBkc3RbMV0gPSAwO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAwO1xuICBkc3RbNV0gPSAyIC8gKHRvcCAtIGJvdHRvbSk7XG4gIGRzdFs2XSA9IDA7XG4gIGRzdFs3XSA9IDA7XG4gIGRzdFs4XSA9IDA7XG4gIGRzdFs5XSA9IDA7XG4gIGRzdFsxMF0gPSAyIC8gKG5lYXIgLSBmYXIpO1xuICBkc3RbMTFdID0gMDtcbiAgZHN0WzEyXSA9IChyaWdodCArIGxlZnQpIC8gKGxlZnQgLSByaWdodCk7XG4gIGRzdFsxM10gPSAodG9wICsgYm90dG9tKSAvIChib3R0b20gLSB0b3ApO1xuICBkc3RbMTRdID0gKGZhciArIG5lYXIpIC8gKG5lYXIgLSBmYXIpO1xuICBkc3RbMTVdID0gMTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgYSA0LWJ5LTQgcGVyc3BlY3RpdmUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGdpdmVuIHRoZSBsZWZ0LCByaWdodCxcbiAqIHRvcCwgYm90dG9tLCBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiBUaGUgYXJndW1lbnRzIGRlZmluZSBhIGZydXN0dW1cbiAqIGV4dGVuZGluZyBpbiB0aGUgbmVnYXRpdmUgeiBkaXJlY3Rpb24uIFRoZSBhcmd1bWVudHMgbmVhciBhbmQgZmFyIGFyZSB0aGVcbiAqIGRpc3RhbmNlcyB0byB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gTm90ZSB0aGF0IG5lYXIgYW5kIGZhciBhcmUgbm90XG4gKiB6IGNvb3JkaW5hdGVzLCBidXQgcmF0aGVyIHRoZXkgYXJlIGRpc3RhbmNlcyBhbG9uZyB0aGUgbmVnYXRpdmUgei1heGlzLiBUaGVcbiAqIG1hdHJpeCBnZW5lcmF0ZWQgc2VuZHMgdGhlIHZpZXdpbmcgZnJ1c3R1bSB0byB0aGUgdW5pdCBib3guIFdlIGFzc3VtZSBhIHVuaXRcbiAqIGJveCBleHRlbmRpbmcgZnJvbSAtMSB0byAxIGluIHRoZSB4IGFuZCB5IGRpbWVuc2lvbnMgYW5kIGZyb20gMCB0byAxIGluIHRoZSB6XG4gKiBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHBsYW5lIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgcGxhbmUgb2YgdGhlIGJveC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIHBsYW5lIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IHBsYW5lIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBUaGUgbmVnYXRpdmUgeiBjb29yZGluYXRlIG9mIHRoZSBuZWFyIHBsYW5lIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIFRoZSBuZWdhdGl2ZSB6IGNvb3JkaW5hdGUgb2YgdGhlIGZhciBwbGFuZSBvZiB0aGUgYm94LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBPdXRwdXQgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBmcnVzdHVtKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIGR4ID0gcmlnaHQgLSBsZWZ0O1xuICB2YXIgZHkgPSB0b3AgLSBib3R0b207XG4gIHZhciBkeiA9IG5lYXIgLSBmYXI7XG4gIGRzdFswXSA9IDIgKiBuZWFyIC8gZHg7XG4gIGRzdFsxXSA9IDA7XG4gIGRzdFsyXSA9IDA7XG4gIGRzdFszXSA9IDA7XG4gIGRzdFs0XSA9IDA7XG4gIGRzdFs1XSA9IDIgKiBuZWFyIC8gZHk7XG4gIGRzdFs2XSA9IDA7XG4gIGRzdFs3XSA9IDA7XG4gIGRzdFs4XSA9IChsZWZ0ICsgcmlnaHQpIC8gZHg7XG4gIGRzdFs5XSA9ICh0b3AgKyBib3R0b20pIC8gZHk7XG4gIGRzdFsxMF0gPSBmYXIgLyBkejtcbiAgZHN0WzExXSA9IC0xO1xuICBkc3RbMTJdID0gMDtcbiAgZHN0WzEzXSA9IDA7XG4gIGRzdFsxNF0gPSBuZWFyICogZmFyIC8gZHo7XG4gIGRzdFsxNV0gPSAwO1xuICByZXR1cm4gZHN0O1xufVxuXG52YXIgeEF4aXM7XG52YXIgeUF4aXM7XG52YXIgekF4aXM7XG4vKipcbiAqIENvbXB1dGVzIGEgNC1ieS00IGxvb2stYXQgdHJhbnNmb3JtYXRpb24uXG4gKlxuICogVGhpcyBpcyBhIG1hdHJpeCB3aGljaCBwb3NpdGlvbnMgdGhlIGNhbWVyYSBpdHNlbGYuIElmIHlvdSB3YW50XG4gKiBhIHZpZXcgbWF0cml4IChhIG1hdHJpeCB3aGljaCBtb3ZlcyB0aGluZ3MgaW4gZnJvbnQgb2YgdGhlIGNhbWVyYSlcbiAqIHRha2UgdGhlIGludmVyc2Ugb2YgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGV5ZSBUaGUgcG9zaXRpb24gb2YgdGhlIGV5ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdGFyZ2V0IFRoZSBwb3NpdGlvbiBtZWFudCB0byBiZSB2aWV3ZWQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHVwIEEgdmVjdG9yIHBvaW50aW5nIHVwLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgbG9vay1hdCBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5mdW5jdGlvbiBsb29rQXQoZXllLCB0YXJnZXQsIHVwLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgeEF4aXMgPSB4QXhpcyB8fCB2My5jcmVhdGUoKTtcbiAgeUF4aXMgPSB5QXhpcyB8fCB2My5jcmVhdGUoKTtcbiAgekF4aXMgPSB6QXhpcyB8fCB2My5jcmVhdGUoKTtcbiAgdjMubm9ybWFsaXplKHYzLnN1YnRyYWN0KGV5ZSwgdGFyZ2V0LCB6QXhpcyksIHpBeGlzKTtcbiAgdjMubm9ybWFsaXplKHYzLmNyb3NzKHVwLCB6QXhpcywgeEF4aXMpLCB4QXhpcyk7XG4gIHYzLm5vcm1hbGl6ZSh2My5jcm9zcyh6QXhpcywgeEF4aXMsIHlBeGlzKSwgeUF4aXMpO1xuICBkc3RbMF0gPSB4QXhpc1swXTtcbiAgZHN0WzFdID0geEF4aXNbMV07XG4gIGRzdFsyXSA9IHhBeGlzWzJdO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSB5QXhpc1swXTtcbiAgZHN0WzVdID0geUF4aXNbMV07XG4gIGRzdFs2XSA9IHlBeGlzWzJdO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSB6QXhpc1swXTtcbiAgZHN0WzldID0gekF4aXNbMV07XG4gIGRzdFsxMF0gPSB6QXhpc1syXTtcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSBleWVbMF07XG4gIGRzdFsxM10gPSBleWVbMV07XG4gIGRzdFsxNF0gPSBleWVbMl07XG4gIGRzdFsxNV0gPSAxO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCB0cmFuc2xhdGVzIGJ5IHRoZSBnaXZlbiB2ZWN0b3Igdi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgdmVjdG9yIGJ5XG4gKiAgICAgd2hpY2ggdG8gdHJhbnNsYXRlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgdHJhbnNsYXRpb24gbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2xhdGlvbih2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgZHN0WzBdID0gMTtcbiAgZHN0WzFdID0gMDtcbiAgZHN0WzJdID0gMDtcbiAgZHN0WzNdID0gMDtcbiAgZHN0WzRdID0gMDtcbiAgZHN0WzVdID0gMTtcbiAgZHN0WzZdID0gMDtcbiAgZHN0WzddID0gMDtcbiAgZHN0WzhdID0gMDtcbiAgZHN0WzldID0gMDtcbiAgZHN0WzEwXSA9IDE7XG4gIGRzdFsxMV0gPSAwO1xuICBkc3RbMTJdID0gdlswXTtcbiAgZHN0WzEzXSA9IHZbMV07XG4gIGRzdFsxNF0gPSB2WzJdO1xuICBkc3RbMTVdID0gMTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogVHJhbnNsYXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBieSB0aGUgZ2l2ZW4gdmVjdG9yIHYuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgdmVjdG9yIGJ5XG4gKiAgICAgd2hpY2ggdG8gdHJhbnNsYXRlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgdHJhbnNsYXRlZCBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShtLCB2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIHYwID0gdlswXTtcbiAgdmFyIHYxID0gdlsxXTtcbiAgdmFyIHYyID0gdlsyXTtcbiAgdmFyIG0wMCA9IG1bMF07XG4gIHZhciBtMDEgPSBtWzFdO1xuICB2YXIgbTAyID0gbVsyXTtcbiAgdmFyIG0wMyA9IG1bM107XG4gIHZhciBtMTAgPSBtWzEgKiA0ICsgMF07XG4gIHZhciBtMTEgPSBtWzEgKiA0ICsgMV07XG4gIHZhciBtMTIgPSBtWzEgKiA0ICsgMl07XG4gIHZhciBtMTMgPSBtWzEgKiA0ICsgM107XG4gIHZhciBtMjAgPSBtWzIgKiA0ICsgMF07XG4gIHZhciBtMjEgPSBtWzIgKiA0ICsgMV07XG4gIHZhciBtMjIgPSBtWzIgKiA0ICsgMl07XG4gIHZhciBtMjMgPSBtWzIgKiA0ICsgM107XG4gIHZhciBtMzAgPSBtWzMgKiA0ICsgMF07XG4gIHZhciBtMzEgPSBtWzMgKiA0ICsgMV07XG4gIHZhciBtMzIgPSBtWzMgKiA0ICsgMl07XG4gIHZhciBtMzMgPSBtWzMgKiA0ICsgM107XG5cbiAgaWYgKG0gIT09IGRzdCkge1xuICAgIGRzdFswXSA9IG0wMDtcbiAgICBkc3RbMV0gPSBtMDE7XG4gICAgZHN0WzJdID0gbTAyO1xuICAgIGRzdFszXSA9IG0wMztcbiAgICBkc3RbNF0gPSBtMTA7XG4gICAgZHN0WzVdID0gbTExO1xuICAgIGRzdFs2XSA9IG0xMjtcbiAgICBkc3RbN10gPSBtMTM7XG4gICAgZHN0WzhdID0gbTIwO1xuICAgIGRzdFs5XSA9IG0yMTtcbiAgICBkc3RbMTBdID0gbTIyO1xuICAgIGRzdFsxMV0gPSBtMjM7XG4gIH1cblxuICBkc3RbMTJdID0gbTAwICogdjAgKyBtMTAgKiB2MSArIG0yMCAqIHYyICsgbTMwO1xuICBkc3RbMTNdID0gbTAxICogdjAgKyBtMTEgKiB2MSArIG0yMSAqIHYyICsgbTMxO1xuICBkc3RbMTRdID0gbTAyICogdjAgKyBtMTIgKiB2MSArIG0yMiAqIHYyICsgbTMyO1xuICBkc3RbMTVdID0gbTAzICogdjAgKyBtMTMgKiB2MSArIG0yMyAqIHYyICsgbTMzO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgeC1heGlzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHJvdGF0aW9uIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRpb25YKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIHZhciBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICBkc3RbMF0gPSAxO1xuICBkc3RbMV0gPSAwO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAwO1xuICBkc3RbNV0gPSBjO1xuICBkc3RbNl0gPSBzO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSAwO1xuICBkc3RbOV0gPSAtcztcbiAgZHN0WzEwXSA9IGM7XG4gIGRzdFsxMV0gPSAwO1xuICBkc3RbMTJdID0gMDtcbiAgZHN0WzEzXSA9IDA7XG4gIGRzdFsxNF0gPSAwO1xuICBkc3RbMTVdID0gMTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogUm90YXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBhcm91bmQgdGhlIHgtYXhpcyBieSB0aGUgZ2l2ZW5cbiAqIGFuZ2xlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSByb3RhdGVkIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWChtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIHZhciBtMTAgPSBtWzRdO1xuICB2YXIgbTExID0gbVs1XTtcbiAgdmFyIG0xMiA9IG1bNl07XG4gIHZhciBtMTMgPSBtWzddO1xuICB2YXIgbTIwID0gbVs4XTtcbiAgdmFyIG0yMSA9IG1bOV07XG4gIHZhciBtMjIgPSBtWzEwXTtcbiAgdmFyIG0yMyA9IG1bMTFdO1xuICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gIGRzdFs0XSA9IGMgKiBtMTAgKyBzICogbTIwO1xuICBkc3RbNV0gPSBjICogbTExICsgcyAqIG0yMTtcbiAgZHN0WzZdID0gYyAqIG0xMiArIHMgKiBtMjI7XG4gIGRzdFs3XSA9IGMgKiBtMTMgKyBzICogbTIzO1xuICBkc3RbOF0gPSBjICogbTIwIC0gcyAqIG0xMDtcbiAgZHN0WzldID0gYyAqIG0yMSAtIHMgKiBtMTE7XG4gIGRzdFsxMF0gPSBjICogbTIyIC0gcyAqIG0xMjtcbiAgZHN0WzExXSA9IGMgKiBtMjMgLSBzICogbTEzO1xuXG4gIGlmIChtICE9PSBkc3QpIHtcbiAgICBkc3RbMF0gPSBtWzBdO1xuICAgIGRzdFsxXSA9IG1bMV07XG4gICAgZHN0WzJdID0gbVsyXTtcbiAgICBkc3RbM10gPSBtWzNdO1xuICAgIGRzdFsxMl0gPSBtWzEyXTtcbiAgICBkc3RbMTNdID0gbVsxM107XG4gICAgZHN0WzE0XSA9IG1bMTRdO1xuICAgIGRzdFsxNV0gPSBtWzE1XTtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYXJvdW5kIHRoZSB5LWF4aXMgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgcm90YXRpb24gbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGlvblkoYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gIGRzdFswXSA9IGM7XG4gIGRzdFsxXSA9IDA7XG4gIGRzdFsyXSA9IC1zO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAwO1xuICBkc3RbNV0gPSAxO1xuICBkc3RbNl0gPSAwO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSBzO1xuICBkc3RbOV0gPSAwO1xuICBkc3RbMTBdID0gYztcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSAwO1xuICBkc3RbMTNdID0gMDtcbiAgZHN0WzE0XSA9IDA7XG4gIGRzdFsxNV0gPSAxO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBSb3RhdGVzIHRoZSBnaXZlbiA0LWJ5LTQgbWF0cml4IGFyb3VuZCB0aGUgeS1heGlzIGJ5IHRoZSBnaXZlblxuICogYW5nbGUuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHJvdGF0ZWQgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVZKG0sIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIG0wMCA9IG1bMCAqIDQgKyAwXTtcbiAgdmFyIG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgdmFyIG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgdmFyIG0wMyA9IG1bMCAqIDQgKyAzXTtcbiAgdmFyIG0yMCA9IG1bMiAqIDQgKyAwXTtcbiAgdmFyIG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgdmFyIG0yMiA9IG1bMiAqIDQgKyAyXTtcbiAgdmFyIG0yMyA9IG1bMiAqIDQgKyAzXTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIHZhciBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICBkc3RbMF0gPSBjICogbTAwIC0gcyAqIG0yMDtcbiAgZHN0WzFdID0gYyAqIG0wMSAtIHMgKiBtMjE7XG4gIGRzdFsyXSA9IGMgKiBtMDIgLSBzICogbTIyO1xuICBkc3RbM10gPSBjICogbTAzIC0gcyAqIG0yMztcbiAgZHN0WzhdID0gYyAqIG0yMCArIHMgKiBtMDA7XG4gIGRzdFs5XSA9IGMgKiBtMjEgKyBzICogbTAxO1xuICBkc3RbMTBdID0gYyAqIG0yMiArIHMgKiBtMDI7XG4gIGRzdFsxMV0gPSBjICogbTIzICsgcyAqIG0wMztcblxuICBpZiAobSAhPT0gZHN0KSB7XG4gICAgZHN0WzRdID0gbVs0XTtcbiAgICBkc3RbNV0gPSBtWzVdO1xuICAgIGRzdFs2XSA9IG1bNl07XG4gICAgZHN0WzddID0gbVs3XTtcbiAgICBkc3RbMTJdID0gbVsxMl07XG4gICAgZHN0WzEzXSA9IG1bMTNdO1xuICAgIGRzdFsxNF0gPSBtWzE0XTtcbiAgICBkc3RbMTVdID0gbVsxNV07XG4gIH1cblxuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgei1heGlzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHJvdGF0aW9uIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRpb25aKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIHZhciBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICBkc3RbMF0gPSBjO1xuICBkc3RbMV0gPSBzO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAtcztcbiAgZHN0WzVdID0gYztcbiAgZHN0WzZdID0gMDtcbiAgZHN0WzddID0gMDtcbiAgZHN0WzhdID0gMDtcbiAgZHN0WzldID0gMDtcbiAgZHN0WzEwXSA9IDE7XG4gIGRzdFsxMV0gPSAwO1xuICBkc3RbMTJdID0gMDtcbiAgZHN0WzEzXSA9IDA7XG4gIGRzdFsxNF0gPSAwO1xuICBkc3RbMTVdID0gMTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogUm90YXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBhcm91bmQgdGhlIHotYXhpcyBieSB0aGUgZ2l2ZW5cbiAqIGFuZ2xlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSByb3RhdGVkIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWihtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIHZhciBtMDAgPSBtWzAgKiA0ICsgMF07XG4gIHZhciBtMDEgPSBtWzAgKiA0ICsgMV07XG4gIHZhciBtMDIgPSBtWzAgKiA0ICsgMl07XG4gIHZhciBtMDMgPSBtWzAgKiA0ICsgM107XG4gIHZhciBtMTAgPSBtWzEgKiA0ICsgMF07XG4gIHZhciBtMTEgPSBtWzEgKiA0ICsgMV07XG4gIHZhciBtMTIgPSBtWzEgKiA0ICsgMl07XG4gIHZhciBtMTMgPSBtWzEgKiA0ICsgM107XG4gIHZhciBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgZHN0WzBdID0gYyAqIG0wMCArIHMgKiBtMTA7XG4gIGRzdFsxXSA9IGMgKiBtMDEgKyBzICogbTExO1xuICBkc3RbMl0gPSBjICogbTAyICsgcyAqIG0xMjtcbiAgZHN0WzNdID0gYyAqIG0wMyArIHMgKiBtMTM7XG4gIGRzdFs0XSA9IGMgKiBtMTAgLSBzICogbTAwO1xuICBkc3RbNV0gPSBjICogbTExIC0gcyAqIG0wMTtcbiAgZHN0WzZdID0gYyAqIG0xMiAtIHMgKiBtMDI7XG4gIGRzdFs3XSA9IGMgKiBtMTMgLSBzICogbTAzO1xuXG4gIGlmIChtICE9PSBkc3QpIHtcbiAgICBkc3RbOF0gPSBtWzhdO1xuICAgIGRzdFs5XSA9IG1bOV07XG4gICAgZHN0WzEwXSA9IG1bMTBdO1xuICAgIGRzdFsxMV0gPSBtWzExXTtcbiAgICBkc3RbMTJdID0gbVsxMl07XG4gICAgZHN0WzEzXSA9IG1bMTNdO1xuICAgIGRzdFsxNF0gPSBtWzE0XTtcbiAgICBkc3RbMTVdID0gbVsxNV07XG4gIH1cblxuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpcyBieSB0aGUgZ2l2ZW5cbiAqIGFuZ2xlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBheGlzIFRoZSBheGlzXG4gKiAgICAgYWJvdXQgd2hpY2ggdG8gcm90YXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBBIG1hdHJpeCB3aGljaCByb3RhdGVzIGFuZ2xlIHJhZGlhbnNcbiAqICAgICBhcm91bmQgdGhlIGF4aXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIGF4aXNSb3RhdGlvbihheGlzLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIHZhciB4ID0gYXhpc1swXTtcbiAgdmFyIHkgPSBheGlzWzFdO1xuICB2YXIgeiA9IGF4aXNbMl07XG4gIHZhciBuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIHggLz0gbjtcbiAgeSAvPSBuO1xuICB6IC89IG47XG4gIHZhciB4eCA9IHggKiB4O1xuICB2YXIgeXkgPSB5ICogeTtcbiAgdmFyIHp6ID0geiAqIHo7XG4gIHZhciBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgdmFyIG9uZU1pbnVzQ29zaW5lID0gMSAtIGM7XG4gIGRzdFswXSA9IHh4ICsgKDEgLSB4eCkgKiBjO1xuICBkc3RbMV0gPSB4ICogeSAqIG9uZU1pbnVzQ29zaW5lICsgeiAqIHM7XG4gIGRzdFsyXSA9IHggKiB6ICogb25lTWludXNDb3NpbmUgLSB5ICogcztcbiAgZHN0WzNdID0gMDtcbiAgZHN0WzRdID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSAtIHogKiBzO1xuICBkc3RbNV0gPSB5eSArICgxIC0geXkpICogYztcbiAgZHN0WzZdID0geSAqIHogKiBvbmVNaW51c0Nvc2luZSArIHggKiBzO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lICsgeSAqIHM7XG4gIGRzdFs5XSA9IHkgKiB6ICogb25lTWludXNDb3NpbmUgLSB4ICogcztcbiAgZHN0WzEwXSA9IHp6ICsgKDEgLSB6eikgKiBjO1xuICBkc3RbMTFdID0gMDtcbiAgZHN0WzEyXSA9IDA7XG4gIGRzdFsxM10gPSAwO1xuICBkc3RbMTRdID0gMDtcbiAgZHN0WzE1XSA9IDE7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFJvdGF0ZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggYXJvdW5kIHRoZSBnaXZlbiBheGlzIGJ5IHRoZVxuICogZ2l2ZW4gYW5nbGUuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYXhpcyBUaGUgYXhpc1xuICogICAgIGFib3V0IHdoaWNoIHRvIHJvdGF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHJvdGF0ZWQgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBheGlzUm90YXRlKG0sIGF4aXMsIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIHggPSBheGlzWzBdO1xuICB2YXIgeSA9IGF4aXNbMV07XG4gIHZhciB6ID0gYXhpc1syXTtcbiAgdmFyIG4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgeCAvPSBuO1xuICB5IC89IG47XG4gIHogLz0gbjtcbiAgdmFyIHh4ID0geCAqIHg7XG4gIHZhciB5eSA9IHkgKiB5O1xuICB2YXIgenogPSB6ICogejtcbiAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIHZhciBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICB2YXIgb25lTWludXNDb3NpbmUgPSAxIC0gYztcbiAgdmFyIHIwMCA9IHh4ICsgKDEgLSB4eCkgKiBjO1xuICB2YXIgcjAxID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSArIHogKiBzO1xuICB2YXIgcjAyID0geCAqIHogKiBvbmVNaW51c0Nvc2luZSAtIHkgKiBzO1xuICB2YXIgcjEwID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSAtIHogKiBzO1xuICB2YXIgcjExID0geXkgKyAoMSAtIHl5KSAqIGM7XG4gIHZhciByMTIgPSB5ICogeiAqIG9uZU1pbnVzQ29zaW5lICsgeCAqIHM7XG4gIHZhciByMjAgPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lICsgeSAqIHM7XG4gIHZhciByMjEgPSB5ICogeiAqIG9uZU1pbnVzQ29zaW5lIC0geCAqIHM7XG4gIHZhciByMjIgPSB6eiArICgxIC0genopICogYztcbiAgdmFyIG0wMCA9IG1bMF07XG4gIHZhciBtMDEgPSBtWzFdO1xuICB2YXIgbTAyID0gbVsyXTtcbiAgdmFyIG0wMyA9IG1bM107XG4gIHZhciBtMTAgPSBtWzRdO1xuICB2YXIgbTExID0gbVs1XTtcbiAgdmFyIG0xMiA9IG1bNl07XG4gIHZhciBtMTMgPSBtWzddO1xuICB2YXIgbTIwID0gbVs4XTtcbiAgdmFyIG0yMSA9IG1bOV07XG4gIHZhciBtMjIgPSBtWzEwXTtcbiAgdmFyIG0yMyA9IG1bMTFdO1xuICBkc3RbMF0gPSByMDAgKiBtMDAgKyByMDEgKiBtMTAgKyByMDIgKiBtMjA7XG4gIGRzdFsxXSA9IHIwMCAqIG0wMSArIHIwMSAqIG0xMSArIHIwMiAqIG0yMTtcbiAgZHN0WzJdID0gcjAwICogbTAyICsgcjAxICogbTEyICsgcjAyICogbTIyO1xuICBkc3RbM10gPSByMDAgKiBtMDMgKyByMDEgKiBtMTMgKyByMDIgKiBtMjM7XG4gIGRzdFs0XSA9IHIxMCAqIG0wMCArIHIxMSAqIG0xMCArIHIxMiAqIG0yMDtcbiAgZHN0WzVdID0gcjEwICogbTAxICsgcjExICogbTExICsgcjEyICogbTIxO1xuICBkc3RbNl0gPSByMTAgKiBtMDIgKyByMTEgKiBtMTIgKyByMTIgKiBtMjI7XG4gIGRzdFs3XSA9IHIxMCAqIG0wMyArIHIxMSAqIG0xMyArIHIxMiAqIG0yMztcbiAgZHN0WzhdID0gcjIwICogbTAwICsgcjIxICogbTEwICsgcjIyICogbTIwO1xuICBkc3RbOV0gPSByMjAgKiBtMDEgKyByMjEgKiBtMTEgKyByMjIgKiBtMjE7XG4gIGRzdFsxMF0gPSByMjAgKiBtMDIgKyByMjEgKiBtMTIgKyByMjIgKiBtMjI7XG4gIGRzdFsxMV0gPSByMjAgKiBtMDMgKyByMjEgKiBtMTMgKyByMjIgKiBtMjM7XG5cbiAgaWYgKG0gIT09IGRzdCkge1xuICAgIGRzdFsxMl0gPSBtWzEyXTtcbiAgICBkc3RbMTNdID0gbVsxM107XG4gICAgZHN0WzE0XSA9IG1bMTRdO1xuICAgIGRzdFsxNV0gPSBtWzE1XTtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHNjYWxlcyBpbiBlYWNoIGRpbWVuc2lvbiBieSBhbiBhbW91bnQgZ2l2ZW4gYnlcbiAqIHRoZSBjb3JyZXNwb25kaW5nIGVudHJ5IGluIHRoZSBnaXZlbiB2ZWN0b3I7IGFzc3VtZXMgdGhlIHZlY3RvciBoYXMgdGhyZWVcbiAqIGVudHJpZXMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgQSB2ZWN0b3Igb2ZcbiAqICAgICB0aHJlZSBlbnRyaWVzIHNwZWNpZnlpbmcgdGhlIGZhY3RvciBieSB3aGljaCB0byBzY2FsZSBpbiBlYWNoIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHNjYWxpbmcgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsaW5nKHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICBkc3RbMF0gPSB2WzBdO1xuICBkc3RbMV0gPSAwO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAwO1xuICBkc3RbNV0gPSB2WzFdO1xuICBkc3RbNl0gPSAwO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSAwO1xuICBkc3RbOV0gPSAwO1xuICBkc3RbMTBdID0gdlsyXTtcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSAwO1xuICBkc3RbMTNdID0gMDtcbiAgZHN0WzE0XSA9IDA7XG4gIGRzdFsxNV0gPSAxO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBTY2FsZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggaW4gZWFjaCBkaW1lbnNpb24gYnkgYW4gYW1vdW50XG4gKiBnaXZlbiBieSB0aGUgY29ycmVzcG9uZGluZyBlbnRyeSBpbiB0aGUgZ2l2ZW4gdmVjdG9yOyBhc3N1bWVzIHRoZSB2ZWN0b3IgaGFzXG4gKiB0aHJlZSBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXggdG8gYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgQSB2ZWN0b3Igb2YgdGhyZWUgZW50cmllcyBzcGVjaWZ5aW5nIHRoZVxuICogICAgIGZhY3RvciBieSB3aGljaCB0byBzY2FsZSBpbiBlYWNoIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHNjYWxlZCBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG0sIHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICB2YXIgdjAgPSB2WzBdO1xuICB2YXIgdjEgPSB2WzFdO1xuICB2YXIgdjIgPSB2WzJdO1xuICBkc3RbMF0gPSB2MCAqIG1bMCAqIDQgKyAwXTtcbiAgZHN0WzFdID0gdjAgKiBtWzAgKiA0ICsgMV07XG4gIGRzdFsyXSA9IHYwICogbVswICogNCArIDJdO1xuICBkc3RbM10gPSB2MCAqIG1bMCAqIDQgKyAzXTtcbiAgZHN0WzRdID0gdjEgKiBtWzEgKiA0ICsgMF07XG4gIGRzdFs1XSA9IHYxICogbVsxICogNCArIDFdO1xuICBkc3RbNl0gPSB2MSAqIG1bMSAqIDQgKyAyXTtcbiAgZHN0WzddID0gdjEgKiBtWzEgKiA0ICsgM107XG4gIGRzdFs4XSA9IHYyICogbVsyICogNCArIDBdO1xuICBkc3RbOV0gPSB2MiAqIG1bMiAqIDQgKyAxXTtcbiAgZHN0WzEwXSA9IHYyICogbVsyICogNCArIDJdO1xuICBkc3RbMTFdID0gdjIgKiBtWzIgKiA0ICsgM107XG5cbiAgaWYgKG0gIT09IGRzdCkge1xuICAgIGRzdFsxMl0gPSBtWzEyXTtcbiAgICBkc3RbMTNdID0gbVsxM107XG4gICAgZHN0WzE0XSA9IG1bMTRdO1xuICAgIGRzdFsxNV0gPSBtWzE1XTtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFRha2VzIGEgNC1ieS00IG1hdHJpeCBhbmQgYSB2ZWN0b3Igd2l0aCAzIGVudHJpZXMsXG4gKiBpbnRlcnByZXRzIHRoZSB2ZWN0b3IgYXMgYSBwb2ludCwgdHJhbnNmb3JtcyB0aGF0IHBvaW50IGJ5IHRoZSBtYXRyaXgsIGFuZFxuICogcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIHBvaW50LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSBvcHRpb25hbCB2ZWMzIHRvIHN0b3JlIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSB0cmFuc2Zvcm1lZCBwb2ludC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnQobSwgdiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCB2My5jcmVhdGUoKTtcbiAgdmFyIHYwID0gdlswXTtcbiAgdmFyIHYxID0gdlsxXTtcbiAgdmFyIHYyID0gdlsyXTtcbiAgdmFyIGQgPSB2MCAqIG1bMCAqIDQgKyAzXSArIHYxICogbVsxICogNCArIDNdICsgdjIgKiBtWzIgKiA0ICsgM10gKyBtWzMgKiA0ICsgM107XG4gIGRzdFswXSA9ICh2MCAqIG1bMCAqIDQgKyAwXSArIHYxICogbVsxICogNCArIDBdICsgdjIgKiBtWzIgKiA0ICsgMF0gKyBtWzMgKiA0ICsgMF0pIC8gZDtcbiAgZHN0WzFdID0gKHYwICogbVswICogNCArIDFdICsgdjEgKiBtWzEgKiA0ICsgMV0gKyB2MiAqIG1bMiAqIDQgKyAxXSArIG1bMyAqIDQgKyAxXSkgLyBkO1xuICBkc3RbMl0gPSAodjAgKiBtWzAgKiA0ICsgMl0gKyB2MSAqIG1bMSAqIDQgKyAyXSArIHYyICogbVsyICogNCArIDJdICsgbVszICogNCArIDJdKSAvIGQ7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFRha2VzIGEgNC1ieS00IG1hdHJpeCBhbmQgYSB2ZWN0b3Igd2l0aCAzIGVudHJpZXMsIGludGVycHJldHMgdGhlIHZlY3RvciBhcyBhXG4gKiBkaXJlY3Rpb24sIHRyYW5zZm9ybXMgdGhhdCBkaXJlY3Rpb24gYnkgdGhlIG1hdHJpeCwgYW5kIHJldHVybnMgdGhlIHJlc3VsdDtcbiAqIGFzc3VtZXMgdGhlIHRyYW5zZm9ybWF0aW9uIG9mIDMtZGltZW5zaW9uYWwgc3BhY2UgcmVwcmVzZW50ZWQgYnkgdGhlIG1hdHJpeFxuICogaXMgcGFyYWxsZWwtcHJlc2VydmluZywgaS5lLiBhbnkgY29tYmluYXRpb24gb2Ygcm90YXRpb24sIHNjYWxpbmcgYW5kXG4gKiB0cmFuc2xhdGlvbiwgYnV0IG5vdCBhIHBlcnNwZWN0aXZlIGRpc3RvcnRpb24uIFJldHVybnMgYSB2ZWN0b3Igd2l0aCAzXG4gKiBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIGRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gb3B0aW9uYWwgVmVjMyB0byBzdG9yZSByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBUaGUgdHJhbnNmb3JtZWQgZGlyZWN0aW9uLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1EaXJlY3Rpb24obSwgdiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCB2My5jcmVhdGUoKTtcbiAgdmFyIHYwID0gdlswXTtcbiAgdmFyIHYxID0gdlsxXTtcbiAgdmFyIHYyID0gdlsyXTtcbiAgZHN0WzBdID0gdjAgKiBtWzAgKiA0ICsgMF0gKyB2MSAqIG1bMSAqIDQgKyAwXSArIHYyICogbVsyICogNCArIDBdO1xuICBkc3RbMV0gPSB2MCAqIG1bMCAqIDQgKyAxXSArIHYxICogbVsxICogNCArIDFdICsgdjIgKiBtWzIgKiA0ICsgMV07XG4gIGRzdFsyXSA9IHYwICogbVswICogNCArIDJdICsgdjEgKiBtWzEgKiA0ICsgMl0gKyB2MiAqIG1bMiAqIDQgKyAyXTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogVGFrZXMgYSA0LWJ5LTQgbWF0cml4IG0gYW5kIGEgdmVjdG9yIHYgd2l0aCAzIGVudHJpZXMsIGludGVycHJldHMgdGhlIHZlY3RvclxuICogYXMgYSBub3JtYWwgdG8gYSBzdXJmYWNlLCBhbmQgY29tcHV0ZXMgYSB2ZWN0b3Igd2hpY2ggaXMgbm9ybWFsIHVwb25cbiAqIHRyYW5zZm9ybWluZyB0aGF0IHN1cmZhY2UgYnkgdGhlIG1hdHJpeC4gVGhlIGVmZmVjdCBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRoZVxuICogc2FtZSBhcyB0cmFuc2Zvcm1pbmcgdiAoYXMgYSBkaXJlY3Rpb24pIGJ5IHRoZSBpbnZlcnNlLXRyYW5zcG9zZSBvZiBtLiAgVGhpc1xuICogZnVuY3Rpb24gYXNzdW1lcyB0aGUgdHJhbnNmb3JtYXRpb24gb2YgMy1kaW1lbnNpb25hbCBzcGFjZSByZXByZXNlbnRlZCBieSB0aGVcbiAqIG1hdHJpeCBpcyBwYXJhbGxlbC1wcmVzZXJ2aW5nLCBpLmUuIGFueSBjb21iaW5hdGlvbiBvZiByb3RhdGlvbiwgc2NhbGluZyBhbmRcbiAqIHRyYW5zbGF0aW9uLCBidXQgbm90IGEgcGVyc3BlY3RpdmUgZGlzdG9ydGlvbi4gIFJldHVybnMgYSB2ZWN0b3Igd2l0aCAzXG4gKiBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIG5vcm1hbC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gVGhlIGRpcmVjdGlvbi4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSB0cmFuc2Zvcm1lZCBub3JtYWwuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vcm1hbChtLCB2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IHYzLmNyZWF0ZSgpO1xuICB2YXIgbWkgPSBpbnZlcnNlKG0pO1xuICB2YXIgdjAgPSB2WzBdO1xuICB2YXIgdjEgPSB2WzFdO1xuICB2YXIgdjIgPSB2WzJdO1xuICBkc3RbMF0gPSB2MCAqIG1pWzAgKiA0ICsgMF0gKyB2MSAqIG1pWzAgKiA0ICsgMV0gKyB2MiAqIG1pWzAgKiA0ICsgMl07XG4gIGRzdFsxXSA9IHYwICogbWlbMSAqIDQgKyAwXSArIHYxICogbWlbMSAqIDQgKyAxXSArIHYyICogbWlbMSAqIDQgKyAyXTtcbiAgZHN0WzJdID0gdjAgKiBtaVsyICogNCArIDBdICsgdjEgKiBtaVsyICogNCArIDFdICsgdjIgKiBtaVsyICogNCArIDJdO1xuICByZXR1cm4gZHN0O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9wcmltaXRpdmVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcHJpbWl0aXZlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlM0RGVmVydGljZXMgPSBjcmVhdGUzREZWZXJ0aWNlcztcbmV4cG9ydHMuY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXk7XG5leHBvcnRzLmNyZWF0ZUN1YmVWZXJ0aWNlcyA9IGNyZWF0ZUN1YmVWZXJ0aWNlcztcbmV4cG9ydHMuY3JlYXRlUGxhbmVWZXJ0aWNlcyA9IGNyZWF0ZVBsYW5lVmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZVNwaGVyZVZlcnRpY2VzID0gY3JlYXRlU3BoZXJlVmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZVRydW5jYXRlZENvbmVWZXJ0aWNlcyA9IGNyZWF0ZVRydW5jYXRlZENvbmVWZXJ0aWNlcztcbmV4cG9ydHMuY3JlYXRlWFlRdWFkVmVydGljZXMgPSBjcmVhdGVYWVF1YWRWZXJ0aWNlcztcbmV4cG9ydHMuY3JlYXRlQ3Jlc2NlbnRWZXJ0aWNlcyA9IGNyZWF0ZUNyZXNjZW50VmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZUN5bGluZGVyVmVydGljZXMgPSBjcmVhdGVDeWxpbmRlclZlcnRpY2VzO1xuZXhwb3J0cy5jcmVhdGVUb3J1c1ZlcnRpY2VzID0gY3JlYXRlVG9ydXNWZXJ0aWNlcztcbmV4cG9ydHMuY3JlYXRlRGlzY1ZlcnRpY2VzID0gY3JlYXRlRGlzY1ZlcnRpY2VzO1xuZXhwb3J0cy5kZWluZGV4VmVydGljZXMgPSBkZWluZGV4VmVydGljZXM7XG5leHBvcnRzLmZsYXR0ZW5Ob3JtYWxzID0gZmxhdHRlbk5vcm1hbHM7XG5leHBvcnRzLm1ha2VSYW5kb21WZXJ0ZXhDb2xvcnMgPSBtYWtlUmFuZG9tVmVydGV4Q29sb3JzO1xuZXhwb3J0cy5yZW9yaWVudERpcmVjdGlvbnMgPSByZW9yaWVudERpcmVjdGlvbnM7XG5leHBvcnRzLnJlb3JpZW50Tm9ybWFscyA9IHJlb3JpZW50Tm9ybWFscztcbmV4cG9ydHMucmVvcmllbnRQb3NpdGlvbnMgPSByZW9yaWVudFBvc2l0aW9ucztcbmV4cG9ydHMucmVvcmllbnRWZXJ0aWNlcyA9IHJlb3JpZW50VmVydGljZXM7XG5leHBvcnRzLmNvbmNhdFZlcnRpY2VzID0gY29uY2F0VmVydGljZXM7XG5leHBvcnRzLmR1cGxpY2F0ZVZlcnRpY2VzID0gZHVwbGljYXRlVmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZURpc2NCdWZmZXJzID0gZXhwb3J0cy5jcmVhdGVEaXNjQnVmZmVySW5mbyA9IGV4cG9ydHMuY3JlYXRlVG9ydXNCdWZmZXJzID0gZXhwb3J0cy5jcmVhdGVUb3J1c0J1ZmZlckluZm8gPSBleHBvcnRzLmNyZWF0ZUN5bGluZGVyQnVmZmVycyA9IGV4cG9ydHMuY3JlYXRlQ3lsaW5kZXJCdWZmZXJJbmZvID0gZXhwb3J0cy5jcmVhdGVDcmVzY2VudEJ1ZmZlcnMgPSBleHBvcnRzLmNyZWF0ZUNyZXNjZW50QnVmZmVySW5mbyA9IGV4cG9ydHMuY3JlYXRlQ3Jlc2VudFZlcnRpY2VzID0gZXhwb3J0cy5jcmVhdGVDcmVzZW50QnVmZmVycyA9IGV4cG9ydHMuY3JlYXRlQ3Jlc2VudEJ1ZmZlckluZm8gPSBleHBvcnRzLmNyZWF0ZVhZUXVhZEJ1ZmZlcnMgPSBleHBvcnRzLmNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8gPSBleHBvcnRzLmNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJzID0gZXhwb3J0cy5jcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVySW5mbyA9IGV4cG9ydHMuY3JlYXRlU3BoZXJlQnVmZmVycyA9IGV4cG9ydHMuY3JlYXRlU3BoZXJlQnVmZmVySW5mbyA9IGV4cG9ydHMuY3JlYXRlUGxhbmVCdWZmZXJzID0gZXhwb3J0cy5jcmVhdGVQbGFuZUJ1ZmZlckluZm8gPSBleHBvcnRzLmNyZWF0ZUN1YmVCdWZmZXJzID0gZXhwb3J0cy5jcmVhdGVDdWJlQnVmZmVySW5mbyA9IGV4cG9ydHMuY3JlYXRlM0RGQnVmZmVycyA9IGV4cG9ydHMuY3JlYXRlM0RGQnVmZmVySW5mbyA9IHZvaWQgMDtcblxudmFyIGF0dHJpYnV0ZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2F0dHJpYnV0ZXMuanMgKi8gXCIuL3NyYy9hdHRyaWJ1dGVzLmpzXCIpKTtcblxudmFyIGhlbHBlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGVscGVyLmpzICovIFwiLi9zcmMvaGVscGVyLmpzXCIpKTtcblxudmFyIHR5cGVkQXJyYXlzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90eXBlZGFycmF5cy5qcyAqLyBcIi4vc3JjL3R5cGVkYXJyYXlzLmpzXCIpKTtcblxudmFyIG00ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tNC5qcyAqLyBcIi4vc3JjL200LmpzXCIpKTtcblxudmFyIHYzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92My5qcyAqLyBcIi4vc3JjL3YzLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIFZhcmlvdXMgZnVuY3Rpb25zIHRvIG1ha2Ugc2ltcGxlIHByaW1pdGl2ZXNcbiAqXG4gKiBub3RlOiBNb3N0IHByaW1pdGl2ZSBmdW5jdGlvbnMgY29tZSBpbiAzIHN0eWxlc1xuICpcbiAqICogIGBjcmVhdGVTb21lU2hhcGVCdWZmZXJJbmZvYFxuICpcbiAqICAgIFRoZXNlIGZ1bmN0aW9ucyBhcmUgYWxtb3N0IGFsd2F5cyB0aGUgZnVuY3Rpb25zIHlvdSB3YW50IHRvIGNhbGwuIFRoZXlcbiAqICAgIGNyZWF0ZSB2ZXJ0aWNlcyB0aGVuIG1ha2UgV2ViR0xCdWZmZXJzIGFuZCBjcmVhdGUge0BsaW5rIG1vZHVsZTp0d2dsLkF0dHJpYkluZm99c1xuICogICAgcmV0dXJuaW5nIGEge0BsaW5rIG1vZHVsZTp0d2dsLkJ1ZmZlckluZm99IHlvdSBjYW4gcGFzcyB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXN9XG4gKiAgICBhbmQge0BsaW5rIG1vZHVsZTp0d2dsLmRyYXdCdWZmZXJJbmZvfSBldGMuLi5cbiAqXG4gKiAqICBgY3JlYXRlU29tZVNoYXBlQnVmZmVyc2BcbiAqXG4gKiAgICBUaGVzZSBjcmVhdGUgV2ViR0xCdWZmZXJzIGFuZCBwdXQgeW91ciBkYXRhIGluIHRoZW0gYnV0IG5vdGhpbmcgZWxzZS5cbiAqICAgIEl0J3MgYSBzaG9ydGN1dCB0byBkb2luZyBpdCB5b3Vyc2VsZiBpZiB5b3UgZG9uJ3Qgd2FudCB0byB1c2VcbiAqICAgIHRoZSBoaWdoZXIgbGV2ZWwgZnVuY3Rpb25zLlxuICpcbiAqICogIGBjcmVhdGVTb21lU2hhcGVWZXJ0aWNlc2BcbiAqXG4gKiAgICBUaGVzZSBqdXN0IGNyZWF0ZSB2ZXJ0aWNlcywgbm8gYnVmZmVycy4gVGhpcyBhbGxvd3MgeW91IHRvIG1hbmlwdWxhdGUgdGhlIHZlcnRpY2VzXG4gKiAgICBvciBhZGQgbW9yZSBkYXRhIGJlZm9yZSBnZW5lcmF0aW5nIGEge0BsaW5rIG1vZHVsZTp0d2dsLkJ1ZmZlckluZm99LiBPbmNlIHlvdSdyZSBmaW5pc2hlZFxuICogICAgbWFuaXB1bGF0aW5nIHRoZSB2ZXJ0aWNlcyBjYWxsIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5c30uXG4gKlxuICogICAgZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgY29uc3QgYXJyYXlzID0gdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVBsYW5lQXJyYXlzKDEpO1xuICogICAgICAgIHR3Z2wucHJpbWl0aXZlcy5yZW9yaWVudFZlcnRpY2VzKGFycmF5cywgbTQucm90YXRpb25YKE1hdGguUEkgKiAwLjUpKTtcbiAqICAgICAgICBjb25zdCBidWZmZXJJbmZvID0gdHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwgYXJyYXlzKTtcbiAqXG4gKiBAbW9kdWxlIHR3Z2wvcHJpbWl0aXZlc1xuICovXG52YXIgZ2V0QXJyYXkgPSBhdHRyaWJ1dGVzLmdldEFycmF5XzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG52YXIgZ2V0TnVtQ29tcG9uZW50cyA9IGF0dHJpYnV0ZXMuZ2V0TnVtQ29tcG9uZW50c187IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBAdHlwZWRlZiB7KEludDhBcnJheXxVaW50OEFycmF5fEludDE2QXJyYXl8VWludDE2QXJyYXl8SW50MzJBcnJheXxVaW50MzJBcnJheXxGbG9hdDMyQXJyYXkpfSBUeXBlZEFycmF5XG4gKi9cblxuLyoqXG4gKiBBZGQgYHB1c2hgIHRvIGEgdHlwZWQgYXJyYXkuIEl0IGp1c3Qga2VlcHMgYSAnY3Vyc29yJ1xuICogYW5kIGFsbG93cyB1c2UgdG8gYHB1c2hgIHZhbHVlcyBpbnRvIHRoZSBhcnJheSBzbyB3ZVxuICogZG9uJ3QgaGF2ZSB0byBtYW51YWxseSBjb21wdXRlIG9mZnNldHNcbiAqIEBwYXJhbSB7VHlwZWRBcnJheX0gdHlwZWRBcnJheSBUeXBlZEFycmF5IHRvIGF1Z21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1Db21wb25lbnRzIG51bWJlciBvZiBjb21wb25lbnRzLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhdWdtZW50VHlwZWRBcnJheSh0eXBlZEFycmF5LCBudW1Db21wb25lbnRzKSB7XG4gIHZhciBjdXJzb3IgPSAwO1xuXG4gIHR5cGVkQXJyYXkucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpaSkge1xuICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzW2lpXTtcblxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgfHwgdHlwZWRBcnJheXMuaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgZm9yICh2YXIgamogPSAwOyBqaiA8IHZhbHVlLmxlbmd0aDsgKytqaikge1xuICAgICAgICAgIHR5cGVkQXJyYXlbY3Vyc29yKytdID0gdmFsdWVbampdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlZEFycmF5W2N1cnNvcisrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0eXBlZEFycmF5LnJlc2V0ID0gZnVuY3Rpb24gKG9wdF9pbmRleCkge1xuICAgIGN1cnNvciA9IG9wdF9pbmRleCB8fCAwO1xuICB9O1xuXG4gIHR5cGVkQXJyYXkubnVtQ29tcG9uZW50cyA9IG51bUNvbXBvbmVudHM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlZEFycmF5LCAnbnVtRWxlbWVudHMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggLyB0aGlzLm51bUNvbXBvbmVudHMgfCAwO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0eXBlZEFycmF5O1xufVxuLyoqXG4gKiBjcmVhdGVzIGEgdHlwZWQgYXJyYXkgd2l0aCBhIGBwdXNoYCBmdW5jdGlvbiBhdHRhY2hlZFxuICogc28gdGhhdCB5b3UgY2FuIGVhc2lseSAqcHVzaCogdmFsdWVzLlxuICpcbiAqIGBwdXNoYCBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMuIElmIGFuIGFyZ3VtZW50IGlzIGFuIGFycmF5IGVhY2ggZWxlbWVudFxuICogb2YgdGhlIGFycmF5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHR5cGVkIGFycmF5LlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGFycmF5ID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCAyKTsgIC8vIGNyZWF0ZXMgYSBGbG9hdDMyQXJyYXkgd2l0aCA2IHZhbHVlc1xuICogICAgIGFycmF5LnB1c2goMSwgMiwgMyk7XG4gKiAgICAgYXJyYXkucHVzaChbNCwgNSwgNl0pO1xuICogICAgIC8vIGFycmF5IG5vdyBjb250YWlucyBbMSwgMiwgMywgNCwgNSwgNl1cbiAqXG4gKiBBbHNvIGhhcyBgbnVtQ29tcG9uZW50c2AgYW5kIGBudW1FbGVtZW50c2AgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtQ29tcG9uZW50cyBudW1iZXIgb2YgY29tcG9uZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG51bUVsZW1lbnRzIG51bWJlciBvZiBlbGVtZW50cy4gVGhlIHRvdGFsIHNpemUgb2YgdGhlIGFycmF5IHdpbGwgYmUgYG51bUNvbXBvbmVudHMgKiBudW1FbGVtZW50c2AuXG4gKiBAcGFyYW0ge2NvbnN0cnVjdG9yfSBvcHRfdHlwZSBBIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZS4gRGVmYXVsdCA9IGBGbG9hdDMyQXJyYXlgLlxuICogQHJldHVybiB7QXJyYXlCdWZmZXJWaWV3fSBBIHR5cGVkIGFycmF5LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkobnVtQ29tcG9uZW50cywgbnVtRWxlbWVudHMsIG9wdF90eXBlKSB7XG4gIHZhciBUeXBlID0gb3B0X3R5cGUgfHwgRmxvYXQzMkFycmF5O1xuICByZXR1cm4gYXVnbWVudFR5cGVkQXJyYXkobmV3IFR5cGUobnVtQ29tcG9uZW50cyAqIG51bUVsZW1lbnRzKSwgbnVtQ29tcG9uZW50cyk7XG59XG5cbmZ1bmN0aW9uIGFsbEJ1dEluZGljZXMobmFtZSkge1xuICByZXR1cm4gbmFtZSAhPT0gXCJpbmRpY2VzXCI7XG59XG4vKipcbiAqIEdpdmVuIGluZGV4ZWQgdmVydGljZXMgY3JlYXRlcyBhIG5ldyBzZXQgb2YgdmVydGljZXMgdW4taW5kZXhlZCBieSBleHBhbmRpbmcgdGhlIGluZGV4ZWQgdmVydGljZXMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gdmVydGljZXMgVGhlIGluZGV4ZWQgdmVydGljZXMgdG8gZGVpbmRleFxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgZGVpbmRleGVkIHZlcnRpY2VzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gZGVpbmRleFZlcnRpY2VzKHZlcnRpY2VzKSB7XG4gIHZhciBpbmRpY2VzID0gdmVydGljZXMuaW5kaWNlcztcbiAgdmFyIG5ld1ZlcnRpY2VzID0ge307XG4gIHZhciBudW1FbGVtZW50cyA9IGluZGljZXMubGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGV4cGFuZFRvVW5pbmRleGVkKGNoYW5uZWwpIHtcbiAgICB2YXIgc3JjQnVmZmVyID0gdmVydGljZXNbY2hhbm5lbF07XG4gICAgdmFyIG51bUNvbXBvbmVudHMgPSBzcmNCdWZmZXIubnVtQ29tcG9uZW50cztcbiAgICB2YXIgZHN0QnVmZmVyID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheShudW1Db21wb25lbnRzLCBudW1FbGVtZW50cywgc3JjQnVmZmVyLmNvbnN0cnVjdG9yKTtcblxuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1FbGVtZW50czsgKytpaSkge1xuICAgICAgdmFyIG5keCA9IGluZGljZXNbaWldO1xuICAgICAgdmFyIG9mZnNldCA9IG5keCAqIG51bUNvbXBvbmVudHM7XG5cbiAgICAgIGZvciAodmFyIGpqID0gMDsgamogPCBudW1Db21wb25lbnRzOyArK2pqKSB7XG4gICAgICAgIGRzdEJ1ZmZlci5wdXNoKHNyY0J1ZmZlcltvZmZzZXQgKyBqal0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5ld1ZlcnRpY2VzW2NoYW5uZWxdID0gZHN0QnVmZmVyO1xuICB9XG5cbiAgT2JqZWN0LmtleXModmVydGljZXMpLmZpbHRlcihhbGxCdXRJbmRpY2VzKS5mb3JFYWNoKGV4cGFuZFRvVW5pbmRleGVkKTtcbiAgcmV0dXJuIG5ld1ZlcnRpY2VzO1xufVxuLyoqXG4gKiBmbGF0dGVucyB0aGUgbm9ybWFscyBvZiBkZWluZGV4ZWQgdmVydGljZXMgaW4gcGxhY2UuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gdmVydGljZXMgVGhlIGRlaW5kZXhlZCB2ZXJ0aWNlcyB3aG8ncyBub3JtYWxzIHRvIGZsYXR0ZW5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGZsYXR0ZW5lZCB2ZXJ0aWNlcyAoc2FtZSBhcyB3YXMgcGFzc2VkIGluKVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGZsYXR0ZW5Ob3JtYWxzKHZlcnRpY2VzKSB7XG4gIGlmICh2ZXJ0aWNlcy5pbmRpY2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW4gbm90IGZsYXR0ZW4gbm9ybWFscyBvZiBpbmRleGVkIHZlcnRpY2VzLiBkZWluZGV4IHRoZW0gZmlyc3QnKTtcbiAgfVxuXG4gIHZhciBub3JtYWxzID0gdmVydGljZXMubm9ybWFsO1xuICB2YXIgbnVtTm9ybWFscyA9IG5vcm1hbHMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1Ob3JtYWxzOyBpaSArPSA5KSB7XG4gICAgLy8gcHVsbCBvdXQgdGhlIDMgbm9ybWFscyBmb3IgdGhpcyB0cmlhbmdsZVxuICAgIHZhciBuYXggPSBub3JtYWxzW2lpICsgMF07XG4gICAgdmFyIG5heSA9IG5vcm1hbHNbaWkgKyAxXTtcbiAgICB2YXIgbmF6ID0gbm9ybWFsc1tpaSArIDJdO1xuICAgIHZhciBuYnggPSBub3JtYWxzW2lpICsgM107XG4gICAgdmFyIG5ieSA9IG5vcm1hbHNbaWkgKyA0XTtcbiAgICB2YXIgbmJ6ID0gbm9ybWFsc1tpaSArIDVdO1xuICAgIHZhciBuY3ggPSBub3JtYWxzW2lpICsgNl07XG4gICAgdmFyIG5jeSA9IG5vcm1hbHNbaWkgKyA3XTtcbiAgICB2YXIgbmN6ID0gbm9ybWFsc1tpaSArIDhdOyAvLyBhZGQgdGhlbVxuXG4gICAgdmFyIG54ID0gbmF4ICsgbmJ4ICsgbmN4O1xuICAgIHZhciBueSA9IG5heSArIG5ieSArIG5jeTtcbiAgICB2YXIgbnogPSBuYXogKyBuYnogKyBuY3o7IC8vIG5vcm1hbGl6ZSB0aGVtXG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KG54ICogbnggKyBueSAqIG55ICsgbnogKiBueik7XG4gICAgbnggLz0gbGVuZ3RoO1xuICAgIG55IC89IGxlbmd0aDtcbiAgICBueiAvPSBsZW5ndGg7IC8vIGNvcHkgdGhlbSBiYWNrIGluXG5cbiAgICBub3JtYWxzW2lpICsgMF0gPSBueDtcbiAgICBub3JtYWxzW2lpICsgMV0gPSBueTtcbiAgICBub3JtYWxzW2lpICsgMl0gPSBuejtcbiAgICBub3JtYWxzW2lpICsgM10gPSBueDtcbiAgICBub3JtYWxzW2lpICsgNF0gPSBueTtcbiAgICBub3JtYWxzW2lpICsgNV0gPSBuejtcbiAgICBub3JtYWxzW2lpICsgNl0gPSBueDtcbiAgICBub3JtYWxzW2lpICsgN10gPSBueTtcbiAgICBub3JtYWxzW2lpICsgOF0gPSBuejtcbiAgfVxuXG4gIHJldHVybiB2ZXJ0aWNlcztcbn1cblxuZnVuY3Rpb24gYXBwbHlGdW5jVG9WM0FycmF5KGFycmF5LCBtYXRyaXgsIGZuKSB7XG4gIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gIHZhciB0bXAgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW47IGlpICs9IDMpIHtcbiAgICBmbihtYXRyaXgsIFthcnJheVtpaV0sIGFycmF5W2lpICsgMV0sIGFycmF5W2lpICsgMl1dLCB0bXApO1xuICAgIGFycmF5W2lpXSA9IHRtcFswXTtcbiAgICBhcnJheVtpaSArIDFdID0gdG1wWzFdO1xuICAgIGFycmF5W2lpICsgMl0gPSB0bXBbMl07XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9ybWFsKG1pLCB2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IHYzLmNyZWF0ZSgpO1xuICB2YXIgdjAgPSB2WzBdO1xuICB2YXIgdjEgPSB2WzFdO1xuICB2YXIgdjIgPSB2WzJdO1xuICBkc3RbMF0gPSB2MCAqIG1pWzAgKiA0ICsgMF0gKyB2MSAqIG1pWzAgKiA0ICsgMV0gKyB2MiAqIG1pWzAgKiA0ICsgMl07XG4gIGRzdFsxXSA9IHYwICogbWlbMSAqIDQgKyAwXSArIHYxICogbWlbMSAqIDQgKyAxXSArIHYyICogbWlbMSAqIDQgKyAyXTtcbiAgZHN0WzJdID0gdjAgKiBtaVsyICogNCArIDBdICsgdjEgKiBtaVsyICogNCArIDFdICsgdjIgKiBtaVsyICogNCArIDJdO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBSZW9yaWVudHMgZGlyZWN0aW9ucyBieSB0aGUgZ2l2ZW4gbWF0cml4Li5cbiAqIEBwYXJhbSB7KG51bWJlcltdfFR5cGVkQXJyYXkpfSBhcnJheSBUaGUgYXJyYXkuIEFzc3VtZXMgdmFsdWUgZmxvYXRzIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtYXRyaXggQSBtYXRyaXggdG8gbXVsdGlwbHkgYnkuXG4gKiBAcmV0dXJuIHsobnVtYmVyW118VHlwZWRBcnJheSl9IHRoZSBzYW1lIGFycmF5IHRoYXQgd2FzIHBhc3NlZCBpblxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlb3JpZW50RGlyZWN0aW9ucyhhcnJheSwgbWF0cml4KSB7XG4gIGFwcGx5RnVuY1RvVjNBcnJheShhcnJheSwgbWF0cml4LCBtNC50cmFuc2Zvcm1EaXJlY3Rpb24pO1xuICByZXR1cm4gYXJyYXk7XG59XG4vKipcbiAqIFJlb3JpZW50cyBub3JtYWxzIGJ5IHRoZSBpbnZlcnNlLXRyYW5zcG9zZSBvZiB0aGUgZ2l2ZW5cbiAqIG1hdHJpeC4uXG4gKiBAcGFyYW0geyhudW1iZXJbXXxUeXBlZEFycmF5KX0gYXJyYXkgVGhlIGFycmF5LiBBc3N1bWVzIHZhbHVlIGZsb2F0cyBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbWF0cml4IEEgbWF0cml4IHRvIG11bHRpcGx5IGJ5LlxuICogQHJldHVybiB7KG51bWJlcltdfFR5cGVkQXJyYXkpfSB0aGUgc2FtZSBhcnJheSB0aGF0IHdhcyBwYXNzZWQgaW5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuXG5mdW5jdGlvbiByZW9yaWVudE5vcm1hbHMoYXJyYXksIG1hdHJpeCkge1xuICBhcHBseUZ1bmNUb1YzQXJyYXkoYXJyYXksIG00LmludmVyc2UobWF0cml4KSwgdHJhbnNmb3JtTm9ybWFsKTtcbiAgcmV0dXJuIGFycmF5O1xufVxuLyoqXG4gKiBSZW9yaWVudHMgcG9zaXRpb25zIGJ5IHRoZSBnaXZlbiBtYXRyaXguIEluIG90aGVyIHdvcmRzLCBpdFxuICogbXVsdGlwbGllcyBlYWNoIHZlcnRleCBieSB0aGUgZ2l2ZW4gbWF0cml4LlxuICogQHBhcmFtIHsobnVtYmVyW118VHlwZWRBcnJheSl9IGFycmF5IFRoZSBhcnJheS4gQXNzdW1lcyB2YWx1ZSBmbG9hdHMgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG1hdHJpeCBBIG1hdHJpeCB0byBtdWx0aXBseSBieS5cbiAqIEByZXR1cm4geyhudW1iZXJbXXxUeXBlZEFycmF5KX0gdGhlIHNhbWUgYXJyYXkgdGhhdCB3YXMgcGFzc2VkIGluXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gcmVvcmllbnRQb3NpdGlvbnMoYXJyYXksIG1hdHJpeCkge1xuICBhcHBseUZ1bmNUb1YzQXJyYXkoYXJyYXksIG1hdHJpeCwgbTQudHJhbnNmb3JtUG9pbnQpO1xuICByZXR1cm4gYXJyYXk7XG59XG4vKipcbiAqIEB0eXBlZGVmIHsobnVtYmVyW118VHlwZWRBcnJheSl9IE5hdGl2ZUFycmF5T3JUeXBlZEFycmF5XG4gKi9cblxuLyoqXG4gKiBSZW9yaWVudHMgYXJyYXlzIGJ5IHRoZSBnaXZlbiBtYXRyaXguIEFzc3VtZXMgYXJyYXlzIGhhdmVcbiAqIG5hbWVzIHRoYXQgY29udGFpbnMgJ3BvcycgY291bGQgYmUgcmVvcmllbnRlZCBhcyBwb3NpdGlvbnMsXG4gKiAnYmlub3JtJyBvciAndGFuJyBhcyBkaXJlY3Rpb25zLCBhbmQgJ25vcm0nIGFzIG5vcm1hbHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgTmF0aXZlQXJyYXlPclR5cGVkQXJyYXk+fSBhcnJheXMgVGhlIHZlcnRpY2VzIHRvIHJlb3JpZW50XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG1hdHJpeCBtYXRyaXggdG8gcmVvcmllbnQgYnkuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgTmF0aXZlQXJyYXlPclR5cGVkQXJyYXk+fSBzYW1lIGFycmF5cyB0aGF0IHdlcmUgcGFzc2VkIGluLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlb3JpZW50VmVydGljZXMoYXJyYXlzLCBtYXRyaXgpIHtcbiAgT2JqZWN0LmtleXMoYXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGFycmF5ID0gYXJyYXlzW25hbWVdO1xuXG4gICAgaWYgKG5hbWUuaW5kZXhPZihcInBvc1wiKSA+PSAwKSB7XG4gICAgICByZW9yaWVudFBvc2l0aW9ucyhhcnJheSwgbWF0cml4KTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuaW5kZXhPZihcInRhblwiKSA+PSAwIHx8IG5hbWUuaW5kZXhPZihcImJpbm9ybVwiKSA+PSAwKSB7XG4gICAgICByZW9yaWVudERpcmVjdGlvbnMoYXJyYXksIG1hdHJpeCk7XG4gICAgfSBlbHNlIGlmIChuYW1lLmluZGV4T2YoXCJub3JtXCIpID49IDApIHtcbiAgICAgIHJlb3JpZW50Tm9ybWFscyhhcnJheSwgbWF0cml4KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXJyYXlzO1xufVxuLyoqXG4gKiBDcmVhdGVzIFhZIHF1YWQgQnVmZmVySW5mb1xuICpcbiAqIFRoZSBkZWZhdWx0IHdpdGggbm8gcGFyYW1ldGVycyB3aWxsIHJldHVybiBhIDJ4MiBxdWFkIHdpdGggdmFsdWVzIGZyb20gLTEgdG8gKzEuXG4gKiBJZiB5b3Ugd2FudCBhIHVuaXQgcXVhZCB3aXRoIHRoYXQgZ29lcyBmcm9tIDAgdG8gMSB5b3UnZCBjYWxsIGl0IHdpdGhcbiAqXG4gKiAgICAgdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8oZ2wsIDEsIDAuNSwgMC41KTtcbiAqXG4gKiBJZiB5b3Ugd2FudCBhIHVuaXQgcXVhZCBjZW50ZXJlZCBhYm92ZSAwLDAgeW91J2QgY2FsbCBpdCB3aXRoXG4gKlxuICogICAgIHR3Z2wucHJpbWl0aXZlcy5jcmVhdGVYWVF1YWRCdWZmZXJJbmZvKGdsLCAxLCAwLCAwLjUpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXSB0aGUgc2l6ZSBhY3Jvc3MgdGhlIHF1YWQuIERlZmF1bHRzIHRvIDIgd2hpY2ggbWVhbnMgdmVydGljZXMgd2lsbCBnbyBmcm9tIC0xIHRvICsxXG4gKiBAcGFyYW0ge251bWJlcn0gW3hPZmZzZXRdIHRoZSBhbW91bnQgdG8gb2Zmc2V0IHRoZSBxdWFkIGluIFhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeU9mZnNldF0gdGhlIGFtb3VudCB0byBvZmZzZXQgdGhlIHF1YWQgaW4gWVxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFdlYkdMQnVmZmVyPn0gdGhlIGNyZWF0ZWQgWFkgUXVhZCBCdWZmZXJJbmZvXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVhZUXVhZEJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgWFkgcXVhZCBCdWZmZXJzXG4gKlxuICogVGhlIGRlZmF1bHQgd2l0aCBubyBwYXJhbWV0ZXJzIHdpbGwgcmV0dXJuIGEgMngyIHF1YWQgd2l0aCB2YWx1ZXMgZnJvbSAtMSB0byArMS5cbiAqIElmIHlvdSB3YW50IGEgdW5pdCBxdWFkIHdpdGggdGhhdCBnb2VzIGZyb20gMCB0byAxIHlvdSdkIGNhbGwgaXQgd2l0aFxuICpcbiAqICAgICB0d2dsLnByaW1pdGl2ZXMuY3JlYXRlWFlRdWFkQnVmZmVySW5mbyhnbCwgMSwgMC41LCAwLjUpO1xuICpcbiAqIElmIHlvdSB3YW50IGEgdW5pdCBxdWFkIGNlbnRlcmVkIGFib3ZlIDAsMCB5b3UnZCBjYWxsIGl0IHdpdGhcbiAqXG4gKiAgICAgdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8oZ2wsIDEsIDAsIDAuNSk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemVdIHRoZSBzaXplIGFjcm9zcyB0aGUgcXVhZC4gRGVmYXVsdHMgdG8gMiB3aGljaCBtZWFucyB2ZXJ0aWNlcyB3aWxsIGdvIGZyb20gLTEgdG8gKzFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeE9mZnNldF0gdGhlIGFtb3VudCB0byBvZmZzZXQgdGhlIHF1YWQgaW4gWFxuICogQHBhcmFtIHtudW1iZXJ9IFt5T2Zmc2V0XSB0aGUgYW1vdW50IHRvIG9mZnNldCB0aGUgcXVhZCBpbiBZXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSB0aGUgY3JlYXRlZCBYWSBRdWFkIGJ1ZmZlcnNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlWFlRdWFkQnVmZmVySW5mb1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBYWSBxdWFkIHZlcnRpY2VzXG4gKlxuICogVGhlIGRlZmF1bHQgd2l0aCBubyBwYXJhbWV0ZXJzIHdpbGwgcmV0dXJuIGEgMngyIHF1YWQgd2l0aCB2YWx1ZXMgZnJvbSAtMSB0byArMS5cbiAqIElmIHlvdSB3YW50IGEgdW5pdCBxdWFkIHdpdGggdGhhdCBnb2VzIGZyb20gMCB0byAxIHlvdSdkIGNhbGwgaXQgd2l0aFxuICpcbiAqICAgICB0d2dsLnByaW1pdGl2ZXMuY3JlYXRlWFlRdWFkVmVydGljZXMoMSwgMC41LCAwLjUpO1xuICpcbiAqIElmIHlvdSB3YW50IGEgdW5pdCBxdWFkIGNlbnRlcmVkIGFib3ZlIDAsMCB5b3UnZCBjYWxsIGl0IHdpdGhcbiAqXG4gKiAgICAgdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVhZUXVhZFZlcnRpY2VzKDEsIDAsIDAuNSk7XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXSB0aGUgc2l6ZSBhY3Jvc3MgdGhlIHF1YWQuIERlZmF1bHRzIHRvIDIgd2hpY2ggbWVhbnMgdmVydGljZXMgd2lsbCBnbyBmcm9tIC0xIHRvICsxXG4gKiBAcGFyYW0ge251bWJlcn0gW3hPZmZzZXRdIHRoZSBhbW91bnQgdG8gb2Zmc2V0IHRoZSBxdWFkIGluIFhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeU9mZnNldF0gdGhlIGFtb3VudCB0byBvZmZzZXQgdGhlIHF1YWQgaW4gWVxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSB0aGUgY3JlYXRlZCBYWSBRdWFkIHZlcnRpY2VzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlWFlRdWFkVmVydGljZXMoc2l6ZSwgeE9mZnNldCwgeU9mZnNldCkge1xuICBzaXplID0gc2l6ZSB8fCAyO1xuICB4T2Zmc2V0ID0geE9mZnNldCB8fCAwO1xuICB5T2Zmc2V0ID0geU9mZnNldCB8fCAwO1xuICBzaXplICo9IDAuNTtcbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjoge1xuICAgICAgbnVtQ29tcG9uZW50czogMixcbiAgICAgIGRhdGE6IFt4T2Zmc2V0ICsgLTEgKiBzaXplLCB5T2Zmc2V0ICsgLTEgKiBzaXplLCB4T2Zmc2V0ICsgMSAqIHNpemUsIHlPZmZzZXQgKyAtMSAqIHNpemUsIHhPZmZzZXQgKyAtMSAqIHNpemUsIHlPZmZzZXQgKyAxICogc2l6ZSwgeE9mZnNldCArIDEgKiBzaXplLCB5T2Zmc2V0ICsgMSAqIHNpemVdXG4gICAgfSxcbiAgICBub3JtYWw6IFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSxcbiAgICB0ZXhjb29yZDogWzAsIDAsIDEsIDAsIDAsIDEsIDEsIDFdLFxuICAgIGluZGljZXM6IFswLCAxLCAyLCAyLCAxLCAzXVxuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIFhaIHBsYW5lIEJ1ZmZlckluZm8uXG4gKlxuICogVGhlIGNyZWF0ZWQgcGxhbmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSBXaWR0aCBvZiB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoXSBEZXB0aCBvZiB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3N1YmRpdmlzaW9uc1dpZHRoXSBOdW1iZXIgb2Ygc3RlcHMgYWNyb3NzIHRoZSBwbGFuZS4gRGVmYXVsdCA9IDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3ViZGl2aXNpb25zRGVwdGhdIE51bWJlciBvZiBzdGVwcyBkb3duIHRoZSBwbGFuZS4gRGVmYXVsdCA9IDFcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW21hdHJpeF0gQSBtYXRyaXggYnkgd2hpY2ggdG8gbXVsdGlwbHkgYWxsIHRoZSB2ZXJ0aWNlcy5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIHBsYW5lIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVBsYW5lQnVmZmVySW5mb1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBYWiBwbGFuZSBidWZmZXJzLlxuICpcbiAqIFRoZSBjcmVhdGVkIHBsYW5lIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCBhbmQgdGV4Y29vcmQgZGF0YVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gV2lkdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aF0gRGVwdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtzdWJkaXZpc2lvbnNXaWR0aF0gTnVtYmVyIG9mIHN0ZXBzIGFjcm9zcyB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3N1YmRpdmlzaW9uc0RlcHRoXSBOdW1iZXIgb2Ygc3RlcHMgZG93biB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFttYXRyaXhdIEEgbWF0cml4IGJ5IHdoaWNoIHRvIG11bHRpcGx5IGFsbCB0aGUgdmVydGljZXMuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBwbGFuZSBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVQbGFuZUJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgWFogcGxhbmUgdmVydGljZXMuXG4gKlxuICogVGhlIGNyZWF0ZWQgcGxhbmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gV2lkdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aF0gRGVwdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtzdWJkaXZpc2lvbnNXaWR0aF0gTnVtYmVyIG9mIHN0ZXBzIGFjcm9zcyB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3N1YmRpdmlzaW9uc0RlcHRoXSBOdW1iZXIgb2Ygc3RlcHMgZG93biB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFttYXRyaXhdIEEgbWF0cml4IGJ5IHdoaWNoIHRvIG11bHRpcGx5IGFsbCB0aGUgdmVydGljZXMuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHBsYW5lIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBsYW5lVmVydGljZXMod2lkdGgsIGRlcHRoLCBzdWJkaXZpc2lvbnNXaWR0aCwgc3ViZGl2aXNpb25zRGVwdGgsIG1hdHJpeCkge1xuICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gIGRlcHRoID0gZGVwdGggfHwgMTtcbiAgc3ViZGl2aXNpb25zV2lkdGggPSBzdWJkaXZpc2lvbnNXaWR0aCB8fCAxO1xuICBzdWJkaXZpc2lvbnNEZXB0aCA9IHN1YmRpdmlzaW9uc0RlcHRoIHx8IDE7XG4gIG1hdHJpeCA9IG1hdHJpeCB8fCBtNC5pZGVudGl0eSgpO1xuICB2YXIgbnVtVmVydGljZXMgPSAoc3ViZGl2aXNpb25zV2lkdGggKyAxKSAqIChzdWJkaXZpc2lvbnNEZXB0aCArIDEpO1xuICB2YXIgcG9zaXRpb25zID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciBub3JtYWxzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciB0ZXhjb29yZHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsIG51bVZlcnRpY2VzKTtcblxuICBmb3IgKHZhciB6ID0gMDsgeiA8PSBzdWJkaXZpc2lvbnNEZXB0aDsgeisrKSB7XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPD0gc3ViZGl2aXNpb25zV2lkdGg7IHgrKykge1xuICAgICAgdmFyIHUgPSB4IC8gc3ViZGl2aXNpb25zV2lkdGg7XG4gICAgICB2YXIgdiA9IHogLyBzdWJkaXZpc2lvbnNEZXB0aDtcbiAgICAgIHBvc2l0aW9ucy5wdXNoKHdpZHRoICogdSAtIHdpZHRoICogMC41LCAwLCBkZXB0aCAqIHYgLSBkZXB0aCAqIDAuNSk7XG4gICAgICBub3JtYWxzLnB1c2goMCwgMSwgMCk7XG4gICAgICB0ZXhjb29yZHMucHVzaCh1LCB2KTtcbiAgICB9XG4gIH1cblxuICB2YXIgbnVtVmVydHNBY3Jvc3MgPSBzdWJkaXZpc2lvbnNXaWR0aCArIDE7XG4gIHZhciBpbmRpY2VzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBzdWJkaXZpc2lvbnNXaWR0aCAqIHN1YmRpdmlzaW9uc0RlcHRoICogMiwgVWludDE2QXJyYXkpO1xuXG4gIGZvciAodmFyIF96ID0gMDsgX3ogPCBzdWJkaXZpc2lvbnNEZXB0aDsgX3orKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmb3IgKHZhciBfeCA9IDA7IF94IDwgc3ViZGl2aXNpb25zV2lkdGg7IF94KyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIE1ha2UgdHJpYW5nbGUgMSBvZiBxdWFkLlxuICAgICAgaW5kaWNlcy5wdXNoKChfeiArIDApICogbnVtVmVydHNBY3Jvc3MgKyBfeCwgKF96ICsgMSkgKiBudW1WZXJ0c0Fjcm9zcyArIF94LCAoX3ogKyAwKSAqIG51bVZlcnRzQWNyb3NzICsgX3ggKyAxKTsgLy8gTWFrZSB0cmlhbmdsZSAyIG9mIHF1YWQuXG5cbiAgICAgIGluZGljZXMucHVzaCgoX3ogKyAxKSAqIG51bVZlcnRzQWNyb3NzICsgX3gsIChfeiArIDEpICogbnVtVmVydHNBY3Jvc3MgKyBfeCArIDEsIChfeiArIDApICogbnVtVmVydHNBY3Jvc3MgKyBfeCArIDEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhcnJheXMgPSByZW9yaWVudFZlcnRpY2VzKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXNcbiAgfSwgbWF0cml4KTtcbiAgcmV0dXJuIGFycmF5cztcbn1cbi8qKlxuICogQ3JlYXRlcyBzcGhlcmUgQnVmZmVySW5mby5cbiAqXG4gKiBUaGUgY3JlYXRlZCBzcGhlcmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIHJhZGl1cyBvZiB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0F4aXMgbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0hlaWdodCBudW1iZXIgb2YgdmVydGljYWxseSBvbiB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gc3RhcnQgdGhlXG4gKiAgICAgdG9wIG9mIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnNdIFdoZXJlIHRvIGVuZCB0aGVcbiAqICAgICBib3R0b20gb2YgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IE1hdGguUEkuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9zdGFydExvbmdpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gc3RhcnRcbiAqICAgICB3cmFwcGluZyB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X2VuZExvbmdpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gZW5kXG4gKiAgICAgd3JhcHBpbmcgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDIgKiBNYXRoLlBJLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgc3BoZXJlIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVNwaGVyZUJ1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgc3BoZXJlIGJ1ZmZlcnMuXG4gKlxuICogVGhlIGNyZWF0ZWQgc3BoZXJlIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCBhbmQgdGV4Y29vcmQgZGF0YVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyByYWRpdXMgb2YgdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNBeGlzIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNIZWlnaHQgbnVtYmVyIG9mIHZlcnRpY2FsbHkgb24gdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X3N0YXJ0TGF0aXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIHN0YXJ0IHRoZVxuICogICAgIHRvcCBvZiB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X2VuZExhdGl0dWRlSW5SYWRpYW5zXSBXaGVyZSB0byBlbmQgdGhlXG4gKiAgICAgYm90dG9tIG9mIHRoZSBzcGhlcmUuIERlZmF1bHQgPSBNYXRoLlBJLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIHN0YXJ0XG4gKiAgICAgd3JhcHBpbmcgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9lbmRMb25naXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIGVuZFxuICogICAgIHdyYXBwaW5nIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAyICogTWF0aC5QSS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIHNwaGVyZSBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVTcGhlcmVCdWZmZXJzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIHNwaGVyZSB2ZXJ0aWNlcy5cbiAqXG4gKiBUaGUgY3JlYXRlZCBzcGhlcmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyByYWRpdXMgb2YgdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNBeGlzIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNIZWlnaHQgbnVtYmVyIG9mIHZlcnRpY2FsbHkgb24gdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X3N0YXJ0TGF0aXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIHN0YXJ0IHRoZVxuICogICAgIHRvcCBvZiB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X2VuZExhdGl0dWRlSW5SYWRpYW5zXSBXaGVyZSB0byBlbmQgdGhlXG4gKiAgICAgYm90dG9tIG9mIHRoZSBzcGhlcmUuIERlZmF1bHQgPSBNYXRoLlBJLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIHN0YXJ0XG4gKiAgICAgd3JhcHBpbmcgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9lbmRMb25naXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIGVuZFxuICogICAgIHdyYXBwaW5nIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAyICogTWF0aC5QSS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgc3BoZXJlIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNwaGVyZVZlcnRpY2VzKHJhZGl1cywgc3ViZGl2aXNpb25zQXhpcywgc3ViZGl2aXNpb25zSGVpZ2h0LCBvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFucywgb3B0X2VuZExhdGl0dWRlSW5SYWRpYW5zLCBvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnMsIG9wdF9lbmRMb25naXR1ZGVJblJhZGlhbnMpIHtcbiAgaWYgKHN1YmRpdmlzaW9uc0F4aXMgPD0gMCB8fCBzdWJkaXZpc2lvbnNIZWlnaHQgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3ViZGl2aXNpb25BeGlzIGFuZCBzdWJkaXZpc2lvbkhlaWdodCBtdXN0IGJlID4gMCcpO1xuICB9XG5cbiAgb3B0X3N0YXJ0TGF0aXR1ZGVJblJhZGlhbnMgPSBvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFucyB8fCAwO1xuICBvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnMgPSBvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnMgfHwgTWF0aC5QSTtcbiAgb3B0X3N0YXJ0TG9uZ2l0dWRlSW5SYWRpYW5zID0gb3B0X3N0YXJ0TG9uZ2l0dWRlSW5SYWRpYW5zIHx8IDA7XG4gIG9wdF9lbmRMb25naXR1ZGVJblJhZGlhbnMgPSBvcHRfZW5kTG9uZ2l0dWRlSW5SYWRpYW5zIHx8IE1hdGguUEkgKiAyO1xuICB2YXIgbGF0UmFuZ2UgPSBvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnMgLSBvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFucztcbiAgdmFyIGxvbmdSYW5nZSA9IG9wdF9lbmRMb25naXR1ZGVJblJhZGlhbnMgLSBvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnM7IC8vIFdlIGFyZSBnb2luZyB0byBnZW5lcmF0ZSBvdXIgc3BoZXJlIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGl0c1xuICAvLyBzcGhlcmljYWwgY29vcmRpbmF0ZXMgYW5kIGdlbmVyYXRpbmcgMiB0cmlhbmdsZXMgZm9yIGVhY2ggcXVhZCBvbiBhXG4gIC8vIHJpbmcgb2YgdGhlIHNwaGVyZS5cblxuICB2YXIgbnVtVmVydGljZXMgPSAoc3ViZGl2aXNpb25zQXhpcyArIDEpICogKHN1YmRpdmlzaW9uc0hlaWdodCArIDEpO1xuICB2YXIgcG9zaXRpb25zID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciBub3JtYWxzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciB0ZXhjb29yZHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsIG51bVZlcnRpY2VzKTsgLy8gR2VuZXJhdGUgdGhlIGluZGl2aWR1YWwgdmVydGljZXMgaW4gb3VyIHZlcnRleCBidWZmZXIuXG5cbiAgZm9yICh2YXIgeSA9IDA7IHkgPD0gc3ViZGl2aXNpb25zSGVpZ2h0OyB5KyspIHtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8PSBzdWJkaXZpc2lvbnNBeGlzOyB4KyspIHtcbiAgICAgIC8vIEdlbmVyYXRlIGEgdmVydGV4IGJhc2VkIG9uIGl0cyBzcGhlcmljYWwgY29vcmRpbmF0ZXNcbiAgICAgIHZhciB1ID0geCAvIHN1YmRpdmlzaW9uc0F4aXM7XG4gICAgICB2YXIgdiA9IHkgLyBzdWJkaXZpc2lvbnNIZWlnaHQ7XG4gICAgICB2YXIgdGhldGEgPSBsb25nUmFuZ2UgKiB1ICsgb3B0X3N0YXJ0TG9uZ2l0dWRlSW5SYWRpYW5zO1xuICAgICAgdmFyIHBoaSA9IGxhdFJhbmdlICogdiArIG9wdF9zdGFydExhdGl0dWRlSW5SYWRpYW5zO1xuICAgICAgdmFyIHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgdmFyIGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHNpblBoaSA9IE1hdGguc2luKHBoaSk7XG4gICAgICB2YXIgY29zUGhpID0gTWF0aC5jb3MocGhpKTtcbiAgICAgIHZhciB1eCA9IGNvc1RoZXRhICogc2luUGhpO1xuICAgICAgdmFyIHV5ID0gY29zUGhpO1xuICAgICAgdmFyIHV6ID0gc2luVGhldGEgKiBzaW5QaGk7XG4gICAgICBwb3NpdGlvbnMucHVzaChyYWRpdXMgKiB1eCwgcmFkaXVzICogdXksIHJhZGl1cyAqIHV6KTtcbiAgICAgIG5vcm1hbHMucHVzaCh1eCwgdXksIHV6KTtcbiAgICAgIHRleGNvb3Jkcy5wdXNoKDEgLSB1LCB2KTtcbiAgICB9XG4gIH1cblxuICB2YXIgbnVtVmVydHNBcm91bmQgPSBzdWJkaXZpc2lvbnNBeGlzICsgMTtcbiAgdmFyIGluZGljZXMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIHN1YmRpdmlzaW9uc0F4aXMgKiBzdWJkaXZpc2lvbnNIZWlnaHQgKiAyLCBVaW50MTZBcnJheSk7XG5cbiAgZm9yICh2YXIgX3gyID0gMDsgX3gyIDwgc3ViZGl2aXNpb25zQXhpczsgX3gyKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZm9yICh2YXIgX3kgPSAwOyBfeSA8IHN1YmRpdmlzaW9uc0hlaWdodDsgX3krKykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgLy8gTWFrZSB0cmlhbmdsZSAxIG9mIHF1YWQuXG4gICAgICBpbmRpY2VzLnB1c2goKF95ICsgMCkgKiBudW1WZXJ0c0Fyb3VuZCArIF94MiwgKF95ICsgMCkgKiBudW1WZXJ0c0Fyb3VuZCArIF94MiArIDEsIChfeSArIDEpICogbnVtVmVydHNBcm91bmQgKyBfeDIpOyAvLyBNYWtlIHRyaWFuZ2xlIDIgb2YgcXVhZC5cblxuICAgICAgaW5kaWNlcy5wdXNoKChfeSArIDEpICogbnVtVmVydHNBcm91bmQgKyBfeDIsIChfeSArIDApICogbnVtVmVydHNBcm91bmQgKyBfeDIgKyAxLCAoX3kgKyAxKSAqIG51bVZlcnRzQXJvdW5kICsgX3gyICsgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXNcbiAgfTtcbn1cbi8qKlxuICogQXJyYXkgb2YgdGhlIGluZGljZXMgb2YgY29ybmVycyBvZiBlYWNoIGZhY2Ugb2YgYSBjdWJlLlxuICogQHR5cGUge0FycmF5LjxudW1iZXJbXT59XG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIENVQkVfRkFDRV9JTkRJQ0VTID0gW1szLCA3LCA1LCAxXSwgLy8gcmlnaHRcbls2LCAyLCAwLCA0XSwgLy8gbGVmdFxuWzYsIDcsIDMsIDJdLCAvLyA/P1xuWzAsIDEsIDUsIDRdLCAvLyA/P1xuWzcsIDYsIDQsIDVdLCAvLyBmcm9udFxuWzIsIDMsIDEsIDBdIC8vIGJhY2tcbl07XG4vKipcbiAqIENyZWF0ZXMgYSBCdWZmZXJJbmZvIGZvciBhIGN1YmUuXG4gKlxuICogVGhlIGN1YmUgaXMgY3JlYXRlZCBhcm91bmQgdGhlIG9yaWdpbi4gKC1zaXplIC8gMiwgc2l6ZSAvIDIpLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXSB3aWR0aCwgaGVpZ2h0IGFuZCBkZXB0aCBvZiB0aGUgY3ViZS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUN1YmVCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBidWZmZXJzIGFuZCBpbmRpY2VzIGZvciBhIGN1YmUuXG4gKlxuICogVGhlIGN1YmUgaXMgY3JlYXRlZCBhcm91bmQgdGhlIG9yaWdpbi4gKC1zaXplIC8gMiwgc2l6ZSAvIDIpLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXSB3aWR0aCwgaGVpZ2h0IGFuZCBkZXB0aCBvZiB0aGUgY3ViZS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUN1YmVCdWZmZXJzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIHRoZSB2ZXJ0aWNlcyBhbmQgaW5kaWNlcyBmb3IgYSBjdWJlLlxuICpcbiAqIFRoZSBjdWJlIGlzIGNyZWF0ZWQgYXJvdW5kIHRoZSBvcmlnaW4uICgtc2l6ZSAvIDIsIHNpemUgLyAyKS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemVdIHdpZHRoLCBoZWlnaHQgYW5kIGRlcHRoIG9mIHRoZSBjdWJlLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQ3ViZVZlcnRpY2VzKHNpemUpIHtcbiAgc2l6ZSA9IHNpemUgfHwgMTtcbiAgdmFyIGsgPSBzaXplIC8gMjtcbiAgdmFyIGNvcm5lclZlcnRpY2VzID0gW1staywgLWssIC1rXSwgWytrLCAtaywgLWtdLCBbLWssICtrLCAta10sIFsraywgK2ssIC1rXSwgWy1rLCAtaywgK2tdLCBbK2ssIC1rLCAra10sIFstaywgK2ssICtrXSwgWytrLCAraywgK2tdXTtcbiAgdmFyIGZhY2VOb3JtYWxzID0gW1srMSwgKzAsICswXSwgWy0xLCArMCwgKzBdLCBbKzAsICsxLCArMF0sIFsrMCwgLTEsICswXSwgWyswLCArMCwgKzFdLCBbKzAsICswLCAtMV1dO1xuICB2YXIgdXZDb29yZHMgPSBbWzEsIDBdLCBbMCwgMF0sIFswLCAxXSwgWzEsIDFdXTtcbiAgdmFyIG51bVZlcnRpY2VzID0gNiAqIDQ7XG4gIHZhciBwb3NpdGlvbnMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIG5vcm1hbHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIHRleGNvb3JkcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiwgbnVtVmVydGljZXMpO1xuICB2YXIgaW5kaWNlcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgNiAqIDIsIFVpbnQxNkFycmF5KTtcblxuICBmb3IgKHZhciBmID0gMDsgZiA8IDY7ICsrZikge1xuICAgIHZhciBmYWNlSW5kaWNlcyA9IENVQkVfRkFDRV9JTkRJQ0VTW2ZdO1xuXG4gICAgZm9yICh2YXIgdiA9IDA7IHYgPCA0OyArK3YpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGNvcm5lclZlcnRpY2VzW2ZhY2VJbmRpY2VzW3ZdXTtcbiAgICAgIHZhciBub3JtYWwgPSBmYWNlTm9ybWFsc1tmXTtcbiAgICAgIHZhciB1diA9IHV2Q29vcmRzW3ZdOyAvLyBFYWNoIGZhY2UgbmVlZHMgYWxsIGZvdXIgdmVydGljZXMgYmVjYXVzZSB0aGUgbm9ybWFscyBhbmQgdGV4dHVyZVxuICAgICAgLy8gY29vcmRpbmF0ZXMgYXJlIG5vdCBhbGwgdGhlIHNhbWUuXG5cbiAgICAgIHBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcbiAgICAgIG5vcm1hbHMucHVzaChub3JtYWwpO1xuICAgICAgdGV4Y29vcmRzLnB1c2godXYpO1xuICAgIH0gLy8gVHdvIHRyaWFuZ2xlcyBtYWtlIGEgc3F1YXJlIGZhY2UuXG5cblxuICAgIHZhciBvZmZzZXQgPSA0ICogZjtcbiAgICBpbmRpY2VzLnB1c2gob2Zmc2V0ICsgMCwgb2Zmc2V0ICsgMSwgb2Zmc2V0ICsgMik7XG4gICAgaW5kaWNlcy5wdXNoKG9mZnNldCArIDAsIG9mZnNldCArIDIsIG9mZnNldCArIDMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXNcbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIEJ1ZmZlckluZm8gZm9yIGEgdHJ1bmNhdGVkIGNvbmUsIHdoaWNoIGlzIGxpa2UgYSBjeWxpbmRlclxuICogZXhjZXB0IHRoYXQgaXQgaGFzIGRpZmZlcmVudCB0b3AgYW5kIGJvdHRvbSByYWRpaS4gQSB0cnVuY2F0ZWQgY29uZVxuICogY2FuIGFsc28gYmUgdXNlZCB0byBjcmVhdGUgY3lsaW5kZXJzIGFuZCByZWd1bGFyIGNvbmVzLiBUaGVcbiAqIHRydW5jYXRlZCBjb25lIHdpbGwgYmUgY3JlYXRlZCBjZW50ZXJlZCBhYm91dCB0aGUgb3JpZ2luLCB3aXRoIHRoZVxuICogeSBheGlzIGFzIGl0cyB2ZXJ0aWNhbCBheGlzLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbVJhZGl1cyBCb3R0b20gcmFkaXVzIG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcFJhZGl1cyBUb3AgcmFkaXVzIG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGVcbiAqICAgICB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBkb3duIHRoZVxuICogICAgIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0X3RvcENhcF0gQ3JlYXRlIHRvcCBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0X2JvdHRvbUNhcF0gQ3JlYXRlIGJvdHRvbSBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgY29uZSBCdWZmZXJJbmZvLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVySW5mb1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBidWZmZXJzIGZvciBhIHRydW5jYXRlZCBjb25lLCB3aGljaCBpcyBsaWtlIGEgY3lsaW5kZXJcbiAqIGV4Y2VwdCB0aGF0IGl0IGhhcyBkaWZmZXJlbnQgdG9wIGFuZCBib3R0b20gcmFkaWkuIEEgdHJ1bmNhdGVkIGNvbmVcbiAqIGNhbiBhbHNvIGJlIHVzZWQgdG8gY3JlYXRlIGN5bGluZGVycyBhbmQgcmVndWxhciBjb25lcy4gVGhlXG4gKiB0cnVuY2F0ZWQgY29uZSB3aWxsIGJlIGNyZWF0ZWQgY2VudGVyZWQgYWJvdXQgdGhlIG9yaWdpbiwgd2l0aCB0aGVcbiAqIHkgYXhpcyBhcyBpdHMgdmVydGljYWwgYXhpcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b21SYWRpdXMgQm90dG9tIHJhZGl1cyBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3BSYWRpdXMgVG9wIHJhZGl1cyBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlXG4gKiAgICAgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgZG93biB0aGVcbiAqICAgICB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdF90b3BDYXBdIENyZWF0ZSB0b3AgY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdF9ib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGNvbmUgYnVmZmVycy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlVHJ1bmNhdGVkQ29uZUJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgdmVydGljZXMgZm9yIGEgdHJ1bmNhdGVkIGNvbmUsIHdoaWNoIGlzIGxpa2UgYSBjeWxpbmRlclxuICogZXhjZXB0IHRoYXQgaXQgaGFzIGRpZmZlcmVudCB0b3AgYW5kIGJvdHRvbSByYWRpaS4gQSB0cnVuY2F0ZWQgY29uZVxuICogY2FuIGFsc28gYmUgdXNlZCB0byBjcmVhdGUgY3lsaW5kZXJzIGFuZCByZWd1bGFyIGNvbmVzLiBUaGVcbiAqIHRydW5jYXRlZCBjb25lIHdpbGwgYmUgY3JlYXRlZCBjZW50ZXJlZCBhYm91dCB0aGUgb3JpZ2luLCB3aXRoIHRoZVxuICogeSBheGlzIGFzIGl0cyB2ZXJ0aWNhbCBheGlzLiAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbVJhZGl1cyBCb3R0b20gcmFkaXVzIG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcFJhZGl1cyBUb3AgcmFkaXVzIG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGVcbiAqICAgICB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBkb3duIHRoZVxuICogICAgIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0X3RvcENhcF0gQ3JlYXRlIHRvcCBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0X2JvdHRvbUNhcF0gQ3JlYXRlIGJvdHRvbSBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCBjb25lIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVRydW5jYXRlZENvbmVWZXJ0aWNlcyhib3R0b21SYWRpdXMsIHRvcFJhZGl1cywgaGVpZ2h0LCByYWRpYWxTdWJkaXZpc2lvbnMsIHZlcnRpY2FsU3ViZGl2aXNpb25zLCBvcHRfdG9wQ2FwLCBvcHRfYm90dG9tQ2FwKSB7XG4gIGlmIChyYWRpYWxTdWJkaXZpc2lvbnMgPCAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpYWxTdWJkaXZpc2lvbnMgbXVzdCBiZSAzIG9yIGdyZWF0ZXInKTtcbiAgfVxuXG4gIGlmICh2ZXJ0aWNhbFN1YmRpdmlzaW9ucyA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnRpY2FsU3ViZGl2aXNpb25zIG11c3QgYmUgMSBvciBncmVhdGVyJyk7XG4gIH1cblxuICB2YXIgdG9wQ2FwID0gb3B0X3RvcENhcCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdF90b3BDYXA7XG4gIHZhciBib3R0b21DYXAgPSBvcHRfYm90dG9tQ2FwID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0X2JvdHRvbUNhcDtcbiAgdmFyIGV4dHJhID0gKHRvcENhcCA/IDIgOiAwKSArIChib3R0b21DYXAgPyAyIDogMCk7XG4gIHZhciBudW1WZXJ0aWNlcyA9IChyYWRpYWxTdWJkaXZpc2lvbnMgKyAxKSAqICh2ZXJ0aWNhbFN1YmRpdmlzaW9ucyArIDEgKyBleHRyYSk7XG4gIHZhciBwb3NpdGlvbnMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIG5vcm1hbHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIHRleGNvb3JkcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiwgbnVtVmVydGljZXMpO1xuICB2YXIgaW5kaWNlcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgcmFkaWFsU3ViZGl2aXNpb25zICogKHZlcnRpY2FsU3ViZGl2aXNpb25zICsgZXh0cmEgLyAyKSAqIDIsIFVpbnQxNkFycmF5KTtcbiAgdmFyIHZlcnRzQXJvdW5kRWRnZSA9IHJhZGlhbFN1YmRpdmlzaW9ucyArIDE7IC8vIFRoZSBzbGFudCBvZiB0aGUgY29uZSBpcyBjb25zdGFudCBhY3Jvc3MgaXRzIHN1cmZhY2VcblxuICB2YXIgc2xhbnQgPSBNYXRoLmF0YW4yKGJvdHRvbVJhZGl1cyAtIHRvcFJhZGl1cywgaGVpZ2h0KTtcbiAgdmFyIGNvc1NsYW50ID0gTWF0aC5jb3Moc2xhbnQpO1xuICB2YXIgc2luU2xhbnQgPSBNYXRoLnNpbihzbGFudCk7XG4gIHZhciBzdGFydCA9IHRvcENhcCA/IC0yIDogMDtcbiAgdmFyIGVuZCA9IHZlcnRpY2FsU3ViZGl2aXNpb25zICsgKGJvdHRvbUNhcCA/IDIgOiAwKTtcblxuICBmb3IgKHZhciB5eSA9IHN0YXJ0OyB5eSA8PSBlbmQ7ICsreXkpIHtcbiAgICB2YXIgdiA9IHl5IC8gdmVydGljYWxTdWJkaXZpc2lvbnM7XG4gICAgdmFyIHkgPSBoZWlnaHQgKiB2O1xuICAgIHZhciByaW5nUmFkaXVzID0gdm9pZCAwO1xuXG4gICAgaWYgKHl5IDwgMCkge1xuICAgICAgeSA9IDA7XG4gICAgICB2ID0gMTtcbiAgICAgIHJpbmdSYWRpdXMgPSBib3R0b21SYWRpdXM7XG4gICAgfSBlbHNlIGlmICh5eSA+IHZlcnRpY2FsU3ViZGl2aXNpb25zKSB7XG4gICAgICB5ID0gaGVpZ2h0O1xuICAgICAgdiA9IDE7XG4gICAgICByaW5nUmFkaXVzID0gdG9wUmFkaXVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByaW5nUmFkaXVzID0gYm90dG9tUmFkaXVzICsgKHRvcFJhZGl1cyAtIGJvdHRvbVJhZGl1cykgKiAoeXkgLyB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKHl5ID09PSAtMiB8fCB5eSA9PT0gdmVydGljYWxTdWJkaXZpc2lvbnMgKyAyKSB7XG4gICAgICByaW5nUmFkaXVzID0gMDtcbiAgICAgIHYgPSAwO1xuICAgIH1cblxuICAgIHkgLT0gaGVpZ2h0IC8gMjtcblxuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB2ZXJ0c0Fyb3VuZEVkZ2U7ICsraWkpIHtcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihpaSAqIE1hdGguUEkgKiAyIC8gcmFkaWFsU3ViZGl2aXNpb25zKTtcbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhpaSAqIE1hdGguUEkgKiAyIC8gcmFkaWFsU3ViZGl2aXNpb25zKTtcbiAgICAgIHBvc2l0aW9ucy5wdXNoKHNpbiAqIHJpbmdSYWRpdXMsIHksIGNvcyAqIHJpbmdSYWRpdXMpO1xuXG4gICAgICBpZiAoeXkgPCAwKSB7XG4gICAgICAgIG5vcm1hbHMucHVzaCgwLCAtMSwgMCk7XG4gICAgICB9IGVsc2UgaWYgKHl5ID4gdmVydGljYWxTdWJkaXZpc2lvbnMpIHtcbiAgICAgICAgbm9ybWFscy5wdXNoKDAsIDEsIDApO1xuICAgICAgfSBlbHNlIGlmIChyaW5nUmFkaXVzID09PSAwLjApIHtcbiAgICAgICAgbm9ybWFscy5wdXNoKDAsIDAsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFscy5wdXNoKHNpbiAqIGNvc1NsYW50LCBzaW5TbGFudCwgY29zICogY29zU2xhbnQpO1xuICAgICAgfVxuXG4gICAgICB0ZXhjb29yZHMucHVzaChpaSAvIHJhZGlhbFN1YmRpdmlzaW9ucywgMSAtIHYpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF95eSA9IDA7IF95eSA8IHZlcnRpY2FsU3ViZGl2aXNpb25zICsgZXh0cmE7ICsrX3l5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChfeXkgPT09IDEgJiYgdG9wQ2FwIHx8IF95eSA9PT0gdmVydGljYWxTdWJkaXZpc2lvbnMgKyBleHRyYSAtIDIgJiYgYm90dG9tQ2FwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaWkgPSAwOyBfaWkgPCByYWRpYWxTdWJkaXZpc2lvbnM7ICsrX2lpKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpbmRpY2VzLnB1c2godmVydHNBcm91bmRFZGdlICogKF95eSArIDApICsgMCArIF9paSwgdmVydHNBcm91bmRFZGdlICogKF95eSArIDApICsgMSArIF9paSwgdmVydHNBcm91bmRFZGdlICogKF95eSArIDEpICsgMSArIF9paSk7XG4gICAgICBpbmRpY2VzLnB1c2godmVydHNBcm91bmRFZGdlICogKF95eSArIDApICsgMCArIF9paSwgdmVydHNBcm91bmRFZGdlICogKF95eSArIDEpICsgMSArIF9paSwgdmVydHNBcm91bmRFZGdlICogKF95eSArIDEpICsgMCArIF9paSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXNcbiAgfTtcbn1cbi8qKlxuICogRXhwYW5kcyBSTEUgZGF0YVxuICogQHBhcmFtIHtudW1iZXJbXX0gcmxlRGF0YSBkYXRhIGluIGZvcm1hdCBvZiBydW4tbGVuZ3RoLCB4LCB5LCB6LCBydW4tbGVuZ3RoLCB4LCB5LCB6XG4gKiBAcGFyYW0ge251bWJlcltdfSBbcGFkZGluZ10gdmFsdWUgdG8gYWRkIGVhY2ggZW50cnkgd2l0aC5cbiAqIEByZXR1cm4ge251bWJlcltdfSB0aGUgZXhwYW5kZWQgcmxlRGF0YVxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4cGFuZFJMRURhdGEocmxlRGF0YSwgcGFkZGluZykge1xuICBwYWRkaW5nID0gcGFkZGluZyB8fCBbXTtcbiAgdmFyIGRhdGEgPSBbXTtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgcmxlRGF0YS5sZW5ndGg7IGlpICs9IDQpIHtcbiAgICB2YXIgcnVuTGVuZ3RoID0gcmxlRGF0YVtpaV07XG4gICAgdmFyIGVsZW1lbnQgPSBybGVEYXRhLnNsaWNlKGlpICsgMSwgaWkgKyA0KTtcbiAgICBlbGVtZW50LnB1c2guYXBwbHkoZWxlbWVudCwgcGFkZGluZyk7XG5cbiAgICBmb3IgKHZhciBqaiA9IDA7IGpqIDwgcnVuTGVuZ3RoOyArK2pqKSB7XG4gICAgICBkYXRhLnB1c2guYXBwbHkoZGF0YSwgZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENyZWF0ZXMgM0QgJ0YnIEJ1ZmZlckluZm8uXG4gKiBBbiAnRicgaXMgdXNlZnVsIGJlY2F1c2UgeW91IGNhbiBlYXNpbHkgdGVsbCB3aGljaCB3YXkgaXQgaXMgb3JpZW50ZWQuXG4gKiBUaGUgY3JlYXRlZCAnRicgaGFzIHBvc2l0aW9uLCBub3JtYWwsIHRleGNvb3JkLCBhbmQgY29sb3IgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZTNERkJ1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgM0QgJ0YnIGJ1ZmZlcnMuXG4gKiBBbiAnRicgaXMgdXNlZnVsIGJlY2F1c2UgeW91IGNhbiBlYXNpbHkgdGVsbCB3aGljaCB3YXkgaXQgaXMgb3JpZW50ZWQuXG4gKiBUaGUgY3JlYXRlZCAnRicgaGFzIHBvc2l0aW9uLCBub3JtYWwsIHRleGNvb3JkLCBhbmQgY29sb3IgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZTNERkJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgM0QgJ0YnIHZlcnRpY2VzLlxuICogQW4gJ0YnIGlzIHVzZWZ1bCBiZWNhdXNlIHlvdSBjYW4gZWFzaWx5IHRlbGwgd2hpY2ggd2F5IGl0IGlzIG9yaWVudGVkLlxuICogVGhlIGNyZWF0ZWQgJ0YnIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCB0ZXhjb29yZCwgYW5kIGNvbG9yIGFycmF5cy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZTNERlZlcnRpY2VzKCkge1xuICB2YXIgcG9zaXRpb25zID0gWy8vIGxlZnQgY29sdW1uIGZyb250XG4gIDAsIDAsIDAsIDAsIDE1MCwgMCwgMzAsIDAsIDAsIDAsIDE1MCwgMCwgMzAsIDE1MCwgMCwgMzAsIDAsIDAsIC8vIHRvcCBydW5nIGZyb250XG4gIDMwLCAwLCAwLCAzMCwgMzAsIDAsIDEwMCwgMCwgMCwgMzAsIDMwLCAwLCAxMDAsIDMwLCAwLCAxMDAsIDAsIDAsIC8vIG1pZGRsZSBydW5nIGZyb250XG4gIDMwLCA2MCwgMCwgMzAsIDkwLCAwLCA2NywgNjAsIDAsIDMwLCA5MCwgMCwgNjcsIDkwLCAwLCA2NywgNjAsIDAsIC8vIGxlZnQgY29sdW1uIGJhY2tcbiAgMCwgMCwgMzAsIDMwLCAwLCAzMCwgMCwgMTUwLCAzMCwgMCwgMTUwLCAzMCwgMzAsIDAsIDMwLCAzMCwgMTUwLCAzMCwgLy8gdG9wIHJ1bmcgYmFja1xuICAzMCwgMCwgMzAsIDEwMCwgMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDEwMCwgMCwgMzAsIDEwMCwgMzAsIDMwLCAvLyBtaWRkbGUgcnVuZyBiYWNrXG4gIDMwLCA2MCwgMzAsIDY3LCA2MCwgMzAsIDMwLCA5MCwgMzAsIDMwLCA5MCwgMzAsIDY3LCA2MCwgMzAsIDY3LCA5MCwgMzAsIC8vIHRvcFxuICAwLCAwLCAwLCAxMDAsIDAsIDAsIDEwMCwgMCwgMzAsIDAsIDAsIDAsIDEwMCwgMCwgMzAsIDAsIDAsIDMwLCAvLyB0b3AgcnVuZyBmcm9udFxuICAxMDAsIDAsIDAsIDEwMCwgMzAsIDAsIDEwMCwgMzAsIDMwLCAxMDAsIDAsIDAsIDEwMCwgMzAsIDMwLCAxMDAsIDAsIDMwLCAvLyB1bmRlciB0b3AgcnVuZ1xuICAzMCwgMzAsIDAsIDMwLCAzMCwgMzAsIDEwMCwgMzAsIDMwLCAzMCwgMzAsIDAsIDEwMCwgMzAsIDMwLCAxMDAsIDMwLCAwLCAvLyBiZXR3ZWVuIHRvcCBydW5nIGFuZCBtaWRkbGVcbiAgMzAsIDMwLCAwLCAzMCwgNjAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDAsIDMwLCA2MCwgMCwgMzAsIDYwLCAzMCwgLy8gdG9wIG9mIG1pZGRsZSBydW5nXG4gIDMwLCA2MCwgMCwgNjcsIDYwLCAzMCwgMzAsIDYwLCAzMCwgMzAsIDYwLCAwLCA2NywgNjAsIDAsIDY3LCA2MCwgMzAsIC8vIGZyb250IG9mIG1pZGRsZSBydW5nXG4gIDY3LCA2MCwgMCwgNjcsIDkwLCAzMCwgNjcsIDYwLCAzMCwgNjcsIDYwLCAwLCA2NywgOTAsIDAsIDY3LCA5MCwgMzAsIC8vIGJvdHRvbSBvZiBtaWRkbGUgcnVuZy5cbiAgMzAsIDkwLCAwLCAzMCwgOTAsIDMwLCA2NywgOTAsIDMwLCAzMCwgOTAsIDAsIDY3LCA5MCwgMzAsIDY3LCA5MCwgMCwgLy8gZnJvbnQgb2YgYm90dG9tXG4gIDMwLCA5MCwgMCwgMzAsIDE1MCwgMzAsIDMwLCA5MCwgMzAsIDMwLCA5MCwgMCwgMzAsIDE1MCwgMCwgMzAsIDE1MCwgMzAsIC8vIGJvdHRvbVxuICAwLCAxNTAsIDAsIDAsIDE1MCwgMzAsIDMwLCAxNTAsIDMwLCAwLCAxNTAsIDAsIDMwLCAxNTAsIDMwLCAzMCwgMTUwLCAwLCAvLyBsZWZ0IHNpZGVcbiAgMCwgMCwgMCwgMCwgMCwgMzAsIDAsIDE1MCwgMzAsIDAsIDAsIDAsIDAsIDE1MCwgMzAsIDAsIDE1MCwgMF07XG4gIHZhciB0ZXhjb29yZHMgPSBbLy8gbGVmdCBjb2x1bW4gZnJvbnRcbiAgMC4yMiwgMC4xOSwgMC4yMiwgMC43OSwgMC4zNCwgMC4xOSwgMC4yMiwgMC43OSwgMC4zNCwgMC43OSwgMC4zNCwgMC4xOSwgLy8gdG9wIHJ1bmcgZnJvbnRcbiAgMC4zNCwgMC4xOSwgMC4zNCwgMC4zMSwgMC42MiwgMC4xOSwgMC4zNCwgMC4zMSwgMC42MiwgMC4zMSwgMC42MiwgMC4xOSwgLy8gbWlkZGxlIHJ1bmcgZnJvbnRcbiAgMC4zNCwgMC40MywgMC4zNCwgMC41NSwgMC40OSwgMC40MywgMC4zNCwgMC41NSwgMC40OSwgMC41NSwgMC40OSwgMC40MywgLy8gbGVmdCBjb2x1bW4gYmFja1xuICAwLCAwLCAxLCAwLCAwLCAxLCAwLCAxLCAxLCAwLCAxLCAxLCAvLyB0b3AgcnVuZyBiYWNrXG4gIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDEsIDEsIDAsIDEsIDEsIC8vIG1pZGRsZSBydW5nIGJhY2tcbiAgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMSwgMSwgMCwgMSwgMSwgLy8gdG9wXG4gIDAsIDAsIDEsIDAsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIC8vIHRvcCBydW5nIGZyb250XG4gIDAsIDAsIDEsIDAsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIC8vIHVuZGVyIHRvcCBydW5nXG4gIDAsIDAsIDAsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDEsIDAsIC8vIGJldHdlZW4gdG9wIHJ1bmcgYW5kIG1pZGRsZVxuICAwLCAwLCAxLCAxLCAwLCAxLCAwLCAwLCAxLCAwLCAxLCAxLCAvLyB0b3Agb2YgbWlkZGxlIHJ1bmdcbiAgMCwgMCwgMSwgMSwgMCwgMSwgMCwgMCwgMSwgMCwgMSwgMSwgLy8gZnJvbnQgb2YgbWlkZGxlIHJ1bmdcbiAgMCwgMCwgMSwgMSwgMCwgMSwgMCwgMCwgMSwgMCwgMSwgMSwgLy8gYm90dG9tIG9mIG1pZGRsZSBydW5nLlxuICAwLCAwLCAwLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAxLCAwLCAvLyBmcm9udCBvZiBib3R0b21cbiAgMCwgMCwgMSwgMSwgMCwgMSwgMCwgMCwgMSwgMCwgMSwgMSwgLy8gYm90dG9tXG4gIDAsIDAsIDAsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDEsIDAsIC8vIGxlZnQgc2lkZVxuICAwLCAwLCAwLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAxLCAwXTtcbiAgdmFyIG5vcm1hbHMgPSBleHBhbmRSTEVEYXRhKFsvLyBsZWZ0IGNvbHVtbiBmcm9udFxuICAvLyB0b3AgcnVuZyBmcm9udFxuICAvLyBtaWRkbGUgcnVuZyBmcm9udFxuICAxOCwgMCwgMCwgMSwgLy8gbGVmdCBjb2x1bW4gYmFja1xuICAvLyB0b3AgcnVuZyBiYWNrXG4gIC8vIG1pZGRsZSBydW5nIGJhY2tcbiAgMTgsIDAsIDAsIC0xLCAvLyB0b3BcbiAgNiwgMCwgMSwgMCwgLy8gdG9wIHJ1bmcgZnJvbnRcbiAgNiwgMSwgMCwgMCwgLy8gdW5kZXIgdG9wIHJ1bmdcbiAgNiwgMCwgLTEsIDAsIC8vIGJldHdlZW4gdG9wIHJ1bmcgYW5kIG1pZGRsZVxuICA2LCAxLCAwLCAwLCAvLyB0b3Agb2YgbWlkZGxlIHJ1bmdcbiAgNiwgMCwgMSwgMCwgLy8gZnJvbnQgb2YgbWlkZGxlIHJ1bmdcbiAgNiwgMSwgMCwgMCwgLy8gYm90dG9tIG9mIG1pZGRsZSBydW5nLlxuICA2LCAwLCAtMSwgMCwgLy8gZnJvbnQgb2YgYm90dG9tXG4gIDYsIDEsIDAsIDAsIC8vIGJvdHRvbVxuICA2LCAwLCAtMSwgMCwgLy8gbGVmdCBzaWRlXG4gIDYsIC0xLCAwLCAwXSk7XG4gIHZhciBjb2xvcnMgPSBleHBhbmRSTEVEYXRhKFsvLyBsZWZ0IGNvbHVtbiBmcm9udFxuICAvLyB0b3AgcnVuZyBmcm9udFxuICAvLyBtaWRkbGUgcnVuZyBmcm9udFxuICAxOCwgMjAwLCA3MCwgMTIwLCAvLyBsZWZ0IGNvbHVtbiBiYWNrXG4gIC8vIHRvcCBydW5nIGJhY2tcbiAgLy8gbWlkZGxlIHJ1bmcgYmFja1xuICAxOCwgODAsIDcwLCAyMDAsIC8vIHRvcFxuICA2LCA3MCwgMjAwLCAyMTAsIC8vIHRvcCBydW5nIGZyb250XG4gIDYsIDIwMCwgMjAwLCA3MCwgLy8gdW5kZXIgdG9wIHJ1bmdcbiAgNiwgMjEwLCAxMDAsIDcwLCAvLyBiZXR3ZWVuIHRvcCBydW5nIGFuZCBtaWRkbGVcbiAgNiwgMjEwLCAxNjAsIDcwLCAvLyB0b3Agb2YgbWlkZGxlIHJ1bmdcbiAgNiwgNzAsIDE4MCwgMjEwLCAvLyBmcm9udCBvZiBtaWRkbGUgcnVuZ1xuICA2LCAxMDAsIDcwLCAyMTAsIC8vIGJvdHRvbSBvZiBtaWRkbGUgcnVuZy5cbiAgNiwgNzYsIDIxMCwgMTAwLCAvLyBmcm9udCBvZiBib3R0b21cbiAgNiwgMTQwLCAyMTAsIDgwLCAvLyBib3R0b21cbiAgNiwgOTAsIDEzMCwgMTEwLCAvLyBsZWZ0IHNpZGVcbiAgNiwgMTYwLCAxNjAsIDIyMF0sIFsyNTVdKTtcbiAgdmFyIG51bVZlcnRzID0gcG9zaXRpb25zLmxlbmd0aCAvIDM7XG4gIHZhciBhcnJheXMgPSB7XG4gICAgcG9zaXRpb246IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydHMpLFxuICAgIHRleGNvb3JkOiBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsIG51bVZlcnRzKSxcbiAgICBub3JtYWw6IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydHMpLFxuICAgIGNvbG9yOiBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDQsIG51bVZlcnRzLCBVaW50OEFycmF5KSxcbiAgICBpbmRpY2VzOiBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRzIC8gMywgVWludDE2QXJyYXkpXG4gIH07XG4gIGFycmF5cy5wb3NpdGlvbi5wdXNoKHBvc2l0aW9ucyk7XG4gIGFycmF5cy50ZXhjb29yZC5wdXNoKHRleGNvb3Jkcyk7XG4gIGFycmF5cy5ub3JtYWwucHVzaChub3JtYWxzKTtcbiAgYXJyYXlzLmNvbG9yLnB1c2goY29sb3JzKTtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbnVtVmVydHM7ICsraWkpIHtcbiAgICBhcnJheXMuaW5kaWNlcy5wdXNoKGlpKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheXM7XG59XG4vKipcbiAqIENyZWF0ZXMgY3Jlc2NlbnQgQnVmZmVySW5mby5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFJhZGl1cyBUaGUgdmVydGljYWwgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRlclJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbm5lclJhZGl1cyBUaGUgaW5uZXIgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGlja25lc3MgVGhlIHRoaWNrbmVzcyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zRG93biBudW1iZXIgb2Ygc3RlcHMgYXJvdW5kIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRPZmZzZXRdIFdoZXJlIHRvIHN0YXJ0IGFyYy4gRGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmRPZmZzZXRdIFdoZXJlIHRvIGVuZCBhcmcuIERlZmF1bHQgMS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUNyZXNlbnRCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGNyZXNjZW50IGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxSYWRpdXMgVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0ZXJSYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5uZXJSYWRpdXMgVGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIFRoZSB0aGlja25lc3Mgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0Rvd24gbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0T2Zmc2V0XSBXaGVyZSB0byBzdGFydCBhcmMuIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kT2Zmc2V0XSBXaGVyZSB0byBlbmQgYXJnLiBEZWZhdWx0IDEuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVDcmVzZW50QnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBjcmVzY2VudCB2ZXJ0aWNlcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxSYWRpdXMgVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0ZXJSYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5uZXJSYWRpdXMgVGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIFRoZSB0aGlja25lc3Mgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0Rvd24gbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0T2Zmc2V0XSBXaGVyZSB0byBzdGFydCBhcmMuIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kT2Zmc2V0XSBXaGVyZSB0byBlbmQgYXJnLiBEZWZhdWx0IDEuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVDcmVzZW50QnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBjcmVzY2VudCBCdWZmZXJJbmZvLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsUmFkaXVzIFRoZSB2ZXJ0aWNhbCByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG91dGVyUmFkaXVzIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGlubmVyUmFkaXVzIFRoZSBpbm5lciByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRoaWNrbmVzcyBUaGUgdGhpY2tuZXNzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNEb3duIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydE9mZnNldF0gV2hlcmUgdG8gc3RhcnQgYXJjLiBEZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZE9mZnNldF0gV2hlcmUgdG8gZW5kIGFyZy4gRGVmYXVsdCAxLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlQ3Jlc2NlbnRCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGNyZXNjZW50IGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxSYWRpdXMgVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0ZXJSYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5uZXJSYWRpdXMgVGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIFRoZSB0aGlja25lc3Mgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0Rvd24gbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0T2Zmc2V0XSBXaGVyZSB0byBzdGFydCBhcmMuIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kT2Zmc2V0XSBXaGVyZSB0byBlbmQgYXJnLiBEZWZhdWx0IDEuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVDcmVzY2VudEJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgY3Jlc2NlbnQgdmVydGljZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsUmFkaXVzIFRoZSB2ZXJ0aWNhbCByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG91dGVyUmFkaXVzIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGlubmVyUmFkaXVzIFRoZSBpbm5lciByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRoaWNrbmVzcyBUaGUgdGhpY2tuZXNzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNEb3duIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydE9mZnNldF0gV2hlcmUgdG8gc3RhcnQgYXJjLiBEZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZE9mZnNldF0gV2hlcmUgdG8gZW5kIGFyZy4gRGVmYXVsdCAxLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVDcmVzY2VudFZlcnRpY2VzKHZlcnRpY2FsUmFkaXVzLCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMsIHRoaWNrbmVzcywgc3ViZGl2aXNpb25zRG93biwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICBpZiAoc3ViZGl2aXNpb25zRG93biA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdWJkaXZpc2lvbkRvd24gbXVzdCBiZSA+IDAnKTtcbiAgfVxuXG4gIHN0YXJ0T2Zmc2V0ID0gc3RhcnRPZmZzZXQgfHwgMDtcbiAgZW5kT2Zmc2V0ID0gZW5kT2Zmc2V0IHx8IDE7XG4gIHZhciBzdWJkaXZpc2lvbnNUaGljayA9IDI7XG4gIHZhciBvZmZzZXRSYW5nZSA9IGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xuICB2YXIgbnVtVmVydGljZXMgPSAoc3ViZGl2aXNpb25zRG93biArIDEpICogMiAqICgyICsgc3ViZGl2aXNpb25zVGhpY2spO1xuICB2YXIgcG9zaXRpb25zID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciBub3JtYWxzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciB0ZXhjb29yZHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsIG51bVZlcnRpY2VzKTtcblxuICBmdW5jdGlvbiBsZXJwKGEsIGIsIHMpIHtcbiAgICByZXR1cm4gYSArIChiIC0gYSkgKiBzO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJjKGFyY1JhZGl1cywgeCwgbm9ybWFsTXVsdCwgbm9ybWFsQWRkLCB1TXVsdCwgdUFkZCkge1xuICAgIGZvciAodmFyIHogPSAwOyB6IDw9IHN1YmRpdmlzaW9uc0Rvd247IHorKykge1xuICAgICAgdmFyIHVCYWNrID0geCAvIChzdWJkaXZpc2lvbnNUaGljayAtIDEpO1xuICAgICAgdmFyIHYgPSB6IC8gc3ViZGl2aXNpb25zRG93bjtcbiAgICAgIHZhciB4QmFjayA9ICh1QmFjayAtIDAuNSkgKiAyO1xuICAgICAgdmFyIGFuZ2xlID0gKHN0YXJ0T2Zmc2V0ICsgdiAqIG9mZnNldFJhbmdlKSAqIE1hdGguUEk7XG4gICAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgdmFyIHJhZGl1cyA9IGxlcnAodmVydGljYWxSYWRpdXMsIGFyY1JhZGl1cywgcyk7XG4gICAgICB2YXIgcHggPSB4QmFjayAqIHRoaWNrbmVzcztcbiAgICAgIHZhciBweSA9IGMgKiB2ZXJ0aWNhbFJhZGl1cztcbiAgICAgIHZhciBweiA9IHMgKiByYWRpdXM7XG4gICAgICBwb3NpdGlvbnMucHVzaChweCwgcHksIHB6KTtcbiAgICAgIHZhciBuID0gdjMuYWRkKHYzLm11bHRpcGx5KFswLCBzLCBjXSwgbm9ybWFsTXVsdCksIG5vcm1hbEFkZCk7XG4gICAgICBub3JtYWxzLnB1c2gobik7XG4gICAgICB0ZXhjb29yZHMucHVzaCh1QmFjayAqIHVNdWx0ICsgdUFkZCwgdik7XG4gICAgfVxuICB9IC8vIEdlbmVyYXRlIHRoZSBpbmRpdmlkdWFsIHZlcnRpY2VzIGluIG91ciB2ZXJ0ZXggYnVmZmVyLlxuXG5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCBzdWJkaXZpc2lvbnNUaGljazsgeCsrKSB7XG4gICAgdmFyIHVCYWNrID0gKHggLyAoc3ViZGl2aXNpb25zVGhpY2sgLSAxKSAtIDAuNSkgKiAyO1xuICAgIGNyZWF0ZUFyYyhvdXRlclJhZGl1cywgeCwgWzEsIDEsIDFdLCBbMCwgMCwgMF0sIDEsIDApO1xuICAgIGNyZWF0ZUFyYyhvdXRlclJhZGl1cywgeCwgWzAsIDAsIDBdLCBbdUJhY2ssIDAsIDBdLCAwLCAwKTtcbiAgICBjcmVhdGVBcmMoaW5uZXJSYWRpdXMsIHgsIFsxLCAxLCAxXSwgWzAsIDAsIDBdLCAxLCAwKTtcbiAgICBjcmVhdGVBcmMoaW5uZXJSYWRpdXMsIHgsIFswLCAwLCAwXSwgW3VCYWNrLCAwLCAwXSwgMCwgMSk7XG4gIH0gLy8gRG8gb3V0ZXIgc3VyZmFjZS5cblxuXG4gIHZhciBpbmRpY2VzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBzdWJkaXZpc2lvbnNEb3duICogMiAqICgyICsgc3ViZGl2aXNpb25zVGhpY2spLCBVaW50MTZBcnJheSk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3VyZmFjZShsZWZ0QXJjT2Zmc2V0LCByaWdodEFyY09mZnNldCkge1xuICAgIGZvciAodmFyIHogPSAwOyB6IDwgc3ViZGl2aXNpb25zRG93bjsgKyt6KSB7XG4gICAgICAvLyBNYWtlIHRyaWFuZ2xlIDEgb2YgcXVhZC5cbiAgICAgIGluZGljZXMucHVzaChsZWZ0QXJjT2Zmc2V0ICsgeiArIDAsIGxlZnRBcmNPZmZzZXQgKyB6ICsgMSwgcmlnaHRBcmNPZmZzZXQgKyB6ICsgMCk7IC8vIE1ha2UgdHJpYW5nbGUgMiBvZiBxdWFkLlxuXG4gICAgICBpbmRpY2VzLnB1c2gobGVmdEFyY09mZnNldCArIHogKyAxLCByaWdodEFyY09mZnNldCArIHogKyAxLCByaWdodEFyY09mZnNldCArIHogKyAwKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbnVtVmVydGljZXNEb3duID0gc3ViZGl2aXNpb25zRG93biArIDE7IC8vIGZyb250XG5cbiAgY3JlYXRlU3VyZmFjZShudW1WZXJ0aWNlc0Rvd24gKiAwLCBudW1WZXJ0aWNlc0Rvd24gKiA0KTsgLy8gcmlnaHRcblxuICBjcmVhdGVTdXJmYWNlKG51bVZlcnRpY2VzRG93biAqIDUsIG51bVZlcnRpY2VzRG93biAqIDcpOyAvLyBiYWNrXG5cbiAgY3JlYXRlU3VyZmFjZShudW1WZXJ0aWNlc0Rvd24gKiA2LCBudW1WZXJ0aWNlc0Rvd24gKiAyKTsgLy8gbGVmdFxuXG4gIGNyZWF0ZVN1cmZhY2UobnVtVmVydGljZXNEb3duICogMywgbnVtVmVydGljZXNEb3duICogMSk7XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9ucyxcbiAgICBub3JtYWw6IG5vcm1hbHMsXG4gICAgdGV4Y29vcmQ6IHRleGNvb3JkcyxcbiAgICBpbmRpY2VzOiBpbmRpY2VzXG4gIH07XG59XG4vKipcbiAqIENyZWF0ZXMgY3lsaW5kZXIgQnVmZmVySW5mby4gVGhlIGN5bGluZGVyIHdpbGwgYmUgY3JlYXRlZCBhcm91bmQgdGhlIG9yaWdpblxuICogYWxvbmcgdGhlIHktYXhpcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgY3lsaW5kZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGUgY3lsaW5kZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgZG93biB0aGUgY3lsaW5kZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0b3BDYXBdIENyZWF0ZSB0b3AgY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JvdHRvbUNhcF0gQ3JlYXRlIGJvdHRvbSBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlQ3lsaW5kZXJCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGN5bGluZGVyIGJ1ZmZlcnMuIFRoZSBjeWxpbmRlciB3aWxsIGJlIGNyZWF0ZWQgYXJvdW5kIHRoZSBvcmlnaW5cbiAqIGFsb25nIHRoZSB5LWF4aXMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBjeWxpbmRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGRvd24gdGhlIGN5bGluZGVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdG9wQ2FwXSBDcmVhdGUgdG9wIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUN5bGluZGVyQnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBjeWxpbmRlciB2ZXJ0aWNlcy4gVGhlIGN5bGluZGVyIHdpbGwgYmUgY3JlYXRlZCBhcm91bmQgdGhlIG9yaWdpblxuICogYWxvbmcgdGhlIHktYXhpcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBjeWxpbmRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGRvd24gdGhlIGN5bGluZGVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdG9wQ2FwXSBDcmVhdGUgdG9wIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQ3lsaW5kZXJWZXJ0aWNlcyhyYWRpdXMsIGhlaWdodCwgcmFkaWFsU3ViZGl2aXNpb25zLCB2ZXJ0aWNhbFN1YmRpdmlzaW9ucywgdG9wQ2FwLCBib3R0b21DYXApIHtcbiAgcmV0dXJuIGNyZWF0ZVRydW5jYXRlZENvbmVWZXJ0aWNlcyhyYWRpdXMsIHJhZGl1cywgaGVpZ2h0LCByYWRpYWxTdWJkaXZpc2lvbnMsIHZlcnRpY2FsU3ViZGl2aXNpb25zLCB0b3BDYXAsIGJvdHRvbUNhcCk7XG59XG4vKipcbiAqIENyZWF0ZXMgQnVmZmVySW5mbyBmb3IgYSB0b3J1c1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyByYWRpdXMgb2YgY2VudGVyIG9mIHRvcnVzIGNpcmNsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGlja25lc3MgcmFkaXVzIG9mIHRvcnVzIHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGUgdG9ydXMuXG4gKiBAcGFyYW0ge251bWJlcn0gYm9keVN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIGJvZHkgdG9ydXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFydEFuZ2xlXSBzdGFydCBhbmdsZSBpbiByYWRpYW5zLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuZEFuZ2xlXSBlbmQgYW5nbGUgaW4gcmFkaWFucy4gRGVmYXVsdCA9IE1hdGguUEkgKiAyLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlVG9ydXNCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGJ1ZmZlcnMgZm9yIGEgdG9ydXNcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgcmFkaXVzIG9mIGNlbnRlciBvZiB0b3J1cyBjaXJjbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIHJhZGl1cyBvZiB0b3J1cyByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIHRvcnVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvZHlTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZSBib2R5IHRvcnVzLlxuICogQHBhcmFtIHtib29sZWFufSBbc3RhcnRBbmdsZV0gc3RhcnQgYW5nbGUgaW4gcmFkaWFucy4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRBbmdsZV0gZW5kIGFuZ2xlIGluIHJhZGlhbnMuIERlZmF1bHQgPSBNYXRoLlBJICogMi5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVRvcnVzQnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyB2ZXJ0aWNlcyBmb3IgYSB0b3J1c1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgcmFkaXVzIG9mIGNlbnRlciBvZiB0b3J1cyBjaXJjbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIHJhZGl1cyBvZiB0b3J1cyByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIHRvcnVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvZHlTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZSBib2R5IHRvcnVzLlxuICogQHBhcmFtIHtib29sZWFufSBbc3RhcnRBbmdsZV0gc3RhcnQgYW5nbGUgaW4gcmFkaWFucy4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRBbmdsZV0gZW5kIGFuZ2xlIGluIHJhZGlhbnMuIERlZmF1bHQgPSBNYXRoLlBJICogMi5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlVG9ydXNWZXJ0aWNlcyhyYWRpdXMsIHRoaWNrbmVzcywgcmFkaWFsU3ViZGl2aXNpb25zLCBib2R5U3ViZGl2aXNpb25zLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkge1xuICBpZiAocmFkaWFsU3ViZGl2aXNpb25zIDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmFkaWFsU3ViZGl2aXNpb25zIG11c3QgYmUgMyBvciBncmVhdGVyJyk7XG4gIH1cblxuICBpZiAoYm9keVN1YmRpdmlzaW9ucyA8IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnRpY2FsU3ViZGl2aXNpb25zIG11c3QgYmUgMyBvciBncmVhdGVyJyk7XG4gIH1cblxuICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSB8fCAwO1xuICBlbmRBbmdsZSA9IGVuZEFuZ2xlIHx8IE1hdGguUEkgKiAyO1xuICB2YXIgcmFuZ2UgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gIHZhciByYWRpYWxQYXJ0cyA9IHJhZGlhbFN1YmRpdmlzaW9ucyArIDE7XG4gIHZhciBib2R5UGFydHMgPSBib2R5U3ViZGl2aXNpb25zICsgMTtcbiAgdmFyIG51bVZlcnRpY2VzID0gcmFkaWFsUGFydHMgKiBib2R5UGFydHM7XG4gIHZhciBwb3NpdGlvbnMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIG5vcm1hbHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIHRleGNvb3JkcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiwgbnVtVmVydGljZXMpO1xuICB2YXIgaW5kaWNlcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgcmFkaWFsU3ViZGl2aXNpb25zICogYm9keVN1YmRpdmlzaW9ucyAqIDIsIFVpbnQxNkFycmF5KTtcblxuICBmb3IgKHZhciBzbGljZSA9IDA7IHNsaWNlIDwgYm9keVBhcnRzOyArK3NsaWNlKSB7XG4gICAgdmFyIHYgPSBzbGljZSAvIGJvZHlTdWJkaXZpc2lvbnM7XG4gICAgdmFyIHNsaWNlQW5nbGUgPSB2ICogTWF0aC5QSSAqIDI7XG4gICAgdmFyIHNsaWNlU2luID0gTWF0aC5zaW4oc2xpY2VBbmdsZSk7XG4gICAgdmFyIHJpbmdSYWRpdXMgPSByYWRpdXMgKyBzbGljZVNpbiAqIHRoaWNrbmVzcztcbiAgICB2YXIgbnkgPSBNYXRoLmNvcyhzbGljZUFuZ2xlKTtcbiAgICB2YXIgeSA9IG55ICogdGhpY2tuZXNzO1xuXG4gICAgZm9yICh2YXIgcmluZyA9IDA7IHJpbmcgPCByYWRpYWxQYXJ0czsgKytyaW5nKSB7XG4gICAgICB2YXIgdSA9IHJpbmcgLyByYWRpYWxTdWJkaXZpc2lvbnM7XG4gICAgICB2YXIgcmluZ0FuZ2xlID0gc3RhcnRBbmdsZSArIHUgKiByYW5nZTtcbiAgICAgIHZhciB4U2luID0gTWF0aC5zaW4ocmluZ0FuZ2xlKTtcbiAgICAgIHZhciB6Q29zID0gTWF0aC5jb3MocmluZ0FuZ2xlKTtcbiAgICAgIHZhciB4ID0geFNpbiAqIHJpbmdSYWRpdXM7XG4gICAgICB2YXIgeiA9IHpDb3MgKiByaW5nUmFkaXVzO1xuICAgICAgdmFyIG54ID0geFNpbiAqIHNsaWNlU2luO1xuICAgICAgdmFyIG56ID0gekNvcyAqIHNsaWNlU2luO1xuICAgICAgcG9zaXRpb25zLnB1c2goeCwgeSwgeik7XG4gICAgICBub3JtYWxzLnB1c2gobngsIG55LCBueik7XG4gICAgICB0ZXhjb29yZHMucHVzaCh1LCAxIC0gdik7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3NsaWNlID0gMDsgX3NsaWNlIDwgYm9keVN1YmRpdmlzaW9uczsgKytfc2xpY2UpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZm9yICh2YXIgX3JpbmcgPSAwOyBfcmluZyA8IHJhZGlhbFN1YmRpdmlzaW9uczsgKytfcmluZykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgdmFyIG5leHRSaW5nSW5kZXggPSAxICsgX3Jpbmc7XG4gICAgICB2YXIgbmV4dFNsaWNlSW5kZXggPSAxICsgX3NsaWNlO1xuICAgICAgaW5kaWNlcy5wdXNoKHJhZGlhbFBhcnRzICogX3NsaWNlICsgX3JpbmcsIHJhZGlhbFBhcnRzICogbmV4dFNsaWNlSW5kZXggKyBfcmluZywgcmFkaWFsUGFydHMgKiBfc2xpY2UgKyBuZXh0UmluZ0luZGV4KTtcbiAgICAgIGluZGljZXMucHVzaChyYWRpYWxQYXJ0cyAqIG5leHRTbGljZUluZGV4ICsgX3JpbmcsIHJhZGlhbFBhcnRzICogbmV4dFNsaWNlSW5kZXggKyBuZXh0UmluZ0luZGV4LCByYWRpYWxQYXJ0cyAqIF9zbGljZSArIG5leHRSaW5nSW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9ucyxcbiAgICBub3JtYWw6IG5vcm1hbHMsXG4gICAgdGV4Y29vcmQ6IHRleGNvb3JkcyxcbiAgICBpbmRpY2VzOiBpbmRpY2VzXG4gIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBkaXNjIEJ1ZmZlckluZm8uIFRoZSBkaXNjIHdpbGwgYmUgaW4gdGhlIHh6IHBsYW5lLCBjZW50ZXJlZCBhdFxuICogdGhlIG9yaWdpbi4gV2hlbiBjcmVhdGluZywgYXQgbGVhc3QgMyBkaXZpc2lvbnMsIG9yIHBpZVxuICogcGllY2VzLCBuZWVkIHRvIGJlIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHRoZSB0cmlhbmdsZXMgbWFraW5nXG4gKiB1cCB0aGUgZGlzYyB3aWxsIGJlIGRlZ2VuZXJhdGUuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IHRoZVxuICogbnVtYmVyIG9mIHJhZGlhbCBwaWVjZXMgYHN0YWNrc2AuIEEgdmFsdWUgb2YgMSBmb3JcbiAqIHN0YWNrcyB3aWxsIGdpdmUgeW91IGEgc2ltcGxlIGRpc2Mgb2YgcGllIHBpZWNlcy4gIElmIHlvdVxuICogd2FudCB0byBjcmVhdGUgYW4gYW5udWx1cyB5b3UgY2FuIHNldCBgaW5uZXJSYWRpdXNgIHRvIGFcbiAqIHZhbHVlID4gMC4gRmluYWxseSwgYHN0YWNrUG93ZXJgIGFsbG93cyB5b3UgdG8gaGF2ZSB0aGUgd2lkdGhzXG4gKiBpbmNyZWFzZSBvciBkZWNyZWFzZSBhcyB5b3UgbW92ZSBhd2F5IGZyb20gdGhlIGNlbnRlci4gVGhpc1xuICogaXMgcGFydGljdWxhcmx5IHVzZWZ1bCB3aGVuIHVzaW5nIHRoZSBkaXNjIGFzIGEgZ3JvdW5kIHBsYW5lXG4gKiB3aXRoIGEgZml4ZWQgY2FtZXJhIHN1Y2ggdGhhdCB5b3UgZG9uJ3QgbmVlZCB0aGUgcmVzb2x1dGlvblxuICogb2Ygc21hbGwgdHJpYW5nbGVzIG5lYXIgdGhlIHBlcmltZXRlci4gRm9yIGV4YW1wbGUsIGEgdmFsdWVcbiAqIG9mIDIgd2lsbCBwcm9kdWNlIHN0YWNrcyB3aG9zZSBvdXRzaWRlIHJhZGl1cyBpbmNyZWFzZXMgd2l0aFxuICogdGhlIHNxdWFyZSBvZiB0aGUgc3RhY2sgaW5kZXguIEEgdmFsdWUgb2YgMSB3aWxsIGdpdmUgdW5pZm9ybVxuICogc3RhY2tzLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgdGhlIGdyb3VuZCBwbGFuZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpc2lvbnMgTnVtYmVyIG9mIHRyaWFuZ2xlcyBpbiB0aGUgZ3JvdW5kIHBsYW5lIChhdCBsZWFzdCAzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhY2tzXSBOdW1iZXIgb2YgcmFkaWFsIGRpdmlzaW9ucyAoZGVmYXVsdD0xKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5uZXJSYWRpdXNdIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhY2tQb3dlcl0gUG93ZXIgdG8gcmFpc2Ugc3RhY2sgc2l6ZSB0byBmb3IgZGVjcmVhc2luZyB3aWR0aC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZURpc2NCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGRpc2MgYnVmZmVycy4gVGhlIGRpc2Mgd2lsbCBiZSBpbiB0aGUgeHogcGxhbmUsIGNlbnRlcmVkIGF0XG4gKiB0aGUgb3JpZ2luLiBXaGVuIGNyZWF0aW5nLCBhdCBsZWFzdCAzIGRpdmlzaW9ucywgb3IgcGllXG4gKiBwaWVjZXMsIG5lZWQgdG8gYmUgc3BlY2lmaWVkLCBvdGhlcndpc2UgdGhlIHRyaWFuZ2xlcyBtYWtpbmdcbiAqIHVwIHRoZSBkaXNjIHdpbGwgYmUgZGVnZW5lcmF0ZS4gWW91IGNhbiBhbHNvIHNwZWNpZnkgdGhlXG4gKiBudW1iZXIgb2YgcmFkaWFsIHBpZWNlcyBgc3RhY2tzYC4gQSB2YWx1ZSBvZiAxIGZvclxuICogc3RhY2tzIHdpbGwgZ2l2ZSB5b3UgYSBzaW1wbGUgZGlzYyBvZiBwaWUgcGllY2VzLiAgSWYgeW91XG4gKiB3YW50IHRvIGNyZWF0ZSBhbiBhbm51bHVzIHlvdSBjYW4gc2V0IGBpbm5lclJhZGl1c2AgdG8gYVxuICogdmFsdWUgPiAwLiBGaW5hbGx5LCBgc3RhY2tQb3dlcmAgYWxsb3dzIHlvdSB0byBoYXZlIHRoZSB3aWR0aHNcbiAqIGluY3JlYXNlIG9yIGRlY3JlYXNlIGFzIHlvdSBtb3ZlIGF3YXkgZnJvbSB0aGUgY2VudGVyLiBUaGlzXG4gKiBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gdXNpbmcgdGhlIGRpc2MgYXMgYSBncm91bmQgcGxhbmVcbiAqIHdpdGggYSBmaXhlZCBjYW1lcmEgc3VjaCB0aGF0IHlvdSBkb24ndCBuZWVkIHRoZSByZXNvbHV0aW9uXG4gKiBvZiBzbWFsbCB0cmlhbmdsZXMgbmVhciB0aGUgcGVyaW1ldGVyLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZVxuICogb2YgMiB3aWxsIHByb2R1Y2Ugc3RhY2tzIHdob3NlIG91dHNpZGUgcmFkaXVzIGluY3JlYXNlcyB3aXRoXG4gKiB0aGUgc3F1YXJlIG9mIHRoZSBzdGFjayBpbmRleC4gQSB2YWx1ZSBvZiAxIHdpbGwgZ2l2ZSB1bmlmb3JtXG4gKiBzdGFja3MuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgZ3JvdW5kIHBsYW5lLlxuICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzaW9ucyBOdW1iZXIgb2YgdHJpYW5nbGVzIGluIHRoZSBncm91bmQgcGxhbmUgKGF0IGxlYXN0IDMpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja3NdIE51bWJlciBvZiByYWRpYWwgZGl2aXNpb25zIChkZWZhdWx0PTEpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtpbm5lclJhZGl1c10gRGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja1Bvd2VyXSBQb3dlciB0byByYWlzZSBzdGFjayBzaXplIHRvIGZvciBkZWNyZWFzaW5nIHdpZHRoLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFdlYkdMQnVmZmVyPn0gVGhlIGNyZWF0ZWQgYnVmZmVycy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlRGlzY0J1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgZGlzYyB2ZXJ0aWNlcy4gVGhlIGRpc2Mgd2lsbCBiZSBpbiB0aGUgeHogcGxhbmUsIGNlbnRlcmVkIGF0XG4gKiB0aGUgb3JpZ2luLiBXaGVuIGNyZWF0aW5nLCBhdCBsZWFzdCAzIGRpdmlzaW9ucywgb3IgcGllXG4gKiBwaWVjZXMsIG5lZWQgdG8gYmUgc3BlY2lmaWVkLCBvdGhlcndpc2UgdGhlIHRyaWFuZ2xlcyBtYWtpbmdcbiAqIHVwIHRoZSBkaXNjIHdpbGwgYmUgZGVnZW5lcmF0ZS4gWW91IGNhbiBhbHNvIHNwZWNpZnkgdGhlXG4gKiBudW1iZXIgb2YgcmFkaWFsIHBpZWNlcyBgc3RhY2tzYC4gQSB2YWx1ZSBvZiAxIGZvclxuICogc3RhY2tzIHdpbGwgZ2l2ZSB5b3UgYSBzaW1wbGUgZGlzYyBvZiBwaWUgcGllY2VzLiAgSWYgeW91XG4gKiB3YW50IHRvIGNyZWF0ZSBhbiBhbm51bHVzIHlvdSBjYW4gc2V0IGBpbm5lclJhZGl1c2AgdG8gYVxuICogdmFsdWUgPiAwLiBGaW5hbGx5LCBgc3RhY2tQb3dlcmAgYWxsb3dzIHlvdSB0byBoYXZlIHRoZSB3aWR0aHNcbiAqIGluY3JlYXNlIG9yIGRlY3JlYXNlIGFzIHlvdSBtb3ZlIGF3YXkgZnJvbSB0aGUgY2VudGVyLiBUaGlzXG4gKiBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gdXNpbmcgdGhlIGRpc2MgYXMgYSBncm91bmQgcGxhbmVcbiAqIHdpdGggYSBmaXhlZCBjYW1lcmEgc3VjaCB0aGF0IHlvdSBkb24ndCBuZWVkIHRoZSByZXNvbHV0aW9uXG4gKiBvZiBzbWFsbCB0cmlhbmdsZXMgbmVhciB0aGUgcGVyaW1ldGVyLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZVxuICogb2YgMiB3aWxsIHByb2R1Y2Ugc3RhY2tzIHdob3NlIG91dHNpZGUgcmFkaXVzIGluY3JlYXNlcyB3aXRoXG4gKiB0aGUgc3F1YXJlIG9mIHRoZSBzdGFjayBpbmRleC4gQSB2YWx1ZSBvZiAxIHdpbGwgZ2l2ZSB1bmlmb3JtXG4gKiBzdGFja3MuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgdGhlIGdyb3VuZCBwbGFuZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpc2lvbnMgTnVtYmVyIG9mIHRyaWFuZ2xlcyBpbiB0aGUgZ3JvdW5kIHBsYW5lIChhdCBsZWFzdCAzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhY2tzXSBOdW1iZXIgb2YgcmFkaWFsIGRpdmlzaW9ucyAoZGVmYXVsdD0xKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5uZXJSYWRpdXNdIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhY2tQb3dlcl0gUG93ZXIgdG8gcmFpc2Ugc3RhY2sgc2l6ZSB0byBmb3IgZGVjcmVhc2luZyB3aWR0aC5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRGlzY1ZlcnRpY2VzKHJhZGl1cywgZGl2aXNpb25zLCBzdGFja3MsIGlubmVyUmFkaXVzLCBzdGFja1Bvd2VyKSB7XG4gIGlmIChkaXZpc2lvbnMgPCAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaXZpc2lvbnMgbXVzdCBiZSBhdCBsZWFzdCAzJyk7XG4gIH1cblxuICBzdGFja3MgPSBzdGFja3MgPyBzdGFja3MgOiAxO1xuICBzdGFja1Bvd2VyID0gc3RhY2tQb3dlciA/IHN0YWNrUG93ZXIgOiAxO1xuICBpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzID8gaW5uZXJSYWRpdXMgOiAwOyAvLyBOb3RlOiBXZSBkb24ndCBzaGFyZSB0aGUgY2VudGVyIHZlcnRleCBiZWNhdXNlIHRoYXQgd291bGRcbiAgLy8gbWVzcyB1cCB0ZXh0dXJlIGNvb3JkaW5hdGVzLlxuXG4gIHZhciBudW1WZXJ0aWNlcyA9IChkaXZpc2lvbnMgKyAxKSAqIChzdGFja3MgKyAxKTtcbiAgdmFyIHBvc2l0aW9ucyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICB2YXIgbm9ybWFscyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICB2YXIgdGV4Y29vcmRzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyLCBudW1WZXJ0aWNlcyk7XG4gIHZhciBpbmRpY2VzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBzdGFja3MgKiBkaXZpc2lvbnMgKiAyLCBVaW50MTZBcnJheSk7XG4gIHZhciBmaXJzdEluZGV4ID0gMDtcbiAgdmFyIHJhZGl1c1NwYW4gPSByYWRpdXMgLSBpbm5lclJhZGl1cztcbiAgdmFyIHBvaW50c1BlclN0YWNrID0gZGl2aXNpb25zICsgMTsgLy8gQnVpbGQgdGhlIGRpc2sgb25lIHN0YWNrIGF0IGEgdGltZS5cblxuICBmb3IgKHZhciBzdGFjayA9IDA7IHN0YWNrIDw9IHN0YWNrczsgKytzdGFjaykge1xuICAgIHZhciBzdGFja1JhZGl1cyA9IGlubmVyUmFkaXVzICsgcmFkaXVzU3BhbiAqIE1hdGgucG93KHN0YWNrIC8gc3RhY2tzLCBzdGFja1Bvd2VyKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGRpdmlzaW9uczsgKytpKSB7XG4gICAgICB2YXIgdGhldGEgPSAyLjAgKiBNYXRoLlBJICogaSAvIGRpdmlzaW9ucztcbiAgICAgIHZhciB4ID0gc3RhY2tSYWRpdXMgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICB2YXIgeiA9IHN0YWNrUmFkaXVzICogTWF0aC5zaW4odGhldGEpO1xuICAgICAgcG9zaXRpb25zLnB1c2goeCwgMCwgeik7XG4gICAgICBub3JtYWxzLnB1c2goMCwgMSwgMCk7XG4gICAgICB0ZXhjb29yZHMucHVzaCgxIC0gaSAvIGRpdmlzaW9ucywgc3RhY2sgLyBzdGFja3MpO1xuXG4gICAgICBpZiAoc3RhY2sgPiAwICYmIGkgIT09IGRpdmlzaW9ucykge1xuICAgICAgICAvLyBhLCBiLCBjIGFuZCBkIGFyZSB0aGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXMgb2YgYSBxdWFkLiAgdW5sZXNzXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHN0YWNrIGlzIHRoZSBvbmUgY2xvc2VzdCB0byB0aGUgY2VudGVyLCBpbiB3aGljaCBjYXNlXG4gICAgICAgIC8vIHRoZSB2ZXJ0aWNlcyBhIGFuZCBiIGNvbm5lY3QgdG8gdGhlIGNlbnRlciB2ZXJ0ZXguXG4gICAgICAgIHZhciBhID0gZmlyc3RJbmRleCArIChpICsgMSk7XG4gICAgICAgIHZhciBiID0gZmlyc3RJbmRleCArIGk7XG4gICAgICAgIHZhciBjID0gZmlyc3RJbmRleCArIGkgLSBwb2ludHNQZXJTdGFjaztcbiAgICAgICAgdmFyIGQgPSBmaXJzdEluZGV4ICsgKGkgKyAxKSAtIHBvaW50c1BlclN0YWNrOyAvLyBNYWtlIGEgcXVhZCBvZiB0aGUgdmVydGljZXMgYSwgYiwgYywgZC5cblxuICAgICAgICBpbmRpY2VzLnB1c2goYSwgYiwgYyk7XG4gICAgICAgIGluZGljZXMucHVzaChhLCBjLCBkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaXJzdEluZGV4ICs9IGRpdmlzaW9ucyArIDE7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbnMsXG4gICAgbm9ybWFsOiBub3JtYWxzLFxuICAgIHRleGNvb3JkOiB0ZXhjb29yZHMsXG4gICAgaW5kaWNlczogaW5kaWNlc1xuICB9O1xufVxuLyoqXG4gKiBjcmVhdGVzIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiAwIGFuZCByYW5nZSAtIDEgaW5jbHVzaXZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHJhbmRvbSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIHJhbmdlIC0gMSBpbmNsdXNpdmUuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gcmFuZEludChyYW5nZSkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIHJhbmdlIHwgMDtcbn1cbi8qKlxuICogVXNlZCB0byBzdXBwbHkgcmFuZG9tIGNvbG9yc1xuICogQGNhbGxiYWNrIFJhbmRvbUNvbG9yRnVuY1xuICogQHBhcmFtIHtudW1iZXJ9IG5keCBpbmRleCBvZiB0cmlhbmdsZS9xdWFkIGlmIHVuaW5kZXhlZCBvciBpbmRleCBvZiB2ZXJ0ZXggaWYgaW5kZXhlZFxuICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWwgMCA9IHJlZCwgMSA9IGdyZWVuLCAyID0gYmx1ZSwgMyA9IGFscGhhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEgbnVtYmVyIGZyb20gMCB0byAyNTVcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSYW5kb21WZXJ0aWNlc09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmVydHNQZXJDb2xvcl0gRGVmYXVsdHMgdG8gMyBmb3Igbm9uLWluZGV4ZWQgdmVydGljZXNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnR3Z2wvcHJpbWl0aXZlcy5SYW5kb21Db2xvckZ1bmN9IFtyYW5kXSBBIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHJhbmRvbSBudW1iZXJzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhdWdtZW50ZWRUeXBlZEFycmF5IG9mIHJhbmRvbSB2ZXJ0ZXggY29sb3JzLlxuICogSWYgdGhlIHZlcnRpY2VzIGFyZSBpbmRleGVkIChoYXZlIGFuIGluZGljZXMgYXJyYXkpIHRoZW4gd2lsbFxuICoganVzdCBtYWtlIHJhbmRvbSBjb2xvcnMuIE90aGVyd2lzZSBhc3N1bWVzIHRoZXkgYXJlIHRyaWFuZ2xlc1xuICogYW5kIG1ha2VzIG9uZSByYW5kb20gY29sb3IgZm9yIGV2ZXJ5IDMgdmVydGljZXMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBBdWdtZW50ZWRUeXBlZEFycmF5Pn0gdmVydGljZXMgVmVydGljZXMgYXMgcmV0dXJuZWQgZnJvbSBvbmUgb2YgdGhlIGNyZWF0ZVhYWFZlcnRpY2VzIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvcHJpbWl0aXZlcy5SYW5kb21WZXJ0aWNlc09wdGlvbnN9IFtvcHRpb25zXSBvcHRpb25zLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIEF1Z21lbnRlZFR5cGVkQXJyYXk+fSBzYW1lIHZlcnRpY2VzIGFzIHBhc3NlZCBpbiB3aXRoIGBjb2xvcmAgYWRkZWQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gbWFrZVJhbmRvbVZlcnRleENvbG9ycyh2ZXJ0aWNlcywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG51bUVsZW1lbnRzID0gdmVydGljZXMucG9zaXRpb24ubnVtRWxlbWVudHM7XG4gIHZhciB2Q29sb3JzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSg0LCBudW1FbGVtZW50cywgVWludDhBcnJheSk7XG5cbiAgdmFyIHJhbmQgPSBvcHRpb25zLnJhbmQgfHwgZnVuY3Rpb24gKG5keCwgY2hhbm5lbCkge1xuICAgIHJldHVybiBjaGFubmVsIDwgMyA/IHJhbmRJbnQoMjU2KSA6IDI1NTtcbiAgfTtcblxuICB2ZXJ0aWNlcy5jb2xvciA9IHZDb2xvcnM7XG5cbiAgaWYgKHZlcnRpY2VzLmluZGljZXMpIHtcbiAgICAvLyBqdXN0IG1ha2UgcmFuZG9tIGNvbG9ycyBpZiBpbmRleFxuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1FbGVtZW50czsgKytpaSkge1xuICAgICAgdkNvbG9ycy5wdXNoKHJhbmQoaWksIDApLCByYW5kKGlpLCAxKSwgcmFuZChpaSwgMiksIHJhbmQoaWksIDMpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFrZSByYW5kb20gY29sb3JzIHBlciB0cmlhbmdsZVxuICAgIHZhciBudW1WZXJ0c1BlckNvbG9yID0gb3B0aW9ucy52ZXJ0c1BlckNvbG9yIHx8IDM7XG4gICAgdmFyIG51bVNldHMgPSBudW1FbGVtZW50cyAvIG51bVZlcnRzUGVyQ29sb3I7XG5cbiAgICBmb3IgKHZhciBfaWkyID0gMDsgX2lpMiA8IG51bVNldHM7ICsrX2lpMikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgdmFyIGNvbG9yID0gW3JhbmQoX2lpMiwgMCksIHJhbmQoX2lpMiwgMSksIHJhbmQoX2lpMiwgMiksIHJhbmQoX2lpMiwgMyldO1xuXG4gICAgICBmb3IgKHZhciBqaiA9IDA7IGpqIDwgbnVtVmVydHNQZXJDb2xvcjsgKytqaikge1xuICAgICAgICB2Q29sb3JzLnB1c2goY29sb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2ZXJ0aWNlcztcbn1cbi8qKlxuICogY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgZm4gdG8gY3JlYXRlIHZlcnRpY2VzIGFuZCB0aGVuXG4gKiBjcmVhdGVzIGEgYnVmZmVycyBmb3IgdGhlbVxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlckZ1bmMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChnbCkge1xuICAgIHZhciBhcnJheXMgPSBmbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICByZXR1cm4gYXR0cmlidXRlcy5jcmVhdGVCdWZmZXJzRnJvbUFycmF5cyhnbCwgYXJyYXlzKTtcbiAgfTtcbn1cbi8qKlxuICogY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgZm4gdG8gY3JlYXRlIHZlcnRpY2VzIGFuZCB0aGVuXG4gKiBjcmVhdGVzIGEgYnVmZmVySW5mbyBvYmplY3QgZm9yIHRoZW1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXJJbmZvRnVuYyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGdsKSB7XG4gICAgdmFyIGFycmF5cyA9IGZuLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHJldHVybiBhdHRyaWJ1dGVzLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzKGdsLCBhcnJheXMpO1xuICB9O1xufVxuXG52YXIgYXJyYXlTcGVjUHJvcGVydHlOYW1lcyA9IFtcIm51bUNvbXBvbmVudHNcIiwgXCJzaXplXCIsIFwidHlwZVwiLCBcIm5vcm1hbGl6ZVwiLCBcInN0cmlkZVwiLCBcIm9mZnNldFwiLCBcImF0dHJpYlwiLCBcIm5hbWVcIiwgXCJhdHRyaWJOYW1lXCJdO1xuLyoqXG4gKiBDb3B5IGVsZW1lbnRzIGZyb20gb25lIGFycmF5IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IHNyYyBzb3VyY2UgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl8VHlwZWRBcnJheX0gZHN0IGRlc3QgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkc3ROZHggaW5kZXggaW4gZGVzdCB0byBjb3B5IHNyY1xuICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRdIG9mZnNldCB0byBhZGQgdG8gY29waWVkIHZhbHVlc1xuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb3B5RWxlbWVudHMoc3JjLCBkc3QsIGRzdE5keCwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgbGVuZ3RoID0gc3JjLmxlbmd0aDtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuZ3RoOyArK2lpKSB7XG4gICAgZHN0W2RzdE5keCArIGlpXSA9IHNyY1tpaV0gKyBvZmZzZXQ7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgc2FtZSB0aW1lXG4gKlxuICogQHBhcmFtIHsobnVtYmVyW118QXJyYXlCdWZmZXJWaWV3fG1vZHVsZTp0d2dsLkZ1bGxBcnJheVNwZWMpfSBzcmNBcnJheSBhcnJheSB3aG8ncyB0eXBlIHRvIGNvcHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggc2l6ZSBvZiBuZXcgYXJyYXlcbiAqIEByZXR1cm4geyhudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd8bW9kdWxlOnR3Z2wuRnVsbEFycmF5U3BlYyl9IGFycmF5IHdpdGggc2FtZSB0eXBlIGFzIHNyY0FycmF5XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlNhbWVUeXBlKHNyY0FycmF5LCBsZW5ndGgpIHtcbiAgdmFyIGFycmF5U3JjID0gZ2V0QXJyYXkoc3JjQXJyYXkpO1xuICB2YXIgbmV3QXJyYXkgPSBuZXcgYXJyYXlTcmMuY29uc3RydWN0b3IobGVuZ3RoKTtcbiAgdmFyIG5ld0FycmF5U3BlYyA9IG5ld0FycmF5OyAvLyBJZiBpdCBhcHBlYXJzIHRvIGhhdmUgYmVlbiBhdWdtZW50ZWQgbWFrZSBuZXcgb25lIGF1Z21lbnRlZFxuXG4gIGlmIChhcnJheVNyYy5udW1Db21wb25lbnRzICYmIGFycmF5U3JjLm51bUVsZW1lbnRzKSB7XG4gICAgYXVnbWVudFR5cGVkQXJyYXkobmV3QXJyYXksIGFycmF5U3JjLm51bUNvbXBvbmVudHMpO1xuICB9IC8vIElmIGl0IHdhcyBhIGZ1bGwgc3BlYyBtYWtlIG5ldyBvbmUgYSBmdWxsIHNwZWNcblxuXG4gIGlmIChzcmNBcnJheS5kYXRhKSB7XG4gICAgbmV3QXJyYXlTcGVjID0ge1xuICAgICAgZGF0YTogbmV3QXJyYXlcbiAgICB9O1xuICAgIGhlbHBlci5jb3B5TmFtZWRQcm9wZXJ0aWVzKGFycmF5U3BlY1Byb3BlcnR5TmFtZXMsIHNyY0FycmF5LCBuZXdBcnJheVNwZWMpO1xuICB9XG5cbiAgcmV0dXJuIG5ld0FycmF5U3BlYztcbn1cbi8qKlxuICogQ29uY2F0ZW5hdGVzIHNldHMgb2YgdmVydGljZXNcbiAqXG4gKiBBc3N1bWVzIHRoZSB2ZXJ0aWNlcyBtYXRjaCBpbiBjb21wb3NpdGlvbi4gRm9yIGV4YW1wbGVcbiAqIGlmIG9uZSBzZXQgb2YgdmVydGljZXMgaGFzIHBvc2l0aW9ucywgbm9ybWFscywgYW5kIGluZGljZXNcbiAqIGFsbCBzZXRzIG9mIHZlcnRpY2VzIG11c3QgaGF2ZSBwb3NpdGlvbnMsIG5vcm1hbHMsIGFuZCBpbmRpY2VzXG4gKiBhbmQgb2YgdGhlIHNhbWUgdHlwZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgY29uc3QgY3ViZVZlcnRpY2VzID0gdHdnbC5wcmltaXRpdmVzLmNyZWF0ZUN1YmVWZXJ0aWNlcygyKTtcbiAqICAgICAgY29uc3Qgc3BoZXJlVmVydGljZXMgPSB0d2dsLnByaW1pdGl2ZXMuY3JlYXRlU3BoZXJlVmVydGljZXMoMSwgMTAsIDEwKTtcbiAqICAgICAgLy8gbW92ZSB0aGUgc3BoZXJlIDIgdW5pdHMgdXBcbiAqICAgICAgdHdnbC5wcmltaXRpdmVzLnJlb3JpZW50VmVydGljZXMoXG4gKiAgICAgICAgICBzcGhlcmVWZXJ0aWNlcywgdHdnbC5tNC50cmFuc2xhdGlvbihbMCwgMiwgMF0pKTtcbiAqICAgICAgLy8gbWVyZ2UgdGhlIHNwaGVyZSB3aXRoIHRoZSBjdWJlXG4gKiAgICAgIGNvbnN0IGN1YmVTcGhlcmVWZXJ0aWNlcyA9IHR3Z2wucHJpbWl0aXZlcy5jb25jYXRWZXJ0aWNlcyhcbiAqICAgICAgICAgIFtjdWJlVmVydGljZXMsIHNwaGVyZVZlcnRpY2VzXSk7XG4gKiAgICAgIC8vIHR1cm4gdGhlbSBpbnRvIFdlYkdMIGJ1ZmZlcnMgYW5kIGF0dHJpYiBkYXRhXG4gKiAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzKGdsLCBjdWJlU3BoZXJlVmVydGljZXMpO1xuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQXJyYXlzW119IGFycmF5cyBBcnJheSBvZiBhcnJheXMgb2YgdmVydGljZXNcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkFycmF5c30gVGhlIGNvbmNhdGVuYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuXG5mdW5jdGlvbiBjb25jYXRWZXJ0aWNlcyhhcnJheU9mQXJyYXlzKSB7XG4gIHZhciBuYW1lcyA9IHt9O1xuICB2YXIgYmFzZU5hbWU7IC8vIGdldCBuYW1lcyBvZiBhbGwgYXJyYXlzLlxuICAvLyBhbmQgbnVtRWxlbWVudHMgZm9yIGVhY2ggc2V0IG9mIHZlcnRpY2VzXG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaWkpIHtcbiAgICB2YXIgYXJyYXlzID0gYXJyYXlPZkFycmF5c1tpaV07XG4gICAgT2JqZWN0LmtleXMoYXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpZiAoIW5hbWVzW25hbWVdKSB7XG4gICAgICAgIG5hbWVzW25hbWVdID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICghYmFzZU5hbWUgJiYgbmFtZSAhPT0gJ2luZGljZXMnKSB7XG4gICAgICAgIGJhc2VOYW1lID0gbmFtZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFycmF5SW5mbyA9IGFycmF5c1tuYW1lXTtcbiAgICAgIHZhciBudW1Db21wb25lbnRzID0gZ2V0TnVtQ29tcG9uZW50cyhhcnJheUluZm8sIG5hbWUpO1xuICAgICAgdmFyIGFycmF5ID0gZ2V0QXJyYXkoYXJyYXlJbmZvKTtcbiAgICAgIHZhciBudW1FbGVtZW50cyA9IGFycmF5Lmxlbmd0aCAvIG51bUNvbXBvbmVudHM7XG4gICAgICBuYW1lc1tuYW1lXS5wdXNoKG51bUVsZW1lbnRzKTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgYXJyYXlPZkFycmF5cy5sZW5ndGg7ICsraWkpIHtcbiAgICBfbG9vcChpaSk7XG4gIH0gLy8gY29tcHV0ZSBsZW5ndGggb2YgY29tYmluZWQgYXJyYXlcbiAgLy8gYW5kIHJldHVybiBvbmUgZm9yIHJlZmVyZW5jZVxuXG5cbiAgZnVuY3Rpb24gZ2V0TGVuZ3RoT2ZDb21iaW5lZEFycmF5cyhuYW1lKSB7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgdmFyIGFycmF5U3BlYztcblxuICAgIGZvciAodmFyIF9paTMgPSAwOyBfaWkzIDwgYXJyYXlPZkFycmF5cy5sZW5ndGg7ICsrX2lpMykge1xuICAgICAgdmFyIGFycmF5cyA9IGFycmF5T2ZBcnJheXNbX2lpM107XG4gICAgICB2YXIgYXJyYXlJbmZvID0gYXJyYXlzW25hbWVdO1xuICAgICAgdmFyIGFycmF5ID0gZ2V0QXJyYXkoYXJyYXlJbmZvKTtcbiAgICAgIGxlbmd0aCArPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmICghYXJyYXlTcGVjIHx8IGFycmF5SW5mby5kYXRhKSB7XG4gICAgICAgIGFycmF5U3BlYyA9IGFycmF5SW5mbztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICBzcGVjOiBhcnJheVNwZWNcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29weUFycmF5c1RvTmV3QXJyYXkobmFtZSwgYmFzZSwgbmV3QXJyYXkpIHtcbiAgICB2YXIgYmFzZUluZGV4ID0gMDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGZvciAodmFyIF9paTQgPSAwOyBfaWk0IDwgYXJyYXlPZkFycmF5cy5sZW5ndGg7ICsrX2lpNCkge1xuICAgICAgdmFyIGFycmF5cyA9IGFycmF5T2ZBcnJheXNbX2lpNF07XG4gICAgICB2YXIgYXJyYXlJbmZvID0gYXJyYXlzW25hbWVdO1xuICAgICAgdmFyIGFycmF5ID0gZ2V0QXJyYXkoYXJyYXlJbmZvKTtcblxuICAgICAgaWYgKG5hbWUgPT09ICdpbmRpY2VzJykge1xuICAgICAgICBjb3B5RWxlbWVudHMoYXJyYXksIG5ld0FycmF5LCBvZmZzZXQsIGJhc2VJbmRleCk7XG4gICAgICAgIGJhc2VJbmRleCArPSBiYXNlW19paTRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weUVsZW1lbnRzKGFycmF5LCBuZXdBcnJheSwgb2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0ICs9IGFycmF5Lmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9IG5hbWVzW2Jhc2VOYW1lXTtcbiAgdmFyIG5ld0FycmF5cyA9IHt9O1xuICBPYmplY3Qua2V5cyhuYW1lcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpbmZvID0gZ2V0TGVuZ3RoT2ZDb21iaW5lZEFycmF5cyhuYW1lKTtcbiAgICB2YXIgbmV3QXJyYXlTcGVjID0gY3JlYXRlQXJyYXlPZlNhbWVUeXBlKGluZm8uc3BlYywgaW5mby5sZW5ndGgpO1xuICAgIGNvcHlBcnJheXNUb05ld0FycmF5KG5hbWUsIGJhc2UsIGdldEFycmF5KG5ld0FycmF5U3BlYykpO1xuICAgIG5ld0FycmF5c1tuYW1lXSA9IG5ld0FycmF5U3BlYztcbiAgfSk7XG4gIHJldHVybiBuZXdBcnJheXM7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBkdXBsaWNhdGUgc2V0IG9mIHZlcnRpY2VzXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNhbGxpbmcgcmVvcmllbnRWZXJ0aWNlcyB3aGVuIHlvdVxuICogYWxzbyB3YW50IHRvIGtlZXAgdGhlIG9yaWdpbmFsIGF2YWlsYWJsZVxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQXJyYXlzfSBhcnJheXMgb2YgdmVydGljZXNcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkFycmF5c30gVGhlIGR1cGxpY2F0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gZHVwbGljYXRlVmVydGljZXMoYXJyYXlzKSB7XG4gIHZhciBuZXdBcnJheXMgPSB7fTtcbiAgT2JqZWN0LmtleXMoYXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGFycmF5U3BlYyA9IGFycmF5c1tuYW1lXTtcbiAgICB2YXIgc3JjQXJyYXkgPSBnZXRBcnJheShhcnJheVNwZWMpO1xuICAgIHZhciBuZXdBcnJheVNwZWMgPSBjcmVhdGVBcnJheU9mU2FtZVR5cGUoYXJyYXlTcGVjLCBzcmNBcnJheS5sZW5ndGgpO1xuICAgIGNvcHlFbGVtZW50cyhzcmNBcnJheSwgZ2V0QXJyYXkobmV3QXJyYXlTcGVjKSwgMCk7XG4gICAgbmV3QXJyYXlzW25hbWVdID0gbmV3QXJyYXlTcGVjO1xuICB9KTtcbiAgcmV0dXJuIG5ld0FycmF5cztcbn1cblxudmFyIGNyZWF0ZTNERkJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGUzREZWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZTNERkJ1ZmZlckluZm8gPSBjcmVhdGUzREZCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZTNERkJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZTNERlZlcnRpY2VzKTtcbmV4cG9ydHMuY3JlYXRlM0RGQnVmZmVycyA9IGNyZWF0ZTNERkJ1ZmZlcnM7XG52YXIgY3JlYXRlQ3ViZUJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVDdWJlVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVDdWJlQnVmZmVySW5mbyA9IGNyZWF0ZUN1YmVCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZUN1YmVCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVDdWJlVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVDdWJlQnVmZmVycyA9IGNyZWF0ZUN1YmVCdWZmZXJzO1xudmFyIGNyZWF0ZVBsYW5lQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZVBsYW5lVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVQbGFuZUJ1ZmZlckluZm8gPSBjcmVhdGVQbGFuZUJ1ZmZlckluZm87XG52YXIgY3JlYXRlUGxhbmVCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVQbGFuZVZlcnRpY2VzKTtcbmV4cG9ydHMuY3JlYXRlUGxhbmVCdWZmZXJzID0gY3JlYXRlUGxhbmVCdWZmZXJzO1xudmFyIGNyZWF0ZVNwaGVyZUJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVTcGhlcmVWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZVNwaGVyZUJ1ZmZlckluZm8gPSBjcmVhdGVTcGhlcmVCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZVNwaGVyZUJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZVNwaGVyZVZlcnRpY2VzKTtcbmV4cG9ydHMuY3JlYXRlU3BoZXJlQnVmZmVycyA9IGNyZWF0ZVNwaGVyZUJ1ZmZlcnM7XG52YXIgY3JlYXRlVHJ1bmNhdGVkQ29uZUJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVUcnVuY2F0ZWRDb25lVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVySW5mbyA9IGNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVUcnVuY2F0ZWRDb25lVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVycyA9IGNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJzO1xudmFyIGNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVYWVF1YWRWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8gPSBjcmVhdGVYWVF1YWRCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZVhZUXVhZEJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZVhZUXVhZFZlcnRpY2VzKTtcbmV4cG9ydHMuY3JlYXRlWFlRdWFkQnVmZmVycyA9IGNyZWF0ZVhZUXVhZEJ1ZmZlcnM7XG52YXIgY3JlYXRlQ3Jlc2NlbnRCdWZmZXJJbmZvID0gY3JlYXRlQnVmZmVySW5mb0Z1bmMoY3JlYXRlQ3Jlc2NlbnRWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZUNyZXNjZW50QnVmZmVySW5mbyA9IGNyZWF0ZUNyZXNjZW50QnVmZmVySW5mbztcbnZhciBjcmVhdGVDcmVzY2VudEJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZUNyZXNjZW50VmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVDcmVzY2VudEJ1ZmZlcnMgPSBjcmVhdGVDcmVzY2VudEJ1ZmZlcnM7XG52YXIgY3JlYXRlQ3lsaW5kZXJCdWZmZXJJbmZvID0gY3JlYXRlQnVmZmVySW5mb0Z1bmMoY3JlYXRlQ3lsaW5kZXJWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZUN5bGluZGVyQnVmZmVySW5mbyA9IGNyZWF0ZUN5bGluZGVyQnVmZmVySW5mbztcbnZhciBjcmVhdGVDeWxpbmRlckJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZUN5bGluZGVyVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVDeWxpbmRlckJ1ZmZlcnMgPSBjcmVhdGVDeWxpbmRlckJ1ZmZlcnM7XG52YXIgY3JlYXRlVG9ydXNCdWZmZXJJbmZvID0gY3JlYXRlQnVmZmVySW5mb0Z1bmMoY3JlYXRlVG9ydXNWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZVRvcnVzQnVmZmVySW5mbyA9IGNyZWF0ZVRvcnVzQnVmZmVySW5mbztcbnZhciBjcmVhdGVUb3J1c0J1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZVRvcnVzVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVUb3J1c0J1ZmZlcnMgPSBjcmVhdGVUb3J1c0J1ZmZlcnM7XG52YXIgY3JlYXRlRGlzY0J1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVEaXNjVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVEaXNjQnVmZmVySW5mbyA9IGNyZWF0ZURpc2NCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZURpc2NCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVEaXNjVmVydGljZXMpOyAvLyB0aGVzZSB3ZXJlIG1pcy1zcGVsbGVkIHVudGlsIDQuMTJcblxuZXhwb3J0cy5jcmVhdGVEaXNjQnVmZmVycyA9IGNyZWF0ZURpc2NCdWZmZXJzO1xudmFyIGNyZWF0ZUNyZXNlbnRCdWZmZXJJbmZvID0gY3JlYXRlQ3Jlc2NlbnRCdWZmZXJJbmZvO1xuZXhwb3J0cy5jcmVhdGVDcmVzZW50QnVmZmVySW5mbyA9IGNyZWF0ZUNyZXNlbnRCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZUNyZXNlbnRCdWZmZXJzID0gY3JlYXRlQ3Jlc2NlbnRCdWZmZXJzO1xuZXhwb3J0cy5jcmVhdGVDcmVzZW50QnVmZmVycyA9IGNyZWF0ZUNyZXNlbnRCdWZmZXJzO1xudmFyIGNyZWF0ZUNyZXNlbnRWZXJ0aWNlcyA9IGNyZWF0ZUNyZXNjZW50VmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZUNyZXNlbnRWZXJ0aWNlcyA9IGNyZWF0ZUNyZXNlbnRWZXJ0aWNlcztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcHJvZ3JhbXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcHJvZ3JhbXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jcmVhdGVBdHRyaWJ1dGVTZXR0ZXJzID0gY3JlYXRlQXR0cmlidXRlU2V0dGVycztcbmV4cG9ydHMuY3JlYXRlUHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW07XG5leHBvcnRzLmNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyA9IGNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cztcbmV4cG9ydHMuY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2VzID0gY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2VzO1xuZXhwb3J0cy5jcmVhdGVQcm9ncmFtSW5mbyA9IGNyZWF0ZVByb2dyYW1JbmZvO1xuZXhwb3J0cy5jcmVhdGVQcm9ncmFtSW5mb0Zyb21Qcm9ncmFtID0gY3JlYXRlUHJvZ3JhbUluZm9Gcm9tUHJvZ3JhbTtcbmV4cG9ydHMuY3JlYXRlVW5pZm9ybVNldHRlcnMgPSBjcmVhdGVVbmlmb3JtU2V0dGVycztcbmV4cG9ydHMuY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtID0gY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtO1xuZXhwb3J0cy5jcmVhdGVVbmlmb3JtQmxvY2tJbmZvRnJvbVByb2dyYW0gPSBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvRnJvbVByb2dyYW07XG5leHBvcnRzLmNyZWF0ZVVuaWZvcm1CbG9ja0luZm8gPSBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvO1xuZXhwb3J0cy5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFjayA9IGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrO1xuZXhwb3J0cy5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFja0luZm8gPSBjcmVhdGVUcmFuc2Zvcm1GZWVkYmFja0luZm87XG5leHBvcnRzLmJpbmRUcmFuc2Zvcm1GZWVkYmFja0luZm8gPSBiaW5kVHJhbnNmb3JtRmVlZGJhY2tJbmZvO1xuZXhwb3J0cy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcbmV4cG9ydHMuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXMgPSBzZXRCdWZmZXJzQW5kQXR0cmlidXRlcztcbmV4cG9ydHMuc2V0VW5pZm9ybXMgPSBzZXRVbmlmb3JtcztcbmV4cG9ydHMuc2V0VW5pZm9ybUJsb2NrID0gc2V0VW5pZm9ybUJsb2NrO1xuZXhwb3J0cy5zZXRCbG9ja1VuaWZvcm1zID0gc2V0QmxvY2tVbmlmb3JtcztcbmV4cG9ydHMuYmluZFVuaWZvcm1CbG9jayA9IGJpbmRVbmlmb3JtQmxvY2s7XG5leHBvcnRzLnNldFVuaWZvcm1zQW5kQmluZFRleHR1cmVzID0gdm9pZCAwO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIikpO1xuXG52YXIgaGVscGVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9oZWxwZXIuanMgKi8gXCIuL3NyYy9oZWxwZXIuanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8qKlxuICogTG93IGxldmVsIHNoYWRlciBwcm9ncmFtIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKlxuICogWW91IHNob3VsZCBnZW5lcmFsbHkgbm90IG5lZWQgdG8gdXNlIHRoZXNlIGZ1bmN0aW9ucy4gVGhleSBhcmUgcHJvdmlkZWRcbiAqIGZvciB0aG9zZSBjYXNlcyB3aGVyZSB5b3UncmUgZG9pbmcgc29tZXRoaW5nIG91dCBvZiB0aGUgb3JkaW5hcnlcbiAqIGFuZCB5b3UgbmVlZCBsb3dlciBsZXZlbCBhY2Nlc3MuXG4gKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgdGhleSBhcmUgYXZhaWxhYmxlIGF0IGJvdGggYHR3Z2wucHJvZ3JhbXNgIGFuZCBgdHdnbGBcbiAqIGl0c2VsZlxuICpcbiAqIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2x9IGZvciBjb3JlIGZ1bmN0aW9uc1xuICpcbiAqIEBtb2R1bGUgdHdnbC9wcm9ncmFtc1xuICovXG52YXIgZXJyb3IgPSBoZWxwZXIuZXJyb3I7XG52YXIgd2FybiA9IGhlbHBlci53YXJuO1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50QnlJZChpZCkge1xuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IG51bGw7XG59XG5cbnZhciBURVhUVVJFMCA9IDB4ODRjMDtcbnZhciBEWU5BTUlDX0RSQVcgPSAweDg4ZTg7XG52YXIgQVJSQVlfQlVGRkVSID0gMHg4ODkyO1xudmFyIEVMRU1FTlRfQVJSQVlfQlVGRkVSID0gMHg4ODkzO1xudmFyIFVOSUZPUk1fQlVGRkVSID0gMHg4YTExO1xudmFyIFRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIgPSAweDhjOGU7XG52YXIgVFJBTlNGT1JNX0ZFRURCQUNLID0gMHg4ZTIyO1xudmFyIENPTVBJTEVfU1RBVFVTID0gMHg4YjgxO1xudmFyIExJTktfU1RBVFVTID0gMHg4YjgyO1xudmFyIEZSQUdNRU5UX1NIQURFUiA9IDB4OGIzMDtcbnZhciBWRVJURVhfU0hBREVSID0gMHg4YjMxO1xudmFyIFNFUEFSQVRFX0FUVFJJQlMgPSAweDhjOGQ7XG52YXIgQUNUSVZFX1VOSUZPUk1TID0gMHg4Yjg2O1xudmFyIEFDVElWRV9BVFRSSUJVVEVTID0gMHg4Yjg5O1xudmFyIFRSQU5TRk9STV9GRUVEQkFDS19WQVJZSU5HUyA9IDB4OGM4MztcbnZhciBBQ1RJVkVfVU5JRk9STV9CTE9DS1MgPSAweDhhMzY7XG52YXIgVU5JRk9STV9CTE9DS19SRUZFUkVOQ0VEX0JZX1ZFUlRFWF9TSEFERVIgPSAweDhhNDQ7XG52YXIgVU5JRk9STV9CTE9DS19SRUZFUkVOQ0VEX0JZX0ZSQUdNRU5UX1NIQURFUiA9IDB4OGE0NjtcbnZhciBVTklGT1JNX0JMT0NLX0RBVEFfU0laRSA9IDB4OGE0MDtcbnZhciBVTklGT1JNX0JMT0NLX0FDVElWRV9VTklGT1JNX0lORElDRVMgPSAweDhhNDM7XG52YXIgRkxPQVQgPSAweDE0MDY7XG52YXIgRkxPQVRfVkVDMiA9IDB4OEI1MDtcbnZhciBGTE9BVF9WRUMzID0gMHg4QjUxO1xudmFyIEZMT0FUX1ZFQzQgPSAweDhCNTI7XG52YXIgSU5UID0gMHgxNDA0O1xudmFyIElOVF9WRUMyID0gMHg4QjUzO1xudmFyIElOVF9WRUMzID0gMHg4QjU0O1xudmFyIElOVF9WRUM0ID0gMHg4QjU1O1xudmFyIEJPT0wgPSAweDhCNTY7XG52YXIgQk9PTF9WRUMyID0gMHg4QjU3O1xudmFyIEJPT0xfVkVDMyA9IDB4OEI1ODtcbnZhciBCT09MX1ZFQzQgPSAweDhCNTk7XG52YXIgRkxPQVRfTUFUMiA9IDB4OEI1QTtcbnZhciBGTE9BVF9NQVQzID0gMHg4QjVCO1xudmFyIEZMT0FUX01BVDQgPSAweDhCNUM7XG52YXIgU0FNUExFUl8yRCA9IDB4OEI1RTtcbnZhciBTQU1QTEVSX0NVQkUgPSAweDhCNjA7XG52YXIgU0FNUExFUl8zRCA9IDB4OEI1RjtcbnZhciBTQU1QTEVSXzJEX1NIQURPVyA9IDB4OEI2MjtcbnZhciBGTE9BVF9NQVQyeDMgPSAweDhCNjU7XG52YXIgRkxPQVRfTUFUMng0ID0gMHg4QjY2O1xudmFyIEZMT0FUX01BVDN4MiA9IDB4OEI2NztcbnZhciBGTE9BVF9NQVQzeDQgPSAweDhCNjg7XG52YXIgRkxPQVRfTUFUNHgyID0gMHg4QjY5O1xudmFyIEZMT0FUX01BVDR4MyA9IDB4OEI2QTtcbnZhciBTQU1QTEVSXzJEX0FSUkFZID0gMHg4REMxO1xudmFyIFNBTVBMRVJfMkRfQVJSQVlfU0hBRE9XID0gMHg4REM0O1xudmFyIFNBTVBMRVJfQ1VCRV9TSEFET1cgPSAweDhEQzU7XG52YXIgVU5TSUdORURfSU5UID0gMHgxNDA1O1xudmFyIFVOU0lHTkVEX0lOVF9WRUMyID0gMHg4REM2O1xudmFyIFVOU0lHTkVEX0lOVF9WRUMzID0gMHg4REM3O1xudmFyIFVOU0lHTkVEX0lOVF9WRUM0ID0gMHg4REM4O1xudmFyIElOVF9TQU1QTEVSXzJEID0gMHg4RENBO1xudmFyIElOVF9TQU1QTEVSXzNEID0gMHg4RENCO1xudmFyIElOVF9TQU1QTEVSX0NVQkUgPSAweDhEQ0M7XG52YXIgSU5UX1NBTVBMRVJfMkRfQVJSQVkgPSAweDhEQ0Y7XG52YXIgVU5TSUdORURfSU5UX1NBTVBMRVJfMkQgPSAweDhERDI7XG52YXIgVU5TSUdORURfSU5UX1NBTVBMRVJfM0QgPSAweDhERDM7XG52YXIgVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRSA9IDB4OERENDtcbnZhciBVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWSA9IDB4OERENztcbnZhciBURVhUVVJFXzJEID0gMHgwREUxO1xudmFyIFRFWFRVUkVfQ1VCRV9NQVAgPSAweDg1MTM7XG52YXIgVEVYVFVSRV8zRCA9IDB4ODA2RjtcbnZhciBURVhUVVJFXzJEX0FSUkFZID0gMHg4QzFBO1xudmFyIHR5cGVNYXAgPSB7fTtcbi8qKlxuICogUmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBiaW5kIHBvaW50IGZvciBhIGdpdmVuIHNhbXBsZXIgdHlwZVxuICovXG5cbmZ1bmN0aW9uIGdldEJpbmRQb2ludEZvclNhbXBsZXJUeXBlKGdsLCB0eXBlKSB7XG4gIHJldHVybiB0eXBlTWFwW3R5cGVdLmJpbmRQb2ludDtcbn0gLy8gVGhpcyBraW5kIG9mIHN1Y2tzISBJZiB5b3UgY291bGQgY29tcG9zZSBmdW5jdGlvbnMgYXMgaW4gYHZhciBmbiA9IGdsW25hbWVdO2Bcbi8vIHRoaXMgY29kZSBjb3VsZCBiZSBhIGxvdCBzbWFsbGVyIGJ1dCB0aGF0IGlzIHNhZGx5IHJlYWxseSBzbG93IChUX1QpXG5cblxuZnVuY3Rpb24gZmxvYXRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0QXJyYXlTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdFZlYzJTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0yZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdFZlYzNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdFZlYzRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm00ZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludEFycmF5U2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50VmVjMlNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludFZlYzNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0zaXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRWZWM0U2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtNGl2KGxvY2F0aW9uLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdWludFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTF1aShsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVpbnRBcnJheVNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTF1aXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1aW50VmVjMlNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTJ1aXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1aW50VmVjM1NldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTN1aXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1aW50VmVjNFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTR1aXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdE1hdDJTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYobG9jYXRpb24sIGZhbHNlLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvYXRNYXQzU2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0NFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdE1hdDIzU2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4MngzZnYobG9jYXRpb24sIGZhbHNlLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvYXRNYXQzMlNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDN4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0MjRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm1NYXRyaXgyeDRmdihsb2NhdGlvbiwgZmFsc2UsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdE1hdDQyU2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4NHgyZnYobG9jYXRpb24sIGZhbHNlLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvYXRNYXQzNFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDN4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0NDNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm1NYXRyaXg0eDNmdihsb2NhdGlvbiwgZmFsc2UsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzYW1wbGVyU2V0dGVyKGdsLCB0eXBlLCB1bml0LCBsb2NhdGlvbikge1xuICB2YXIgYmluZFBvaW50ID0gZ2V0QmluZFBvaW50Rm9yU2FtcGxlclR5cGUoZ2wsIHR5cGUpO1xuICByZXR1cm4gdXRpbHMuaXNXZWJHTDIoZ2wpID8gZnVuY3Rpb24gKHRleHR1cmVPclBhaXIpIHtcbiAgICB2YXIgdGV4dHVyZTtcbiAgICB2YXIgc2FtcGxlcjtcblxuICAgIGlmIChoZWxwZXIuaXNUZXh0dXJlKGdsLCB0ZXh0dXJlT3JQYWlyKSkge1xuICAgICAgdGV4dHVyZSA9IHRleHR1cmVPclBhaXI7XG4gICAgICBzYW1wbGVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dHVyZSA9IHRleHR1cmVPclBhaXIudGV4dHVyZTtcbiAgICAgIHNhbXBsZXIgPSB0ZXh0dXJlT3JQYWlyLnNhbXBsZXI7XG4gICAgfVxuXG4gICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB1bml0KTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKFRFWFRVUkUwICsgdW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoYmluZFBvaW50LCB0ZXh0dXJlKTtcbiAgICBnbC5iaW5kU2FtcGxlcih1bml0LCBzYW1wbGVyKTtcbiAgfSA6IGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB1bml0KTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKFRFWFRVUkUwICsgdW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoYmluZFBvaW50LCB0ZXh0dXJlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2FtcGxlckFycmF5U2V0dGVyKGdsLCB0eXBlLCB1bml0LCBsb2NhdGlvbiwgc2l6ZSkge1xuICB2YXIgYmluZFBvaW50ID0gZ2V0QmluZFBvaW50Rm9yU2FtcGxlclR5cGUoZ2wsIHR5cGUpO1xuICB2YXIgdW5pdHMgPSBuZXcgSW50MzJBcnJheShzaXplKTtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc2l6ZTsgKytpaSkge1xuICAgIHVuaXRzW2lpXSA9IHVuaXQgKyBpaTtcbiAgfVxuXG4gIHJldHVybiB1dGlscy5pc1dlYkdMMihnbCkgPyBmdW5jdGlvbiAodGV4dHVyZXMpIHtcbiAgICBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB1bml0cyk7XG4gICAgdGV4dHVyZXMuZm9yRWFjaChmdW5jdGlvbiAodGV4dHVyZU9yUGFpciwgaW5kZXgpIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoVEVYVFVSRTAgKyB1bml0c1tpbmRleF0pO1xuICAgICAgdmFyIHRleHR1cmU7XG4gICAgICB2YXIgc2FtcGxlcjtcblxuICAgICAgaWYgKGhlbHBlci5pc1RleHR1cmUoZ2wsIHRleHR1cmVPclBhaXIpKSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlT3JQYWlyO1xuICAgICAgICBzYW1wbGVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlT3JQYWlyLnRleHR1cmU7XG4gICAgICAgIHNhbXBsZXIgPSB0ZXh0dXJlT3JQYWlyLnNhbXBsZXI7XG4gICAgICB9XG5cbiAgICAgIGdsLmJpbmRTYW1wbGVyKHVuaXQsIHNhbXBsZXIpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoYmluZFBvaW50LCB0ZXh0dXJlKTtcbiAgICB9KTtcbiAgfSA6IGZ1bmN0aW9uICh0ZXh0dXJlcykge1xuICAgIGdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHVuaXRzKTtcbiAgICB0ZXh0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXh0dXJlLCBpbmRleCkge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShURVhUVVJFMCArIHVuaXRzW2luZGV4XSk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShiaW5kUG9pbnQsIHRleHR1cmUpO1xuICAgIH0pO1xuICB9O1xufVxuXG50eXBlTWFwW0ZMT0FUXSA9IHtcbiAgVHlwZTogRmxvYXQzMkFycmF5LFxuICBzaXplOiA0LFxuICBzZXR0ZXI6IGZsb2F0U2V0dGVyLFxuICBhcnJheVNldHRlcjogZmxvYXRBcnJheVNldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfVkVDMl0gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogOCxcbiAgc2V0dGVyOiBmbG9hdFZlYzJTZXR0ZXJcbn07XG50eXBlTWFwW0ZMT0FUX1ZFQzNdID0ge1xuICBUeXBlOiBGbG9hdDMyQXJyYXksXG4gIHNpemU6IDEyLFxuICBzZXR0ZXI6IGZsb2F0VmVjM1NldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfVkVDNF0gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogMTYsXG4gIHNldHRlcjogZmxvYXRWZWM0U2V0dGVyXG59O1xudHlwZU1hcFtJTlRdID0ge1xuICBUeXBlOiBJbnQzMkFycmF5LFxuICBzaXplOiA0LFxuICBzZXR0ZXI6IGludFNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IGludEFycmF5U2V0dGVyXG59O1xudHlwZU1hcFtJTlRfVkVDMl0gPSB7XG4gIFR5cGU6IEludDMyQXJyYXksXG4gIHNpemU6IDgsXG4gIHNldHRlcjogaW50VmVjMlNldHRlclxufTtcbnR5cGVNYXBbSU5UX1ZFQzNdID0ge1xuICBUeXBlOiBJbnQzMkFycmF5LFxuICBzaXplOiAxMixcbiAgc2V0dGVyOiBpbnRWZWMzU2V0dGVyXG59O1xudHlwZU1hcFtJTlRfVkVDNF0gPSB7XG4gIFR5cGU6IEludDMyQXJyYXksXG4gIHNpemU6IDE2LFxuICBzZXR0ZXI6IGludFZlYzRTZXR0ZXJcbn07XG50eXBlTWFwW1VOU0lHTkVEX0lOVF0gPSB7XG4gIFR5cGU6IFVpbnQzMkFycmF5LFxuICBzaXplOiA0LFxuICBzZXR0ZXI6IHVpbnRTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiB1aW50QXJyYXlTZXR0ZXJcbn07XG50eXBlTWFwW1VOU0lHTkVEX0lOVF9WRUMyXSA9IHtcbiAgVHlwZTogVWludDMyQXJyYXksXG4gIHNpemU6IDgsXG4gIHNldHRlcjogdWludFZlYzJTZXR0ZXJcbn07XG50eXBlTWFwW1VOU0lHTkVEX0lOVF9WRUMzXSA9IHtcbiAgVHlwZTogVWludDMyQXJyYXksXG4gIHNpemU6IDEyLFxuICBzZXR0ZXI6IHVpbnRWZWMzU2V0dGVyXG59O1xudHlwZU1hcFtVTlNJR05FRF9JTlRfVkVDNF0gPSB7XG4gIFR5cGU6IFVpbnQzMkFycmF5LFxuICBzaXplOiAxNixcbiAgc2V0dGVyOiB1aW50VmVjNFNldHRlclxufTtcbnR5cGVNYXBbQk9PTF0gPSB7XG4gIFR5cGU6IFVpbnQzMkFycmF5LFxuICBzaXplOiA0LFxuICBzZXR0ZXI6IGludFNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IGludEFycmF5U2V0dGVyXG59O1xudHlwZU1hcFtCT09MX1ZFQzJdID0ge1xuICBUeXBlOiBVaW50MzJBcnJheSxcbiAgc2l6ZTogOCxcbiAgc2V0dGVyOiBpbnRWZWMyU2V0dGVyXG59O1xudHlwZU1hcFtCT09MX1ZFQzNdID0ge1xuICBUeXBlOiBVaW50MzJBcnJheSxcbiAgc2l6ZTogMTIsXG4gIHNldHRlcjogaW50VmVjM1NldHRlclxufTtcbnR5cGVNYXBbQk9PTF9WRUM0XSA9IHtcbiAgVHlwZTogVWludDMyQXJyYXksXG4gIHNpemU6IDE2LFxuICBzZXR0ZXI6IGludFZlYzRTZXR0ZXJcbn07XG50eXBlTWFwW0ZMT0FUX01BVDJdID0ge1xuICBUeXBlOiBGbG9hdDMyQXJyYXksXG4gIHNpemU6IDE2LFxuICBzZXR0ZXI6IGZsb2F0TWF0MlNldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfTUFUM10gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogMzYsXG4gIHNldHRlcjogZmxvYXRNYXQzU2V0dGVyXG59O1xudHlwZU1hcFtGTE9BVF9NQVQ0XSA9IHtcbiAgVHlwZTogRmxvYXQzMkFycmF5LFxuICBzaXplOiA2NCxcbiAgc2V0dGVyOiBmbG9hdE1hdDRTZXR0ZXJcbn07XG50eXBlTWFwW0ZMT0FUX01BVDJ4M10gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogMjQsXG4gIHNldHRlcjogZmxvYXRNYXQyM1NldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfTUFUMng0XSA9IHtcbiAgVHlwZTogRmxvYXQzMkFycmF5LFxuICBzaXplOiAzMixcbiAgc2V0dGVyOiBmbG9hdE1hdDI0U2V0dGVyXG59O1xudHlwZU1hcFtGTE9BVF9NQVQzeDJdID0ge1xuICBUeXBlOiBGbG9hdDMyQXJyYXksXG4gIHNpemU6IDI0LFxuICBzZXR0ZXI6IGZsb2F0TWF0MzJTZXR0ZXJcbn07XG50eXBlTWFwW0ZMT0FUX01BVDN4NF0gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogNDgsXG4gIHNldHRlcjogZmxvYXRNYXQzNFNldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfTUFUNHgyXSA9IHtcbiAgVHlwZTogRmxvYXQzMkFycmF5LFxuICBzaXplOiAzMixcbiAgc2V0dGVyOiBmbG9hdE1hdDQyU2V0dGVyXG59O1xudHlwZU1hcFtGTE9BVF9NQVQ0eDNdID0ge1xuICBUeXBlOiBGbG9hdDMyQXJyYXksXG4gIHNpemU6IDQ4LFxuICBzZXR0ZXI6IGZsb2F0TWF0NDNTZXR0ZXJcbn07XG50eXBlTWFwW1NBTVBMRVJfMkRdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8yRFxufTtcbnR5cGVNYXBbU0FNUExFUl9DVUJFXSA9IHtcbiAgVHlwZTogbnVsbCxcbiAgc2l6ZTogMCxcbiAgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLFxuICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLFxuICBiaW5kUG9pbnQ6IFRFWFRVUkVfQ1VCRV9NQVBcbn07XG50eXBlTWFwW1NBTVBMRVJfM0RdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8zRFxufTtcbnR5cGVNYXBbU0FNUExFUl8yRF9TSEFET1ddID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8yRFxufTtcbnR5cGVNYXBbU0FNUExFUl8yRF9BUlJBWV0gPSB7XG4gIFR5cGU6IG51bGwsXG4gIHNpemU6IDAsXG4gIHNldHRlcjogc2FtcGxlclNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlcixcbiAgYmluZFBvaW50OiBURVhUVVJFXzJEX0FSUkFZXG59O1xudHlwZU1hcFtTQU1QTEVSXzJEX0FSUkFZX1NIQURPV10gPSB7XG4gIFR5cGU6IG51bGwsXG4gIHNpemU6IDAsXG4gIHNldHRlcjogc2FtcGxlclNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlcixcbiAgYmluZFBvaW50OiBURVhUVVJFXzJEX0FSUkFZXG59O1xudHlwZU1hcFtTQU1QTEVSX0NVQkVfU0hBRE9XXSA9IHtcbiAgVHlwZTogbnVsbCxcbiAgc2l6ZTogMCxcbiAgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLFxuICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLFxuICBiaW5kUG9pbnQ6IFRFWFRVUkVfQ1VCRV9NQVBcbn07XG50eXBlTWFwW0lOVF9TQU1QTEVSXzJEXSA9IHtcbiAgVHlwZTogbnVsbCxcbiAgc2l6ZTogMCxcbiAgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLFxuICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLFxuICBiaW5kUG9pbnQ6IFRFWFRVUkVfMkRcbn07XG50eXBlTWFwW0lOVF9TQU1QTEVSXzNEXSA9IHtcbiAgVHlwZTogbnVsbCxcbiAgc2l6ZTogMCxcbiAgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLFxuICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLFxuICBiaW5kUG9pbnQ6IFRFWFRVUkVfM0Rcbn07XG50eXBlTWFwW0lOVF9TQU1QTEVSX0NVQkVdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV9DVUJFX01BUFxufTtcbnR5cGVNYXBbSU5UX1NBTVBMRVJfMkRfQVJSQVldID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8yRF9BUlJBWVxufTtcbnR5cGVNYXBbVU5TSUdORURfSU5UX1NBTVBMRVJfMkRdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8yRFxufTtcbnR5cGVNYXBbVU5TSUdORURfSU5UX1NBTVBMRVJfM0RdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8zRFxufTtcbnR5cGVNYXBbVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRV0gPSB7XG4gIFR5cGU6IG51bGwsXG4gIHNpemU6IDAsXG4gIHNldHRlcjogc2FtcGxlclNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlcixcbiAgYmluZFBvaW50OiBURVhUVVJFX0NVQkVfTUFQXG59O1xudHlwZU1hcFtVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWV0gPSB7XG4gIFR5cGU6IG51bGwsXG4gIHNpemU6IDAsXG4gIHNldHRlcjogc2FtcGxlclNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlcixcbiAgYmluZFBvaW50OiBURVhUVVJFXzJEX0FSUkFZXG59O1xuXG5mdW5jdGlvbiBmbG9hdEF0dHJpYlNldHRlcihnbCwgaW5kZXgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XG4gICAgaWYgKGIudmFsdWUpIHtcbiAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG5cbiAgICAgIHN3aXRjaCAoYi52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjRmdihpbmRleCwgYi52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjNmdihpbmRleCwgYi52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjJmdihpbmRleCwgYi52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjFmdihpbmRleCwgYi52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBsZW5ndGggb2YgYSBmbG9hdCBjb25zdGFudCB2YWx1ZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNCEnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuYmluZEJ1ZmZlcihBUlJBWV9CVUZGRVIsIGIuYnVmZmVyKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaW5kZXgsIGIubnVtQ29tcG9uZW50cyB8fCBiLnNpemUsIGIudHlwZSB8fCBGTE9BVCwgYi5ub3JtYWxpemUgfHwgZmFsc2UsIGIuc3RyaWRlIHx8IDAsIGIub2Zmc2V0IHx8IDApO1xuXG4gICAgICBpZiAoYi5kaXZpc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihpbmRleCwgYi5kaXZpc29yKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludEF0dHJpYlNldHRlcihnbCwgaW5kZXgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XG4gICAgaWYgKGIudmFsdWUpIHtcbiAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG5cbiAgICAgIGlmIChiLnZhbHVlLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWI0aXYoaW5kZXgsIGIudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbGVuZ3RoIG9mIGFuIGludGVnZXIgY29uc3RhbnQgdmFsdWUgbXVzdCBiZSA0IScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC5iaW5kQnVmZmVyKEFSUkFZX0JVRkZFUiwgYi5idWZmZXIpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuICAgICAgZ2wudmVydGV4QXR0cmliSVBvaW50ZXIoaW5kZXgsIGIubnVtQ29tcG9uZW50cyB8fCBiLnNpemUsIGIudHlwZSB8fCBJTlQsIGIuc3RyaWRlIHx8IDAsIGIub2Zmc2V0IHx8IDApO1xuXG4gICAgICBpZiAoYi5kaXZpc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihpbmRleCwgYi5kaXZpc29yKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVpbnRBdHRyaWJTZXR0ZXIoZ2wsIGluZGV4KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYikge1xuICAgIGlmIChiLnZhbHVlKSB7XG4gICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuXG4gICAgICBpZiAoYi52YWx1ZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliNHVpdihpbmRleCwgYi52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBsZW5ndGggb2YgYW4gdW5zaWduZWQgaW50ZWdlciBjb25zdGFudCB2YWx1ZSBtdXN0IGJlIDQhJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmJpbmRCdWZmZXIoQVJSQVlfQlVGRkVSLCBiLmJ1ZmZlcik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJJUG9pbnRlcihpbmRleCwgYi5udW1Db21wb25lbnRzIHx8IGIuc2l6ZSwgYi50eXBlIHx8IFVOU0lHTkVEX0lOVCwgYi5zdHJpZGUgfHwgMCwgYi5vZmZzZXQgfHwgMCk7XG5cbiAgICAgIGlmIChiLmRpdmlzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGluZGV4LCBiLmRpdmlzb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbWF0QXR0cmliU2V0dGVyKGdsLCBpbmRleCwgdHlwZUluZm8pIHtcbiAgdmFyIGRlZmF1bHRTaXplID0gdHlwZUluZm8uc2l6ZTtcbiAgdmFyIGNvdW50ID0gdHlwZUluZm8uY291bnQ7XG4gIHJldHVybiBmdW5jdGlvbiAoYikge1xuICAgIGdsLmJpbmRCdWZmZXIoQVJSQVlfQlVGRkVSLCBiLmJ1ZmZlcik7XG4gICAgdmFyIG51bUNvbXBvbmVudHMgPSBiLnNpemUgfHwgYi5udW1Db21wb25lbnRzIHx8IGRlZmF1bHRTaXplO1xuICAgIHZhciBzaXplID0gbnVtQ29tcG9uZW50cyAvIGNvdW50O1xuICAgIHZhciB0eXBlID0gYi50eXBlIHx8IEZMT0FUO1xuICAgIHZhciB0eXBlSW5mbyA9IHR5cGVNYXBbdHlwZV07XG4gICAgdmFyIHN0cmlkZSA9IHR5cGVJbmZvLnNpemUgKiBudW1Db21wb25lbnRzO1xuICAgIHZhciBub3JtYWxpemUgPSBiLm5vcm1hbGl6ZSB8fCBmYWxzZTtcbiAgICB2YXIgb2Zmc2V0ID0gYi5vZmZzZXQgfHwgMDtcbiAgICB2YXIgcm93T2Zmc2V0ID0gc3RyaWRlIC8gY291bnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4ICsgaSk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGluZGV4ICsgaSwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplLCBzdHJpZGUsIG9mZnNldCArIHJvd09mZnNldCAqIGkpO1xuXG4gICAgICBpZiAoYi5kaXZpc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihpbmRleCArIGksIGIuZGl2aXNvcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgYXR0clR5cGVNYXAgPSB7fTtcbmF0dHJUeXBlTWFwW0ZMT0FUXSA9IHtcbiAgc2l6ZTogNCxcbiAgc2V0dGVyOiBmbG9hdEF0dHJpYlNldHRlclxufTtcbmF0dHJUeXBlTWFwW0ZMT0FUX1ZFQzJdID0ge1xuICBzaXplOiA4LFxuICBzZXR0ZXI6IGZsb2F0QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbRkxPQVRfVkVDM10gPSB7XG4gIHNpemU6IDEyLFxuICBzZXR0ZXI6IGZsb2F0QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbRkxPQVRfVkVDNF0gPSB7XG4gIHNpemU6IDE2LFxuICBzZXR0ZXI6IGZsb2F0QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbSU5UXSA9IHtcbiAgc2l6ZTogNCxcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtJTlRfVkVDMl0gPSB7XG4gIHNpemU6IDgsXG4gIHNldHRlcjogaW50QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbSU5UX1ZFQzNdID0ge1xuICBzaXplOiAxMixcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtJTlRfVkVDNF0gPSB7XG4gIHNpemU6IDE2LFxuICBzZXR0ZXI6IGludEF0dHJpYlNldHRlclxufTtcbmF0dHJUeXBlTWFwW1VOU0lHTkVEX0lOVF0gPSB7XG4gIHNpemU6IDQsXG4gIHNldHRlcjogdWludEF0dHJpYlNldHRlclxufTtcbmF0dHJUeXBlTWFwW1VOU0lHTkVEX0lOVF9WRUMyXSA9IHtcbiAgc2l6ZTogOCxcbiAgc2V0dGVyOiB1aW50QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbVU5TSUdORURfSU5UX1ZFQzNdID0ge1xuICBzaXplOiAxMixcbiAgc2V0dGVyOiB1aW50QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbVU5TSUdORURfSU5UX1ZFQzRdID0ge1xuICBzaXplOiAxNixcbiAgc2V0dGVyOiB1aW50QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbQk9PTF0gPSB7XG4gIHNpemU6IDQsXG4gIHNldHRlcjogaW50QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbQk9PTF9WRUMyXSA9IHtcbiAgc2l6ZTogOCxcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtCT09MX1ZFQzNdID0ge1xuICBzaXplOiAxMixcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtCT09MX1ZFQzRdID0ge1xuICBzaXplOiAxNixcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtGTE9BVF9NQVQyXSA9IHtcbiAgc2l6ZTogNCxcbiAgc2V0dGVyOiBtYXRBdHRyaWJTZXR0ZXIsXG4gIGNvdW50OiAyXG59O1xuYXR0clR5cGVNYXBbRkxPQVRfTUFUM10gPSB7XG4gIHNpemU6IDksXG4gIHNldHRlcjogbWF0QXR0cmliU2V0dGVyLFxuICBjb3VudDogM1xufTtcbmF0dHJUeXBlTWFwW0ZMT0FUX01BVDRdID0ge1xuICBzaXplOiAxNixcbiAgc2V0dGVyOiBtYXRBdHRyaWJTZXR0ZXIsXG4gIGNvdW50OiA0XG59OyAvLyBtYWtlIHN1cmUgd2UgZG9uJ3Qgc2VlIGEgZ2xvYmFsIGdsXG5cbnZhciBnbCA9IHVuZGVmaW5lZDtcbi8qIGVzbGludC1kaXNhYmxlLWxpbmUgKi9cblxudmFyIGVycm9yUkUgPSAvRVJST1I6XFxzKlxcZCs6KFxcZCspL2dpO1xuXG5mdW5jdGlvbiBhZGRMaW5lTnVtYmVyc1dpdGhFcnJvcihzcmMpIHtcbiAgdmFyIGxvZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gIHZhciBsaW5lT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuXG4gIC8vIE5vdGU6IEVycm9yIG1lc3NhZ2UgZm9ybWF0cyBhcmUgbm90IGRlZmluZWQgYnkgYW55IHNwZWMgc28gdGhpcyBtYXkgb3IgbWF5IG5vdCB3b3JrLlxuICB2YXIgbWF0Y2hlcyA9IF90b0NvbnN1bWFibGVBcnJheShsb2cubWF0Y2hBbGwoZXJyb3JSRSkpO1xuXG4gIHZhciBsaW5lTm9Ub0Vycm9yTWFwID0gbmV3IE1hcChtYXRjaGVzLm1hcChmdW5jdGlvbiAobSwgbmR4KSB7XG4gICAgdmFyIGxpbmVObyA9IHBhcnNlSW50KG1bMV0pO1xuICAgIHZhciBuZXh0ID0gbWF0Y2hlc1tuZHggKyAxXTtcbiAgICB2YXIgZW5kID0gbmV4dCA/IG5leHQuaW5kZXggOiBsb2cubGVuZ3RoO1xuICAgIHZhciBtc2cgPSBsb2cuc3Vic3RyaW5nKG0uaW5kZXgsIGVuZCk7XG4gICAgcmV0dXJuIFtsaW5lTm8gLSAxLCBtc2ddO1xuICB9KSk7XG4gIHJldHVybiBzcmMuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbiAobGluZSwgbGluZU5vKSB7XG4gICAgdmFyIGVyciA9IGxpbmVOb1RvRXJyb3JNYXAuZ2V0KGxpbmVObyk7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGxpbmVObyArIDEgKyBsaW5lT2Zmc2V0LCBcIjogXCIpLmNvbmNhdChsaW5lKS5jb25jYXQoZXJyID8gXCJcXG5cXG5eXl4gXCIuY29uY2F0KGVycikgOiAnJyk7XG4gIH0pLmpvaW4oJ1xcbicpO1xufVxuLyoqXG4gKiBFcnJvciBDYWxsYmFja1xuICogQGNhbGxiYWNrIEVycm9yQ2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGluZU9mZnNldF0gYW1vdW50IHRvIGFkZCB0byBsaW5lIG51bWJlclxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG52YXIgc3BhY2VSRSA9IC9eWyBcXHRdKlxcbi87XG4vKipcbiAqIExvYWRzIGEgc2hhZGVyLlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHNoYWRlclNvdXJjZSBUaGUgc2hhZGVyIHNvdXJjZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaGFkZXJUeXBlIFRoZSB0eXBlIG9mIHNoYWRlci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gb3B0X2Vycm9yQ2FsbGJhY2sgY2FsbGJhY2sgZm9yIGVycm9ycy5cbiAqIEByZXR1cm4ge1dlYkdMU2hhZGVyfSBUaGUgY3JlYXRlZCBzaGFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWRTaGFkZXIoZ2wsIHNoYWRlclNvdXJjZSwgc2hhZGVyVHlwZSwgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgdmFyIGVyckZuID0gb3B0X2Vycm9yQ2FsbGJhY2sgfHwgZXJyb3I7IC8vIENyZWF0ZSB0aGUgc2hhZGVyIG9iamVjdFxuXG4gIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7IC8vIFJlbW92ZSB0aGUgZmlyc3QgZW5kIG9mIGxpbmUgYmVjYXVzZSBXZWJHTCAyLjAgcmVxdWlyZXNcbiAgLy8gI3ZlcnNpb24gMzAwIGVzXG4gIC8vIGFzIHRoZSBmaXJzdCBsaW5lLiBObyB3aGl0ZXNwYWNlIGFsbG93ZWQgYmVmb3JlIHRoYXQgbGluZVxuICAvLyBzb1xuICAvL1xuICAvLyA8c2NyaXB0PlxuICAvLyAjdmVyc2lvbiAzMDAgZXNcbiAgLy8gPC9zY3JpcHQ+XG4gIC8vXG4gIC8vIEhhcyBvbmUgbGluZSBiZWZvcmUgaXQgd2hpY2ggaXMgaW52YWxpZCBhY2NvcmRpbmcgdG8gR0xTTCBFUyAzLjAwXG4gIC8vXG5cbiAgdmFyIGxpbmVPZmZzZXQgPSAwO1xuXG4gIGlmIChzcGFjZVJFLnRlc3Qoc2hhZGVyU291cmNlKSkge1xuICAgIGxpbmVPZmZzZXQgPSAxO1xuICAgIHNoYWRlclNvdXJjZSA9IHNoYWRlclNvdXJjZS5yZXBsYWNlKHNwYWNlUkUsICcnKTtcbiAgfSAvLyBMb2FkIHRoZSBzaGFkZXIgc291cmNlXG5cblxuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpOyAvLyBDb21waWxlIHRoZSBzaGFkZXJcblxuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7IC8vIENoZWNrIHRoZSBjb21waWxlIHN0YXR1c1xuXG4gIHZhciBjb21waWxlZCA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIENPTVBJTEVfU1RBVFVTKTtcblxuICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIGNvbXBpbGF0aW9uOyBnZXQgdGhlIGVycm9yXG4gICAgdmFyIGxhc3RFcnJvciA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICBlcnJGbihcIlwiLmNvbmNhdChhZGRMaW5lTnVtYmVyc1dpdGhFcnJvcihzaGFkZXJTb3VyY2UsIGxhc3RFcnJvciwgbGluZU9mZnNldCksIFwiXFxuRXJyb3IgY29tcGlsaW5nIFwiKS5jb25jYXQodXRpbHMuZ2xFbnVtVG9TdHJpbmcoZ2wsIHNoYWRlclR5cGUpLCBcIjogXCIpLmNvbmNhdChsYXN0RXJyb3IpKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBzaGFkZXI7XG59XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb2dyYW1PcHRpb25zXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKHN0cmluZyl9IFtlcnJvckNhbGxiYWNrXSBjYWxsYmFjayBmb3IgZXJyb3JzXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLG51bWJlcj59IFthdHRyaWJMb2NhdGlvbnNdIGEgYXR0cmlidXRlIG5hbWUgdG8gbG9jYXRpb24gbWFwXG4gKiBAcHJvcGVydHkgeyhtb2R1bGU6dHdnbC5CdWZmZXJJbmZvfE9iamVjdC48c3RyaW5nLG1vZHVsZTp0d2dsLkF0dHJpYkluZm8+fHN0cmluZ1tdKX0gW3RyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3NdIElmIHBhc3NlZFxuICogICBhIEJ1ZmZlckluZm8gd2lsbCB1c2UgdGhlIGF0dHJpYnMgbmFtZXMgaW5zaWRlLiBJZiBwYXNzZWQgYW4gb2JqZWN0IG9mIEF0dHJpYkluZm9zIHdpbGwgdXNlIHRoZSBuYW1lcyBmcm9tIHRoYXQgb2JqZWN0LiBPdGhlcndpc2VcbiAqICAgeW91IGNhbiBwYXNzIGFuIGFycmF5IG9mIG5hbWVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2Zvcm1GZWVkYmFja01vZGVdIHRoZSBtb2RlIHRvIHBhc3MgYGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3NgLiBEZWZhdWx0cyB0byBgU0VQQVJBVEVfQVRUUklCU2AuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEdldHMgdGhlIHByb2dyYW0gb3B0aW9ucyBiYXNlZCBvbiBhbGwgdGhlc2Ugb3B0aW9uYWwgYXJndW1lbnRzXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1PcHRpb25zfHN0cmluZ1tdfSBbb3B0X2F0dHJpYnNdIE9wdGlvbnMgZm9yIHRoZSBwcm9ncmFtIG9yIGFuIGFycmF5IG9mIGF0dHJpYnMgbmFtZXMuIExvY2F0aW9ucyB3aWxsIGJlIGFzc2lnbmVkIGJ5IGluZGV4IGlmIG5vdCBwYXNzZWQgaW5cbiAqIEBwYXJhbSB7bnVtYmVyW119IFtvcHRfbG9jYXRpb25zXSBUaGUgbG9jYXRpb25zIGZvciB0aGUuIEEgcGFyYWxsZWwgYXJyYXkgdG8gb3B0X2F0dHJpYnMgbGV0dGluZyB5b3UgYXNzaWduIGxvY2F0aW9ucy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9lcnJvckNhbGxiYWNrXSBjYWxsYmFjayBmb3IgZXJyb3JzLiBCeSBkZWZhdWx0IGl0IGp1c3QgcHJpbnRzIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlXG4gKiAgICAgICAgb24gZXJyb3IuIElmIHlvdSB3YW50IHNvbWV0aGluZyBlbHNlIHBhc3MgYW4gY2FsbGJhY2suIEl0J3MgcGFzc2VkIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5Qcm9ncmFtT3B0aW9uc30gYW4gaW5zdGFuY2Ugb2YgUHJvZ3JhbU9wdGlvbnMgYmFzZWQgb24gdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW5cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRQcm9ncmFtT3B0aW9ucyhvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgdmFyIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3M7XG4gIHZhciB0cmFuc2Zvcm1GZWVkYmFja01vZGU7XG5cbiAgaWYgKHR5cGVvZiBvcHRfbG9jYXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0X2Vycm9yQ2FsbGJhY2sgPSBvcHRfbG9jYXRpb25zO1xuICAgIG9wdF9sb2NhdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdF9hdHRyaWJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0X2Vycm9yQ2FsbGJhY2sgPSBvcHRfYXR0cmlicztcbiAgICBvcHRfYXR0cmlicyA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChvcHRfYXR0cmlicyAmJiAhQXJyYXkuaXNBcnJheShvcHRfYXR0cmlicykpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGVycm9yQ2FsbGJhY2sgd2UgY2FuIGp1c3QgcmV0dXJuIHRoaXMgb2JqZWN0XG4gICAgLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gY29uc3RydWN0IG9uZSB3aXRoIGRlZmF1bHQgZXJyb3JDYWxsYmFja1xuICAgIGlmIChvcHRfYXR0cmlicy5lcnJvckNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gb3B0X2F0dHJpYnM7XG4gICAgfVxuXG4gICAgdmFyIG9wdCA9IG9wdF9hdHRyaWJzO1xuICAgIG9wdF9lcnJvckNhbGxiYWNrID0gb3B0LmVycm9yQ2FsbGJhY2s7XG4gICAgb3B0X2F0dHJpYnMgPSBvcHQuYXR0cmliTG9jYXRpb25zO1xuICAgIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MgPSBvcHQudHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncztcbiAgICB0cmFuc2Zvcm1GZWVkYmFja01vZGUgPSBvcHQudHJhbnNmb3JtRmVlZGJhY2tNb2RlO1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgZXJyb3JDYWxsYmFjazogb3B0X2Vycm9yQ2FsbGJhY2sgfHwgZXJyb3IsXG4gICAgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nczogdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyxcbiAgICB0cmFuc2Zvcm1GZWVkYmFja01vZGU6IHRyYW5zZm9ybUZlZWRiYWNrTW9kZVxuICB9O1xuXG4gIGlmIChvcHRfYXR0cmlicykge1xuICAgIHZhciBhdHRyaWJMb2NhdGlvbnMgPSB7fTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdF9hdHRyaWJzKSkge1xuICAgICAgb3B0X2F0dHJpYnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmliLCBuZHgpIHtcbiAgICAgICAgYXR0cmliTG9jYXRpb25zW2F0dHJpYl0gPSBvcHRfbG9jYXRpb25zID8gb3B0X2xvY2F0aW9uc1tuZHhdIDogbmR4O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYkxvY2F0aW9ucyA9IG9wdF9hdHRyaWJzO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYXR0cmliTG9jYXRpb25zID0gYXR0cmliTG9jYXRpb25zO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbnZhciBkZWZhdWx0U2hhZGVyVHlwZSA9IFtcIlZFUlRFWF9TSEFERVJcIiwgXCJGUkFHTUVOVF9TSEFERVJcIl07XG5cbmZ1bmN0aW9uIGdldFNoYWRlclR5cGVGcm9tU2NyaXB0VHlwZShnbCwgc2NyaXB0VHlwZSkge1xuICBpZiAoc2NyaXB0VHlwZS5pbmRleE9mKFwiZnJhZ1wiKSA+PSAwKSB7XG4gICAgcmV0dXJuIEZSQUdNRU5UX1NIQURFUjtcbiAgfSBlbHNlIGlmIChzY3JpcHRUeXBlLmluZGV4T2YoXCJ2ZXJ0XCIpID49IDApIHtcbiAgICByZXR1cm4gVkVSVEVYX1NIQURFUjtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZVNoYWRlcnMoZ2wsIHNoYWRlcnMpIHtcbiAgc2hhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzaGFkZXIpIHtcbiAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBwcm9ncmFtLCBhdHRhY2hlcyAoYW5kL29yIGNvbXBpbGVzKSBzaGFkZXJzLCBiaW5kcyBhdHRyaWIgbG9jYXRpb25zLCBsaW5rcyB0aGVcbiAqIHByb2dyYW0gYW5kIGNhbGxzIHVzZVByb2dyYW0uXG4gKlxuICogTk9URTogVGhlcmUgYXJlIDQgc2lnbmF0dXJlcyBmb3IgdGhpcyBmdW5jdGlvblxuICpcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW0oZ2wsIFt2cywgZnNdLCBvcHRpb25zKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW0oZ2wsIFt2cywgZnNdLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtKGdsLCBbdnMsIGZzXSwgb3B0X2F0dHJpYnMsIG9wdF9lcnJGdW5jKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW0oZ2wsIFt2cywgZnNdLCBvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2VyckZ1bmMpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHRvIHVzZS5cbiAqIEBwYXJhbSB7V2ViR0xTaGFkZXJbXXxzdHJpbmdbXX0gc2hhZGVycyBUaGUgc2hhZGVycyB0byBhdHRhY2gsIG9yIGVsZW1lbnQgaWRzIGZvciB0aGVpciBzb3VyY2UsIG9yIHN0cmluZ3MgdGhhdCBjb250YWluIHRoZWlyIHNvdXJjZVxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtT3B0aW9uc3xzdHJpbmdbXXxtb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrfSBbb3B0X2F0dHJpYnNdIE9wdGlvbnMgZm9yIHRoZSBwcm9ncmFtIG9yIGFuIGFycmF5IG9mIGF0dHJpYnMgbmFtZXMgb3IgYW4gZXJyb3IgY2FsbGJhY2suIExvY2F0aW9ucyB3aWxsIGJlIGFzc2lnbmVkIGJ5IGluZGV4IGlmIG5vdCBwYXNzZWQgaW5cbiAqIEBwYXJhbSB7bnVtYmVyW119IFtvcHRfbG9jYXRpb25zfG1vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2tdIFRoZSBsb2NhdGlvbnMgZm9yIHRoZS4gQSBwYXJhbGxlbCBhcnJheSB0byBvcHRfYXR0cmlicyBsZXR0aW5nIHlvdSBhc3NpZ24gbG9jYXRpb25zIG9yIGFuIGVycm9yIGNhbGxiYWNrLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrfSBbb3B0X2Vycm9yQ2FsbGJhY2tdIGNhbGxiYWNrIGZvciBlcnJvcnMuIEJ5IGRlZmF1bHQgaXQganVzdCBwcmludHMgYW4gZXJyb3IgdG8gdGhlIGNvbnNvbGVcbiAqICAgICAgICBvbiBlcnJvci4gSWYgeW91IHdhbnQgc29tZXRoaW5nIGVsc2UgcGFzcyBhbiBjYWxsYmFjay4gSXQncyBwYXNzZWQgYW4gZXJyb3IgbWVzc2FnZS5cbiAqIEByZXR1cm4ge1dlYkdMUHJvZ3JhbT99IHRoZSBjcmVhdGVkIHByb2dyYW0gb3IgbnVsbCBpZiBlcnJvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShnbCwgc2hhZGVycywgb3B0X2F0dHJpYnMsIG9wdF9sb2NhdGlvbnMsIG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gIHZhciBwcm9nT3B0aW9ucyA9IGdldFByb2dyYW1PcHRpb25zKG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjayk7XG4gIHZhciByZWFsU2hhZGVycyA9IFtdO1xuICB2YXIgbmV3U2hhZGVycyA9IFtdO1xuXG4gIGZvciAodmFyIG5keCA9IDA7IG5keCA8IHNoYWRlcnMubGVuZ3RoOyArK25keCkge1xuICAgIHZhciBzaGFkZXIgPSBzaGFkZXJzW25keF07XG5cbiAgICBpZiAodHlwZW9mIHNoYWRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBlbGVtID0gZ2V0RWxlbWVudEJ5SWQoc2hhZGVyKTtcbiAgICAgIHZhciBzcmMgPSBlbGVtID8gZWxlbS50ZXh0IDogc2hhZGVyO1xuICAgICAgdmFyIHR5cGUgPSBnbFtkZWZhdWx0U2hhZGVyVHlwZVtuZHhdXTtcblxuICAgICAgaWYgKGVsZW0gJiYgZWxlbS50eXBlKSB7XG4gICAgICAgIHR5cGUgPSBnZXRTaGFkZXJUeXBlRnJvbVNjcmlwdFR5cGUoZ2wsIGVsZW0udHlwZSkgfHwgdHlwZTtcbiAgICAgIH1cblxuICAgICAgc2hhZGVyID0gbG9hZFNoYWRlcihnbCwgc3JjLCB0eXBlLCBwcm9nT3B0aW9ucy5lcnJvckNhbGxiYWNrKTtcbiAgICAgIG5ld1NoYWRlcnMucHVzaChzaGFkZXIpO1xuICAgIH1cblxuICAgIGlmIChoZWxwZXIuaXNTaGFkZXIoZ2wsIHNoYWRlcikpIHtcbiAgICAgIHJlYWxTaGFkZXJzLnB1c2goc2hhZGVyKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVhbFNoYWRlcnMubGVuZ3RoICE9PSBzaGFkZXJzLmxlbmd0aCkge1xuICAgIHByb2dPcHRpb25zLmVycm9yQ2FsbGJhY2soXCJub3QgZW5vdWdoIHNoYWRlcnMgZm9yIHByb2dyYW1cIik7XG4gICAgZGVsZXRlU2hhZGVycyhnbCwgbmV3U2hhZGVycyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgcmVhbFNoYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2hhZGVyKSB7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcik7XG4gIH0pO1xuXG4gIGlmIChwcm9nT3B0aW9ucy5hdHRyaWJMb2NhdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhwcm9nT3B0aW9ucy5hdHRyaWJMb2NhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYikge1xuICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIHByb2dPcHRpb25zLmF0dHJpYkxvY2F0aW9uc1thdHRyaWJdLCBhdHRyaWIpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHZhcnlpbmdzID0gcHJvZ09wdGlvbnMudHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncztcblxuICBpZiAodmFyeWluZ3MpIHtcbiAgICBpZiAodmFyeWluZ3MuYXR0cmlicykge1xuICAgICAgdmFyeWluZ3MgPSB2YXJ5aW5ncy5hdHRyaWJzO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YXJ5aW5ncykpIHtcbiAgICAgIHZhcnlpbmdzID0gT2JqZWN0LmtleXModmFyeWluZ3MpO1xuICAgIH1cblxuICAgIGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MocHJvZ3JhbSwgdmFyeWluZ3MsIHByb2dPcHRpb25zLnRyYW5zZm9ybUZlZWRiYWNrTW9kZSB8fCBTRVBBUkFURV9BVFRSSUJTKTtcbiAgfVxuXG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pOyAvLyBDaGVjayB0aGUgbGluayBzdGF0dXNcblxuICB2YXIgbGlua2VkID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBMSU5LX1NUQVRVUyk7XG5cbiAgaWYgKCFsaW5rZWQpIHtcbiAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZyB3aXRoIHRoZSBsaW5rXG4gICAgdmFyIGxhc3RFcnJvciA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xuICAgIHByb2dPcHRpb25zLmVycm9yQ2FsbGJhY2soXCJcIi5jb25jYXQocmVhbFNoYWRlcnMubWFwKGZ1bmN0aW9uIChzaGFkZXIpIHtcbiAgICAgIHZhciBzcmMgPSBhZGRMaW5lTnVtYmVyc1dpdGhFcnJvcihnbC5nZXRTaGFkZXJTb3VyY2Uoc2hhZGVyKSwgJycsIDApO1xuICAgICAgdmFyIHR5cGUgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5TSEFERVJfVFlQRSk7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodXRpbHMuZ2xFbnVtVG9TdHJpbmcoZ2wsIHR5cGUpLCBcIlxcblwiKS5jb25jYXQoc3JjLCBcIn1cIik7XG4gICAgfSkuam9pbignXFxuJyksIFwiXFxuRXJyb3IgaW4gcHJvZ3JhbSBsaW5raW5nOiBcIikuY29uY2F0KGxhc3RFcnJvcikpO1xuICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgZGVsZXRlU2hhZGVycyhnbCwgbmV3U2hhZGVycyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcHJvZ3JhbTtcbn1cbi8qKlxuICogTG9hZHMgYSBzaGFkZXIgZnJvbSBhIHNjcmlwdCB0YWcuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0SWQgVGhlIGlkIG9mIHRoZSBzY3JpcHQgdGFnLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc2hhZGVyVHlwZV0gVGhlIHR5cGUgb2Ygc2hhZGVyLiBJZiBub3QgcGFzc2VkIGluIGl0IHdpbGxcbiAqICAgICBiZSBkZXJpdmVkIGZyb20gdGhlIHR5cGUgb2YgdGhlIHNjcmlwdCB0YWcuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9ycy5cbiAqIEByZXR1cm4ge1dlYkdMU2hhZGVyP30gVGhlIGNyZWF0ZWQgc2hhZGVyIG9yIG51bGwgaWYgZXJyb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlU2hhZGVyRnJvbVNjcmlwdChnbCwgc2NyaXB0SWQsIG9wdF9zaGFkZXJUeXBlLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICB2YXIgc2hhZGVyU291cmNlID0gXCJcIjtcbiAgdmFyIHNoYWRlclNjcmlwdCA9IGdldEVsZW1lbnRCeUlkKHNjcmlwdElkKTtcblxuICBpZiAoIXNoYWRlclNjcmlwdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gc2NyaXB0IGVsZW1lbnQ6IFwiLmNvbmNhdChzY3JpcHRJZCkpO1xuICB9XG5cbiAgc2hhZGVyU291cmNlID0gc2hhZGVyU2NyaXB0LnRleHQ7XG4gIHZhciBzaGFkZXJUeXBlID0gb3B0X3NoYWRlclR5cGUgfHwgZ2V0U2hhZGVyVHlwZUZyb21TY3JpcHRUeXBlKGdsLCBzaGFkZXJTY3JpcHQudHlwZSk7XG5cbiAgaWYgKCFzaGFkZXJUeXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHNoYWRlciB0eXBlJyk7XG4gIH1cblxuICByZXR1cm4gbG9hZFNoYWRlcihnbCwgc2hhZGVyU291cmNlLCBzaGFkZXJUeXBlLCBvcHRfZXJyb3JDYWxsYmFjayk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBwcm9ncmFtIGZyb20gMiBzY3JpcHQgdGFncy5cbiAqXG4gKiBOT1RFOiBUaGVyZSBhcmUgNCBzaWduYXR1cmVzIGZvciB0aGlzIGZ1bmN0aW9uXG4gKlxuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzKGdsLCBbdnMsIGZzXSwgb3B0X29wdGlvbnMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzKGdsLCBbdnMsIGZzXSwgb3B0X2VyckZ1bmMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzKGdsLCBbdnMsIGZzXSwgb3B0X2F0dHJpYnMsIG9wdF9lcnJGdW5jKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyhnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyRnVuYyk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqICAgICAgICB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzaGFkZXJTY3JpcHRJZHMgQXJyYXkgb2YgaWRzIG9mIHRoZSBzY3JpcHRcbiAqICAgICAgICB0YWdzIGZvciB0aGUgc2hhZGVycy4gVGhlIGZpcnN0IGlzIGFzc3VtZWQgdG8gYmUgdGhlXG4gKiAgICAgICAgdmVydGV4IHNoYWRlciwgdGhlIHNlY29uZCB0aGUgZnJhZ21lbnQgc2hhZGVyLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtT3B0aW9uc3xzdHJpbmdbXXxtb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrfSBbb3B0X2F0dHJpYnNdIE9wdGlvbnMgZm9yIHRoZSBwcm9ncmFtIG9yIGFuIGFycmF5IG9mIGF0dHJpYnMgbmFtZXMgb3IgYW4gZXJyb3IgY2FsbGJhY2suIExvY2F0aW9ucyB3aWxsIGJlIGFzc2lnbmVkIGJ5IGluZGV4IGlmIG5vdCBwYXNzZWQgaW5cbiAqIEBwYXJhbSB7bnVtYmVyW119IFtvcHRfbG9jYXRpb25zfG1vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2tdIFRoZSBsb2NhdGlvbnMgZm9yIHRoZS4gQSBwYXJhbGxlbCBhcnJheSB0byBvcHRfYXR0cmlicyBsZXR0aW5nIHlvdSBhc3NpZ24gbG9jYXRpb25zIG9yIGFuIGVycm9yIGNhbGxiYWNrLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrfSBbb3B0X2Vycm9yQ2FsbGJhY2tdIGNhbGxiYWNrIGZvciBlcnJvcnMuIEJ5IGRlZmF1bHQgaXQganVzdCBwcmludHMgYW4gZXJyb3IgdG8gdGhlIGNvbnNvbGVcbiAqICAgICAgICBvbiBlcnJvci4gSWYgeW91IHdhbnQgc29tZXRoaW5nIGVsc2UgcGFzcyBhbiBjYWxsYmFjay4gSXQncyBwYXNzZWQgYW4gZXJyb3IgbWVzc2FnZS5cbiAqIEByZXR1cm4ge1dlYkdMUHJvZ3JhbT99IHRoZSBjcmVhdGVkIHByb2dyYW0gb3IgbnVsbCBpZiBlcnJvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzKGdsLCBzaGFkZXJTY3JpcHRJZHMsIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICB2YXIgcHJvZ09wdGlvbnMgPSBnZXRQcm9ncmFtT3B0aW9ucyhvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spO1xuICB2YXIgc2hhZGVycyA9IFtdO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBzaGFkZXJTY3JpcHRJZHMubGVuZ3RoOyArK2lpKSB7XG4gICAgdmFyIHNoYWRlciA9IGNyZWF0ZVNoYWRlckZyb21TY3JpcHQoZ2wsIHNoYWRlclNjcmlwdElkc1tpaV0sIGdsW2RlZmF1bHRTaGFkZXJUeXBlW2lpXV0sIHByb2dPcHRpb25zLmVycm9yQ2FsbGJhY2spO1xuXG4gICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHNoYWRlcnMucHVzaChzaGFkZXIpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVByb2dyYW0oZ2wsIHNoYWRlcnMsIHByb2dPcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHByb2dyYW0gZnJvbSAyIHNvdXJjZXMuXG4gKlxuICogTk9URTogVGhlcmUgYXJlIDQgc2lnbmF0dXJlcyBmb3IgdGhpcyBmdW5jdGlvblxuICpcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Gcm9tU291cmNlKGdsLCBbdnMsIGZzXSwgb3B0X29wdGlvbnMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2UoZ2wsIFt2cywgZnNdLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtRnJvbVNvdXJjZShnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtRnJvbVNvdXJjZShnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyRnVuYyk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqICAgICAgICB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzaGFkZXJTb3VyY2VzIEFycmF5IG9mIHNvdXJjZXMgZm9yIHRoZVxuICogICAgICAgIHNoYWRlcnMuIFRoZSBmaXJzdCBpcyBhc3N1bWVkIHRvIGJlIHRoZSB2ZXJ0ZXggc2hhZGVyLFxuICogICAgICAgIHRoZSBzZWNvbmQgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuUHJvZ3JhbU9wdGlvbnN8c3RyaW5nW118bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9hdHRyaWJzXSBPcHRpb25zIGZvciB0aGUgcHJvZ3JhbSBvciBhbiBhcnJheSBvZiBhdHRyaWJzIG5hbWVzIG9yIGFuIGVycm9yIGNhbGxiYWNrLiBMb2NhdGlvbnMgd2lsbCBiZSBhc3NpZ25lZCBieSBpbmRleCBpZiBub3QgcGFzc2VkIGluXG4gKiBAcGFyYW0ge251bWJlcltdfSBbb3B0X2xvY2F0aW9uc3xtb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrXSBUaGUgbG9jYXRpb25zIGZvciB0aGUuIEEgcGFyYWxsZWwgYXJyYXkgdG8gb3B0X2F0dHJpYnMgbGV0dGluZyB5b3UgYXNzaWduIGxvY2F0aW9ucyBvciBhbiBlcnJvciBjYWxsYmFjay5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9lcnJvckNhbGxiYWNrXSBjYWxsYmFjayBmb3IgZXJyb3JzLiBCeSBkZWZhdWx0IGl0IGp1c3QgcHJpbnRzIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlXG4gKiAgICAgICAgb24gZXJyb3IuIElmIHlvdSB3YW50IHNvbWV0aGluZyBlbHNlIHBhc3MgYW4gY2FsbGJhY2suIEl0J3MgcGFzc2VkIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHtXZWJHTFByb2dyYW0/fSB0aGUgY3JlYXRlZCBwcm9ncmFtIG9yIG51bGwgaWYgZXJyb3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW1Gcm9tU291cmNlcyhnbCwgc2hhZGVyU291cmNlcywgb3B0X2F0dHJpYnMsIG9wdF9sb2NhdGlvbnMsIG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gIHZhciBwcm9nT3B0aW9ucyA9IGdldFByb2dyYW1PcHRpb25zKG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjayk7XG4gIHZhciBzaGFkZXJzID0gW107XG5cbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHNoYWRlclNvdXJjZXMubGVuZ3RoOyArK2lpKSB7XG4gICAgdmFyIHNoYWRlciA9IGxvYWRTaGFkZXIoZ2wsIHNoYWRlclNvdXJjZXNbaWldLCBnbFtkZWZhdWx0U2hhZGVyVHlwZVtpaV1dLCBwcm9nT3B0aW9ucy5lcnJvckNhbGxiYWNrKTtcblxuICAgIGlmICghc2hhZGVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzaGFkZXJzLnB1c2goc2hhZGVyKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVQcm9ncmFtKGdsLCBzaGFkZXJzLCBwcm9nT3B0aW9ucyk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhdHRyaWJ1dGUvdW5pZm9ybSBpcyBhIHJlc2VydmVkL2J1aWx0IGluXG4gKlxuICogSXQgbWFrZXMgbm8gc2Vuc2UgdG8gbWUgd2h5IEdMIHJldHVybnMgdGhlc2UgYmVjYXVzZSBpdCdzXG4gKiBpbGxlZ2FsIHRvIGNhbGwgYGdsLmdldFVuaWZvcm1Mb2NhdGlvbmAgYW5kIGBnbC5nZXRBdHRyaWJMb2NhdGlvbmBcbiAqIHdpdGggbmFtZXMgdGhhdCBzdGFydCB3aXRoIGBnbF9gIChhbmQgYHdlYmdsX2AgaW4gV2ViR0wpXG4gKlxuICogSSBjYW4gb25seSBhc3N1bWUgdGhleSBhcmUgdGhlcmUgYmVjYXVzZSB0aGV5IG1pZ2h0IGNvdW50XG4gKiB3aGVuIGNvbXB1dGluZyB0aGUgbnVtYmVyIG9mIHVuaWZvcm1zL2F0dHJpYnV0ZXMgdXNlZCB3aGVuIHlvdSB3YW50IHRvXG4gKiBrbm93IGlmIHlvdSBhcmUgbmVhciB0aGUgbGltaXQuIFRoYXQgZG9lc24ndCByZWFsbHkgbWFrZSBzZW5zZVxuICogdG8gbWUgYnV0IHRoZSBmYWN0IHRoYXQgdGhlc2UgZ2V0IHJldHVybmVkIGFyZSBpbiB0aGUgc3BlYy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMQWN0aXZlSW5mb30gaW5mbyBBcyByZXR1cm5lZCBmcm9tIGBnbC5nZXRBY3RpdmVVbmlmb3JtYCBvclxuICogICAgYGdsLmdldEFjdGl2ZUF0dHJpYmAuXG4gKiBAcmV0dXJuIHtib29sfSB0cnVlIGlmIGl0J3MgcmVzZXJ2ZWRcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBpc0J1aWx0SW4oaW5mbykge1xuICB2YXIgbmFtZSA9IGluZm8ubmFtZTtcbiAgcmV0dXJuIG5hbWUuc3RhcnRzV2l0aChcImdsX1wiKSB8fCBuYW1lLnN0YXJ0c1dpdGgoXCJ3ZWJnbF9cIik7XG59XG4vKipcbiAqIENyZWF0ZXMgc2V0dGVyIGZ1bmN0aW9ucyBmb3IgYWxsIHVuaWZvcm1zIG9mIGEgc2hhZGVyXG4gKiBwcm9ncmFtLlxuICpcbiAqIEBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLnNldFVuaWZvcm1zfVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHRvIHVzZS5cbiAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtIHRoZSBwcm9ncmFtIHRvIGNyZWF0ZSBzZXR0ZXJzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBhbiBvYmplY3Qgd2l0aCBhIHNldHRlciBieSBuYW1lIGZvciBlYWNoIHVuaWZvcm1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlVW5pZm9ybVNldHRlcnMoZ2wsIHByb2dyYW0pIHtcbiAgdmFyIHRleHR1cmVVbml0ID0gMDtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzZXR0ZXIgZm9yIGEgdW5pZm9ybSBvZiB0aGUgZ2l2ZW4gcHJvZ3JhbSB3aXRoIGl0J3NcbiAgICogbG9jYXRpb24gZW1iZWRkZWQgaW4gdGhlIHNldHRlci5cbiAgICogQHBhcmFtIHtXZWJHTFByb2dyYW19IHByb2dyYW1cbiAgICogQHBhcmFtIHtXZWJHTFVuaWZvcm1JbmZvfSB1bmlmb3JtSW5mb1xuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IHRoZSBjcmVhdGVkIHNldHRlci5cbiAgICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pZm9ybVNldHRlcihwcm9ncmFtLCB1bmlmb3JtSW5mbywgbG9jYXRpb24pIHtcbiAgICB2YXIgaXNBcnJheSA9IHVuaWZvcm1JbmZvLm5hbWUuZW5kc1dpdGgoXCJbMF1cIik7XG4gICAgdmFyIHR5cGUgPSB1bmlmb3JtSW5mby50eXBlO1xuICAgIHZhciB0eXBlSW5mbyA9IHR5cGVNYXBbdHlwZV07XG5cbiAgICBpZiAoIXR5cGVJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IDB4XCIuY29uY2F0KHR5cGUudG9TdHJpbmcoMTYpKSk7IC8vIHdlIHNob3VsZCBuZXZlciBnZXQgaGVyZS5cbiAgICB9XG5cbiAgICB2YXIgc2V0dGVyO1xuXG4gICAgaWYgKHR5cGVJbmZvLmJpbmRQb2ludCkge1xuICAgICAgLy8gaXQncyBhIHNhbXBsZXJcbiAgICAgIHZhciB1bml0ID0gdGV4dHVyZVVuaXQ7XG4gICAgICB0ZXh0dXJlVW5pdCArPSB1bmlmb3JtSW5mby5zaXplO1xuXG4gICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICBzZXR0ZXIgPSB0eXBlSW5mby5hcnJheVNldHRlcihnbCwgdHlwZSwgdW5pdCwgbG9jYXRpb24sIHVuaWZvcm1JbmZvLnNpemUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0dGVyID0gdHlwZUluZm8uc2V0dGVyKGdsLCB0eXBlLCB1bml0LCBsb2NhdGlvbiwgdW5pZm9ybUluZm8uc2l6ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlSW5mby5hcnJheVNldHRlciAmJiBpc0FycmF5KSB7XG4gICAgICAgIHNldHRlciA9IHR5cGVJbmZvLmFycmF5U2V0dGVyKGdsLCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXR0ZXIgPSB0eXBlSW5mby5zZXR0ZXIoZ2wsIGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXR0ZXIubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICByZXR1cm4gc2V0dGVyO1xuICB9XG5cbiAgdmFyIHVuaWZvcm1TZXR0ZXJzID0ge307XG4gIHZhciBudW1Vbmlmb3JtcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgQUNUSVZFX1VOSUZPUk1TKTtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbnVtVW5pZm9ybXM7ICsraWkpIHtcbiAgICB2YXIgdW5pZm9ybUluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGlpKTtcblxuICAgIGlmIChpc0J1aWx0SW4odW5pZm9ybUluZm8pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IHVuaWZvcm1JbmZvLm5hbWU7IC8vIHJlbW92ZSB0aGUgYXJyYXkgc3VmZml4LlxuXG4gICAgaWYgKG5hbWUuZW5kc1dpdGgoXCJbMF1cIikpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigwLCBuYW1lLmxlbmd0aCAtIDMpO1xuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtSW5mby5uYW1lKTsgLy8gdGhlIHVuaWZvcm0gd2lsbCBoYXZlIG5vIGxvY2F0aW9uIGlmIGl0J3MgaW4gYSB1bmlmb3JtIGJsb2NrXG5cbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIHVuaWZvcm1TZXR0ZXJzW25hbWVdID0gY3JlYXRlVW5pZm9ybVNldHRlcihwcm9ncmFtLCB1bmlmb3JtSW5mbywgbG9jYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmlmb3JtU2V0dGVycztcbn1cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVHJhbnNmb3JtRmVlZGJhY2tJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggaW5kZXggb2YgdHJhbnNmb3JtIGZlZWRiYWNrXG4gKiBAcHJvcGVydHkge251bWJlcn0gdHlwZSBHTCB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2l6ZSAxIC0gNFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgVHJhbnNmb3JtRmVlZGJhY2tJbmZvIGZvciBwYXNzaW5nIHRvIGJpbmRUcmFuc2Zvcm1GZWVkYmFja0luZm8uXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSBhbiBleGlzdGluZyBXZWJHTFByb2dyYW0uXG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5UcmFuc2Zvcm1GZWVkYmFja0luZm8+fVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1GZWVkYmFja0luZm8oZ2wsIHByb2dyYW0pIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgdmFyIG51bVZhcnlpbmdzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBUUkFOU0ZPUk1fRkVFREJBQ0tfVkFSWUlOR1MpO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1WYXJ5aW5nczsgKytpaSkge1xuICAgIHZhciB2YXJ5aW5nID0gZ2wuZ2V0VHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nKHByb2dyYW0sIGlpKTtcbiAgICBpbmZvW3ZhcnlpbmcubmFtZV0gPSB7XG4gICAgICBpbmRleDogaWksXG4gICAgICB0eXBlOiB2YXJ5aW5nLnR5cGUsXG4gICAgICBzaXplOiB2YXJ5aW5nLnNpemVcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIEJpbmRzIGJ1ZmZlcnMgZm9yIHRyYW5zZm9ybSBmZWVkYmFjay5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5UcmFuc2Zvcm1GZWVkYmFja0luZm8+KX0gdHJhbnNmb3JtRmVlZGJhY2tJbmZvIEEgUHJvZ3JhbUluZm8gb3IgVHJhbnNmb3JtRmVlZGJhY2tJbmZvLlxuICogQHBhcmFtIHsobW9kdWxlOnR3Z2wuQnVmZmVySW5mb3xPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5BdHRyaWJJbmZvPil9IFtidWZmZXJJbmZvXSBBIEJ1ZmZlckluZm8gb3Igc2V0IG9mIEF0dHJpYkluZm9zLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG5mdW5jdGlvbiBiaW5kVHJhbnNmb3JtRmVlZGJhY2tJbmZvKGdsLCB0cmFuc2Zvcm1GZWVkYmFja0luZm8sIGJ1ZmZlckluZm8pIHtcbiAgaWYgKHRyYW5zZm9ybUZlZWRiYWNrSW5mby50cmFuc2Zvcm1GZWVkYmFja0luZm8pIHtcbiAgICB0cmFuc2Zvcm1GZWVkYmFja0luZm8gPSB0cmFuc2Zvcm1GZWVkYmFja0luZm8udHJhbnNmb3JtRmVlZGJhY2tJbmZvO1xuICB9XG5cbiAgaWYgKGJ1ZmZlckluZm8uYXR0cmlicykge1xuICAgIGJ1ZmZlckluZm8gPSBidWZmZXJJbmZvLmF0dHJpYnM7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIGJ1ZmZlckluZm8pIHtcbiAgICB2YXIgdmFyeWluZyA9IHRyYW5zZm9ybUZlZWRiYWNrSW5mb1tuYW1lXTtcblxuICAgIGlmICh2YXJ5aW5nKSB7XG4gICAgICB2YXIgYnVmID0gYnVmZmVySW5mb1tuYW1lXTtcblxuICAgICAgaWYgKGJ1Zi5vZmZzZXQpIHtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlclJhbmdlKFRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIsIHZhcnlpbmcuaW5kZXgsIGJ1Zi5idWZmZXIsIGJ1Zi5vZmZzZXQsIGJ1Zi5zaXplKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmJpbmRCdWZmZXJCYXNlKFRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIsIHZhcnlpbmcuaW5kZXgsIGJ1Zi5idWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIGZlZWRiYWNrIGFuZCBzZXRzIHRoZSBidWZmZXJzXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfSBwcm9ncmFtSW5mbyBBIFByb2dyYW1JbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVByb2dyYW1JbmZvfVxuICogQHBhcmFtIHsobW9kdWxlOnR3Z2wuQnVmZmVySW5mb3xPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5BdHRyaWJJbmZvPil9IFtidWZmZXJJbmZvXSBBIEJ1ZmZlckluZm8gb3Igc2V0IG9mIEF0dHJpYkluZm9zLlxuICogQHJldHVybiB7V2ViR0xUcmFuc2Zvcm1GZWVkYmFja30gdGhlIGNyZWF0ZWQgdHJhbnNmb3JtIGZlZWRiYWNrXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrKGdsLCBwcm9ncmFtSW5mbywgYnVmZmVySW5mbykge1xuICB2YXIgdGYgPSBnbC5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFjaygpO1xuICBnbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soVFJBTlNGT1JNX0ZFRURCQUNLLCB0Zik7XG4gIGdsLnVzZVByb2dyYW0ocHJvZ3JhbUluZm8ucHJvZ3JhbSk7XG4gIGJpbmRUcmFuc2Zvcm1GZWVkYmFja0luZm8oZ2wsIHByb2dyYW1JbmZvLCBidWZmZXJJbmZvKTtcbiAgZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKFRSQU5TRk9STV9GRUVEQkFDSywgbnVsbCk7XG4gIHJldHVybiB0Zjtcbn1cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVW5pZm9ybURhdGFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0eXBlIFRoZSBXZWJHTCB0eXBlIGVudW0gZm9yIHRoaXMgdW5pZm9ybVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpemUgVGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3IgdGhpcyB1bmlmb3JtXG4gKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tOZHggVGhlIGJsb2NrIGluZGV4IHRoaXMgdW5pZm9ybSBhcHBlYXJzIGluXG4gKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0IFRoZSBieXRlIG9mZnNldCBpbiB0aGUgYmxvY2sgZm9yIHRoaXMgdW5pZm9ybSdzIHZhbHVlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIFRoZSBzcGVjaWZpY2F0aW9uIGZvciBvbmUgVW5pZm9ybUJsb2NrT2JqZWN0XG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQmxvY2tTcGVjXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBibG9jay5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaXplIFRoZSBzaXplIGluIGJ5dGVzIG5lZWRlZCBmb3IgdGhlIGJsb2NrXG4gKiBAcHJvcGVydHkge251bWJlcltdfSB1bmlmb3JtSW5kaWNlcyBUaGUgaW5kaWNlcyBvZiB0aGUgdW5pZm9ybXMgdXNlZCBieSB0aGUgYmxvY2suIFRoZXNlIGluZGljZXNcbiAqICAgIGNvcnJlc3BvbmQgdG8gZW50cmllcyBpbiBhIFVuaWZvcm1EYXRhIGFycmF5IGluIHRoZSB7QGxpbmsgbW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrU3BlY30uXG4gKiBAcHJvcGVydHkge2Jvb2x9IHVzZWRCeVZlcnRleFNoYWRlciBTZWxmIGV4cGxhbmF0b3J5XG4gKiBAcHJvcGVydHkge2Jvb2x9IHVzZWRCeUZyYWdtZW50U2hhZGVyIFNlbGYgZXhwbGFuYXRvcnlcbiAqIEBwcm9wZXJ0eSB7Ym9vbH0gdXNlZCBTZWxmIGV4cGxhbmF0b3J5XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEEgYFVuaWZvcm1CbG9ja1NwZWNgIHJlcHJlc2VudHMgdGhlIGRhdGEgbmVlZGVkIHRvIGNyZWF0ZSBhbmQgYmluZFxuICogVW5pZm9ybUJsb2NrT2JqZWN0cyBmb3IgYSBnaXZlbiBwcm9ncmFtXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVW5pZm9ybUJsb2NrU3BlY1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnR3Z2wuQmxvY2tTcGVjPiBibG9ja1NwZWNzIFRoZSBCbG9ja1NwZWMgZm9yIGVhY2ggYmxvY2sgYnkgYmxvY2sgbmFtZVxuICogQHByb3BlcnR5IHtVbmlmb3JtRGF0YVtdfSB1bmlmb3JtRGF0YSBBbiBhcnJheSBvZiBkYXRhIGZvciBlYWNoIHVuaWZvcm0gYnkgdW5pZm9ybSBpbmRleC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIFVuaWZvcm1CbG9ja1NwZWMgZm9yIHRoZSBnaXZlbiBwcm9ncmFtLlxuICpcbiAqIEEgVW5pZm9ybUJsb2NrU3BlYyByZXByZXNlbnRzIHRoZSBkYXRhIG5lZWRlZCB0byBjcmVhdGUgYW5kIGJpbmRcbiAqIFVuaWZvcm1CbG9ja09iamVjdHNcbiAqXG4gKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0wyIFJlbmRlcmluZyBDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSBBIFdlYkdMUHJvZ3JhbSBmb3IgYSBzdWNjZXNzZnVsbHkgbGlua2VkIHByb2dyYW1cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja1NwZWN9IFRoZSBjcmVhdGVkIFVuaWZvcm1CbG9ja1NwZWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtKGdsLCBwcm9ncmFtKSB7XG4gIHZhciBudW1Vbmlmb3JtcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgQUNUSVZFX1VOSUZPUk1TKTtcbiAgdmFyIHVuaWZvcm1EYXRhID0gW107XG4gIHZhciB1bmlmb3JtSW5kaWNlcyA9IFtdO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1Vbmlmb3JtczsgKytpaSkge1xuICAgIHVuaWZvcm1JbmRpY2VzLnB1c2goaWkpO1xuICAgIHVuaWZvcm1EYXRhLnB1c2goe30pO1xuICAgIHZhciB1bmlmb3JtSW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaWkpO1xuXG4gICAgaWYgKGlzQnVpbHRJbih1bmlmb3JtSW5mbykpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHVuaWZvcm1EYXRhW2lpXS5uYW1lID0gdW5pZm9ybUluZm8ubmFtZTtcbiAgfVxuXG4gIFtbXCJVTklGT1JNX1RZUEVcIiwgXCJ0eXBlXCJdLCBbXCJVTklGT1JNX1NJWkVcIiwgXCJzaXplXCJdLCAvLyBudW0gZWxlbWVudHNcbiAgW1wiVU5JRk9STV9CTE9DS19JTkRFWFwiLCBcImJsb2NrTmR4XCJdLCBbXCJVTklGT1JNX09GRlNFVFwiLCBcIm9mZnNldFwiXV0uZm9yRWFjaChmdW5jdGlvbiAocGFpcikge1xuICAgIHZhciBwbmFtZSA9IHBhaXJbMF07XG4gICAgdmFyIGtleSA9IHBhaXJbMV07XG4gICAgZ2wuZ2V0QWN0aXZlVW5pZm9ybXMocHJvZ3JhbSwgdW5pZm9ybUluZGljZXMsIGdsW3BuYW1lXSkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIG5keCkge1xuICAgICAgdW5pZm9ybURhdGFbbmR4XVtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gIH0pO1xuICB2YXIgYmxvY2tTcGVjcyA9IHt9O1xuICB2YXIgbnVtVW5pZm9ybUJsb2NrcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgQUNUSVZFX1VOSUZPUk1fQkxPQ0tTKTtcblxuICBmb3IgKHZhciBfaWkgPSAwOyBfaWkgPCBudW1Vbmlmb3JtQmxvY2tzOyArK19paSkge1xuICAgIHZhciBuYW1lID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybUJsb2NrTmFtZShwcm9ncmFtLCBfaWkpO1xuICAgIHZhciBibG9ja1NwZWMgPSB7XG4gICAgICBpbmRleDogZ2wuZ2V0VW5pZm9ybUJsb2NrSW5kZXgocHJvZ3JhbSwgbmFtZSksXG4gICAgICB1c2VkQnlWZXJ0ZXhTaGFkZXI6IGdsLmdldEFjdGl2ZVVuaWZvcm1CbG9ja1BhcmFtZXRlcihwcm9ncmFtLCBfaWksIFVOSUZPUk1fQkxPQ0tfUkVGRVJFTkNFRF9CWV9WRVJURVhfU0hBREVSKSxcbiAgICAgIHVzZWRCeUZyYWdtZW50U2hhZGVyOiBnbC5nZXRBY3RpdmVVbmlmb3JtQmxvY2tQYXJhbWV0ZXIocHJvZ3JhbSwgX2lpLCBVTklGT1JNX0JMT0NLX1JFRkVSRU5DRURfQllfRlJBR01FTlRfU0hBREVSKSxcbiAgICAgIHNpemU6IGdsLmdldEFjdGl2ZVVuaWZvcm1CbG9ja1BhcmFtZXRlcihwcm9ncmFtLCBfaWksIFVOSUZPUk1fQkxPQ0tfREFUQV9TSVpFKSxcbiAgICAgIHVuaWZvcm1JbmRpY2VzOiBnbC5nZXRBY3RpdmVVbmlmb3JtQmxvY2tQYXJhbWV0ZXIocHJvZ3JhbSwgX2lpLCBVTklGT1JNX0JMT0NLX0FDVElWRV9VTklGT1JNX0lORElDRVMpXG4gICAgfTtcbiAgICBibG9ja1NwZWMudXNlZCA9IGJsb2NrU3BlYy51c2VkQnlWZXJ0ZXhTaGFkZXIgfHwgYmxvY2tTcGVjLnVzZWRCeUZyYWdtZW50U2hhZGVyO1xuICAgIGJsb2NrU3BlY3NbbmFtZV0gPSBibG9ja1NwZWM7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJsb2NrU3BlY3M6IGJsb2NrU3BlY3MsXG4gICAgdW5pZm9ybURhdGE6IHVuaWZvcm1EYXRhXG4gIH07XG59XG5cbnZhciBhcnJheVN1ZmZpeFJFID0gL1xcW1xcZCtcXF1cXC4kLzsgLy8gYmV0dGVyIHdheSB0byBjaGVjaz9cblxudmFyIHBhZCA9IGZ1bmN0aW9uIHBhZCh2LCBwYWRkaW5nKSB7XG4gIHJldHVybiAoKHYgKyAocGFkZGluZyAtIDEpKSAvIHBhZGRpbmcgfCAwKSAqIHBhZGRpbmc7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVVbmlmb3JtQmxvY2tVbmlmb3JtU2V0dGVyKHZpZXcsIFR5cGUsIHR5cGVTaXplLCBwYWRkZWRTaXplLCBpc0FycmF5KSB7XG4gIGlmIChpc0FycmF5KSB7XG4gICAgdmFyIG51bUVsZW1lbnRzID0gdHlwZVNpemUgLyBUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIHZhciBudW1QYWRkZWRFbGVtZW50cyA9IHBhZGRlZFNpemUgLyBUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBkc3QgPSAwO1xuXG4gICAgICBmb3IgKHZhciBzcmMgPSAwOyBzcmMgPCB2YWx1ZS5sZW5ndGg7IHNyYyArPSBudW1FbGVtZW50cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVsZW1lbnRzOyArK2kpIHtcbiAgICAgICAgICB2aWV3W2RzdCArIGldID0gdmFsdWVbc3JjICsgaV07XG4gICAgICAgIH1cblxuICAgICAgICBkc3QgKz0gbnVtUGFkZGVkRWxlbWVudHM7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZpZXcuc2V0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZXdbMF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBVbmlmb3JtQmxvY2tPYmplY3QgaW5jbHVkaW5nIGFuIEFycmF5QnVmZmVyIHdpdGggYWxsIHRoZSB1bmlmb3JtIHZhbHVlc1xuICogYW5kIGEgY29ycmVzcG9uZGluZyBXZWJHTEJ1ZmZlciB0byBob2xkIHRob3NlIHZhbHVlcyBvbiB0aGUgR1BVXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVW5pZm9ybUJsb2NrSW5mb1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGJsb2NrXG4gKiBAcHJvcGVydHkge0FycmF5QnVmZmVyfSBhcnJheSBUaGUgYXJyYXkgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHVuaWZvcm0gdmFsdWVzXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gYXNGbG9hdCBBIGZsb2F0IHZpZXcgb24gdGhlIGFycmF5IGJ1ZmZlci4gVGhpcyBpcyB1c2VmdWxcbiAqICAgIGluc3BlY3RpbmcgdGhlIGNvbnRlbnRzIG9mIHRoZSBidWZmZXIgaW4gdGhlIGRlYnVnZ2VyLlxuICogQHByb3BlcnR5IHtXZWJHTEJ1ZmZlcn0gYnVmZmVyIEEgV2ViR0wgYnVmZmVyIHRoYXQgd2lsbCBob2xkIGEgY29weSBvZiB0aGUgdW5pZm9ybSB2YWx1ZXMgZm9yIHJlbmRlcmluZy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb2Zmc2V0XSBvZmZzZXQgaW50byBidWZmZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgQXJyYXlCdWZmZXJWaWV3Pn0gdW5pZm9ybXMgQSB1bmlmb3JtIG5hbWUgdG8gQXJyYXlCdWZmZXJWaWV3IG1hcC5cbiAqICAgZWFjaCBVbmlmb3JtIGhhcyBhIGNvcnJlY3RseSB0eXBlZCBgQXJyYXlCdWZmZXJWaWV3YCBpbnRvIGFycmF5IGF0IHRoZSBjb3JyZWN0IG9mZnNldFxuICogICBhbmQgbGVuZ3RoIG9mIHRoYXQgdW5pZm9ybS4gU28gZm9yIGV4YW1wbGUgYSBmbG9hdCB1bmlmb3JtIHdvdWxkIGhhdmUgYSAxIGZsb2F0IGBGbG9hdDMyQXJyYXlgXG4gKiAgIHZpZXcuIEEgc2luZ2xlIG1hdDQgd291bGQgaGF2ZSBhIDE2IGVsZW1lbnQgYEZsb2F0MzJBcnJheWAgdmlldy4gQW4gaXZlYzIgd291bGQgaGF2ZSBhblxuICogICBgSW50MzJBcnJheWAgdmlldywgZXRjLlxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBmdW5jdGlvbj59IHNldHRlcnMgQSBzZXR0ZXIgZm9yIHRoaXMgdW5pZm9ybS5cbiAqICAgVGhlIHJlYXNvbiB0byB1c2Ugc2V0dGVycyBpcyBlbGVtZW50cyBvZiBhcnJheXMgYXJlIHBhZGRlZCB0byB2ZWM0IHNpemVzIHdoaWNoXG4gKiAgIG1lYW5zIGlmIHlvdSB3YW50IHRvIHNldCBhbiBhcnJheSBvZiA0IGZsb2F0cyB5b3UnZCBuZWVkIHRvIHNldCAxNiB2YWx1ZXNcbiAqICAgKG9yIHNldCBlbGVtZW50cyAwLCA0LCA4LCAxMikuIEluIG90aGVyIHdvcmRzXG4gKiAgIGBzb21lQmxvY2tJbmZvLnVuaWZvcm1zLnNvbWU0RmxvYXRBcnJheVVuaWZvcm0uc2V0KFswLCAsICwgLCAxLCAsICwgLCAyLCAsICwgLCAzXSlgXG4gKiAgIHdoZXJlIGFzIHRoZSBzZXR0ZXIgaGFuZGxlcyBqdXN0IHBhc3NpbmcgaW4gWzAsIDEsIDIsIDNdIGVpdGhlciBkaXJlY3RseSBhcyBpblxuICogICBgc29tZUJsb2NrSW5mby5zZXR0ZXIuc29tZTRGbG9hdEFycmF5VW5pZm9ybS5zZXQoWzAsIDEsIDIsIDNdKWAgKG5vdCByZWNvbW1lbmRlZClcbiAqICAgb3IgdmlhIHtAbGluayBtb2R1bGU6dHdnbC5zZXRCbG9ja1VuaWZvcm1zfVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgYFVuaWZvcm1CbG9ja0luZm9gIGZvciB0aGUgc3BlY2lmaWVkIGJsb2NrXG4gKlxuICogTm90ZTogKipJZiB0aGUgYmxvY2tOYW1lIG1hdGNoZXMgbm8gZXhpc3RpbmcgYmxvY2tzIGEgd2FybmluZyBpcyBwcmludGVkIHRvIHRoZSBjb25zb2xlIGFuZCBhIGR1bW15XG4gKiBgVW5pZm9ybUJsb2NrSW5mb2AgaXMgcmV0dXJuZWQqKi4gVGhpcyBpcyBiZWNhdXNlIHdoZW4gZGVidWdnaW5nIEdMU0xcbiAqIGl0IGlzIGNvbW1vbiB0byBjb21tZW50IG91dCBsYXJnZSBwb3J0aW9ucyBvZiBhIHNoYWRlciBvciBmb3IgZXhhbXBsZSBzZXRcbiAqIHRoZSBmaW5hbCBvdXRwdXQgdG8gYSBjb25zdGFudC4gV2hlbiB0aGF0IGhhcHBlbnMgYmxvY2tzIGdldCBvcHRpbWl6ZWQgb3V0LlxuICogSWYgdGhpcyBmdW5jdGlvbiBkaWQgbm90IGNyZWF0ZSBkdW1teSBibG9ja3MgeW91ciBjb2RlIHdvdWxkIGNyYXNoIHdoZW4gZGVidWdnaW5nLlxuICpcbiAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSBBIFdlYkdMUHJvZ3JhbVxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tTcGVjfSB1bmlmb3JtQmxvY2tTcGVjLiBBIFVuaWZvcm1CbG9ja1NwZWMgYXMgcmV0dXJuZWRcbiAqICAgICBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVVbmlmb3JtQmxvY2tTcGVjRnJvbVByb2dyYW19LlxuICogQHBhcmFtIHtzdHJpbmd9IGJsb2NrTmFtZSBUaGUgbmFtZSBvZiB0aGUgYmxvY2suXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tJbmZvfSBUaGUgY3JlYXRlZCBVbmlmb3JtQmxvY2tJbmZvXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaWZvcm1CbG9ja0luZm9Gcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbSwgdW5pZm9ybUJsb2NrU3BlYywgYmxvY2tOYW1lKSB7XG4gIHZhciBibG9ja1NwZWNzID0gdW5pZm9ybUJsb2NrU3BlYy5ibG9ja1NwZWNzO1xuICB2YXIgdW5pZm9ybURhdGEgPSB1bmlmb3JtQmxvY2tTcGVjLnVuaWZvcm1EYXRhO1xuICB2YXIgYmxvY2tTcGVjID0gYmxvY2tTcGVjc1tibG9ja05hbWVdO1xuXG4gIGlmICghYmxvY2tTcGVjKSB7XG4gICAgd2FybihcIm5vIHVuaWZvcm0gYmxvY2sgb2JqZWN0IG5hbWVkOlwiLCBibG9ja05hbWUpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBibG9ja05hbWUsXG4gICAgICB1bmlmb3Jtczoge31cbiAgICB9O1xuICB9XG5cbiAgdmFyIGFycmF5ID0gbmV3IEFycmF5QnVmZmVyKGJsb2NrU3BlYy5zaXplKTtcbiAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICB2YXIgdW5pZm9ybUJ1ZmZlckluZGV4ID0gYmxvY2tTcGVjLmluZGV4O1xuICBnbC5iaW5kQnVmZmVyKFVOSUZPUk1fQlVGRkVSLCBidWZmZXIpO1xuICBnbC51bmlmb3JtQmxvY2tCaW5kaW5nKHByb2dyYW0sIGJsb2NrU3BlYy5pbmRleCwgdW5pZm9ybUJ1ZmZlckluZGV4KTtcbiAgdmFyIHByZWZpeCA9IGJsb2NrTmFtZSArIFwiLlwiO1xuXG4gIGlmIChhcnJheVN1ZmZpeFJFLnRlc3QocHJlZml4KSkge1xuICAgIHByZWZpeCA9IHByZWZpeC5yZXBsYWNlKGFycmF5U3VmZml4UkUsIFwiLlwiKTtcbiAgfVxuXG4gIHZhciB1bmlmb3JtcyA9IHt9O1xuICB2YXIgc2V0dGVycyA9IHt9O1xuICBibG9ja1NwZWMudW5pZm9ybUluZGljZXMuZm9yRWFjaChmdW5jdGlvbiAodW5pZm9ybU5keCkge1xuICAgIHZhciBkYXRhID0gdW5pZm9ybURhdGFbdW5pZm9ybU5keF07XG4gICAgdmFyIHR5cGVJbmZvID0gdHlwZU1hcFtkYXRhLnR5cGVdO1xuICAgIHZhciBUeXBlID0gdHlwZUluZm8uVHlwZTtcbiAgICB2YXIgcGFkZGVkU2l6ZSA9IHBhZCh0eXBlSW5mby5zaXplLCAxNik7XG4gICAgdmFyIGxlbmd0aCA9IHR5cGVJbmZvLnNpemUgKyAoZGF0YS5zaXplIC0gMSkgKiBwYWRkZWRTaXplO1xuICAgIHZhciBuYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIocHJlZml4Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIGlzQXJyYXkgPSBuYW1lLmVuZHNXaXRoKCdbMF0nKTtcblxuICAgIGlmIChpc0FycmF5KSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMCwgbmFtZS5sZW5ndGggLSAzKTtcbiAgICB9XG5cbiAgICB2YXIgdW5pZm9ybVZpZXcgPSBuZXcgVHlwZShhcnJheSwgZGF0YS5vZmZzZXQsIGxlbmd0aCAvIFR5cGUuQllURVNfUEVSX0VMRU1FTlQpO1xuICAgIHVuaWZvcm1zW25hbWVdID0gdW5pZm9ybVZpZXc7XG4gICAgc2V0dGVyc1tuYW1lXSA9IGNyZWF0ZVVuaWZvcm1CbG9ja1VuaWZvcm1TZXR0ZXIodW5pZm9ybVZpZXcsIFR5cGUsIHR5cGVJbmZvLnNpemUsIHBhZGRlZFNpemUsIGlzQXJyYXkpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBibG9ja05hbWUsXG4gICAgYXJyYXk6IGFycmF5LFxuICAgIGFzRmxvYXQ6IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkpLFxuICAgIC8vIGZvciBkZWJ1Z2dpbmdcbiAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICB1bmlmb3JtczogdW5pZm9ybXMsXG4gICAgc2V0dGVyczogc2V0dGVyc1xuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFVuaWZvcm1CbG9ja0luZm9gIGZvciB0aGUgc3BlY2lmaWVkIGJsb2NrXG4gKlxuICogTm90ZTogKipJZiB0aGUgYmxvY2tOYW1lIG1hdGNoZXMgbm8gZXhpc3RpbmcgYmxvY2tzIGEgd2FybmluZyBpcyBwcmludGVkIHRvIHRoZSBjb25zb2xlIGFuZCBhIGR1bW15XG4gKiBgVW5pZm9ybUJsb2NrSW5mb2AgaXMgcmV0dXJuZWQqKi4gVGhpcyBpcyBiZWNhdXNlIHdoZW4gZGVidWdnaW5nIEdMU0xcbiAqIGl0IGlzIGNvbW1vbiB0byBjb21tZW50IG91dCBsYXJnZSBwb3J0aW9ucyBvZiBhIHNoYWRlciBvciBmb3IgZXhhbXBsZSBzZXRcbiAqIHRoZSBmaW5hbCBvdXRwdXQgdG8gYSBjb25zdGFudC4gV2hlbiB0aGF0IGhhcHBlbnMgYmxvY2tzIGdldCBvcHRpbWl6ZWQgb3V0LlxuICogSWYgdGhpcyBmdW5jdGlvbiBkaWQgbm90IGNyZWF0ZSBkdW1teSBibG9ja3MgeW91ciBjb2RlIHdvdWxkIGNyYXNoIHdoZW4gZGVidWdnaW5nLlxuICpcbiAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfSBwcm9ncmFtSW5mbyBhIGBQcm9ncmFtSW5mb2BcbiAqICAgICBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVQcm9ncmFtSW5mb31cbiAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja05hbWUgVGhlIG5hbWUgb2YgdGhlIGJsb2NrLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrSW5mb30gVGhlIGNyZWF0ZWQgVW5pZm9ybUJsb2NrSW5mb1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvKGdsLCBwcm9ncmFtSW5mbywgYmxvY2tOYW1lKSB7XG4gIHJldHVybiBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvRnJvbVByb2dyYW0oZ2wsIHByb2dyYW1JbmZvLnByb2dyYW0sIHByb2dyYW1JbmZvLnVuaWZvcm1CbG9ja1NwZWMsIGJsb2NrTmFtZSk7XG59XG4vKipcbiAqIEJpbmRzIGEgdW5pZm9ybSBibG9jayB0byB0aGUgbWF0Y2hpbmcgdW5pZm9ybSBibG9jayBwb2ludC5cbiAqIE1hdGNoZXMgYnkgYmxvY2tzIGJ5IG5hbWUgc28gYmxvY2tzIG11c3QgaGF2ZSB0aGUgc2FtZSBuYW1lIG5vdCBqdXN0IHRoZSBzYW1lXG4gKiBzdHJ1Y3R1cmUuXG4gKlxuICogSWYgeW91IGhhdmUgY2hhbmdlZCBhbnkgdmFsdWVzIGFuZCB5b3UgdXBsb2FkIHRoZSB2YWx1ZXMgaW50byB0aGUgY29ycmVzcG9uZGluZyBXZWJHTEJ1ZmZlclxuICogY2FsbCB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0VW5pZm9ybUJsb2NrfSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTCAyIHJlbmRlcmluZyBjb250ZXh0LlxuICogQHBhcmFtIHsobW9kdWxlOnR3Z2wuUHJvZ3JhbUluZm98bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrU3BlYyl9IHByb2dyYW1JbmZvIGEgYFByb2dyYW1JbmZvYFxuICogICAgIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVByb2dyYW1JbmZvfSBvciBvciBgVW5pZm9ybUJsb2NrU3BlY2AgYXNcbiAqICAgICByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVVbmlmb3JtQmxvY2tTcGVjRnJvbVByb2dyYW19LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tJbmZvfSB1bmlmb3JtQmxvY2tJbmZvIGEgYFVuaWZvcm1CbG9ja0luZm9gIGFzIHJldHVybmVkIGZyb21cbiAqICAgICB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVW5pZm9ybUJsb2NrSW5mb30uXG4gKiBAcmV0dXJuIHtib29sfSB0cnVlIGlmIGJ1ZmZlciB3YXMgYm91bmQuIElmIHRoZSBwcm9ncmFtSW5mbyBoYXMgbm8gYmxvY2sgd2l0aCB0aGUgc2FtZSBibG9jayBuYW1lXG4gKiAgICAgbm8gYnVmZmVyIGlzIGJvdW5kLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cblxuXG5mdW5jdGlvbiBiaW5kVW5pZm9ybUJsb2NrKGdsLCBwcm9ncmFtSW5mbywgdW5pZm9ybUJsb2NrSW5mbykge1xuICB2YXIgdW5pZm9ybUJsb2NrU3BlYyA9IHByb2dyYW1JbmZvLnVuaWZvcm1CbG9ja1NwZWMgfHwgcHJvZ3JhbUluZm87XG4gIHZhciBibG9ja1NwZWMgPSB1bmlmb3JtQmxvY2tTcGVjLmJsb2NrU3BlY3NbdW5pZm9ybUJsb2NrSW5mby5uYW1lXTtcblxuICBpZiAoYmxvY2tTcGVjKSB7XG4gICAgdmFyIGJ1ZmZlckJpbmRJbmRleCA9IGJsb2NrU3BlYy5pbmRleDtcbiAgICBnbC5iaW5kQnVmZmVyUmFuZ2UoVU5JRk9STV9CVUZGRVIsIGJ1ZmZlckJpbmRJbmRleCwgdW5pZm9ybUJsb2NrSW5mby5idWZmZXIsIHVuaWZvcm1CbG9ja0luZm8ub2Zmc2V0IHx8IDAsIHVuaWZvcm1CbG9ja0luZm8uYXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFVwbG9hZHMgdGhlIGN1cnJlbnQgdW5pZm9ybSB2YWx1ZXMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgV2ViR0xCdWZmZXJcbiAqIGFuZCBiaW5kcyB0aGF0IGJ1ZmZlciB0byB0aGUgcHJvZ3JhbSdzIGNvcnJlc3BvbmRpbmcgYmluZCBwb2ludCBmb3IgdGhlIHVuaWZvcm0gYmxvY2sgb2JqZWN0LlxuICpcbiAqIElmIHlvdSBoYXZlbid0IGNoYW5nZWQgYW55IHZhbHVlcyBhbmQgeW91IG9ubHkgbmVlZCB0byBiaW5kIHRoZSB1bmlmb3JtIGJsb2NrIG9iamVjdFxuICogY2FsbCB7QGxpbmsgbW9kdWxlOnR3Z2wuYmluZFVuaWZvcm1CbG9ja30gaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0wgMiByZW5kZXJpbmcgY29udGV4dC5cbiAqIEBwYXJhbSB7KG1vZHVsZTp0d2dsLlByb2dyYW1JbmZvfG1vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja1NwZWMpfSBwcm9ncmFtSW5mbyBhIGBQcm9ncmFtSW5mb2BcbiAqICAgICBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVQcm9ncmFtSW5mb30gb3Igb3IgYFVuaWZvcm1CbG9ja1NwZWNgIGFzXG4gKiAgICAgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtfS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrSW5mb30gdW5pZm9ybUJsb2NrSW5mbyBhIGBVbmlmb3JtQmxvY2tJbmZvYCBhcyByZXR1cm5lZCBmcm9tXG4gKiAgICAge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVVuaWZvcm1CbG9ja0luZm99LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRVbmlmb3JtQmxvY2soZ2wsIHByb2dyYW1JbmZvLCB1bmlmb3JtQmxvY2tJbmZvKSB7XG4gIGlmIChiaW5kVW5pZm9ybUJsb2NrKGdsLCBwcm9ncmFtSW5mbywgdW5pZm9ybUJsb2NrSW5mbykpIHtcbiAgICBnbC5idWZmZXJEYXRhKFVOSUZPUk1fQlVGRkVSLCB1bmlmb3JtQmxvY2tJbmZvLmFycmF5LCBEWU5BTUlDX0RSQVcpO1xuICB9XG59XG4vKipcbiAqIFNldHMgdmFsdWVzIG9mIGEgdW5pZm9ybSBibG9jayBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja0luZm99IHVuaWZvcm1CbG9ja0luZm8gQSBVbmlmb3JtQmxvY2tJbmZvIGFzIHJldHVybmVkIGJ5IHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVVbmlmb3JtQmxvY2tJbmZvfS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsID8+fSB2YWx1ZXMgQSB1bmlmb3JtIG5hbWUgdG8gdmFsdWUgbWFwIHdoZXJlIHRoZSB2YWx1ZSBpcyBjb3JyZWN0IGZvciB0aGUgZ2l2ZW5cbiAqICAgIHR5cGUgb2YgdW5pZm9ybS4gU28gZm9yIGV4YW1wbGUgZ2l2ZW4gYSBibG9jayBsaWtlXG4gKlxuICogICAgICAgdW5pZm9ybSBTb21lQmxvY2sge1xuICogICAgICAgICBmbG9hdCBzb21lRmxvYXQ7XG4gKiAgICAgICAgIHZlYzIgc29tZVZlYzI7XG4gKiAgICAgICAgIHZlYzMgc29tZVZlYzNBcnJheVsyXTtcbiAqICAgICAgICAgaW50IHNvbWVJbnQ7XG4gKiAgICAgICB9XG4gKlxuICogIFlvdSBjYW4gc2V0IHRoZSB2YWx1ZXMgb2YgdGhlIHVuaWZvcm0gYmxvY2sgd2l0aFxuICpcbiAqICAgICAgIHR3Z2wuc2V0QmxvY2tVbmlmb3Jtcyhzb21lQmxvY2tJbmZvLCB7XG4gKiAgICAgICAgICBzb21lRmxvYXQ6IDEyLjMsXG4gKiAgICAgICAgICBzb21lVmVjMjogWzEsIDJdLFxuICogICAgICAgICAgc29tZVZlYzNBcnJheTogWzEsIDIsIDMsIDQsIDUsIDZdLFxuICogICAgICAgICAgc29tZUludDogNSxcbiAqICAgICAgIH1cbiAqXG4gKiAgQXJyYXlzIGNhbiBiZSBKYXZhU2NyaXB0IGFycmF5cyBvciB0eXBlZCBhcnJheXNcbiAqXG4gKiAgQW55IG5hbWUgdGhhdCBkb2Vzbid0IG1hdGNoIHdpbGwgYmUgaWdub3JlZFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRCbG9ja1VuaWZvcm1zKHVuaWZvcm1CbG9ja0luZm8sIHZhbHVlcykge1xuICB2YXIgc2V0dGVycyA9IHVuaWZvcm1CbG9ja0luZm8uc2V0dGVycztcblxuICBmb3IgKHZhciBuYW1lIGluIHZhbHVlcykge1xuICAgIHZhciBzZXR0ZXIgPSBzZXR0ZXJzW25hbWVdO1xuXG4gICAgaWYgKHNldHRlcikge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW25hbWVdO1xuICAgICAgc2V0dGVyKHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogU2V0IHVuaWZvcm1zIGFuZCBiaW5kcyByZWxhdGVkIHRleHR1cmVzLlxuICpcbiAqIGV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHByb2dyYW1JbmZvID0gY3JlYXRlUHJvZ3JhbUluZm8oXG4gKiAgICAgICAgIGdsLCBbXCJzb21lLXZzXCIsIFwic29tZS1mc1wiXSk7XG4gKlxuICogICAgIGNvbnN0IHRleDEgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gKiAgICAgY29uc3QgdGV4MiA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAqXG4gKiAgICAgLi4uIGFzc3VtZSB3ZSBzZXR1cCB0aGUgdGV4dHVyZXMgd2l0aCBkYXRhIC4uLlxuICpcbiAqICAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAqICAgICAgIHVfc29tZVNhbXBsZXI6IHRleDEsXG4gKiAgICAgICB1X3NvbWVPdGhlclNhbXBsZXI6IHRleDIsXG4gKiAgICAgICB1X3NvbWVDb2xvcjogWzEsMCwwLDFdLFxuICogICAgICAgdV9zb21lUG9zaXRpb246IFswLDEsMV0sXG4gKiAgICAgICB1X3NvbWVNYXRyaXg6IFtcbiAqICAgICAgICAgMSwwLDAsMCxcbiAqICAgICAgICAgMCwxLDAsMCxcbiAqICAgICAgICAgMCwwLDEsMCxcbiAqICAgICAgICAgMCwwLDAsMCxcbiAqICAgICAgIF0sXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAqXG4gKiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSBiaW5kIHRoZSB0ZXh0dXJlcyBBTkQgc2V0IHRoZVxuICogdW5pZm9ybXMuXG4gKlxuICogICAgIHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIHVuaWZvcm1zKTtcbiAqXG4gKiBGb3IgdGhlIGV4YW1wbGUgYWJvdmUgaXQgaXMgZXF1aXZhbGVudCB0b1xuICpcbiAqICAgICB2YXIgdGV4VW5pdCA9IDA7XG4gKiAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleFVuaXQpO1xuICogICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleDEpO1xuICogICAgIGdsLnVuaWZvcm0xaSh1X3NvbWVTYW1wbGVyTG9jYXRpb24sIHRleFVuaXQrKyk7XG4gKiAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleFVuaXQpO1xuICogICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleDIpO1xuICogICAgIGdsLnVuaWZvcm0xaSh1X3NvbWVTYW1wbGVyTG9jYXRpb24sIHRleFVuaXQrKyk7XG4gKiAgICAgZ2wudW5pZm9ybTRmdih1X3NvbWVDb2xvckxvY2F0aW9uLCBbMSwgMCwgMCwgMV0pO1xuICogICAgIGdsLnVuaWZvcm0zZnYodV9zb21lUG9zaXRpb25Mb2NhdGlvbiwgWzAsIDEsIDFdKTtcbiAqICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHVfc29tZU1hdHJpeCwgZmFsc2UsIFtcbiAqICAgICAgICAgMSwwLDAsMCxcbiAqICAgICAgICAgMCwxLDAsMCxcbiAqICAgICAgICAgMCwwLDEsMCxcbiAqICAgICAgICAgMCwwLDAsMCxcbiAqICAgICAgIF0pO1xuICpcbiAqIE5vdGUgaXQgaXMgcGVyZmVjdGx5IHJlYXNvbmFibGUgdG8gY2FsbCBgc2V0VW5pZm9ybXNgIG11bHRpcGxlIHRpbWVzLiBGb3IgZXhhbXBsZVxuICpcbiAqICAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAqICAgICAgIHVfc29tZVNhbXBsZXI6IHRleDEsXG4gKiAgICAgICB1X3NvbWVPdGhlclNhbXBsZXI6IHRleDIsXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgY29uc3QgbW9yZVVuaWZvcm1zIHtcbiAqICAgICAgIHVfc29tZUNvbG9yOiBbMSwwLDAsMV0sXG4gKiAgICAgICB1X3NvbWVQb3NpdGlvbjogWzAsMSwxXSxcbiAqICAgICAgIHVfc29tZU1hdHJpeDogW1xuICogICAgICAgICAxLDAsMCwwLFxuICogICAgICAgICAwLDEsMCwwLFxuICogICAgICAgICAwLDAsMSwwLFxuICogICAgICAgICAwLDAsMCwwLFxuICogICAgICAgXSxcbiAqICAgICB9O1xuICpcbiAqICAgICB0d2dsLnNldFVuaWZvcm1zKHByb2dyYW1JbmZvLCB1bmlmb3Jtcyk7XG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgbW9yZVVuaWZvcm1zKTtcbiAqXG4gKiBZb3UgY2FuIGFsc28gYWRkIFdlYkdMU2FtcGxlcnMgdG8gdW5pZm9ybSBzYW1wbGVycyBhcyBpblxuICpcbiAqICAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAqICAgICAgIHVfc29tZVNhbXBsZXI6IHtcbiAqICAgICAgICAgdGV4dHVyZTogc29tZVdlYkdMVGV4dHVyZSxcbiAqICAgICAgICAgc2FtcGxlcjogc29tZVdlYkdMU2FtcGxlcixcbiAqICAgICAgIH0sXG4gKiAgICAgfTtcbiAqXG4gKiBJbiB3aGljaCBjYXNlIGJvdGggdGhlIHNhbXBsZXIgYW5kIHRleHR1cmUgd2lsbCBiZSBib3VuZCB0byB0aGVcbiAqIHNhbWUgdW5pdC5cbiAqXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+KX0gc2V0dGVycyBhIGBQcm9ncmFtSW5mb2AgYXMgcmV0dXJuZWQgZnJvbSBgY3JlYXRlUHJvZ3JhbUluZm9gIG9yIHRoZSBzZXR0ZXJzIHJldHVybmVkIGZyb21cbiAqICAgICAgICBgY3JlYXRlVW5pZm9ybVNldHRlcnNgLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgPz59IHZhbHVlcyBhbiBvYmplY3Qgd2l0aCB2YWx1ZXMgZm9yIHRoZVxuICogICAgICAgIHVuaWZvcm1zLlxuICogICBZb3UgY2FuIHBhc3MgbXVsdGlwbGUgb2JqZWN0cyBieSBwdXR0aW5nIHRoZW0gaW4gYW4gYXJyYXkgb3IgYnkgY2FsbGluZyB3aXRoIG1vcmUgYXJndW1lbnRzLkZvciBleGFtcGxlXG4gKlxuICogICAgIGNvbnN0IHNoYXJlZFVuaWZvcm1zID0ge1xuICogICAgICAgdV9mb2dOZWFyOiAxMCxcbiAqICAgICAgIHVfcHJvamVjdGlvbjogLi4uXG4gKiAgICAgICAuLi5cbiAqICAgICB9O1xuICpcbiAqICAgICBjb25zdCBsb2NhbFVuaWZvcm1zID0ge1xuICogICAgICAgdV93b3JsZDogLi4uXG4gKiAgICAgICB1X2RpZmZ1c2VDb2xvcjogLi4uXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgc2hhcmVkVW5pZm9ybXMsIGxvY2FsVW5pZm9ybXMpO1xuICpcbiAqICAgICAvLyBpcyB0aGUgc2FtZSBhc1xuICpcbiAqICAgICB0d2dsLnNldFVuaWZvcm1zKHByb2dyYW1JbmZvLCBbc2hhcmVkVW5pZm9ybXMsIGxvY2FsVW5pZm9ybXNdKTtcbiAqXG4gKiAgICAgLy8gaXMgdGhlIHNhbWUgYXNcbiAqXG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgc2hhcmVkVW5pZm9ybXMpO1xuICogICAgIHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIGxvY2FsVW5pZm9ybXN9O1xuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gc2V0VW5pZm9ybXMoc2V0dGVycywgdmFsdWVzKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGFjdHVhbFNldHRlcnMgPSBzZXR0ZXJzLnVuaWZvcm1TZXR0ZXJzIHx8IHNldHRlcnM7XG4gIHZhciBudW1BcmdzID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICBmb3IgKHZhciBhTmR4ID0gMTsgYU5keCA8IG51bUFyZ3M7ICsrYU5keCkge1xuICAgIHZhciBfdmFsdWVzID0gYXJndW1lbnRzW2FOZHhdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX3ZhbHVlcykpIHtcbiAgICAgIHZhciBudW1WYWx1ZXMgPSBfdmFsdWVzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG51bVZhbHVlczsgKytpaSkge1xuICAgICAgICBzZXRVbmlmb3JtcyhhY3R1YWxTZXR0ZXJzLCBfdmFsdWVzW2lpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gX3ZhbHVlcykge1xuICAgICAgICB2YXIgc2V0dGVyID0gYWN0dWFsU2V0dGVyc1tuYW1lXTtcblxuICAgICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgICAgc2V0dGVyKF92YWx1ZXNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEFsaWFzIGZvciBgc2V0VW5pZm9ybXNgXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7KG1vZHVsZTp0d2dsLlByb2dyYW1JbmZvfE9iamVjdC48c3RyaW5nLCBmdW5jdGlvbj4pfSBzZXR0ZXJzIGEgYFByb2dyYW1JbmZvYCBhcyByZXR1cm5lZCBmcm9tIGBjcmVhdGVQcm9ncmFtSW5mb2Agb3IgdGhlIHNldHRlcnMgcmV0dXJuZWQgZnJvbVxuICogICAgICAgIGBjcmVhdGVVbmlmb3JtU2V0dGVyc2AuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCA/Pn0gdmFsdWVzIGFuIG9iamVjdCB3aXRoIHZhbHVlcyBmb3IgdGhlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuXG5cbnZhciBzZXRVbmlmb3Jtc0FuZEJpbmRUZXh0dXJlcyA9IHNldFVuaWZvcm1zO1xuLyoqXG4gKiBDcmVhdGVzIHNldHRlciBmdW5jdGlvbnMgZm9yIGFsbCBhdHRyaWJ1dGVzIG9mIGEgc2hhZGVyXG4gKiBwcm9ncmFtLiBZb3UgY2FuIHBhc3MgdGhpcyB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXN9IHRvIHNldCBhbGwgeW91ciBidWZmZXJzIGFuZCBhdHRyaWJ1dGVzLlxuICpcbiAqIEBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLnNldEF0dHJpYnV0ZXN9IGZvciBleGFtcGxlXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSB0aGUgcHJvZ3JhbSB0byBjcmVhdGUgc2V0dGVycyBmb3IuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBhbiBvYmplY3Qgd2l0aCBhIHNldHRlciBmb3IgZWFjaCBhdHRyaWJ1dGUgYnkgbmFtZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cbmV4cG9ydHMuc2V0VW5pZm9ybXNBbmRCaW5kVGV4dHVyZXMgPSBzZXRVbmlmb3Jtc0FuZEJpbmRUZXh0dXJlcztcblxuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlU2V0dGVycyhnbCwgcHJvZ3JhbSkge1xuICB2YXIgYXR0cmliU2V0dGVycyA9IHt9O1xuICB2YXIgbnVtQXR0cmlicyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgQUNUSVZFX0FUVFJJQlVURVMpO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1BdHRyaWJzOyArK2lpKSB7XG4gICAgdmFyIGF0dHJpYkluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaWkpO1xuXG4gICAgaWYgKGlzQnVpbHRJbihhdHRyaWJJbmZvKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmliSW5mby5uYW1lKTtcbiAgICB2YXIgdHlwZUluZm8gPSBhdHRyVHlwZU1hcFthdHRyaWJJbmZvLnR5cGVdO1xuICAgIHZhciBzZXR0ZXIgPSB0eXBlSW5mby5zZXR0ZXIoZ2wsIGluZGV4LCB0eXBlSW5mbyk7XG4gICAgc2V0dGVyLmxvY2F0aW9uID0gaW5kZXg7XG4gICAgYXR0cmliU2V0dGVyc1thdHRyaWJJbmZvLm5hbWVdID0gc2V0dGVyO1xuICB9XG5cbiAgcmV0dXJuIGF0dHJpYlNldHRlcnM7XG59XG4vKipcbiAqIFNldHMgYXR0cmlidXRlcyBhbmQgYmluZHMgYnVmZmVycyAoZGVwcmVjYXRlZC4uLiB1c2Uge0BsaW5rIG1vZHVsZTp0d2dsLnNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzfSlcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzKFxuICogICAgICAgICBnbCwgW1wic29tZS12c1wiLCBcInNvbWUtZnNcIik7XG4gKlxuICogICAgIGNvbnN0IGF0dHJpYlNldHRlcnMgPSBjcmVhdGVBdHRyaWJ1dGVTZXR0ZXJzKHByb2dyYW0pO1xuICpcbiAqICAgICBjb25zdCBwb3NpdGlvbkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICogICAgIGNvbnN0IHRleGNvb3JkQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gKlxuICogICAgIGNvbnN0IGF0dHJpYnMgPSB7XG4gKiAgICAgICBhX3Bvc2l0aW9uOiB7YnVmZmVyOiBwb3NpdGlvbkJ1ZmZlciwgbnVtQ29tcG9uZW50czogM30sXG4gKiAgICAgICBhX3RleGNvb3JkOiB7YnVmZmVyOiB0ZXhjb29yZEJ1ZmZlciwgbnVtQ29tcG9uZW50czogMn0sXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAqXG4gKiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSBiaW5kIHRoZSBidWZmZXJzIEFORCBzZXQgdGhlXG4gKiBhdHRyaWJ1dGVzLlxuICpcbiAqICAgICBzZXRBdHRyaWJ1dGVzKGF0dHJpYlNldHRlcnMsIGF0dHJpYnMpO1xuICpcbiAqIFByb3BlcnRpZXMgb2YgYXR0cmlicy4gRm9yIGVhY2ggYXR0cmliIHlvdSBjYW4gYWRkXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICogICB0eXBlOiB0aGUgdHlwZSBvZiBkYXRhIGluIHRoZSBidWZmZXIuIERlZmF1bHQgPSBnbC5GTE9BVFxuICogKiAgIG5vcm1hbGl6ZTogd2hldGhlciBvciBub3QgdG8gbm9ybWFsaXplIHRoZSBkYXRhLiBEZWZhdWx0ID0gZmFsc2VcbiAqICogICBzdHJpZGU6IHRoZSBzdHJpZGUuIERlZmF1bHQgPSAwXG4gKiAqICAgb2Zmc2V0OiBvZmZzZXQgaW50byB0aGUgYnVmZmVyLiBEZWZhdWx0ID0gMFxuICogKiAgIGRpdmlzb3I6IHRoZSBkaXZpc29yIGZvciBpbnN0YW5jZXMuIERlZmF1bHQgPSB1bmRlZmluZWRcbiAqXG4gKiBGb3IgZXhhbXBsZSBpZiB5b3UgaGFkIDMgdmFsdWUgZmxvYXQgcG9zaXRpb25zLCAyIHZhbHVlXG4gKiBmbG9hdCB0ZXhjb29yZCBhbmQgNCB2YWx1ZSB1aW50OCBjb2xvcnMgeW91J2Qgc2V0dXAgeW91clxuICogYXR0cmlicyBsaWtlIHRoaXNcbiAqXG4gKiAgICAgY29uc3QgYXR0cmlicyA9IHtcbiAqICAgICAgIGFfcG9zaXRpb246IHtidWZmZXI6IHBvc2l0aW9uQnVmZmVyLCBudW1Db21wb25lbnRzOiAzfSxcbiAqICAgICAgIGFfdGV4Y29vcmQ6IHtidWZmZXI6IHRleGNvb3JkQnVmZmVyLCBudW1Db21wb25lbnRzOiAyfSxcbiAqICAgICAgIGFfY29sb3I6IHtcbiAqICAgICAgICAgYnVmZmVyOiBjb2xvckJ1ZmZlcixcbiAqICAgICAgICAgbnVtQ29tcG9uZW50czogNCxcbiAqICAgICAgICAgdHlwZTogZ2wuVU5TSUdORURfQllURSxcbiAqICAgICAgICAgbm9ybWFsaXplOiB0cnVlLFxuICogICAgICAgfSxcbiAqICAgICB9O1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn0gc2V0dGVycyBBdHRyaWJ1dGUgc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUF0dHJpYnV0ZVNldHRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkF0dHJpYkluZm8+fSBidWZmZXJzIEF0dHJpYkluZm9zIG1hcHBlZCBieSBhdHRyaWJ1dGUgbmFtZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayBtb2R1bGU6dHdnbC5zZXRCdWZmZXJzQW5kQXR0cmlidXRlc31cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoc2V0dGVycywgYnVmZmVycykge1xuICBmb3IgKHZhciBuYW1lIGluIGJ1ZmZlcnMpIHtcbiAgICB2YXIgc2V0dGVyID0gc2V0dGVyc1tuYW1lXTtcblxuICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgIHNldHRlcihidWZmZXJzW25hbWVdKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogU2V0cyBhdHRyaWJ1dGVzIGFuZCBidWZmZXJzIGluY2x1ZGluZyB0aGUgYEVMRU1FTlRfQVJSQVlfQlVGRkVSYCBpZiBhcHByb3ByaWF0ZVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHByb2dyYW1JbmZvID0gY3JlYXRlUHJvZ3JhbUluZm8oXG4gKiAgICAgICAgIGdsLCBbXCJzb21lLXZzXCIsIFwic29tZS1mc1wiKTtcbiAqXG4gKiAgICAgY29uc3QgYXJyYXlzID0ge1xuICogICAgICAgcG9zaXRpb246IHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDAsIDAsIDEwLCAwLCAwLCAwLCAxMCwgMCwgMTAsIDEwLCAwXSwgfSxcbiAqICAgICAgIHRleGNvb3JkOiB7IG51bUNvbXBvbmVudHM6IDIsIGRhdGE6IFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSwgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgY29uc3QgYnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzKGdsLCBhcnJheXMpO1xuICpcbiAqICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW1JbmZvLnByb2dyYW0pO1xuICpcbiAqIFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IGJpbmQgdGhlIGJ1ZmZlcnMgQU5EIHNldCB0aGVcbiAqIGF0dHJpYnV0ZXMuXG4gKlxuICogICAgIHNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzKGdsLCBwcm9ncmFtSW5mbywgYnVmZmVySW5mbyk7XG4gKlxuICogRm9yIHRoZSBleGFtcGxlIGFib3ZlIGl0IGlzIGVxdWl2YWxlbnQgdG9cbiAqXG4gKiAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uQnVmZmVyKTtcbiAqICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX3Bvc2l0aW9uTG9jYXRpb24pO1xuICogICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9wb3NpdGlvbkxvY2F0aW9uLCAzLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICogICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0ZXhjb29yZEJ1ZmZlcik7XG4gKiAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV90ZXhjb29yZExvY2F0aW9uKTtcbiAqICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfdGV4Y29vcmRMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+KX0gc2V0dGVycyBBIGBQcm9ncmFtSW5mb2AgYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlUHJvZ3JhbUluZm99IG9yIEF0dHJpYnV0ZSBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUF0dHJpYnV0ZVNldHRlcnN9XG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5CdWZmZXJJbmZvfG1vZHVsZTp0d2dsLlZlcnRleEFycmF5SW5mbyl9IGJ1ZmZlcnMgYSBgQnVmZmVySW5mb2AgYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXN9LlxuICogICBvciBhIGBWZXJ0ZXhBcnJheUluZm9gIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVZlcnRleEFycmF5SW5mb31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXMoZ2wsIHByb2dyYW1JbmZvLCBidWZmZXJzKSB7XG4gIGlmIChidWZmZXJzLnZlcnRleEFycmF5T2JqZWN0KSB7XG4gICAgZ2wuYmluZFZlcnRleEFycmF5KGJ1ZmZlcnMudmVydGV4QXJyYXlPYmplY3QpO1xuICB9IGVsc2Uge1xuICAgIHNldEF0dHJpYnV0ZXMocHJvZ3JhbUluZm8uYXR0cmliU2V0dGVycyB8fCBwcm9ncmFtSW5mbywgYnVmZmVycy5hdHRyaWJzKTtcblxuICAgIGlmIChidWZmZXJzLmluZGljZXMpIHtcbiAgICAgIGdsLmJpbmRCdWZmZXIoRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMuaW5kaWNlcyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb2dyYW1JbmZvXG4gKiBAcHJvcGVydHkge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSBBIHNoYWRlciBwcm9ncmFtXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIGZ1bmN0aW9uPn0gdW5pZm9ybVNldHRlcnMgb2JqZWN0IG9mIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVVbmlmb3JtU2V0dGVycyxcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgZnVuY3Rpb24+fSBhdHRyaWJTZXR0ZXJzIG9iamVjdCBvZiBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20gY3JlYXRlQXR0cmliU2V0dGVycyxcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrU3BlY30gW3VuaWZvcm1CbG9ja1NwYWNlXSBhIHVuaWZvcm0gYmxvY2sgc3BlYyBmb3IgbWFraW5nIFVuaWZvcm1CbG9ja0luZm9zIHdpdGggY3JlYXRlVW5pZm9ybUJsb2NrSW5mbyBldGMuLlxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5UcmFuc2Zvcm1GZWVkYmFja0luZm8+fSBbdHJhbnNmb3JtRmVlZGJhY2tJbmZvXSBpbmZvIGZvciB0cmFuc2Zvcm0gZmVlZGJhY2tzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBQcm9ncmFtSW5mbyBmcm9tIGFuIGV4aXN0aW5nIHByb2dyYW0uXG4gKlxuICogQSBQcm9ncmFtSW5mbyBjb250YWluc1xuICpcbiAqICAgICBwcm9ncmFtSW5mbyA9IHtcbiAqICAgICAgICBwcm9ncmFtOiBXZWJHTFByb2dyYW0sXG4gKiAgICAgICAgdW5pZm9ybVNldHRlcnM6IG9iamVjdCBvZiBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20gY3JlYXRlVW5pZm9ybVNldHRlcnMsXG4gKiAgICAgICAgYXR0cmliU2V0dGVyczogb2JqZWN0IG9mIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVBdHRyaWJTZXR0ZXJzLFxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogICAgICAgIHRvIHVzZS5cbiAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtIGFuIGV4aXN0aW5nIFdlYkdMUHJvZ3JhbS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfSBUaGUgY3JlYXRlZCBQcm9ncmFtSW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbUluZm9Gcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbSkge1xuICB2YXIgdW5pZm9ybVNldHRlcnMgPSBjcmVhdGVVbmlmb3JtU2V0dGVycyhnbCwgcHJvZ3JhbSk7XG4gIHZhciBhdHRyaWJTZXR0ZXJzID0gY3JlYXRlQXR0cmlidXRlU2V0dGVycyhnbCwgcHJvZ3JhbSk7XG4gIHZhciBwcm9ncmFtSW5mbyA9IHtcbiAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgIHVuaWZvcm1TZXR0ZXJzOiB1bmlmb3JtU2V0dGVycyxcbiAgICBhdHRyaWJTZXR0ZXJzOiBhdHRyaWJTZXR0ZXJzXG4gIH07XG5cbiAgaWYgKHV0aWxzLmlzV2ViR0wyKGdsKSkge1xuICAgIHByb2dyYW1JbmZvLnVuaWZvcm1CbG9ja1NwZWMgPSBjcmVhdGVVbmlmb3JtQmxvY2tTcGVjRnJvbVByb2dyYW0oZ2wsIHByb2dyYW0pO1xuICAgIHByb2dyYW1JbmZvLnRyYW5zZm9ybUZlZWRiYWNrSW5mbyA9IGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrSW5mbyhnbCwgcHJvZ3JhbSk7XG4gIH1cblxuICByZXR1cm4gcHJvZ3JhbUluZm87XG59XG4vKipcbiAqIENyZWF0ZXMgYSBQcm9ncmFtSW5mbyBmcm9tIDIgc291cmNlcy5cbiAqXG4gKiBBIFByb2dyYW1JbmZvIGNvbnRhaW5zXG4gKlxuICogICAgIHByb2dyYW1JbmZvID0ge1xuICogICAgICAgIHByb2dyYW06IFdlYkdMUHJvZ3JhbSxcbiAqICAgICAgICB1bmlmb3JtU2V0dGVyczogb2JqZWN0IG9mIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVVbmlmb3JtU2V0dGVycyxcbiAqICAgICAgICBhdHRyaWJTZXR0ZXJzOiBvYmplY3Qgb2Ygc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUF0dHJpYlNldHRlcnMsXG4gKiAgICAgfVxuICpcbiAqIE5PVEU6IFRoZXJlIGFyZSA0IHNpZ25hdHVyZXMgZm9yIHRoaXMgZnVuY3Rpb25cbiAqXG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZzLCBmc10sIG9wdGlvbnMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUluZm8oZ2wsIFt2cywgZnNdLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyRnVuYyk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqICAgICAgICB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzaGFkZXJTb3VyY2VzIEFycmF5IG9mIHNvdXJjZXMgZm9yIHRoZVxuICogICAgICAgIHNoYWRlcnMgb3IgaWRzLiBUaGUgZmlyc3QgaXMgYXNzdW1lZCB0byBiZSB0aGUgdmVydGV4IHNoYWRlcixcbiAqICAgICAgICB0aGUgc2Vjb25kIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1PcHRpb25zfHN0cmluZ1tdfG1vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfYXR0cmlic10gT3B0aW9ucyBmb3IgdGhlIHByb2dyYW0gb3IgYW4gYXJyYXkgb2YgYXR0cmlicyBuYW1lcyBvciBhbiBlcnJvciBjYWxsYmFjay4gTG9jYXRpb25zIHdpbGwgYmUgYXNzaWduZWQgYnkgaW5kZXggaWYgbm90IHBhc3NlZCBpblxuICogQHBhcmFtIHtudW1iZXJbXX0gW29wdF9sb2NhdGlvbnN8bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja10gVGhlIGxvY2F0aW9ucyBmb3IgdGhlLiBBIHBhcmFsbGVsIGFycmF5IHRvIG9wdF9hdHRyaWJzIGxldHRpbmcgeW91IGFzc2lnbiBsb2NhdGlvbnMgb3IgYW4gZXJyb3IgY2FsbGJhY2suXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9ycy4gQnkgZGVmYXVsdCBpdCBqdXN0IHByaW50cyBhbiBlcnJvciB0byB0aGUgY29uc29sZVxuICogICAgICAgIG9uIGVycm9yLiBJZiB5b3Ugd2FudCBzb21ldGhpbmcgZWxzZSBwYXNzIGFuIGNhbGxiYWNrLiBJdCdzIHBhc3NlZCBhbiBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuUHJvZ3JhbUluZm8/fSBUaGUgY3JlYXRlZCBQcm9ncmFtSW5mbyBvciBudWxsIGlmIGl0IGZhaWxlZCB0byBsaW5rIG9yIGNvbXBpbGVcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbUluZm8oZ2wsIHNoYWRlclNvdXJjZXMsIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICB2YXIgcHJvZ09wdGlvbnMgPSBnZXRQcm9ncmFtT3B0aW9ucyhvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spO1xuICB2YXIgZ29vZCA9IHRydWU7XG4gIHNoYWRlclNvdXJjZXMgPSBzaGFkZXJTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgLy8gTGV0cyBhc3N1bWUgaWYgdGhlcmUgaXMgbm8gXFxuIGl0J3MgYW4gaWRcbiAgICBpZiAoc291cmNlLmluZGV4T2YoXCJcXG5cIikgPCAwKSB7XG4gICAgICB2YXIgc2NyaXB0ID0gZ2V0RWxlbWVudEJ5SWQoc291cmNlKTtcblxuICAgICAgaWYgKCFzY3JpcHQpIHtcbiAgICAgICAgcHJvZ09wdGlvbnMuZXJyb3JDYWxsYmFjayhcIm5vIGVsZW1lbnQgd2l0aCBpZDogXCIgKyBzb3VyY2UpO1xuICAgICAgICBnb29kID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2UgPSBzY3JpcHQudGV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlO1xuICB9KTtcblxuICBpZiAoIWdvb2QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2VzKGdsLCBzaGFkZXJTb3VyY2VzLCBwcm9nT3B0aW9ucyk7XG5cbiAgaWYgKCFwcm9ncmFtKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlUHJvZ3JhbUluZm9Gcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RleHR1cmVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RleHR1cmVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuc2V0VGV4dHVyZURlZmF1bHRzXyA9IHNldERlZmF1bHRzO1xuZXhwb3J0cy5jcmVhdGVTYW1wbGVyID0gY3JlYXRlU2FtcGxlcjtcbmV4cG9ydHMuY3JlYXRlU2FtcGxlcnMgPSBjcmVhdGVTYW1wbGVycztcbmV4cG9ydHMuc2V0U2FtcGxlclBhcmFtZXRlcnMgPSBzZXRTYW1wbGVyUGFyYW1ldGVycztcbmV4cG9ydHMuY3JlYXRlVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmU7XG5leHBvcnRzLnNldEVtcHR5VGV4dHVyZSA9IHNldEVtcHR5VGV4dHVyZTtcbmV4cG9ydHMuc2V0VGV4dHVyZUZyb21BcnJheSA9IHNldFRleHR1cmVGcm9tQXJyYXk7XG5leHBvcnRzLmxvYWRUZXh0dXJlRnJvbVVybCA9IGxvYWRUZXh0dXJlRnJvbVVybDtcbmV4cG9ydHMuc2V0VGV4dHVyZUZyb21FbGVtZW50ID0gc2V0VGV4dHVyZUZyb21FbGVtZW50O1xuZXhwb3J0cy5zZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZSA9IHNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplO1xuZXhwb3J0cy5zZXRUZXh0dXJlUGFyYW1ldGVycyA9IHNldFRleHR1cmVQYXJhbWV0ZXJzO1xuZXhwb3J0cy5zZXREZWZhdWx0VGV4dHVyZUNvbG9yID0gc2V0RGVmYXVsdFRleHR1cmVDb2xvcjtcbmV4cG9ydHMuY3JlYXRlVGV4dHVyZXMgPSBjcmVhdGVUZXh0dXJlcztcbmV4cG9ydHMucmVzaXplVGV4dHVyZSA9IHJlc2l6ZVRleHR1cmU7XG5leHBvcnRzLmNhbkdlbmVyYXRlTWlwbWFwID0gY2FuR2VuZXJhdGVNaXBtYXA7XG5leHBvcnRzLmNhbkZpbHRlciA9IGNhbkZpbHRlcjtcbmV4cG9ydHMuZ2V0TnVtQ29tcG9uZW50c0ZvckZvcm1hdCA9IGdldE51bUNvbXBvbmVudHNGb3JGb3JtYXQ7XG5leHBvcnRzLmdldEJ5dGVzUGVyRWxlbWVudEZvckludGVybmFsRm9ybWF0ID0gZ2V0Qnl0ZXNQZXJFbGVtZW50Rm9ySW50ZXJuYWxGb3JtYXQ7XG5leHBvcnRzLmdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdCA9IGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdDtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy5qcyAqLyBcIi4vc3JjL3V0aWxzLmpzXCIpKTtcblxudmFyIHR5cGVkQXJyYXlzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90eXBlZGFycmF5cy5qcyAqLyBcIi4vc3JjL3R5cGVkYXJyYXlzLmpzXCIpKTtcblxudmFyIGhlbHBlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGVscGVyLmpzICovIFwiLi9zcmMvaGVscGVyLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIExvdyBsZXZlbCB0ZXh0dXJlIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKlxuICogWW91IHNob3VsZCBnZW5lcmFsbHkgbm90IG5lZWQgdG8gdXNlIHRoZXNlIGZ1bmN0aW9ucy4gVGhleSBhcmUgcHJvdmlkZWRcbiAqIGZvciB0aG9zZSBjYXNlcyB3aGVyZSB5b3UncmUgZG9pbmcgc29tZXRoaW5nIG91dCBvZiB0aGUgb3JkaW5hcnlcbiAqIGFuZCB5b3UgbmVlZCBsb3dlciBsZXZlbCBhY2Nlc3MuXG4gKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgdGhleSBhcmUgYXZhaWxhYmxlIGF0IGJvdGggYHR3Z2wudGV4dHVyZXNgIGFuZCBgdHdnbGBcbiAqIGl0c2VsZlxuICpcbiAqIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2x9IGZvciBjb3JlIGZ1bmN0aW9uc1xuICpcbiAqIEBtb2R1bGUgdHdnbC90ZXh0dXJlc1xuICovXG4vLyBtYWtlIHN1cmUgd2UgZG9uJ3Qgc2VlIGEgZ2xvYmFsIGdsXG52YXIgZ2wgPSB1bmRlZmluZWQ7XG4vKiBlc2xpbnQtZGlzYWJsZS1saW5lICovXG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgdGV4dHVyZUNvbG9yOiBuZXcgVWludDhBcnJheShbMTI4LCAxOTIsIDI1NSwgMjU1XSksXG4gIHRleHR1cmVPcHRpb25zOiB7fSxcbiAgY3Jvc3NPcmlnaW46IHVuZGVmaW5lZFxufTtcbnZhciBpc0FycmF5QnVmZmVyID0gdHlwZWRBcnJheXMuaXNBcnJheUJ1ZmZlcjsgLy8gU2hvdWxkIHdlIG1ha2UgdGhpcyBvbiBkZW1hbmQ/XG5cbnZhciBnZXRTaGFyZWQyRENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzX2N0eDtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFNoYXJlZDJEQ29udGV4dCgpIHtcbiAgICBzX2N0eCA9IHNfY3R4IHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKSA6IG51bGwpO1xuICAgIHJldHVybiBzX2N0eDtcbiAgfTtcbn0oKTsgLy8gTk9URTogQ2hyb21lIHN1cHBvcnRzIDJEIGNhbnZhcyBpbiBhIFdvcmtlciAoYmVoaW5kIGZsYWcgYXMgb2YgdjY0IGJ1dFxuLy8gICAgICAgbm90IG9ubHkgZG9lcyBGaXJlZm94IE5PVCBzdXBwb3J0IGl0IGJ1dCBGaXJlZm94IGZyZWV6ZXMgaW1tZWRpYXRlbHlcbi8vICAgICAgIGlmIHlvdSB0cnkgdG8gY3JlYXRlIG9uZSBpbnN0ZWFkIG9mIGp1c3QgcmV0dXJuaW5nIG51bGwgYW5kIGNvbnRpbnVpbmcuXG4vLyAgOiAoZ2xvYmFsLk9mZnNjcmVlbkNhbnZhcyAmJiAobmV3IGdsb2JhbC5PZmZzY3JlZW5DYW52YXMoMSwgMSkpLmdldENvbnRleHQoXCIyZFwiKSk7ICAvLyBPZmZzY3JlZW5DYW52YXMgbWF5IG5vdCBzdXBwb3J0IDJkXG4vLyBOT1RFOiBXZSBjYW4gbWF5YmUgcmVtb3ZlIHNvbWUgb2YgdGhlIG5lZWQgZm9yIHRoZSAyZCBjYW52YXMuIEluIFdlYkdMMlxuLy8gd2UgY2FuIHVzZSB0aGUgdmFyaW91cyB1bnBhY2sgc2V0dGluZ3MuIE90aGVyd2lzZSB3ZSBjb3VsZCB0cnkgdXNpbmdcbi8vIHRoZSBhYmlsaXR5IG9mIGFuIEltYWdlQml0bWFwIHRvIGJlIGN1dC4gVW5mb3J0dW5hdGVseSBjdXR0aW5nIGFuIEltYWdlQml0bWFwXG4vLyBpcyBhc3luYyBhbmQgdGhlIGN1cnJlbnQgVFdHTCBjb2RlIGV4cGVjdHMgYSBub24tQXN5bmMgcmVzdWx0IHRob3VnaCB0aGF0XG4vLyBtaWdodCBub3QgYmUgYSBwcm9ibGVtLiBJbWFnZUJpdG1hcCB0aG91Z2ggaXMgbm90IGF2YWlsYWJsZSBpbiBFZGdlIG9yIFNhZmFyaVxuLy8gYXMgb2YgMjAxOC0wMS0wMlxuXG4vKiBQaXhlbEZvcm1hdCAqL1xuXG5cbnZhciBBTFBIQSA9IDB4MTkwNjtcbnZhciBSR0IgPSAweDE5MDc7XG52YXIgUkdCQSA9IDB4MTkwODtcbnZhciBMVU1JTkFOQ0UgPSAweDE5MDk7XG52YXIgTFVNSU5BTkNFX0FMUEhBID0gMHgxOTBBO1xudmFyIERFUFRIX0NPTVBPTkVOVCA9IDB4MTkwMjtcbnZhciBERVBUSF9TVEVOQ0lMID0gMHg4NEY5O1xuLyogVGV4dHVyZVdyYXBNb2RlICovXG4vLyBjb25zdCBSRVBFQVQgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDI5MDE7XG4vLyBjb25zdCBNSVJST1JFRF9SRVBFQVQgICAgICAgICAgICAgICAgPSAweDgzNzA7XG5cbnZhciBDTEFNUF9UT19FREdFID0gMHg4MTJmO1xuLyogVGV4dHVyZU1hZ0ZpbHRlciAqL1xuXG52YXIgTkVBUkVTVCA9IDB4MjYwMDtcbnZhciBMSU5FQVIgPSAweDI2MDE7XG4vKiBUZXh0dXJlTWluRmlsdGVyICovXG4vLyBjb25zdCBORUFSRVNUX01JUE1BUF9ORUFSRVNUICAgICAgICAgPSAweDI3MDA7XG4vLyBjb25zdCBMSU5FQVJfTUlQTUFQX05FQVJFU1QgICAgICAgICAgPSAweDI3MDE7XG4vLyBjb25zdCBORUFSRVNUX01JUE1BUF9MSU5FQVIgICAgICAgICAgPSAweDI3MDI7XG4vLyBjb25zdCBMSU5FQVJfTUlQTUFQX0xJTkVBUiAgICAgICAgICAgPSAweDI3MDM7XG5cbi8qIFRleHR1cmUgVGFyZ2V0ICovXG5cbnZhciBURVhUVVJFXzJEID0gMHgwZGUxO1xudmFyIFRFWFRVUkVfQ1VCRV9NQVAgPSAweDg1MTM7XG52YXIgVEVYVFVSRV8zRCA9IDB4ODA2ZjtcbnZhciBURVhUVVJFXzJEX0FSUkFZID0gMHg4YzFhO1xuLyogQ3ViZW1hcCBUYXJnZXRzICovXG5cbnZhciBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggPSAweDg1MTU7XG52YXIgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YID0gMHg4NTE2O1xudmFyIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSA9IDB4ODUxNztcbnZhciBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1kgPSAweDg1MTg7XG52YXIgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aID0gMHg4NTE5O1xudmFyIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWiA9IDB4ODUxYTtcbi8qIFRleHR1cmUgUGFyYW1ldGVycyAqL1xuXG52YXIgVEVYVFVSRV9NSU5fRklMVEVSID0gMHgyODAxO1xudmFyIFRFWFRVUkVfTUFHX0ZJTFRFUiA9IDB4MjgwMDtcbnZhciBURVhUVVJFX1dSQVBfUyA9IDB4MjgwMjtcbnZhciBURVhUVVJFX1dSQVBfVCA9IDB4MjgwMztcbnZhciBURVhUVVJFX1dSQVBfUiA9IDB4ODA3MjtcbnZhciBURVhUVVJFX01JTl9MT0QgPSAweDgxM2E7XG52YXIgVEVYVFVSRV9NQVhfTE9EID0gMHg4MTNiO1xudmFyIFRFWFRVUkVfQkFTRV9MRVZFTCA9IDB4ODEzYztcbnZhciBURVhUVVJFX01BWF9MRVZFTCA9IDB4ODEzZDtcbi8qIFBpeGVsIHN0b3JlICovXG5cbnZhciBVTlBBQ0tfQUxJR05NRU5UID0gMHgwY2Y1O1xudmFyIFVOUEFDS19ST1dfTEVOR1RIID0gMHgwY2YyO1xudmFyIFVOUEFDS19JTUFHRV9IRUlHSFQgPSAweDgwNmU7XG52YXIgVU5QQUNLX1NLSVBfUElYRUxTID0gMHgwY2Y0O1xudmFyIFVOUEFDS19TS0lQX1JPV1MgPSAweDBjZjM7XG52YXIgVU5QQUNLX1NLSVBfSU1BR0VTID0gMHg4MDZkO1xudmFyIFVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wgPSAweDkyNDM7XG52YXIgVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMID0gMHg5MjQxO1xudmFyIFVOUEFDS19GTElQX1lfV0VCR0wgPSAweDkyNDA7XG52YXIgUjggPSAweDgyMjk7XG52YXIgUjhfU05PUk0gPSAweDhGOTQ7XG52YXIgUjE2RiA9IDB4ODIyRDtcbnZhciBSMzJGID0gMHg4MjJFO1xudmFyIFI4VUkgPSAweDgyMzI7XG52YXIgUjhJID0gMHg4MjMxO1xudmFyIFJHMTZVSSA9IDB4ODIzQTtcbnZhciBSRzE2SSA9IDB4ODIzOTtcbnZhciBSRzMyVUkgPSAweDgyM0M7XG52YXIgUkczMkkgPSAweDgyM0I7XG52YXIgUkc4ID0gMHg4MjJCO1xudmFyIFJHOF9TTk9STSA9IDB4OEY5NTtcbnZhciBSRzE2RiA9IDB4ODIyRjtcbnZhciBSRzMyRiA9IDB4ODIzMDtcbnZhciBSRzhVSSA9IDB4ODIzODtcbnZhciBSRzhJID0gMHg4MjM3O1xudmFyIFIxNlVJID0gMHg4MjM0O1xudmFyIFIxNkkgPSAweDgyMzM7XG52YXIgUjMyVUkgPSAweDgyMzY7XG52YXIgUjMySSA9IDB4ODIzNTtcbnZhciBSR0I4ID0gMHg4MDUxO1xudmFyIFNSR0I4ID0gMHg4QzQxO1xudmFyIFJHQjU2NSA9IDB4OEQ2MjtcbnZhciBSR0I4X1NOT1JNID0gMHg4Rjk2O1xudmFyIFIxMUZfRzExRl9CMTBGID0gMHg4QzNBO1xudmFyIFJHQjlfRTUgPSAweDhDM0Q7XG52YXIgUkdCMTZGID0gMHg4ODFCO1xudmFyIFJHQjMyRiA9IDB4ODgxNTtcbnZhciBSR0I4VUkgPSAweDhEN0Q7XG52YXIgUkdCOEkgPSAweDhEOEY7XG52YXIgUkdCMTZVSSA9IDB4OEQ3NztcbnZhciBSR0IxNkkgPSAweDhEODk7XG52YXIgUkdCMzJVSSA9IDB4OEQ3MTtcbnZhciBSR0IzMkkgPSAweDhEODM7XG52YXIgUkdCQTggPSAweDgwNTg7XG52YXIgU1JHQjhfQUxQSEE4ID0gMHg4QzQzO1xudmFyIFJHQkE4X1NOT1JNID0gMHg4Rjk3O1xudmFyIFJHQjVfQTEgPSAweDgwNTc7XG52YXIgUkdCQTQgPSAweDgwNTY7XG52YXIgUkdCMTBfQTIgPSAweDgwNTk7XG52YXIgUkdCQTE2RiA9IDB4ODgxQTtcbnZhciBSR0JBMzJGID0gMHg4ODE0O1xudmFyIFJHQkE4VUkgPSAweDhEN0M7XG52YXIgUkdCQThJID0gMHg4RDhFO1xudmFyIFJHQjEwX0EyVUkgPSAweDkwNkY7XG52YXIgUkdCQTE2VUkgPSAweDhENzY7XG52YXIgUkdCQTE2SSA9IDB4OEQ4ODtcbnZhciBSR0JBMzJJID0gMHg4RDgyO1xudmFyIFJHQkEzMlVJID0gMHg4RDcwO1xudmFyIERFUFRIX0NPTVBPTkVOVDE2ID0gMHg4MUE1O1xudmFyIERFUFRIX0NPTVBPTkVOVDI0ID0gMHg4MUE2O1xudmFyIERFUFRIX0NPTVBPTkVOVDMyRiA9IDB4OENBQztcbnZhciBERVBUSDMyRl9TVEVOQ0lMOCA9IDB4OENBRDtcbnZhciBERVBUSDI0X1NURU5DSUw4ID0gMHg4OEYwO1xuLyogRGF0YVR5cGUgKi9cblxudmFyIEJZVEUgPSAweDE0MDA7XG52YXIgVU5TSUdORURfQllURSA9IDB4MTQwMTtcbnZhciBTSE9SVCA9IDB4MTQwMjtcbnZhciBVTlNJR05FRF9TSE9SVCA9IDB4MTQwMztcbnZhciBJTlQgPSAweDE0MDQ7XG52YXIgVU5TSUdORURfSU5UID0gMHgxNDA1O1xudmFyIEZMT0FUID0gMHgxNDA2O1xudmFyIFVOU0lHTkVEX1NIT1JUXzRfNF80XzQgPSAweDgwMzM7XG52YXIgVU5TSUdORURfU0hPUlRfNV81XzVfMSA9IDB4ODAzNDtcbnZhciBVTlNJR05FRF9TSE9SVF81XzZfNSA9IDB4ODM2MztcbnZhciBIQUxGX0ZMT0FUID0gMHgxNDBCO1xudmFyIEhBTEZfRkxPQVRfT0VTID0gMHg4RDYxOyAvLyBUaGFua3MgS2hyb25vcyBmb3IgbWFraW5nIHRoaXMgZGlmZmVyZW50ID46KFxuXG52YXIgVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWID0gMHg4MzY4O1xudmFyIFVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVYgPSAweDhDM0I7XG52YXIgVU5TSUdORURfSU5UXzVfOV85XzlfUkVWID0gMHg4QzNFO1xudmFyIEZMT0FUXzMyX1VOU0lHTkVEX0lOVF8yNF84X1JFViA9IDB4OERBRDtcbnZhciBVTlNJR05FRF9JTlRfMjRfOCA9IDB4ODRGQTtcbnZhciBSRyA9IDB4ODIyNztcbnZhciBSR19JTlRFR0VSID0gMHg4MjI4O1xudmFyIFJFRCA9IDB4MTkwMztcbnZhciBSRURfSU5URUdFUiA9IDB4OEQ5NDtcbnZhciBSR0JfSU5URUdFUiA9IDB4OEQ5ODtcbnZhciBSR0JBX0lOVEVHRVIgPSAweDhEOTk7XG52YXIgZm9ybWF0SW5mbyA9IHt9O1xue1xuICAvLyBOT1RFOiB0aGlzIGlzIG5hbWVkIGBudW1Db2xvckNvbXBvbmVudHNgIHZzIGBudW1Db21wb25lbnRzYCBzbyB3ZSBjYW4gbGV0IFVnbGlmeSBtYW5nbGVcbiAgLy8gdGhlIG5hbWUuXG4gIHZhciBmID0gZm9ybWF0SW5mbztcbiAgZltBTFBIQV0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiAxXG4gIH07XG4gIGZbTFVNSU5BTkNFXSA9IHtcbiAgICBudW1Db2xvckNvbXBvbmVudHM6IDFcbiAgfTtcbiAgZltMVU1JTkFOQ0VfQUxQSEFdID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogMlxuICB9O1xuICBmW1JHQl0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiAzXG4gIH07XG4gIGZbUkdCQV0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiA0XG4gIH07XG4gIGZbUkVEXSA9IHtcbiAgICBudW1Db2xvckNvbXBvbmVudHM6IDFcbiAgfTtcbiAgZltSRURfSU5URUdFUl0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiAxXG4gIH07XG4gIGZbUkddID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogMlxuICB9O1xuICBmW1JHX0lOVEVHRVJdID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogMlxuICB9O1xuICBmW1JHQl0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiAzXG4gIH07XG4gIGZbUkdCX0lOVEVHRVJdID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogM1xuICB9O1xuICBmW1JHQkFdID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogNFxuICB9O1xuICBmW1JHQkFfSU5URUdFUl0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiA0XG4gIH07XG4gIGZbREVQVEhfQ09NUE9ORU5UXSA9IHtcbiAgICBudW1Db2xvckNvbXBvbmVudHM6IDFcbiAgfTtcbiAgZltERVBUSF9TVEVOQ0lMXSA9IHtcbiAgICBudW1Db2xvckNvbXBvbmVudHM6IDJcbiAgfTtcbn1cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGV4dHVyZUZvcm1hdERldGFpbHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0ZXh0dXJlRm9ybWF0IGZvcm1hdCB0byBwYXNzIHRleEltYWdlMkQgYW5kIHNpbWlsYXIgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb2xvclJlbmRlcmFibGUgdHJ1ZSBpZiB5b3UgY2FuIHJlbmRlciB0byB0aGlzIGZvcm1hdCBvZiB0ZXh0dXJlLlxuICogQHByb3BlcnR5IHtib29sZWFufSB0ZXh0dXJlRmlsdGVyYWJsZSB0cnVlIGlmIHlvdSBjYW4gZmlsdGVyIHRoZSB0ZXh0dXJlLCBmYWxzZSBpZiB5b3UgY2FuIG9ueSB1c2UgYE5FQVJFU1RgLlxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gdHlwZSBBcnJheSBvZiBwb3NzaWJsZSB0eXBlcyB5b3UgY2FuIHBhc3MgdG8gdGV4SW1hZ2UyRCBhbmQgc2ltaWxhciBmdW5jdGlvblxuICogQHByb3BlcnR5IHtPYmplY3QuPG51bWJlcixudW1iZXI+fSBieXRlc1BlckVsZW1lbnRNYXAgQSBtYXAgb2YgdHlwZXMgdG8gYnl0ZXMgcGVyIGVsZW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIHNfdGV4dHVyZUludGVybmFsRm9ybWF0SW5mbztcblxuZnVuY3Rpb24gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0SW5mbyhpbnRlcm5hbEZvcm1hdCkge1xuICBpZiAoIXNfdGV4dHVyZUludGVybmFsRm9ybWF0SW5mbykge1xuICAgIC8vIE5PVEU6IHRoZXNlIHByb3BlcnRpZXMgbmVlZCB1bmlxdWUgbmFtZXMgc28gd2UgY2FuIGxldCBVZ2xpZnkgbWFuZ2xlIHRoZSBuYW1lLlxuICAgIHZhciB0ID0ge307IC8vIHVuc2l6ZWQgZm9ybWF0c1xuXG4gICAgdFtBTFBIQV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBBTFBIQSxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbMSwgMiwgMiwgNF0sXG4gICAgICB0eXBlOiBbVU5TSUdORURfQllURSwgSEFMRl9GTE9BVCwgSEFMRl9GTE9BVF9PRVMsIEZMT0FUXVxuICAgIH07XG4gICAgdFtMVU1JTkFOQ0VdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogTFVNSU5BTkNFLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFsxLCAyLCAyLCA0XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFLCBIQUxGX0ZMT0FULCBIQUxGX0ZMT0FUX09FUywgRkxPQVRdXG4gICAgfTtcbiAgICB0W0xVTUlOQU5DRV9BTFBIQV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBMVU1JTkFOQ0VfQUxQSEEsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzIsIDQsIDQsIDhdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUsIEhBTEZfRkxPQVQsIEhBTEZfRkxPQVRfT0VTLCBGTE9BVF1cbiAgICB9O1xuICAgIHRbUkdCXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHQixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbMywgNiwgNiwgMTIsIDJdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUsIEhBTEZfRkxPQVQsIEhBTEZfRkxPQVRfT0VTLCBGTE9BVCwgVU5TSUdORURfU0hPUlRfNV82XzVdXG4gICAgfTtcbiAgICB0W1JHQkFdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCQSxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNCwgOCwgOCwgMTYsIDIsIDJdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUsIEhBTEZfRkxPQVQsIEhBTEZfRkxPQVRfT0VTLCBGTE9BVCwgVU5TSUdORURfU0hPUlRfNF80XzRfNCwgVU5TSUdORURfU0hPUlRfNV81XzVfMV1cbiAgICB9O1xuICAgIHRbREVQVEhfQ09NUE9ORU5UXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IERFUFRIX0NPTVBPTkVOVCxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzIsIDRdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0lOVCwgVU5TSUdORURfU0hPUlRdXG4gICAgfTsgLy8gc2l6ZWQgZm9ybWF0c1xuXG4gICAgdFtSOF0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSRUQsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzFdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEVdXG4gICAgfTtcbiAgICB0W1I4X1NOT1JNXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJFRCxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzFdLFxuICAgICAgdHlwZTogW0JZVEVdXG4gICAgfTtcbiAgICB0W1IxNkZdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkVELFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNCwgMl0sXG4gICAgICB0eXBlOiBbRkxPQVQsIEhBTEZfRkxPQVRdXG4gICAgfTtcbiAgICB0W1IzMkZdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkVELFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzRdLFxuICAgICAgdHlwZTogW0ZMT0FUXVxuICAgIH07XG4gICAgdFtSOFVJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJFRF9JTlRFR0VSLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbMV0sXG4gICAgICB0eXBlOiBbVU5TSUdORURfQllURV1cbiAgICB9O1xuICAgIHRbUjhJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJFRF9JTlRFR0VSLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbMV0sXG4gICAgICB0eXBlOiBbQllURV1cbiAgICB9O1xuICAgIHRbUjE2VUldID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkVEX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFsyXSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9TSE9SVF1cbiAgICB9O1xuICAgIHRbUjE2SV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSRURfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzJdLFxuICAgICAgdHlwZTogW1NIT1JUXVxuICAgIH07XG4gICAgdFtSMzJVSV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSRURfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzRdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0lOVF1cbiAgICB9O1xuICAgIHRbUjMySV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSRURfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzRdLFxuICAgICAgdHlwZTogW0lOVF1cbiAgICB9O1xuICAgIHRbUkc4XSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFsyXSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFXVxuICAgIH07XG4gICAgdFtSRzhfU05PUk1dID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkcsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFsyXSxcbiAgICAgIHR5cGU6IFtCWVRFXVxuICAgIH07XG4gICAgdFtSRzE2Rl0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSRyxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzgsIDRdLFxuICAgICAgdHlwZTogW0ZMT0FULCBIQUxGX0ZMT0FUXVxuICAgIH07XG4gICAgdFtSRzMyRl0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSRyxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs4XSxcbiAgICAgIHR5cGU6IFtGTE9BVF1cbiAgICB9O1xuICAgIHRbUkc4VUldID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzJdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEVdXG4gICAgfTtcbiAgICB0W1JHOEldID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzJdLFxuICAgICAgdHlwZTogW0JZVEVdXG4gICAgfTtcbiAgICB0W1JHMTZVSV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR19JTlRFR0VSLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sXG4gICAgICB0eXBlOiBbVU5TSUdORURfU0hPUlRdXG4gICAgfTtcbiAgICB0W1JHMTZJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs0XSxcbiAgICAgIHR5cGU6IFtTSE9SVF1cbiAgICB9O1xuICAgIHRbUkczMlVJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs4XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlRdXG4gICAgfTtcbiAgICB0W1JHMzJJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs4XSxcbiAgICAgIHR5cGU6IFtJTlRdXG4gICAgfTtcbiAgICB0W1JHQjhdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFszXSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFXVxuICAgIH07XG4gICAgdFtTUkdCOF0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0IsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFszXSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFXVxuICAgIH07XG4gICAgdFtSR0I1NjVdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFszLCAyXSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFLCBVTlNJR05FRF9TSE9SVF81XzZfNV1cbiAgICB9O1xuICAgIHRbUkdCOF9TTk9STV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0IsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFszXSxcbiAgICAgIHR5cGU6IFtCWVRFXVxuICAgIH07XG4gICAgdFtSMTFGX0cxMUZfQjEwRl0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0IsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFsxMiwgNiwgNF0sXG4gICAgICB0eXBlOiBbRkxPQVQsIEhBTEZfRkxPQVQsIFVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVZdXG4gICAgfTtcbiAgICB0W1JHQjlfRTVdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbMTIsIDYsIDRdLFxuICAgICAgdHlwZTogW0ZMT0FULCBIQUxGX0ZMT0FULCBVTlNJR05FRF9JTlRfNV85XzlfOV9SRVZdXG4gICAgfTtcbiAgICB0W1JHQjE2Rl0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0IsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFsxMiwgNl0sXG4gICAgICB0eXBlOiBbRkxPQVQsIEhBTEZfRkxPQVRdXG4gICAgfTtcbiAgICB0W1JHQjMyRl0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0IsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbMTJdLFxuICAgICAgdHlwZTogW0ZMT0FUXVxuICAgIH07XG4gICAgdFtSR0I4VUldID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbM10sXG4gICAgICB0eXBlOiBbVU5TSUdORURfQllURV1cbiAgICB9O1xuICAgIHRbUkdCOEldID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbM10sXG4gICAgICB0eXBlOiBbQllURV1cbiAgICB9O1xuICAgIHRbUkdCMTZVSV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs2XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9TSE9SVF1cbiAgICB9O1xuICAgIHRbUkdCMTZJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHQl9JTlRFR0VSLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzZdLFxuICAgICAgdHlwZTogW1NIT1JUXVxuICAgIH07XG4gICAgdFtSR0IzMlVJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHQl9JTlRFR0VSLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzEyXSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlRdXG4gICAgfTtcbiAgICB0W1JHQjMySV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFsxMl0sXG4gICAgICB0eXBlOiBbSU5UXVxuICAgIH07XG4gICAgdFtSR0JBOF0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs0XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFXVxuICAgIH07XG4gICAgdFtTUkdCOF9BTFBIQThdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCQSxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sXG4gICAgICB0eXBlOiBbVU5TSUdORURfQllURV1cbiAgICB9O1xuICAgIHRbUkdCQThfU05PUk1dID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCQSxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzRdLFxuICAgICAgdHlwZTogW0JZVEVdXG4gICAgfTtcbiAgICB0W1JHQjVfQTFdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCQSxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNCwgMiwgNF0sXG4gICAgICB0eXBlOiBbVU5TSUdORURfQllURSwgVU5TSUdORURfU0hPUlRfNV81XzVfMSwgVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWXVxuICAgIH07XG4gICAgdFtSR0JBNF0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs0LCAyXSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFLCBVTlNJR05FRF9TSE9SVF80XzRfNF80XVxuICAgIH07XG4gICAgdFtSR0IxMF9BMl0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs0XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlRfMl8xMF8xMF8xMF9SRVZdXG4gICAgfTtcbiAgICB0W1JHQkExNkZdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCQSxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzE2LCA4XSxcbiAgICAgIHR5cGU6IFtGTE9BVCwgSEFMRl9GTE9BVF1cbiAgICB9O1xuICAgIHRbUkdCQTMyRl0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzE2XSxcbiAgICAgIHR5cGU6IFtGTE9BVF1cbiAgICB9O1xuICAgIHRbUkdCQThVSV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs0XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFXVxuICAgIH07XG4gICAgdFtSR0JBOEldID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCQV9JTlRFR0VSLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sXG4gICAgICB0eXBlOiBbQllURV1cbiAgICB9O1xuICAgIHRbUkdCMTBfQTJVSV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs0XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlRfMl8xMF8xMF8xMF9SRVZdXG4gICAgfTtcbiAgICB0W1JHQkExNlVJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzhdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX1NIT1JUXVxuICAgIH07XG4gICAgdFtSR0JBMTZJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzhdLFxuICAgICAgdHlwZTogW1NIT1JUXVxuICAgIH07XG4gICAgdFtSR0JBMzJJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzE2XSxcbiAgICAgIHR5cGU6IFtJTlRdXG4gICAgfTtcbiAgICB0W1JHQkEzMlVJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzE2XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlRdXG4gICAgfTsgLy8gU2l6ZWQgSW50ZXJuYWxcblxuICAgIHRbREVQVEhfQ09NUE9ORU5UMTZdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogREVQVEhfQ09NUE9ORU5ULFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbMiwgNF0sXG4gICAgICB0eXBlOiBbVU5TSUdORURfU0hPUlQsIFVOU0lHTkVEX0lOVF1cbiAgICB9O1xuICAgIHRbREVQVEhfQ09NUE9ORU5UMjRdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogREVQVEhfQ09NUE9ORU5ULFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sXG4gICAgICB0eXBlOiBbVU5TSUdORURfSU5UXVxuICAgIH07XG4gICAgdFtERVBUSF9DT01QT05FTlQzMkZdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogREVQVEhfQ09NUE9ORU5ULFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sXG4gICAgICB0eXBlOiBbRkxPQVRdXG4gICAgfTtcbiAgICB0W0RFUFRIMjRfU1RFTkNJTDhdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogREVQVEhfU1RFTkNJTCxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzRdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0lOVF8yNF84XVxuICAgIH07XG4gICAgdFtERVBUSDMyRl9TVEVOQ0lMOF0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBERVBUSF9TVEVOQ0lMLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sXG4gICAgICB0eXBlOiBbRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWXVxuICAgIH07XG4gICAgT2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJuYWxGb3JtYXQpIHtcbiAgICAgIHZhciBpbmZvID0gdFtpbnRlcm5hbEZvcm1hdF07XG4gICAgICBpbmZvLmJ5dGVzUGVyRWxlbWVudE1hcCA9IHt9O1xuICAgICAgaW5mby5ieXRlc1BlckVsZW1lbnQuZm9yRWFjaChmdW5jdGlvbiAoYnl0ZXNQZXJFbGVtZW50LCBuZHgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBpbmZvLnR5cGVbbmR4XTtcbiAgICAgICAgaW5mby5ieXRlc1BlckVsZW1lbnRNYXBbdHlwZV0gPSBieXRlc1BlckVsZW1lbnQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBzX3RleHR1cmVJbnRlcm5hbEZvcm1hdEluZm8gPSB0O1xuICB9XG5cbiAgcmV0dXJuIHNfdGV4dHVyZUludGVybmFsRm9ybWF0SW5mb1tpbnRlcm5hbEZvcm1hdF07XG59XG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBieXRlcyBwZXIgZWxlbWVudCBmb3IgYSBnaXZlbiBpbnRlcm5hbEZvcm1hdCAvIHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcm5hbEZvcm1hdCBUaGUgaW50ZXJuYWxGb3JtYXQgcGFyYW1ldGVyIGZyb20gdGV4SW1hZ2UyRCBldGMuLlxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgVGhlIHR5cGUgcGFyYW1ldGVyIGZvciB0ZXhJbWFnZTJEIGV0Yy4uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgYnl0ZXMgcGVyIGVsZW1lbnQgZm9yIHRoZSBnaXZlbiBpbnRlcm5hbEZvcm1hdCwgdHlwZSBjb21ib1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRCeXRlc1BlckVsZW1lbnRGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCwgdHlwZSkge1xuICB2YXIgaW5mbyA9IGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdEluZm8oaW50ZXJuYWxGb3JtYXQpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHRocm93IFwidW5rbm93biBpbnRlcm5hbCBmb3JtYXRcIjtcbiAgfVxuXG4gIHZhciBieXRlc1BlckVsZW1lbnQgPSBpbmZvLmJ5dGVzUGVyRWxlbWVudE1hcFt0eXBlXTtcblxuICBpZiAoYnl0ZXNQZXJFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBcInVua25vd24gaW50ZXJuYWwgZm9ybWF0XCI7XG4gIH1cblxuICByZXR1cm4gYnl0ZXNQZXJFbGVtZW50O1xufVxuLyoqXG4gKiBJbmZvIHJlbGF0ZWQgdG8gYSBzcGVjaWZpYyB0ZXh0dXJlIGludGVybmFsRm9ybWF0IGFzIHJldHVybmVkXG4gKiBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC90ZXh0dXJlcy5nZXRGb3JtYXRBbmRUeXBlRm9ySW50ZXJuYWxGb3JtYXR9LlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHR1cmVGb3JtYXRJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gZm9ybWF0IEZvcm1hdCB0byBwYXNzIHRvIHRleEltYWdlMkQgYW5kIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gdHlwZSBUeXBlIHRvIHBhc3MgdG8gdGV4SW1hZ2UyRCBhbmQgcmVsYXRlZCBmdW5jdGlvbnNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cbi8qKlxuICogR2V0cyB0aGUgZm9ybWF0IGFuZCB0eXBlIGZvciBhIGdpdmVuIGludGVybmFsRm9ybWF0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGludGVybmFsRm9ybWF0IFRoZSBpbnRlcm5hbCBmb3JtYXRcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3RleHR1cmVzLlRleHR1cmVGb3JtYXRJbmZvfSB0aGUgY29ycmVzcG9uZGluZyBmb3JtYXQgYW5kIHR5cGUsXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCkge1xuICB2YXIgaW5mbyA9IGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdEluZm8oaW50ZXJuYWxGb3JtYXQpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHRocm93IFwidW5rbm93biBpbnRlcm5hbCBmb3JtYXRcIjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBpbmZvLnRleHR1cmVGb3JtYXQsXG4gICAgdHlwZTogaW5mby50eXBlWzBdXG4gIH07XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBwb3dlciBvZiAyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgbnVtYmVyIHRvIGNoZWNrLlxuICogQHJldHVybiB0cnVlIGlmIHZhbHVlIGlzIHBvd2VyIG9mIDJcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBpc1Bvd2VyT2YyKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgJiB2YWx1ZSAtIDEpID09PSAwO1xufVxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHdlIGNhbiBnZW5lcmF0ZSBtaXBzIGZvciB0aGUgZ2l2ZW5cbiAqIGludGVybmFsIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBwYXJhbWV0ZXIgZnJvbSB0ZXhJbWFnZTJEIGV0Yy4uXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgcGFyYW1ldGVyIGZyb20gdGV4SW1hZ2UyRCBldGMuLlxuICogQHBhcmFtIHtudW1iZXJ9IGludGVybmFsRm9ybWF0IFRoZSBpbnRlcm5hbEZvcm1hdCBwYXJhbWV0ZXIgZnJvbSB0ZXhJbWFnZTJEIGV0Yy4uXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHdlIGNhbiBnZW5lcmF0ZSBtaXBzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNhbkdlbmVyYXRlTWlwbWFwKGdsLCB3aWR0aCwgaGVpZ2h0LCBpbnRlcm5hbEZvcm1hdCkge1xuICBpZiAoIXV0aWxzLmlzV2ViR0wyKGdsKSkge1xuICAgIHJldHVybiBpc1Bvd2VyT2YyKHdpZHRoKSAmJiBpc1Bvd2VyT2YyKGhlaWdodCk7XG4gIH1cblxuICB2YXIgaW5mbyA9IGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdEluZm8oaW50ZXJuYWxGb3JtYXQpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHRocm93IFwidW5rbm93biBpbnRlcm5hbCBmb3JtYXRcIjtcbiAgfVxuXG4gIHJldHVybiBpbmZvLmNvbG9yUmVuZGVyYWJsZSAmJiBpbmZvLnRleHR1cmVGaWx0ZXJhYmxlO1xufVxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHdlIGNhbiBnZW5lcmF0ZSBtaXBzIGZvciB0aGUgZ2l2ZW4gZm9ybWF0XG4gKiBAcGFyYW0ge251bWJlcn0gaW50ZXJuYWxGb3JtYXQgVGhlIGludGVybmFsRm9ybWF0IHBhcmFtZXRlciBmcm9tIHRleEltYWdlMkQgZXRjLi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgd2UgY2FuIGdlbmVyYXRlIG1pcHNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cblxuZnVuY3Rpb24gY2FuRmlsdGVyKGludGVybmFsRm9ybWF0KSB7XG4gIHZhciBpbmZvID0gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0SW5mbyhpbnRlcm5hbEZvcm1hdCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdGhyb3cgXCJ1bmtub3duIGludGVybmFsIGZvcm1hdFwiO1xuICB9XG5cbiAgcmV0dXJuIGluZm8udGV4dHVyZUZpbHRlcmFibGU7XG59XG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBjb21wb25lbnRzIGZvciBhIGdpdmVuIGltYWdlIGZvcm1hdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3JtYXQgdGhlIGZvcm1hdC5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIGZvciB0aGUgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBnZXROdW1Db21wb25lbnRzRm9yRm9ybWF0KGZvcm1hdCkge1xuICB2YXIgaW5mbyA9IGZvcm1hdEluZm9bZm9ybWF0XTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB0aHJvdyBcInVua25vd24gZm9ybWF0OiBcIiArIGZvcm1hdDtcbiAgfVxuXG4gIHJldHVybiBpbmZvLm51bUNvbG9yQ29tcG9uZW50cztcbn1cbi8qKlxuICogR2V0cyB0aGUgdGV4dHVyZSB0eXBlIGZvciBhIGdpdmVuIGFycmF5IHR5cGUuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgZ2wgdGV4dHVyZSB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0VGV4dHVyZVR5cGVGb3JBcnJheVR5cGUoZ2wsIHNyYywgZGVmYXVsdFR5cGUpIHtcbiAgaWYgKGlzQXJyYXlCdWZmZXIoc3JjKSkge1xuICAgIHJldHVybiB0eXBlZEFycmF5cy5nZXRHTFR5cGVGb3JUeXBlZEFycmF5KHNyYyk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFR5cGUgfHwgVU5TSUdORURfQllURTtcbn1cblxuZnVuY3Rpb24gZ3Vlc3NEaW1lbnNpb25zKGdsLCB0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIG51bUVsZW1lbnRzKSB7XG4gIGlmIChudW1FbGVtZW50cyAlIDEgIT09IDApIHtcbiAgICB0aHJvdyBcImNhbid0IGd1ZXNzIGRpbWVuc2lvbnNcIjtcbiAgfVxuXG4gIGlmICghd2lkdGggJiYgIWhlaWdodCkge1xuICAgIHZhciBzaXplID0gTWF0aC5zcXJ0KG51bUVsZW1lbnRzIC8gKHRhcmdldCA9PT0gVEVYVFVSRV9DVUJFX01BUCA/IDYgOiAxKSk7XG5cbiAgICBpZiAoc2l6ZSAlIDEgPT09IDApIHtcbiAgICAgIHdpZHRoID0gc2l6ZTtcbiAgICAgIGhlaWdodCA9IHNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gbnVtRWxlbWVudHM7XG4gICAgICBoZWlnaHQgPSAxO1xuICAgIH1cbiAgfSBlbHNlIGlmICghaGVpZ2h0KSB7XG4gICAgaGVpZ2h0ID0gbnVtRWxlbWVudHMgLyB3aWR0aDtcblxuICAgIGlmIChoZWlnaHQgJSAxKSB7XG4gICAgICB0aHJvdyBcImNhbid0IGd1ZXNzIGRpbWVuc2lvbnNcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIXdpZHRoKSB7XG4gICAgd2lkdGggPSBudW1FbGVtZW50cyAvIGhlaWdodDtcblxuICAgIGlmICh3aWR0aCAlIDEpIHtcbiAgICAgIHRocm93IFwiY2FuJ3QgZ3Vlc3MgZGltZW5zaW9uc1wiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG4vKipcbiAqIFNldHMgdGhlIGRlZmF1bHQgdGV4dHVyZSBjb2xvci5cbiAqXG4gKiBUaGUgZGVmYXVsdCB0ZXh0dXJlIGNvbG9yIGlzIHVzZWQgd2hlbiBsb2FkaW5nIHRleHR1cmVzIGZyb21cbiAqIHVybHMuIEJlY2F1c2UgdGhlIFVSTCB3aWxsIGJlIGxvYWRlZCBhc3luYyB3ZSdkIGxpa2UgdG8gYmVcbiAqIGFibGUgdG8gdXNlIHRoZSB0ZXh0dXJlIGltbWVkaWF0ZWx5LiBCeSBwdXR0aW5nIGEgMXgxIHBpeGVsXG4gKiBjb2xvciBpbiB0aGUgdGV4dHVyZSB3ZSBjYW4gc3RhcnQgdXNpbmcgdGhlIHRleHR1cmUgYmVmb3JlXG4gKiB0aGUgVVJMIGhhcyBsb2FkZWQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IgQXJyYXkgb2YgNCB2YWx1ZXMgaW4gdGhlIHJhbmdlIDAgdG8gMVxuICogQGRlcHJlY2F0ZWQgc2VlIHtAbGluayBtb2R1bGU6dHdnbC5zZXREZWZhdWx0c31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cblxuZnVuY3Rpb24gc2V0RGVmYXVsdFRleHR1cmVDb2xvcihjb2xvcikge1xuICBkZWZhdWx0cy50ZXh0dXJlQ29sb3IgPSBuZXcgVWludDhBcnJheShbY29sb3JbMF0gKiAyNTUsIGNvbG9yWzFdICogMjU1LCBjb2xvclsyXSAqIDI1NSwgY29sb3JbM10gKiAyNTVdKTtcbn1cblxuZnVuY3Rpb24gc2V0RGVmYXVsdHMobmV3RGVmYXVsdHMpIHtcbiAgaGVscGVyLmNvcHlFeGlzdGluZ1Byb3BlcnRpZXMobmV3RGVmYXVsdHMsIGRlZmF1bHRzKTtcblxuICBpZiAobmV3RGVmYXVsdHMudGV4dHVyZUNvbG9yKSB7XG4gICAgc2V0RGVmYXVsdFRleHR1cmVDb2xvcihuZXdEZWZhdWx0cy50ZXh0dXJlQ29sb3IpO1xuICB9XG59XG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIHNvdXJjZSBmb3IgYSB0ZXh0dXJlLlxuICogQGNhbGxiYWNrIFRleHR1cmVGdW5jXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgdGhlIHRleHR1cmUgb3B0aW9uc1xuICogQHJldHVybiB7Kn0gUmV0dXJucyBhbnkgb2YgdGhlIHRoaW5ncyBkb2N1bWVudGVkIGZvciBgc3JjYCBmb3Ige0BsaW5rIG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogVGV4dHVyZSBvcHRpb25zIHBhc3NlZCB0byBtb3N0IHRleHR1cmUgZnVuY3Rpb25zLiBFYWNoIGZ1bmN0aW9uIHdpbGwgdXNlIHdoYXRldmVyIG9wdGlvbnNcbiAqIGFyZSBhcHByb3ByaWF0ZSBmb3IgaXRzIG5lZWRzLiBUaGlzIGxldHMgeW91IHBhc3MgdGhlIHNhbWUgb3B0aW9ucyB0byBhbGwgZnVuY3Rpb25zLlxuICpcbiAqIE5vdGU6IEEgYFRleEltYWdlU291cmNlYCBpcyBkZWZpbmVkIGluIHRoZSBXZWJHTCBzcGVjIGFzIGEgYEhUTUxJbWFnZUVsZW1lbnRgLCBgSFRNTFZpZGVvRWxlbWVudGAsXG4gKiBgSFRNTENhbnZhc0VsZW1lbnRgLCBgSW1hZ2VCaXRtYXBgLCBvciBgSW1hZ2VEYXRhYC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXh0dXJlT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YXJnZXRdIHRoZSB0eXBlIG9mIHRleHR1cmUgYGdsLlRFWFRVUkVfMkRgIG9yIGBnbC5URVhUVVJFX0NVQkVfTUFQYC4gRGVmYXVsdHMgdG8gYGdsLlRFWFRVUkVfMkRgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsZXZlbF0gdGhlIG1pcCBsZXZlbCB0byBhZmZlY3QuIERlZmF1bHRzIHRvIDAuIE5vdGUsIGlmIHNldCBhdXRvIHdpbGwgYmUgY29uc2lkZXJlZCBmYWxzZSB1bmxlc3MgZXhwbGljaXRseSBzZXQgdG8gdHJ1ZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd2lkdGhdIHRoZSB3aWR0aCBvZiB0aGUgdGV4dHVyZS4gT25seSB1c2VkIGlmIHNyYyBpcyBhbiBhcnJheSBvciB0eXBlZCBhcnJheSBvciBudWxsLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoZWlnaHRdIHRoZSBoZWlnaHQgb2YgYSB0ZXh0dXJlLiBPbmx5IHVzZWQgaWYgc3JjIGlzIGFuIGFycmF5IG9yIHR5cGVkIGFycmF5IG9yIG51bGwuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlcHRoXSB0aGUgZGVwdGggb2YgYSB0ZXh0dXJlLiBPbmx5IHVzZWQgaWYgc3JjIGlzIGFuIGFycmF5IG9yIHR5cGUgYXJyYXkgb3IgbnVsbCBhbmQgdGFyZ2V0IGlzIGBURVhUVVJFXzNEYCAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pbl0gdGhlIG1pbiBmaWx0ZXIgc2V0dGluZyAoZWcuIGBnbC5MSU5FQVJgKS4gRGVmYXVsdHMgdG8gYGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUmBcbiAqICAgICBvciBpZiB0ZXh0dXJlIGlzIG5vdCBhIHBvd2VyIG9mIDIgb24gYm90aCBkaW1lbnNpb25zIHRoZW4gZGVmYXVsdHMgdG8gYGdsLkxJTkVBUmAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21hZ10gdGhlIG1hZyBmaWx0ZXIgc2V0dGluZyAoZWcuIGBnbC5MSU5FQVJgKS4gRGVmYXVsdHMgdG8gYGdsLkxJTkVBUmBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluTWFnXSBib3RoIHRoZSBtaW4gYW5kIG1hZyBmaWx0ZXIgc2V0dGluZ3MuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ludGVybmFsRm9ybWF0XSBpbnRlcm5hbCBmb3JtYXQgZm9yIHRleHR1cmUuIERlZmF1bHRzIHRvIGBnbC5SR0JBYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmb3JtYXRdIGZvcm1hdCBmb3IgdGV4dHVyZS4gRGVmYXVsdHMgdG8gYGdsLlJHQkFgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0eXBlXSB0eXBlIGZvciB0ZXh0dXJlLiBEZWZhdWx0cyB0byBgZ2wuVU5TSUdORURfQllURWAgdW5sZXNzIGBzcmNgIGlzIEFycmF5QnVmZmVyVmlldy4gSWYgYHNyY2BcbiAqICAgICBpcyBBcnJheUJ1ZmZlclZpZXcgZGVmYXVsdHMgdG8gdHlwZSB0aGF0IG1hdGNoZXMgQXJyYXlCdWZmZXJWaWV3IHR5cGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dyYXBdIFRleHR1cmUgd3JhcHBpbmcgZm9yIGJvdGggUyBhbmQgVCAoYW5kIFIgaWYgVEVYVFVSRV8zRCBvciBXZWJHTFNhbXBsZXIpLiBEZWZhdWx0cyB0byBgZ2wuUkVQRUFUYCBmb3IgMkQgdW5sZXNzIHNyYyBpcyBXZWJHTDEgYW5kIHNyYyBub3QgbnBvdCBhbmQgYGdsLkNMQU1QX1RPX0VER0VgIGZvciBjdWJlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dyYXBTXSBUZXh0dXJlIHdyYXBwaW5nIGZvciBTLiBEZWZhdWx0cyB0byBgZ2wuUkVQRUFUYCBhbmQgYGdsLkNMQU1QX1RPX0VER0VgIGZvciBjdWJlLiBJZiBzZXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGB3cmFwYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd3JhcFRdIFRleHR1cmUgd3JhcHBpbmcgZm9yIFQuIERlZmF1bHRzIHRvIGBnbC5SRVBFQVRgIGFuZCBgZ2wuQ0xBTVBfVE9fRURHRWAgZm9yIGN1YmUuIElmIHNldCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYHdyYXBgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3cmFwUl0gVGV4dHVyZSB3cmFwcGluZyBmb3IgUi4gRGVmYXVsdHMgdG8gYGdsLlJFUEVBVGAgYW5kIGBnbC5DTEFNUF9UT19FREdFYCBmb3IgY3ViZS4gSWYgc2V0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgd3JhcGAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pbkxvZF0gVEVYVFVSRV9NSU5fTE9EIHNldHRpbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4TG9kXSBURVhUVVJFX01BWF9MT0Qgc2V0dGluZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtiYXNlTGV2ZWxdIFRFWFRVUkVfQkFTRV9MRVZFTCBzZXR0aW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heExldmVsXSBURVhUVVJFX01BWF9MRVZFTCBzZXR0aW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3VucGFja0FsaWdubWVudF0gVGhlIGBnbC5VTlBBQ0tfQUxJR05NRU5UYCB1c2VkIHdoZW4gdXBsb2FkaW5nIGFuIGFycmF5LiBEZWZhdWx0cyB0byAxLlxuICogQHByb3BlcnR5IHtudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd9IFtjb2xvcl0gQ29sb3IgdG8gaW5pdGlhbGl6ZSB0aGlzIHRleHR1cmUgd2l0aCBpZiBsb2FkaW5nIGFuIGltYWdlIGFzeW5jaHJvbm91c2x5LlxuICogICAgIFRoZSBkZWZhdWx0IHVzZSBhIGJsdWUgMXgxIHBpeGVsIHRleHR1cmUuIFlvdSBjYW4gc2V0IGFub3RoZXIgZGVmYXVsdCBieSBjYWxsaW5nIGB0d2dsLnNldERlZmF1bHRzYFxuICogICAgIG9yIHlvdSBjYW4gc2V0IGFuIGluZGl2aWR1YWwgdGV4dHVyZSdzIGluaXRpYWwgY29sb3IgYnkgc2V0dGluZyB0aGlzIHByb3BlcnR5LiBFeGFtcGxlOiBgWzEsIC41LCAuNSwgMV1gID0gcGlua1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwcmVtdWx0aXBseUFscGhhXSBXaGV0aGVyIG9yIG5vdCB0byBwcmVtdWx0aXBseSBhbHBoYS4gRGVmYXVsdHMgdG8gd2hhdGV2ZXIgdGhlIGN1cnJlbnQgc2V0dGluZyBpcy5cbiAqICAgICBUaGlzIGxldHMgeW91IHNldCBpdCBvbmNlIGJlZm9yZSBjYWxsaW5nIGB0d2dsLmNyZWF0ZVRleHR1cmVgIG9yIGB0d2dsLmNyZWF0ZVRleHR1cmVzYCBhbmQgb25seSBvdmVycmlkZVxuICogICAgIHRoZSBjdXJyZW50IHNldHRpbmcgZm9yIHNwZWNpZmljIHRleHR1cmVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmbGlwWV0gV2hldGhlciBvciBub3QgdG8gZmxpcCB0aGUgdGV4dHVyZSB2ZXJ0aWNhbGx5IG9uIHVwbG9hZC4gRGVmYXVsdHMgdG8gd2hhdGV2ZXIgdGhlIGN1cnJlbnQgc2V0dGluZyBpcy5cbiAqICAgICBUaGlzIGxldHMgeW91IHNldCBpdCBvbmNlIGJlZm9yZSBjYWxsaW5nIGB0d2dsLmNyZWF0ZVRleHR1cmVgIG9yIGB0d2dsLmNyZWF0ZVRleHR1cmVzYCBhbmQgb25seSBvdmVycmlkZVxuICogICAgIHRoZSBjdXJyZW50IHNldHRpbmcgZm9yIHNwZWNpZmljIHRleHR1cmVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjb2xvcnNwYWNlQ29udmVyc2lvbl0gV2hldGhlciBvciBub3QgdG8gbGV0IHRoZSBicm93c2VyIGRvIGNvbG9yc3BhY2UgY29udmVyc2lvbiBvZiB0aGUgdGV4dHVyZSBvbiB1cGxvYWQuIERlZmF1bHRzIHRvIHdoYXRldmVyIHRoZSBjdXJyZW50IHNldHRpbmcgaXMuXG4gKiAgICAgVGhpcyBsZXRzIHlvdSBzZXQgaXQgb25jZSBiZWZvcmUgY2FsbGluZyBgdHdnbC5jcmVhdGVUZXh0dXJlYCBvciBgdHdnbC5jcmVhdGVUZXh0dXJlc2AgYW5kIG9ubHkgb3ZlcnJpZGVcbiAqICAgICB0aGUgY3VycmVudCBzZXR0aW5nIGZvciBzcGVjaWZpYyB0ZXh0dXJlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F1dG9dIElmIGB1bmRlZmluZWRgIG9yIGB0cnVlYCwgaW4gV2ViR0wxLCB0ZXh0dXJlIGZpbHRlcmluZyBpcyBzZXQgYXV0b21hdGljYWxseSBmb3Igbm9uLXBvd2VyIG9mIDIgaW1hZ2VzIGFuZFxuICogICAgbWlwcyBhcmUgZ2VuZXJhdGVkIGZvciBwb3dlciBvZiAyIGltYWdlcy4gSW4gV2ViR0wyIG1pcHMgYXJlIGdlbmVyYXRlZCBpZiB0aGV5IGNhbiBiZS4gTm90ZTogaWYgYGxldmVsYCBpcyBzZXQgYWJvdmVcbiAqICAgIHRoZW4gdGhlbiBgYXV0b2AgaXMgYXNzdW1lZCB0byBiZSBgZmFsc2VgIHVubGVzcyBleHBsaWNpdHkgc2V0IHRvIGB0cnVlYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IFtjdWJlRmFjZU9yZGVyXSBUaGUgb3JkZXIgdGhhdCBjdWJlIGZhY2VzIGFyZSBwdWxsZWQgb3V0IG9mIGFuIGltZyBvciBzZXQgb2YgaW1hZ2VzLiBUaGUgZGVmYXVsdCBpc1xuICpcbiAqICAgICBbZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLFxuICogICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gsXG4gKiAgICAgIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSxcbiAqICAgICAgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZLFxuICogICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osXG4gKiAgICAgIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWl1cbiAqXG4gKiBAcHJvcGVydHkgeyhudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd8VGV4SW1hZ2VTb3VyY2V8VGV4SW1hZ2VTb3VyY2VbXXxzdHJpbmd8c3RyaW5nW118bW9kdWxlOnR3Z2wuVGV4dHVyZUZ1bmMpfSBbc3JjXSBzb3VyY2UgZm9yIHRleHR1cmVcbiAqXG4gKiAgICBJZiBgc3RyaW5nYCB0aGVuIGl0J3MgYXNzdW1lZCB0byBiZSBhIFVSTCB0byBhbiBpbWFnZS4gVGhlIGltYWdlIHdpbGwgYmUgZG93bmxvYWRlZCBhc3luYy4gQSB1c2FibGVcbiAqICAgIDF4MSBwaXhlbCB0ZXh0dXJlIHdpbGwgYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHkuIFRoZSB0ZXh0dXJlIHdpbGwgYmUgdXBkYXRlZCBvbmNlIHRoZSBpbWFnZSBoYXMgZG93bmxvYWRlZC5cbiAqICAgIElmIGB0YXJnZXRgIGlzIGBnbC5URVhUVVJFX0NVQkVfTUFQYCB3aWxsIGF0dGVtcHQgdG8gZGl2aWRlIGltYWdlIGludG8gNiBzcXVhcmUgcGllY2VzLiAxeDYsIDZ4MSwgM3gyLCAyeDMuXG4gKiAgICBUaGUgcGllY2VzIHdpbGwgYmUgdXBsb2FkZWQgaW4gYGN1YmVGYWNlT3JkZXJgXG4gKlxuICogICAgSWYgYHN0cmluZ1tdYCBvciBgVGV4SW1hZ2VTb3VyY2VbXWAgYW5kIHRhcmdldCBpcyBgZ2wuVEVYVFVSRV9DVUJFX01BUGAgdGhlbiBpdCBtdXN0IGhhdmUgNiBlbnRyaWVzLCBvbmUgZm9yIGVhY2ggZmFjZSBvZiBhIGN1YmUgbWFwLlxuICpcbiAqICAgIElmIGBzdHJpbmdbXWAgb3IgYFRleEltYWdlU291cmNlW11gIGFuZCB0YXJnZXQgaXMgYGdsLlRFWFRVUkVfMkRfQVJSQVlgIHRoZW4gZWFjaCBlbnRyeSBpcyBhIHNsaWNlIG9mIHRoZSBhIDJkIGFycmF5IHRleHR1cmVcbiAqICAgIGFuZCB3aWxsIGJlIHNjYWxlZCB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQgT1IgdG8gdGhlIHNpemUgb2YgdGhlIGZpcnN0IGltYWdlIHRoYXQgbG9hZHMuXG4gKlxuICogICAgSWYgYFRleEltYWdlU291cmNlYCB0aGVuIGl0IHdpbCBiZSB1c2VkIGltbWVkaWF0ZWx5IHRvIGNyZWF0ZSB0aGUgY29udGVudHMgb2YgdGhlIHRleHR1cmUuIEV4YW1wbGVzIGBIVE1MSW1hZ2VFbGVtZW50YCxcbiAqICAgIGBIVE1MQ2FudmFzRWxlbWVudGAsIGBIVE1MVmlkZW9FbGVtZW50YC5cbiAqXG4gKiAgICBJZiBgbnVtYmVyW11gIG9yIGBBcnJheUJ1ZmZlclZpZXdgIGl0J3MgYXNzdW1lZCB0byBiZSBkYXRhIGZvciBhIHRleHR1cmUuIElmIGB3aWR0aGAgb3IgYGhlaWdodGAgaXNcbiAqICAgIG5vdCBzcGVjaWZpZWQgaXQgaXMgZ3Vlc3NlZCBhcyBmb2xsb3dzLiBGaXJzdCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGlzIGNvbXB1dGVkIGJ5IGBzcmMubGVuZ3RoIC8gbnVtQ29tcG9uZW50c2BcbiAqICAgIHdoZXJlIGBudW1Db21wb25lbnRzYCBpcyBkZXJpdmVkIGZyb20gYGZvcm1hdGAuIElmIGB0YXJnZXRgIGlzIGBnbC5URVhUVVJFX0NVQkVfTUFQYCB0aGVuIGBudW1FbGVtZW50c2AgaXMgZGl2aWRlZFxuICogICAgYnkgNi4gVGhlblxuICpcbiAqICAgICogICBJZiBuZWl0aGVyIGB3aWR0aGAgbm9yIGBoZWlnaHRgIGFyZSBzcGVjaWZpZWQgYW5kIGBzcXJ0KG51bUVsZW1lbnRzKWAgaXMgYW4gaW50ZWdlciB0aGVuIHdpZHRoIGFuZCBoZWlnaHRcbiAqICAgICAgICBhcmUgc2V0IHRvIGBzcXJ0KG51bUVsZW1lbnRzKWAuIE90aGVyd2lzZSBgd2lkdGggPSBudW1FbGVtZW50c2AgYW5kIGBoZWlnaHQgPSAxYC5cbiAqXG4gKiAgICAqICAgSWYgb25seSBvbmUgb2YgYHdpZHRoYCBvciBgaGVpZ2h0YCBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgb3RoZXIgZXF1YWxzIGBudW1FbGVtZW50cyAvIHNwZWNpZmllZERpbWVuc2lvbmAuXG4gKlxuICogSWYgYG51bWJlcltdYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBgdHlwZWAuXG4gKlxuICogSWYgYHNyY2AgaXMgYSBmdW5jdGlvbiBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgYFdlYkdMUmVuZGVyaW5nQ29udGV4dGAgYW5kIHRoZXNlIG9wdGlvbnMuXG4gKiBXaGF0ZXZlciBpdCByZXR1cm5zIGlzIHN1YmplY3QgdG8gdGhlc2UgcnVsZXMuIFNvIGl0IGNhbiByZXR1cm4gYSBzdHJpbmcgdXJsLCBhbiBgSFRNTEVsZW1lbnRgXG4gKiBhbiBhcnJheSBldGMuLi5cbiAqXG4gKiBJZiBgc3JjYCBpcyB1bmRlZmluZWQgdGhlbiBhbiBlbXB0eSB0ZXh0dXJlIHdpbGwgYmUgY3JlYXRlZCBvZiBzaXplIGB3aWR0aGAgYnkgYGhlaWdodGAuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjcm9zc09yaWdpbl0gV2hhdCB0byBzZXQgdGhlIGNyb3NzT3JpZ2luIHByb3BlcnR5IG9mIGltYWdlcyB3aGVuIHRoZXkgYXJlIGRvd25sb2FkZWQuXG4gKiAgICBkZWZhdWx0OiB1bmRlZmluZWQuIEFsc28gc2VlIHtAbGluayBtb2R1bGU6dHdnbC5zZXREZWZhdWx0c30uXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBTZXRzIGFueSBwYWNraW5nIHN0YXRlIHRoYXQgd2lsbCBiZSBzZXQgYmFzZWQgb24gdGhlIG9wdGlvbnMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFBhY2tTdGF0ZShnbCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5jb2xvcnNwYWNlQ29udmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgb3B0aW9ucy5jb2xvcnNwYWNlQ29udmVyc2lvbik7XG4gIH1cblxuICBpZiAob3B0aW9ucy5wcmVtdWx0aXBseUFscGhhICE9PSB1bmRlZmluZWQpIHtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIG9wdGlvbnMucHJlbXVsdGlwbHlBbHBoYSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5mbGlwWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX0ZMSVBfWV9XRUJHTCwgb3B0aW9ucy5mbGlwWSk7XG4gIH1cbn1cbi8qKlxuICogU2V0IHNraXAgc3RhdGUgdG8gZGVmYXVsdHNcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2V0U2tpcFN0YXRlVG9EZWZhdWx0KGdsKSB7XG4gIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19BTElHTk1FTlQsIDQpO1xuXG4gIGlmICh1dGlscy5pc1dlYkdMMihnbCkpIHtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfUk9XX0xFTkdUSCwgMCk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX0lNQUdFX0hFSUdIVCwgMCk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX1NLSVBfUElYRUxTLCAwKTtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfU0tJUF9ST1dTLCAwKTtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfU0tJUF9JTUFHRVMsIDApO1xuICB9XG59XG4vKipcbiAqIFNldHMgdGhlIHBhcmFtZXRlcnMgb2YgYSB0ZXh0dXJlIG9yIHNhbXBsZXJcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcnxXZWJHTFNhbXBsZXJ9IHRhcmdldCB0ZXh0dXJlIHRhcmdldCBvciBzYW1wbGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IHBhcmFtZXRlcmlGbiB0ZXhQYXJhbWV0ZXJpIG9yIHNhbXBsZXJQYXJhbWV0ZXJpIGZuXG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiAgIFRoaXMgaXMgb2Z0ZW4gdGhlIHNhbWUgb3B0aW9ucyB5b3UgcGFzc2VkIGluIHdoZW4geW91IGNyZWF0ZWQgdGhlIHRleHR1cmUuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2V0VGV4dHVyZVNhbXBsZXJQYXJhbWV0ZXJzKGdsLCB0YXJnZXQsIHBhcmFtZXRlcmlGbiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5taW5NYWcpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX01JTl9GSUxURVIsIG9wdGlvbnMubWluTWFnKTtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX01BR19GSUxURVIsIG9wdGlvbnMubWluTWFnKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLm1pbikge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfTUlOX0ZJTFRFUiwgb3B0aW9ucy5taW4pO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMubWFnKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9NQUdfRklMVEVSLCBvcHRpb25zLm1hZyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy53cmFwKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9XUkFQX1MsIG9wdGlvbnMud3JhcCk7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9XUkFQX1QsIG9wdGlvbnMud3JhcCk7XG5cbiAgICBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEIHx8IGhlbHBlci5pc1NhbXBsZXIoZ2wsIHRhcmdldCkpIHtcbiAgICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfV1JBUF9SLCBvcHRpb25zLndyYXApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLndyYXBSKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9XUkFQX1IsIG9wdGlvbnMud3JhcFIpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMud3JhcFMpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX1dSQVBfUywgb3B0aW9ucy53cmFwUyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy53cmFwVCkge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfV1JBUF9ULCBvcHRpb25zLndyYXBUKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLm1pbkxvZCkge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfTUlOX0xPRCwgb3B0aW9ucy5taW5Mb2QpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMubWF4TG9kKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9NQVhfTE9ELCBvcHRpb25zLm1heExvZCk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5iYXNlTGV2ZWwpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX0JBU0VfTEVWRUwsIG9wdGlvbnMuYmFzZUxldmVsKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLm1heExldmVsKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9NQVhfTEVWRUwsIG9wdGlvbnMubWF4TGV2ZWwpO1xuICB9XG59XG4vKipcbiAqIFNldHMgdGhlIHRleHR1cmUgcGFyYW1ldGVycyBvZiBhIHRleHR1cmUuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogICBUaGlzIGlzIG9mdGVuIHRoZSBzYW1lIG9wdGlvbnMgeW91IHBhc3NlZCBpbiB3aGVuIHlvdSBjcmVhdGVkIHRoZSB0ZXh0dXJlLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRUZXh0dXJlUGFyYW1ldGVycyhnbCwgdGV4LCBvcHRpb25zKSB7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJEO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gIHNldFRleHR1cmVTYW1wbGVyUGFyYW1ldGVycyhnbCwgdGFyZ2V0LCBnbC50ZXhQYXJhbWV0ZXJpLCBvcHRpb25zKTtcbn1cbi8qKlxuICogU2V0cyB0aGUgc2FtcGxlciBwYXJhbWV0ZXJzIG9mIGEgc2FtcGxlci5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMU2FtcGxlcn0gc2FtcGxlciB0aGUgV2ViR0xTYW1wbGVyIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRTYW1wbGVyUGFyYW1ldGVycyhnbCwgc2FtcGxlciwgb3B0aW9ucykge1xuICBzZXRUZXh0dXJlU2FtcGxlclBhcmFtZXRlcnMoZ2wsIHNhbXBsZXIsIGdsLnNhbXBsZXJQYXJhbWV0ZXJpLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzYW1wbGVyIG9iamVjdCBhbmQgc2V0cyBwYXJhbWV0ZXJzLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICBjb25zdCBzYW1wbGVyID0gdHdnbC5jcmVhdGVTYW1wbGVyKGdsLCB7XG4gKiAgICAgICAgbWluTWFnOiBnbC5ORUFSRVNULCAgICAgICAgIC8vIHNldHMgYm90aCBURVhUVVJFX01JTl9GSUxURVIgYW5kIFRFWFRVUkVfTUFHX0ZJTFRFUlxuICogICAgICAgIHdyYXA6IGdsLkNMQU1QX1RPX05FQVJFU1QsICAvLyBzZXRzIGJvdGggVEVYVFVSRV9XUkFQX1MgYW5kIFRFWFRVUkVfV1JBUF9UIGFuZCBURVhUVVJFX1dSQVBfUlxuICogICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxtb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9ucz59IG9wdGlvbnMgQSBvYmplY3Qgb2YgVGV4dHVyZU9wdGlvbnMgb25lIHBlciBzYW1wbGVyLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsV2ViR0xTYW1wbGVyPn0gdGhlIGNyZWF0ZWQgc2FtcGxlcnMgYnkgbmFtZVxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNhbXBsZXIoZ2wsIG9wdGlvbnMpIHtcbiAgdmFyIHNhbXBsZXIgPSBnbC5jcmVhdGVTYW1wbGVyKCk7XG4gIHNldFNhbXBsZXJQYXJhbWV0ZXJzKGdsLCBzYW1wbGVyLCBvcHRpb25zKTtcbiAgcmV0dXJuIHNhbXBsZXI7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtdWx0aXBsZSBzYW1wbGVyIG9iamVjdHMgYW5kIHNldHMgcGFyYW1ldGVycyBvbiBlYWNoLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICBjb25zdCBzYW1wbGVycyA9IHR3Z2wuY3JlYXRlU2FtcGxlcnMoZ2wsIHtcbiAqICAgICAgICBuZWFyZXN0OiB7XG4gKiAgICAgICAgICBtaW5NYWc6IGdsLk5FQVJFU1QsXG4gKiAgICAgICAgfSxcbiAqICAgICAgICBuZWFyZXN0Q2xhbXBTOiB7XG4gKiAgICAgICAgICBtaW5NYWc6IGdsLk5FQVJFU1QsXG4gKiAgICAgICAgICB3cmFwUzogZ2wuQ0xBTVBfVE9fTkVBUkVTVCxcbiAqICAgICAgICB9LFxuICogICAgICAgIGxpbmVhcjoge1xuICogICAgICAgICAgbWluTWFnOiBnbC5MSU5FQVIsXG4gKiAgICAgICAgfSxcbiAqICAgICAgICBuZWFyZXN0Q2xhbXA6IHtcbiAqICAgICAgICAgIG1pbk1hZzogZ2wuTkVBUkVTVCxcbiAqICAgICAgICAgIHdyYXA6IGdsLkNMQU1QX1RPX0VER0UsXG4gKiAgICAgICAgfSxcbiAqICAgICAgICBsaW5lYXJDbGFtcDoge1xuICogICAgICAgICAgbWluTWFnOiBnbC5MSU5FQVIsXG4gKiAgICAgICAgICB3cmFwOiBnbC5DTEFNUF9UT19FREdFLFxuICogICAgICAgIH0sXG4gKiAgICAgICAgbGluZWFyQ2xhbXBUOiB7XG4gKiAgICAgICAgICBtaW5NYWc6IGdsLkxJTkVBUixcbiAqICAgICAgICAgIHdyYXBUOiBnbC5DTEFNUF9UT19FREdFLFxuICogICAgICAgIH0sXG4gKiAgICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldCBvbiB0aGUgc2FtcGxlclxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNhbXBsZXJzKGdsLCBzYW1wbGVyT3B0aW9ucykge1xuICB2YXIgc2FtcGxlcnMgPSB7fTtcbiAgT2JqZWN0LmtleXMoc2FtcGxlck9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBzYW1wbGVyc1tuYW1lXSA9IGNyZWF0ZVNhbXBsZXIoZ2wsIHNhbXBsZXJPcHRpb25zW25hbWVdKTtcbiAgfSk7XG4gIHJldHVybiBzYW1wbGVycztcbn1cbi8qKlxuICogTWFrZXMgYSAxeDEgcGl4ZWxcbiAqIElmIG5vIGNvbG9yIGlzIHBhc3NlZCBpbiB1c2VzIHRoZSBkZWZhdWx0IGNvbG9yIHdoaWNoIGNhbiBiZSBzZXQgYnkgY2FsbGluZyBgc2V0RGVmYXVsdFRleHR1cmVDb2xvcmAuXG4gKiBAcGFyYW0geyhudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXcpfSBbY29sb3JdIFRoZSBjb2xvciB1c2luZyAwLTEgdmFsdWVzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fSBVbml0OEFycmF5IHdpdGggY29sb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbWFrZTFQaXhlbChjb2xvcikge1xuICBjb2xvciA9IGNvbG9yIHx8IGRlZmF1bHRzLnRleHR1cmVDb2xvcjtcblxuICBpZiAoaXNBcnJheUJ1ZmZlcihjb2xvcikpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW2NvbG9yWzBdICogMjU1LCBjb2xvclsxXSAqIDI1NSwgY29sb3JbMl0gKiAyNTUsIGNvbG9yWzNdICogMjU1XSk7XG59XG4vKipcbiAqIFNldHMgZmlsdGVyaW5nIG9yIGdlbmVyYXRlcyBtaXBzIGZvciB0ZXh0dXJlIGJhc2VkIG9uIHdpZHRoIG9yIGhlaWdodFxuICogSWYgd2lkdGggb3IgaGVpZ2h0IGlzIG5vdCBwYXNzZWQgaW4gdXNlcyBgb3B0aW9ucy53aWR0aGAgYW5kLy9vciBgb3B0aW9ucy5oZWlnaHRgXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIFdlYkdMVGV4dHVyZSB0byBzZXQgcGFyYW1ldGVycyBmb3JcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IFtvcHRpb25zXSBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogICBUaGlzIGlzIG9mdGVuIHRoZSBzYW1lIG9wdGlvbnMgeW91IHBhc3NlZCBpbiB3aGVuIHlvdSBjcmVhdGVkIHRoZSB0ZXh0dXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gd2lkdGggb2YgdGV4dHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIGhlaWdodCBvZiB0ZXh0dXJlXG4gKiBAcGFyYW0ge251bWJlcn0gW2ludGVybmFsRm9ybWF0XSBUaGUgaW50ZXJuYWxGb3JtYXQgcGFyYW1ldGVyIGZyb20gdGV4SW1hZ2UyRCBldGMuLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShnbCwgdGV4LCBvcHRpb25zLCB3aWR0aCwgaGVpZ2h0LCBpbnRlcm5hbEZvcm1hdCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cy50ZXh0dXJlT3B0aW9ucztcbiAgaW50ZXJuYWxGb3JtYXQgPSBpbnRlcm5hbEZvcm1hdCB8fCBSR0JBO1xuICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRDtcbiAgd2lkdGggPSB3aWR0aCB8fCBvcHRpb25zLndpZHRoO1xuICBoZWlnaHQgPSBoZWlnaHQgfHwgb3B0aW9ucy5oZWlnaHQ7XG4gIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcblxuICBpZiAoY2FuR2VuZXJhdGVNaXBtYXAoZ2wsIHdpZHRoLCBoZWlnaHQsIGludGVybmFsRm9ybWF0KSkge1xuICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpbHRlcmluZyA9IGNhbkZpbHRlcihpbnRlcm5hbEZvcm1hdCkgPyBMSU5FQVIgOiBORUFSRVNUO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBURVhUVVJFX01JTl9GSUxURVIsIGZpbHRlcmluZyk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIFRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyaW5nKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgVEVYVFVSRV9XUkFQX1MsIENMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBURVhUVVJFX1dSQVBfVCwgQ0xBTVBfVE9fRURHRSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQXV0b21hdGljYWxseVNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuYXV0byA9PT0gdHJ1ZSB8fCBvcHRpb25zLmF1dG8gPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmxldmVsID09PSB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEdldHMgYW4gYXJyYXkgb2YgY3ViZW1hcCBmYWNlIGVudW1zXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogICBUaGlzIGlzIG9mdGVuIHRoZSBzYW1lIG9wdGlvbnMgeW91IHBhc3NlZCBpbiB3aGVuIHlvdSBjcmVhdGVkIHRoZSB0ZXh0dXJlLlxuICogQHJldHVybiB7bnVtYmVyW119IGN1YmVtYXAgZmFjZSBlbnVtc1xuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEN1YmVGYWNlT3JkZXIoZ2wsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHJldHVybiBvcHRpb25zLmN1YmVGYWNlT3JkZXIgfHwgW1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCwgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YLCBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ksIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWSwgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aLCBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1pdO1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGYWNlSW5mb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGZhY2UgZ2wgZW51bSBmb3IgdGV4SW1hZ2UyRFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG5keCBmYWNlIGluZGV4ICgwIC0gNSkgaW50byBzb3VyY2UgZGF0YVxuICogQGlnbm9yZVxuICovXG5cbi8qKlxuICogR2V0cyBhbiBhcnJheSBvZiBGYWNlSW5mb3NcbiAqIFRoZXJlJ3MgYSBidWcgaW4gc29tZSBOVmlkaWEgZHJpdmVycyB0aGF0IHdpbGwgY3Jhc2ggdGhlIGRyaXZlciBpZlxuICogYGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWGAgaXMgbm90IHVwbG9hZGVkIGZpcnN0LiBTbywgd2UgdGFrZVxuICogdGhlIHVzZXIncyBkZXNpcmVkIG9yZGVyIGZyb20gaGlzIGZhY2VzIHRvIFdlYkdMIGFuZCBtYWtlIHN1cmUgd2VcbiAqIGRvIHRoZSBmYWNlcyBpbiBXZWJHTCBvcmRlclxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAcmV0dXJuIHtGYWNlSW5mb1tdfSBjdWJlbWFwIGZhY2UgaW5mb3MuIEFyZ3VhYmx5IHRoZSBgZmFjZWAgcHJvcGVydHkgb2YgZWFjaCBlbGVtZW50IGlzIHJlZHVuZGFudCBidXRcbiAqICAgIGl0J3MgbmVlZGVkIGludGVybmFsbHkgdG8gc29ydCB0aGUgYXJyYXkgb2YgYG5keGAgcHJvcGVydGllcyBieSBgZmFjZWAuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q3ViZUZhY2VzV2l0aE5keChnbCwgb3B0aW9ucykge1xuICB2YXIgZmFjZXMgPSBnZXRDdWJlRmFjZU9yZGVyKGdsLCBvcHRpb25zKTsgLy8gd29yayBhcm91bmQgYnVnIGluIE5WaWRpYSBkcml2ZXJzLiBXZSBoYXZlIHRvIHVwbG9hZCB0aGUgZmlyc3QgZmFjZSBmaXJzdCBlbHNlIHRoZSBkcml2ZXIgY3Jhc2hlcyA6KFxuXG4gIHZhciBmYWNlc1dpdGhOZHggPSBmYWNlcy5tYXAoZnVuY3Rpb24gKGZhY2UsIG5keCkge1xuICAgIHJldHVybiB7XG4gICAgICBmYWNlOiBmYWNlLFxuICAgICAgbmR4OiBuZHhcbiAgICB9O1xuICB9KTtcbiAgZmFjZXNXaXRoTmR4LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5mYWNlIC0gYi5mYWNlO1xuICB9KTtcbiAgcmV0dXJuIGZhY2VzV2l0aE5keDtcbn1cbi8qKlxuICogU2V0IGEgdGV4dHVyZSBmcm9tIHRoZSBjb250ZW50cyBvZiBhbiBlbGVtZW50LiBXaWxsIGFsc28gc2V0XG4gKiB0ZXh0dXJlIGZpbHRlcmluZyBvciBnZW5lcmF0ZSBtaXBzIGJhc2VkIG9uIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBlbGVtZW50XG4gKiB1bmxlc3MgYG9wdGlvbnMuYXV0byA9PT0gZmFsc2VgLiBJZiBgdGFyZ2V0ID09PSBnbC5URVhUVVJFX0NVQkVfTUFQYCB3aWxsXG4gKiBhdHRlbXB0IHRvIHNsaWNlIGltYWdlIGludG8gMXg2LCAyeDMsIDN4Miwgb3IgNngxIGltYWdlcywgb25lIGZvciBlYWNoIGZhY2UuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBhIGNhbnZhcywgaW1nLCBvciB2aWRlbyBlbGVtZW50LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gW29wdGlvbnNdIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiAgIFRoaXMgaXMgb2Z0ZW4gdGhlIHNhbWUgb3B0aW9ucyB5b3UgcGFzc2VkIGluIHdoZW4geW91IGNyZWF0ZWQgdGhlIHRleHR1cmUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqIEBraW5kIGZ1bmN0aW9uXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRUZXh0dXJlRnJvbUVsZW1lbnQoZ2wsIHRleCwgZWxlbWVudCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cy50ZXh0dXJlT3B0aW9ucztcbiAgdmFyIHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IFRFWFRVUkVfMkQ7XG4gIHZhciBsZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwgMDtcbiAgdmFyIHdpZHRoID0gZWxlbWVudC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnQuaGVpZ2h0O1xuICB2YXIgaW50ZXJuYWxGb3JtYXQgPSBvcHRpb25zLmludGVybmFsRm9ybWF0IHx8IG9wdGlvbnMuZm9ybWF0IHx8IFJHQkE7XG4gIHZhciBmb3JtYXRUeXBlID0gZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0KTtcbiAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGZvcm1hdFR5cGUuZm9ybWF0O1xuICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBmb3JtYXRUeXBlLnR5cGU7XG4gIHNldFBhY2tTdGF0ZShnbCwgb3B0aW9ucyk7XG4gIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcblxuICBpZiAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgLy8gZ3Vlc3MgdGhlIHBhcnRzXG4gICAgdmFyIGltZ1dpZHRoID0gZWxlbWVudC53aWR0aDtcbiAgICB2YXIgaW1nSGVpZ2h0ID0gZWxlbWVudC5oZWlnaHQ7XG4gICAgdmFyIHNpemU7XG4gICAgdmFyIHNsaWNlcztcblxuICAgIGlmIChpbWdXaWR0aCAvIDYgPT09IGltZ0hlaWdodCkge1xuICAgICAgLy8gSXQncyA2eDFcbiAgICAgIHNpemUgPSBpbWdIZWlnaHQ7XG4gICAgICBzbGljZXMgPSBbMCwgMCwgMSwgMCwgMiwgMCwgMywgMCwgNCwgMCwgNSwgMF07XG4gICAgfSBlbHNlIGlmIChpbWdIZWlnaHQgLyA2ID09PSBpbWdXaWR0aCkge1xuICAgICAgLy8gSXQncyAxeDZcbiAgICAgIHNpemUgPSBpbWdXaWR0aDtcbiAgICAgIHNsaWNlcyA9IFswLCAwLCAwLCAxLCAwLCAyLCAwLCAzLCAwLCA0LCAwLCA1XTtcbiAgICB9IGVsc2UgaWYgKGltZ1dpZHRoIC8gMyA9PT0gaW1nSGVpZ2h0IC8gMikge1xuICAgICAgLy8gSXQncyAzeDJcbiAgICAgIHNpemUgPSBpbWdXaWR0aCAvIDM7XG4gICAgICBzbGljZXMgPSBbMCwgMCwgMSwgMCwgMiwgMCwgMCwgMSwgMSwgMSwgMiwgMV07XG4gICAgfSBlbHNlIGlmIChpbWdXaWR0aCAvIDIgPT09IGltZ0hlaWdodCAvIDMpIHtcbiAgICAgIC8vIEl0J3MgMngzXG4gICAgICBzaXplID0gaW1nV2lkdGggLyAyO1xuICAgICAgc2xpY2VzID0gWzAsIDAsIDEsIDAsIDAsIDEsIDEsIDEsIDAsIDIsIDEsIDJdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBcImNhbid0IGZpZ3VyZSBvdXQgY3ViZSBtYXAgZnJvbSBlbGVtZW50OiBcIiArIChlbGVtZW50LnNyYyA/IGVsZW1lbnQuc3JjIDogZWxlbWVudC5ub2RlTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGN0eCA9IGdldFNoYXJlZDJEQ29udGV4dCgpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmNhbnZhcy53aWR0aCA9IHNpemU7XG4gICAgICBjdHguY2FudmFzLmhlaWdodCA9IHNpemU7XG4gICAgICB3aWR0aCA9IHNpemU7XG4gICAgICBoZWlnaHQgPSBzaXplO1xuICAgICAgZ2V0Q3ViZUZhY2VzV2l0aE5keChnbCwgb3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICB2YXIgeE9mZnNldCA9IHNsaWNlc1tmLm5keCAqIDIgKyAwXSAqIHNpemU7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gc2xpY2VzW2YubmR4ICogMiArIDFdICogc2l6ZTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShlbGVtZW50LCB4T2Zmc2V0LCB5T2Zmc2V0LCBzaXplLCBzaXplLCAwLCAwLCBzaXplLCBzaXplKTtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChmLmZhY2UsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBjdHguY2FudmFzKTtcbiAgICAgIH0pOyAvLyBGcmVlIHVwIHRoZSBjYW52YXMgbWVtb3J5XG5cbiAgICAgIGN0eC5jYW52YXMud2lkdGggPSAxO1xuICAgICAgY3R4LmNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gTk9URTogSXQgc2VlbXMgbGlrZSB3ZSBzaG91bGQgcHJlZmVyIEltYWdlQml0bWFwIGJlY2F1c2UgdW5saWtlIGNhbnZhcyBpdCdzXG4gICAgICAvLyBub3RlIGxvc3N5PyAoYWxwaGEgaXMgbm90IHByZW11bHRpcGxpZWQ/IGFsdGhvdWdoIEknbSBub3Qgc3VyZSB3aGF0XG4gICAgICB3aWR0aCA9IHNpemU7XG4gICAgICBoZWlnaHQgPSBzaXplO1xuICAgICAgZ2V0Q3ViZUZhY2VzV2l0aE5keChnbCwgb3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICB2YXIgeE9mZnNldCA9IHNsaWNlc1tmLm5keCAqIDIgKyAwXSAqIHNpemU7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gc2xpY2VzW2YubmR4ICogMiArIDFdICogc2l6ZTsgLy8gV2UgY2FuJ3QgZWFzaWx5IHVzZSBhIGRlZmF1bHQgdGV4dHVyZSBjb2xvciBoZXJlIGFzIGl0IHdvdWxkIGhhdmUgdG8gbWF0Y2hcbiAgICAgICAgLy8gdGhlIHR5cGUgYWNyb3NzIGFsbCBmYWNlcyB3aGVyZSBhcyB3aXRoIGEgMkQgb25lIHRoZXJlJ3Mgb25seSBvbmUgZmFjZVxuICAgICAgICAvLyBzbyB3ZSdyZSByZXBsYWNpbmcgZXZlcnl0aGluZyBhbGwgYXQgb25jZS4gSXQgYWxzbyBoYXMgdG8gYmUgdGhlIGNvcnJlY3Qgc2l6ZS5cbiAgICAgICAgLy8gT24gdGhlIG90aGVyIGhhbmQgd2UgbmVlZCBhbGwgZmFjZXMgdG8gYmUgdGhlIHNhbWUgc2l6ZSBzbyBhcyBvbmUgZmFjZSBsb2Fkc1xuICAgICAgICAvLyB0aGUgcmVzdCBtYXRjaCBlbHNlIHRoZSB0ZXh0dXJlIHdpbGwgYmUgdW4tcmVuZGVyYWJsZS5cblxuICAgICAgICBnbC50ZXhJbWFnZTJEKGYuZmFjZSwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBzaXplLCBzaXplLCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuICAgICAgICBjcmVhdGVJbWFnZUJpdG1hcChlbGVtZW50LCB4T2Zmc2V0LCB5T2Zmc2V0LCBzaXplLCBzaXplLCB7XG4gICAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogJ25vbmUnLFxuICAgICAgICAgIGNvbG9yU3BhY2VDb252ZXJzaW9uOiAnbm9uZSdcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoaW1hZ2VCaXRtYXApIHtcbiAgICAgICAgICBzZXRQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xuICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcbiAgICAgICAgICBnbC50ZXhJbWFnZTJEKGYuZmFjZSwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIGltYWdlQml0bWFwKTtcblxuICAgICAgICAgIGlmIChzaG91bGRBdXRvbWF0aWNhbGx5U2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKGdsLCB0ZXgsIG9wdGlvbnMsIHdpZHRoLCBoZWlnaHQsIGludGVybmFsRm9ybWF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV8zRCB8fCB0YXJnZXQgPT09IFRFWFRVUkVfMkRfQVJSQVkpIHtcbiAgICB2YXIgc21hbGxlc3QgPSBNYXRoLm1pbihlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCk7XG4gICAgdmFyIGxhcmdlc3QgPSBNYXRoLm1heChlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCk7XG4gICAgdmFyIGRlcHRoID0gbGFyZ2VzdCAvIHNtYWxsZXN0O1xuXG4gICAgaWYgKGRlcHRoICUgMSAhPT0gMCkge1xuICAgICAgdGhyb3cgXCJjYW4gbm90IGNvbXB1dGUgM0QgZGltZW5zaW9ucyBvZiBlbGVtZW50XCI7XG4gICAgfVxuXG4gICAgdmFyIHhNdWx0ID0gZWxlbWVudC53aWR0aCA9PT0gbGFyZ2VzdCA/IDEgOiAwO1xuICAgIHZhciB5TXVsdCA9IGVsZW1lbnQuaGVpZ2h0ID09PSBsYXJnZXN0ID8gMSA6IDA7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX0FMSUdOTUVOVCwgMSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX1JPV19MRU5HVEgsIGVsZW1lbnQud2lkdGgpO1xuICAgIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19JTUFHRV9IRUlHSFQsIDApO1xuICAgIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19TS0lQX0lNQUdFUywgMCk7XG4gICAgZ2wudGV4SW1hZ2UzRCh0YXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgc21hbGxlc3QsIHNtYWxsZXN0LCBzbWFsbGVzdCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcblxuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGVwdGg7ICsrZCkge1xuICAgICAgdmFyIHNyY1ggPSBkICogc21hbGxlc3QgKiB4TXVsdDtcbiAgICAgIHZhciBzcmNZID0gZCAqIHNtYWxsZXN0ICogeU11bHQ7XG4gICAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfU0tJUF9QSVhFTFMsIHNyY1gpO1xuICAgICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX1NLSVBfUk9XUywgc3JjWSk7XG4gICAgICBnbC50ZXhTdWJJbWFnZTNEKHRhcmdldCwgbGV2ZWwsIDAsIDAsIGQsIHNtYWxsZXN0LCBzbWFsbGVzdCwgMSwgZm9ybWF0LCB0eXBlLCBlbGVtZW50KTtcbiAgICB9XG5cbiAgICBzZXRTa2lwU3RhdGVUb0RlZmF1bHQoZ2wpO1xuICB9IGVsc2Uge1xuICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgZWxlbWVudCk7XG4gIH1cblxuICBpZiAoc2hvdWxkQXV0b21hdGljYWxseVNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKG9wdGlvbnMpKSB7XG4gICAgc2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUoZ2wsIHRleCwgb3B0aW9ucywgd2lkdGgsIGhlaWdodCwgaW50ZXJuYWxGb3JtYXQpO1xuICB9XG5cbiAgc2V0VGV4dHVyZVBhcmFtZXRlcnMoZ2wsIHRleCwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXJsJ3Mgb3JpZ2luIGlzIHRoZSBzYW1lIHNvIHRoYXQgd2UgY2FuIHNldCB0aGUgYGNyb3NzT3JpZ2luYFxuICogQHBhcmFtIHtzdHJpbmd9IHVybCB1cmwgdG8gaW1hZ2VcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB3aW5kb3cncyBvcmlnaW4gaXMgdGhlIHNhbWUgYXMgaW1hZ2UncyB1cmxcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiB1cmxJc1NhbWVPcmlnaW4odXJsKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gZm9yIElFIHJlYWxseVxuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGEuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gYS5ob3N0bmFtZSA9PT0gbG9jYXRpb24uaG9zdG5hbWUgJiYgYS5wb3J0ID09PSBsb2NhdGlvbi5wb3J0ICYmIGEucHJvdG9jb2wgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICB9IGVsc2Uge1xuICAgIHZhciBsb2NhbE9yaWdpbiA9IG5ldyBVUkwobG9jYXRpb24uaHJlZikub3JpZ2luO1xuICAgIHZhciB1cmxPcmlnaW4gPSBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZikub3JpZ2luO1xuICAgIHJldHVybiB1cmxPcmlnaW4gPT09IGxvY2FsT3JpZ2luO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldFRvQW5vbnltb3VzSWZVbmRlZmluZWRBbmRVUkxJc05vdFNhbWVPcmlnaW4odXJsLCBjcm9zc09yaWdpbikge1xuICByZXR1cm4gY3Jvc3NPcmlnaW4gPT09IHVuZGVmaW5lZCAmJiAhdXJsSXNTYW1lT3JpZ2luKHVybCkgPyAnYW5vbnltb3VzJyA6IGNyb3NzT3JpZ2luO1xufVxuLyoqXG4gKiBMb2FkcyBhbiBpbWFnZVxuICogQHBhcmFtIHtzdHJpbmd9IHVybCB1cmwgdG8gaW1hZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBjcm9zc09yaWdpblxuICogQHBhcmFtIHtmdW5jdGlvbihlcnIsIGltZyl9IFtjYWxsYmFja10gYSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIGFuIGVycm9yIGFuZCB0aGUgaW1hZ2UuIFRoZSBlcnJvciB3aWxsIGJlIG5vbi1udWxsXG4gKiAgICAgaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSB0aGUgaW1hZ2UgYmVpbmcgbG9hZGVkLlxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRJbWFnZSh1cmwsIGNyb3NzT3JpZ2luLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gIHZhciBpbWc7XG4gIGNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCA/IGNyb3NzT3JpZ2luIDogZGVmYXVsdHMuY3Jvc3NPcmlnaW47XG4gIGNyb3NzT3JpZ2luID0gc2V0VG9Bbm9ueW1vdXNJZlVuZGVmaW5lZEFuZFVSTElzTm90U2FtZU9yaWdpbih1cmwsIGNyb3NzT3JpZ2luKTtcblxuICBpZiAodHlwZW9mIEltYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGltZyA9IG5ldyBJbWFnZSgpO1xuXG4gICAgaWYgKGNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgIH1cblxuICAgIHZhciBjbGVhckV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiBjbGVhckV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICBpbWcucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICBpbWcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgaW1nID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgICAgdmFyIG1zZyA9IFwiY291bGRuJ3QgbG9hZCBpbWFnZTogXCIgKyB1cmw7XG4gICAgICBoZWxwZXIuZXJyb3IobXNnKTtcbiAgICAgIGNhbGxiYWNrKG1zZywgaW1nKTtcbiAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpO1xuICAgIH07XG5cbiAgICB2YXIgb25Mb2FkID0gZnVuY3Rpb24gb25Mb2FkKCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgaW1nKTtcbiAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpO1xuICAgIH07XG5cbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgaW1nLnNyYyA9IHVybDtcbiAgICByZXR1cm4gaW1nO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgZXJyO1xuICAgIHZhciBibTtcblxuICAgIHZhciBjYiA9IGZ1bmN0aW9uIGNiKCkge1xuICAgICAgY2FsbGJhY2soZXJyLCBibSk7XG4gICAgfTtcblxuICAgIHZhciBvcHRpb25zID0ge307XG5cbiAgICBpZiAoY3Jvc3NPcmlnaW4pIHtcbiAgICAgIG9wdGlvbnMubW9kZSA9ICdjb3JzJzsgLy8gVE9ETzogbm90IHN1cmUgaG93IHRvIHRyYW5zbGF0ZSBpbWFnZS5jcm9zc09yaWdpblxuICAgIH1cblxuICAgIGZldGNoKHVybCwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgcmVzcG9uc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKGJsb2IsIHtcbiAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogJ25vbmUnLFxuICAgICAgICBjb2xvclNwYWNlQ29udmVyc2lvbjogJ25vbmUnXG4gICAgICB9KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChiaXRtYXApIHtcbiAgICAgIC8vIG5vdCBzdXJlIGlmIHRoaXMgd29ya3MuIFdlIGRvbid0IHdhbnRcbiAgICAgIC8vIHRvIGNhdGNoIHRoZSB1c2VyJ3MgZXJyb3IuIFNvLCBjYWxsXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgaW4gYSB0aW1lb3V0IHNvIHdlJ3JlXG4gICAgICAvLyBub3QgaW4gdGhpcyBzY29wZSBpbnNpZGUgdGhlIHByb21pc2UuXG4gICAgICBibSA9IGJpdG1hcDtcbiAgICAgIHNldFRpbWVvdXQoY2IpO1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgICBzZXRUaW1lb3V0KGNiKTtcbiAgICB9KTtcbiAgICBpbWcgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGltZztcbn1cbi8qKlxuICogY2hlY2sgaWYgb2JqZWN0IGlzIGEgVGV4SW1hZ2VTb3VyY2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBhIFRleEltYWdlU291cmNlXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gaXNUZXhJbWFnZVNvdXJjZShvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAgfHwgdHlwZW9mIEltYWdlRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgSW1hZ2VEYXRhIHx8IHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG4vKipcbiAqIGlmIG9iaiBpcyBhbiBUZXhJbWFnZVNvdXJjZSB0aGVuIGp1c3RcbiAqIHVzZXMgaXQgb3RoZXJ3aXNlIGlmIG9iaiBpcyBhIHN0cmluZ1xuICogdGhlbiBsb2FkIGl0IGZpcnN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFRleEltYWdlU291cmNlfSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjcm9zc09yaWdpblxuICogQHBhcmFtIHtmdW5jdGlvbihlcnIsIGltZyl9IFtjYWxsYmFja10gYSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIGFuIGVycm9yIGFuZCB0aGUgaW1hZ2UuIFRoZSBlcnJvciB3aWxsIGJlIG5vbi1udWxsXG4gKiAgICAgaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9hZEFuZFVzZUltYWdlKG9iaiwgY3Jvc3NPcmlnaW4sIGNhbGxiYWNrKSB7XG4gIGlmIChpc1RleEltYWdlU291cmNlKG9iaikpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIG9iaik7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHJldHVybiBsb2FkSW1hZ2Uob2JqLCBjcm9zc09yaWdpbiwgY2FsbGJhY2spO1xufVxuLyoqXG4gKiBTZXRzIGEgdGV4dHVyZSB0byBhIDF4MSBwaXhlbCBjb2xvci4gSWYgYG9wdGlvbnMuY29sb3IgPT09IGZhbHNlYCBpcyBub3RoaW5nIGhhcHBlbnMuIElmIGl0J3Mgbm90IHNldFxuICogdGhlIGRlZmF1bHQgdGV4dHVyZSBjb2xvciBpcyB1c2VkIHdoaWNoIGNhbiBiZSBzZXQgYnkgY2FsbGluZyBgc2V0RGVmYXVsdFRleHR1cmVDb2xvcmAuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gW29wdGlvbnNdIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiAgIFRoaXMgaXMgb2Z0ZW4gdGhlIHNhbWUgb3B0aW9ucyB5b3UgcGFzc2VkIGluIHdoZW4geW91IGNyZWF0ZWQgdGhlIHRleHR1cmUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRleHR1cmVUbzFQaXhlbENvbG9yKGdsLCB0ZXgsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHMudGV4dHVyZU9wdGlvbnM7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJEO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG5cbiAgaWYgKG9wdGlvbnMuY29sb3IgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIEFzc3VtZSBpdCdzIGEgVVJMXG4gIC8vIFB1dCAxeDEgcGl4ZWxzIGluIHRleHR1cmUuIFRoYXQgbWFrZXMgaXQgcmVuZGVyYWJsZSBpbW1lZGlhdGVseSByZWdhcmRsZXNzIG9mIGZpbHRlcmluZy5cblxuXG4gIHZhciBjb2xvciA9IG1ha2UxUGl4ZWwob3B0aW9ucy5jb2xvcik7XG5cbiAgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV9DVUJFX01BUCkge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCA2OyArK2lpKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGlpLCAwLCBSR0JBLCAxLCAxLCAwLCBSR0JBLCBVTlNJR05FRF9CWVRFLCBjb2xvcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV8zRCB8fCB0YXJnZXQgPT09IFRFWFRVUkVfMkRfQVJSQVkpIHtcbiAgICBnbC50ZXhJbWFnZTNEKHRhcmdldCwgMCwgUkdCQSwgMSwgMSwgMSwgMCwgUkdCQSwgVU5TSUdORURfQllURSwgY29sb3IpO1xuICB9IGVsc2Uge1xuICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCAwLCBSR0JBLCAxLCAxLCAwLCBSR0JBLCBVTlNJR05FRF9CWVRFLCBjb2xvcik7XG4gIH1cbn1cbi8qKlxuICogVGhlIHNyYyBpbWFnZShzKSB1c2VkIHRvIGNyZWF0ZSBhIHRleHR1cmUuXG4gKlxuICogV2hlbiB5b3UgY2FsbCB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVGV4dHVyZX0gb3Ige0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVRleHR1cmVzfVxuICogeW91IGNhbiBwYXNzIGluIHVybHMgZm9yIGltYWdlcyB0byBsb2FkIGludG8gdGhlIHRleHR1cmVzLiBJZiBpdCdzIGEgc2luZ2xlIHVybFxuICogdGhlbiB0aGlzIHdpbGwgYmUgYSBzaW5nbGUgSFRNTEltYWdlRWxlbWVudC4gSWYgaXQncyBhbiBhcnJheSBvZiB1cmxzIHVzZWQgZm9yIGEgY3ViZW1hcFxuICogdGhpcyB3aWxsIGJlIGEgY29ycmVzcG9uZGluZyBhcnJheSBvZiBpbWFnZXMgZm9yIHRoZSBjdWJlbWFwLlxuICpcbiAqIEB0eXBlZGVmIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnRbXX0gVGV4dHVyZVNyY1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBBIGNhbGxiYWNrIGZvciB3aGVuIGFuIGltYWdlIGZpbmlzaGVkIGRvd25sb2FkaW5nIGFuZCBiZWVuIHVwbG9hZGVkIGludG8gYSB0ZXh0dXJlXG4gKiBAY2FsbGJhY2sgVGV4dHVyZVJlYWR5Q2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gZXJyIElmIHRydXRoeSB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4dHVyZSB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZVNyY30gc291cmNlIGltYWdlKHMpIHVzZWQgdG8gYXMgdGhlIHNyYyBmb3IgdGhlIHRleHR1cmVcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQSBjYWxsYmFjayBmb3Igd2hlbiBhbGwgaW1hZ2VzIGhhdmUgZmluaXNoZWQgZG93bmxvYWRpbmcgYW5kIGJlZW4gdXBsb2FkZWQgaW50byB0aGVpciByZXNwZWN0aXZlIHRleHR1cmVzXG4gKiBAY2FsbGJhY2sgVGV4dHVyZXNSZWFkeUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGVyciBJZiB0cnV0aHkgdGhlcmUgd2FzIGFuIGVycm9yLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgV2ViR0xUZXh0dXJlPn0gdGV4dHVyZXMgdGhlIGNyZWF0ZWQgdGV4dHVyZXMgYnkgbmFtZS4gU2FtZSBhcyByZXR1cm5lZCBieSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVGV4dHVyZXN9LlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnR3Z2wuVGV4dHVyZVNyYz59IHNvdXJjZXMgdGhlIGltYWdlKHMpIHVzZWQgZm9yIHRoZSB0ZXh0dXJlIGJ5IG5hbWUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgZm9yIHdoZW4gYW4gaW1hZ2UgZmluaXNoZWQgZG93bmxvYWRpbmcgYW5kIGJlZW4gdXBsb2FkZWQgaW50byBhIHRleHR1cmVcbiAqIEBjYWxsYmFjayBDdWJlbWFwUmVhZHlDYWxsYmFja1xuICogQHBhcmFtIHsqfSBlcnIgSWYgdHJ1dGh5IHRoZXJlIHdhcyBhbiBlcnJvci5cbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIHRleHR1cmUuXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnRbXX0gaW1ncyB0aGUgaW1hZ2VzIGZvciBlYWNoIGZhY2UuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgZm9yIHdoZW4gYW4gaW1hZ2UgZmluaXNoZWQgZG93bmxvYWRpbmcgYW5kIGJlZW4gdXBsb2FkZWQgaW50byBhIHRleHR1cmVcbiAqIEBjYWxsYmFjayBUaHJlZURSZWFkeUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGVyciBJZiB0cnV0aHkgdGhlcmUgd2FzIGFuIGVycm9yLlxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudFtdfSBpbWdzIHRoZSBpbWFnZXMgZm9yIGVhY2ggc2xpY2UuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIExvYWRzIGEgdGV4dHVyZSBmcm9tIGFuIGltYWdlIGZyb20gYSBVcmwgYXMgc3BlY2lmaWVkIGluIGBvcHRpb25zLnNyY2BcbiAqIElmIGBvcHRpb25zLmNvbG9yICE9PSBmYWxzZWAgd2lsbCBzZXQgdGhlIHRleHR1cmUgdG8gYSAxeDEgcGl4ZWwgY29sb3Igc28gdGhhdCB0aGUgdGV4dHVyZSBpc1xuICogaW1tZWRpYXRlbHkgdXNlYWJsZS4gSXQgd2lsbCBiZSB1cGRhdGVkIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBpbWFnZSBvbmNlIHRoZSBpbWFnZSBoYXMgZmluaXNoZWRcbiAqIGRvd25sb2FkaW5nLiBGaWx0ZXJpbmcgb3B0aW9ucyB3aWxsIGJlIHNldCBhcyBhcHByb3ByaWF0ZSBmb3IgaW1hZ2UgdW5sZXNzIGBvcHRpb25zLmF1dG8gPT09IGZhbHNlYC5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZVJlYWR5Q2FsbGJhY2t9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgaW1hZ2UgaGFzIGZpbmlzaGVkIGxvYWRpbmcuIGVyciB3aWxsXG4gKiAgICBiZSBub24gbnVsbCBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSB0aGUgaW1hZ2UgYmVpbmcgZG93bmxvYWRlZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cblxuZnVuY3Rpb24gbG9hZFRleHR1cmVGcm9tVXJsKGdsLCB0ZXgsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHMudGV4dHVyZU9wdGlvbnM7XG4gIHNldFRleHR1cmVUbzFQaXhlbENvbG9yKGdsLCB0ZXgsIG9wdGlvbnMpOyAvLyBCZWNhdXNlIGl0J3MgYXN5bmMgd2UgbmVlZCB0byBjb3B5IHRoZSBvcHRpb25zLlxuXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgdmFyIGltZyA9IGxvYWRBbmRVc2VJbWFnZShvcHRpb25zLnNyYywgb3B0aW9ucy5jcm9zc09yaWdpbiwgZnVuY3Rpb24gKGVyciwgaW1nKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyLCB0ZXgsIGltZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRleHR1cmVGcm9tRWxlbWVudChnbCwgdGV4LCBpbWcsIG9wdGlvbnMpO1xuICAgICAgY2FsbGJhY2sobnVsbCwgdGV4LCBpbWcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbWc7XG59XG4vKipcbiAqIExvYWRzIGEgY3ViZW1hcCBmcm9tIDYgdXJscyBvciBUZXhJbWFnZVNvdXJjZXMgYXMgc3BlY2lmaWVkIGluIGBvcHRpb25zLnNyY2AuIFdpbGwgc2V0IHRoZSBjdWJlbWFwIHRvIGEgMXgxIHBpeGVsIGNvbG9yXG4gKiBzbyB0aGF0IGl0IGlzIHVzYWJsZSBpbW1lZGlhdGVseSB1bmxlc3MgYG9wdGlvbi5jb2xvciA9PT0gZmFsc2VgLlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIFdlYkdMVGV4dHVyZSB0byBzZXQgcGFyYW1ldGVycyBmb3JcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQ3ViZW1hcFJlYWR5Q2FsbGJhY2t9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBhbGwgdGhlIGltYWdlcyBoYXZlIGZpbmlzaGVkIGxvYWRpbmcuIGVyciB3aWxsXG4gKiAgICBiZSBub24gbnVsbCBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRDdWJlbWFwRnJvbVVybHMoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICB2YXIgdXJscyA9IG9wdGlvbnMuc3JjO1xuXG4gIGlmICh1cmxzLmxlbmd0aCAhPT0gNikge1xuICAgIHRocm93IFwidGhlcmUgbXVzdCBiZSA2IHVybHMgZm9yIGEgY3ViZW1hcFwiO1xuICB9XG5cbiAgdmFyIGxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCAwO1xuICB2YXIgaW50ZXJuYWxGb3JtYXQgPSBvcHRpb25zLmludGVybmFsRm9ybWF0IHx8IG9wdGlvbnMuZm9ybWF0IHx8IFJHQkE7XG4gIHZhciBmb3JtYXRUeXBlID0gZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0KTtcbiAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGZvcm1hdFR5cGUuZm9ybWF0O1xuICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBVTlNJR05FRF9CWVRFO1xuICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRDtcblxuICBpZiAodGFyZ2V0ICE9PSBURVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgdGhyb3cgXCJ0YXJnZXQgbXVzdCBiZSBURVhUVVJFX0NVQkVfTUFQXCI7XG4gIH1cblxuICBzZXRUZXh0dXJlVG8xUGl4ZWxDb2xvcihnbCwgdGV4LCBvcHRpb25zKTsgLy8gQmVjYXVzZSBpdCdzIGFzeW5jIHdlIG5lZWQgdG8gY29weSB0aGUgb3B0aW9ucy5cblxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gIHZhciBudW1Ub0xvYWQgPSA2O1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBmYWNlcyA9IGdldEN1YmVGYWNlT3JkZXIoZ2wsIG9wdGlvbnMpO1xuICB2YXIgaW1nczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGZ1bmN0aW9uIHVwbG9hZEltZyhmYWNlVGFyZ2V0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIGltZykge1xuICAgICAgLS1udW1Ub0xvYWQ7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbWcud2lkdGggIT09IGltZy5oZWlnaHQpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChcImN1YmVtYXAgZmFjZSBpbWcgaXMgbm90IGEgc3F1YXJlOiBcIiArIGltZy5zcmMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFBhY2tTdGF0ZShnbCwgb3B0aW9ucyk7XG4gICAgICAgICAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpOyAvLyBTbyBhc3N1bWluZyB0aGlzIGlzIHRoZSBmaXJzdCBpbWFnZSB3ZSBub3cgaGF2ZSBvbmUgZmFjZSB0aGF0J3MgaW1nIHNpemVkXG4gICAgICAgICAgLy8gYW5kIDUgZmFjZXMgdGhhdCBhcmUgMXgxIHBpeGVsIHNvIHNpemUgdGhlIG90aGVyIGZhY2VzXG5cbiAgICAgICAgICBpZiAobnVtVG9Mb2FkID09PSA1KSB7XG4gICAgICAgICAgICAvLyB1c2UgdGhlIGRlZmF1bHQgb3JkZXJcbiAgICAgICAgICAgIGdldEN1YmVGYWNlT3JkZXIoZ2wpLmZvckVhY2goZnVuY3Rpb24gKG90aGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICAgIC8vIFNob3VsZCB3ZSByZS11c2UgdGhlIHNhbWUgZmFjZSBvciBhIGNvbG9yP1xuICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKG90aGVyVGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgaW1nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGZhY2VUYXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBpbWcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG91bGRBdXRvbWF0aWNhbGx5U2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1Ub0xvYWQgPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IHVuZGVmaW5lZCwgdGV4LCBpbWdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaW1ncyA9IHVybHMubWFwKGZ1bmN0aW9uICh1cmwsIG5keCkge1xuICAgIHJldHVybiBsb2FkQW5kVXNlSW1hZ2UodXJsLCBvcHRpb25zLmNyb3NzT3JpZ2luLCB1cGxvYWRJbWcoZmFjZXNbbmR4XSkpO1xuICB9KTtcbn1cbi8qKlxuICogTG9hZHMgYSAyZCBhcnJheSBvciAzZCB0ZXh0dXJlIGZyb20gdXJscyBPUiBUZXhJbWFnZVNvdXJjZXMgYXMgc3BlY2lmaWVkIGluIGBvcHRpb25zLnNyY2AuXG4gKiBXaWxsIHNldCB0aGUgdGV4dHVyZSB0byBhIDF4MSBwaXhlbCBjb2xvclxuICogc28gdGhhdCBpdCBpcyB1c2FibGUgaW1tZWRpYXRlbHkgdW5sZXNzIGBvcHRpb24uY29sb3IgPT09IGZhbHNlYC5cbiAqXG4gKiBJZiB0aGUgd2lkdGggYW5kIGhlaWdodCBpcyBub3Qgc3BlY2lmaWVkIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBmaXJzdFxuICogaW1hZ2UgbG9hZGVkIHdpbGwgYmUgdXNlZC4gTm90ZSB0aGF0IHNpbmNlIGltYWdlcyBhcmUgbG9hZGVkIGFzeW5jXG4gKiB3aGljaCBpbWFnZSBkb3dubG9hZHMgZmlyc3QgaXMgdW5rbm93bi5cbiAqXG4gKiBJZiBhbiBpbWFnZSBpcyBub3QgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgd2lkdGggYW5kIGhlaWdodCBpdCB3aWxsIGJlIHNjYWxlZFxuICogdG8gdGhhdCB3aWR0aCBhbmQgaGVpZ2h0LlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRocmVlRFJlYWR5Q2FsbGJhY2t9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBhbGwgdGhlIGltYWdlcyBoYXZlIGZpbmlzaGVkIGxvYWRpbmcuIGVyciB3aWxsXG4gKiAgICBiZSBub24gbnVsbCBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRTbGljZXNGcm9tVXJscyhnbCwgdGV4LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gIHZhciB1cmxzID0gb3B0aW9ucy5zcmM7XG4gIHZhciBpbnRlcm5hbEZvcm1hdCA9IG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgfHwgb3B0aW9ucy5mb3JtYXQgfHwgUkdCQTtcbiAgdmFyIGZvcm1hdFR5cGUgPSBnZXRGb3JtYXRBbmRUeXBlRm9ySW50ZXJuYWxGb3JtYXQoaW50ZXJuYWxGb3JtYXQpO1xuICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgZm9ybWF0VHlwZS5mb3JtYXQ7XG4gIHZhciB0eXBlID0gb3B0aW9ucy50eXBlIHx8IFVOU0lHTkVEX0JZVEU7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJEX0FSUkFZO1xuXG4gIGlmICh0YXJnZXQgIT09IFRFWFRVUkVfM0QgJiYgdGFyZ2V0ICE9PSBURVhUVVJFXzJEX0FSUkFZKSB7XG4gICAgdGhyb3cgXCJ0YXJnZXQgbXVzdCBiZSBURVhUVVJFXzNEIG9yIFRFWFRVUkVfMkRfQVJSQVlcIjtcbiAgfVxuXG4gIHNldFRleHR1cmVUbzFQaXhlbENvbG9yKGdsLCB0ZXgsIG9wdGlvbnMpOyAvLyBCZWNhdXNlIGl0J3MgYXN5bmMgd2UgbmVlZCB0byBjb3B5IHRoZSBvcHRpb25zLlxuXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgdmFyIG51bVRvTG9hZCA9IHVybHMubGVuZ3RoO1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBpbWdzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgdmFyIGxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCAwO1xuICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciBkZXB0aCA9IHVybHMubGVuZ3RoO1xuICB2YXIgZmlyc3RJbWFnZSA9IHRydWU7XG5cbiAgZnVuY3Rpb24gdXBsb2FkSW1nKHNsaWNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIGltZykge1xuICAgICAgLS1udW1Ub0xvYWQ7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFBhY2tTdGF0ZShnbCwgb3B0aW9ucyk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcblxuICAgICAgICBpZiAoZmlyc3RJbWFnZSkge1xuICAgICAgICAgIGZpcnN0SW1hZ2UgPSBmYWxzZTtcbiAgICAgICAgICB3aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgaW1nLndpZHRoO1xuICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IGltZy5oZWlnaHQ7XG4gICAgICAgICAgZ2wudGV4SW1hZ2UzRCh0YXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7IC8vIHB1dCBpdCBpbiBldmVyeSBzbGljZSBvdGhlcndpc2Ugc29tZSBzbGljZXMgd2lsbCBiZSAwLDAsMCwwXG5cbiAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IGRlcHRoOyArK3MpIHtcbiAgICAgICAgICAgIGdsLnRleFN1YkltYWdlM0QodGFyZ2V0LCBsZXZlbCwgMCwgMCwgcywgd2lkdGgsIGhlaWdodCwgMSwgZm9ybWF0LCB0eXBlLCBpbWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3JjID0gaW1nO1xuICAgICAgICAgIHZhciBjdHg7XG5cbiAgICAgICAgICBpZiAoaW1nLndpZHRoICE9PSB3aWR0aCB8fCBpbWcuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIFNpemUgdGhlIGltYWdlIHRvIGZpeFxuICAgICAgICAgICAgY3R4ID0gZ2V0U2hhcmVkMkRDb250ZXh0KCk7XG4gICAgICAgICAgICBzcmMgPSBjdHguY2FudmFzO1xuICAgICAgICAgICAgY3R4LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgY3R4LmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2wudGV4U3ViSW1hZ2UzRCh0YXJnZXQsIGxldmVsLCAwLCAwLCBzbGljZSwgd2lkdGgsIGhlaWdodCwgMSwgZm9ybWF0LCB0eXBlLCBzcmMpOyAvLyBmcmVlIHRoZSBjYW52YXMgbWVtb3J5XG5cbiAgICAgICAgICBpZiAoY3R4ICYmIHNyYyA9PT0gY3R4LmNhbnZhcykge1xuICAgICAgICAgICAgY3R4LmNhbnZhcy53aWR0aCA9IDA7XG4gICAgICAgICAgICBjdHguY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZEF1dG9tYXRpY2FsbHlTZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShvcHRpb25zKSkge1xuICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG51bVRvTG9hZCA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjayhlcnJvcnMubGVuZ3RoID8gZXJyb3JzIDogdW5kZWZpbmVkLCB0ZXgsIGltZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpbWdzID0gdXJscy5tYXAoZnVuY3Rpb24gKHVybCwgbmR4KSB7XG4gICAgcmV0dXJuIGxvYWRBbmRVc2VJbWFnZSh1cmwsIG9wdGlvbnMuY3Jvc3NPcmlnaW4sIHVwbG9hZEltZyhuZHgpKTtcbiAgfSk7XG59XG4vKipcbiAqIFNldHMgYSB0ZXh0dXJlIGZyb20gYW4gYXJyYXkgb3IgdHlwZWQgYXJyYXkuIElmIHRoZSB3aWR0aCBvciBoZWlnaHQgaXMgbm90IHByb3ZpZGVkIHdpbGwgYXR0ZW1wdCB0b1xuICogZ3Vlc3MgdGhlIHNpemUuIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9LlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIFdlYkdMVGV4dHVyZSB0byBzZXQgcGFyYW1ldGVycyBmb3JcbiAqIEBwYXJhbSB7KG51bWJlcltdfEFycmF5QnVmZmVyVmlldyl9IHNyYyBBbiBhcnJheSBvciB0eXBlZCBhcnJ5IHdpdGggdGV4dHVyZSBkYXRhLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gW29wdGlvbnNdIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiAgIFRoaXMgaXMgb2Z0ZW4gdGhlIHNhbWUgb3B0aW9ucyB5b3UgcGFzc2VkIGluIHdoZW4geW91IGNyZWF0ZWQgdGhlIHRleHR1cmUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRleHR1cmVGcm9tQXJyYXkoZ2wsIHRleCwgc3JjLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzLnRleHR1cmVPcHRpb25zO1xuICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRDtcbiAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciBkZXB0aCA9IG9wdGlvbnMuZGVwdGg7XG4gIHZhciBsZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwgMDtcbiAgdmFyIGludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCB8fCBvcHRpb25zLmZvcm1hdCB8fCBSR0JBO1xuICB2YXIgZm9ybWF0VHlwZSA9IGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCk7XG4gIHZhciBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBmb3JtYXRUeXBlLmZvcm1hdDtcbiAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgZ2V0VGV4dHVyZVR5cGVGb3JBcnJheVR5cGUoZ2wsIHNyYywgZm9ybWF0VHlwZS50eXBlKTtcblxuICBpZiAoIWlzQXJyYXlCdWZmZXIoc3JjKSkge1xuICAgIHZhciBUeXBlID0gdHlwZWRBcnJheXMuZ2V0VHlwZWRBcnJheVR5cGVGb3JHTFR5cGUodHlwZSk7XG4gICAgc3JjID0gbmV3IFR5cGUoc3JjKTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgIHNyYyA9IG5ldyBVaW50OEFycmF5KHNyYy5idWZmZXIpO1xuICB9XG5cbiAgdmFyIGJ5dGVzUGVyRWxlbWVudCA9IGdldEJ5dGVzUGVyRWxlbWVudEZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0LCB0eXBlKTtcbiAgdmFyIG51bUVsZW1lbnRzID0gc3JjLmJ5dGVMZW5ndGggLyBieXRlc1BlckVsZW1lbnQ7IC8vIFRPRE86IGNoZWNrIFVOUEFDS19BTElHTk1FTlQ/XG5cbiAgaWYgKG51bUVsZW1lbnRzICUgMSkge1xuICAgIHRocm93IFwibGVuZ3RoIHdyb25nIHNpemUgZm9yIGZvcm1hdDogXCIgKyB1dGlscy5nbEVudW1Ub1N0cmluZyhnbCwgZm9ybWF0KTtcbiAgfVxuXG4gIHZhciBkaW1lbnNpb25zO1xuXG4gIGlmICh0YXJnZXQgPT09IFRFWFRVUkVfM0QgfHwgdGFyZ2V0ID09PSBURVhUVVJFXzJEX0FSUkFZKSB7XG4gICAgaWYgKCF3aWR0aCAmJiAhaGVpZ2h0ICYmICFkZXB0aCkge1xuICAgICAgdmFyIHNpemUgPSBNYXRoLmNicnQobnVtRWxlbWVudHMpO1xuXG4gICAgICBpZiAoc2l6ZSAlIDEgIT09IDApIHtcbiAgICAgICAgdGhyb3cgXCJjYW4ndCBndWVzcyBjdWJlIHNpemUgb2YgYXJyYXkgb2YgbnVtRWxlbWVudHM6IFwiICsgbnVtRWxlbWVudHM7XG4gICAgICB9XG5cbiAgICAgIHdpZHRoID0gc2l6ZTtcbiAgICAgIGhlaWdodCA9IHNpemU7XG4gICAgICBkZXB0aCA9IHNpemU7XG4gICAgfSBlbHNlIGlmICh3aWR0aCAmJiAoIWhlaWdodCB8fCAhZGVwdGgpKSB7XG4gICAgICBkaW1lbnNpb25zID0gZ3Vlc3NEaW1lbnNpb25zKGdsLCB0YXJnZXQsIGhlaWdodCwgZGVwdGgsIG51bUVsZW1lbnRzIC8gd2lkdGgpO1xuICAgICAgaGVpZ2h0ID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgIGRlcHRoID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChoZWlnaHQgJiYgKCF3aWR0aCB8fCAhZGVwdGgpKSB7XG4gICAgICBkaW1lbnNpb25zID0gZ3Vlc3NEaW1lbnNpb25zKGdsLCB0YXJnZXQsIHdpZHRoLCBkZXB0aCwgbnVtRWxlbWVudHMgLyBoZWlnaHQpO1xuICAgICAgd2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgZGVwdGggPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGltZW5zaW9ucyA9IGd1ZXNzRGltZW5zaW9ucyhnbCwgdGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBudW1FbGVtZW50cyAvIGRlcHRoKTtcbiAgICAgIHdpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgIGhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkaW1lbnNpb25zID0gZ3Vlc3NEaW1lbnNpb25zKGdsLCB0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIG51bUVsZW1lbnRzKTtcbiAgICB3aWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gIH1cblxuICBzZXRTa2lwU3RhdGVUb0RlZmF1bHQoZ2wpO1xuICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfQUxJR05NRU5ULCBvcHRpb25zLnVucGFja0FsaWdubWVudCB8fCAxKTtcbiAgc2V0UGFja1N0YXRlKGdsLCBvcHRpb25zKTtcblxuICBpZiAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgdmFyIGVsZW1lbnRzUGVyRWxlbWVudCA9IGJ5dGVzUGVyRWxlbWVudCAvIHNyYy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICB2YXIgZmFjZVNpemUgPSBudW1FbGVtZW50cyAvIDYgKiBlbGVtZW50c1BlckVsZW1lbnQ7XG4gICAgZ2V0Q3ViZUZhY2VzV2l0aE5keChnbCwgb3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgdmFyIG9mZnNldCA9IGZhY2VTaXplICogZi5uZHg7XG4gICAgICB2YXIgZGF0YSA9IHNyYy5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGZhY2VTaXplKTtcbiAgICAgIGdsLnRleEltYWdlMkQoZi5mYWNlLCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdHlwZSwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEIHx8IHRhcmdldCA9PT0gVEVYVFVSRV8yRF9BUlJBWSkge1xuICAgIGdsLnRleEltYWdlM0QodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCAwLCBmb3JtYXQsIHR5cGUsIHNyYyk7XG4gIH0gZWxzZSB7XG4gICAgZ2wudGV4SW1hZ2UyRCh0YXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBzcmMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgZGVwdGg6IGRlcHRoLFxuICAgIHR5cGU6IHR5cGVcbiAgfTtcbn1cbi8qKlxuICogU2V0cyBhIHRleHR1cmUgd2l0aCBubyBjb250ZW50cyBvZiBhIGNlcnRhaW4gc2l6ZS4gSW4gb3RoZXIgd29yZHMgY2FsbHMgYGdsLnRleEltYWdlMkRgIHdpdGggYG51bGxgLlxuICogWW91IG11c3Qgc2V0IGBvcHRpb25zLndpZHRoYCBhbmQgYG9wdGlvbnMuaGVpZ2h0YC5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldEVtcHR5VGV4dHVyZShnbCwgdGV4LCBvcHRpb25zKSB7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJEO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gIHZhciBsZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwgMDtcbiAgdmFyIGludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCB8fCBvcHRpb25zLmZvcm1hdCB8fCBSR0JBO1xuICB2YXIgZm9ybWF0VHlwZSA9IGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCk7XG4gIHZhciBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBmb3JtYXRUeXBlLmZvcm1hdDtcbiAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgZm9ybWF0VHlwZS50eXBlO1xuICBzZXRQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xuXG4gIGlmICh0YXJnZXQgPT09IFRFWFRVUkVfQ1VCRV9NQVApIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgNjsgKytpaSkge1xuICAgICAgZ2wudGV4SW1hZ2UyRChURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpaSwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEIHx8IHRhcmdldCA9PT0gVEVYVFVSRV8yRF9BUlJBWSkge1xuICAgIGdsLnRleEltYWdlM0QodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0LCBvcHRpb25zLmRlcHRoLCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0LCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSB0ZXh0dXJlIGJhc2VkIG9uIHRoZSBvcHRpb25zIHBhc3NlZCBpbi5cbiAqXG4gKiBOb3RlOiBtYXkgcmVzZXQgVU5QQUNLX0FMSUdOTUVOVCwgVU5QQUNLX1JPV19MRU5HVEgsIFVOUEFDS19JTUFHRV9IRUlHSFQsIFVOUEFDS19TS0lQX0lNQUdFU1xuICogVU5QQUNLX1NLSVBfUElYRUxTLCBhbmQgVU5QQUNLX1NLSVBfUk9XU1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZVJlYWR5Q2FsbGJhY2t9IFtjYWxsYmFja10gQSBjYWxsYmFjayBjYWxsZWQgd2hlbiBhbiBpbWFnZSBoYXMgYmVlbiBkb3dubG9hZGVkIGFuZCB1cGxvYWRlZCB0byB0aGUgdGV4dHVyZS5cbiAqIEByZXR1cm4ge1dlYkdMVGV4dHVyZX0gdGhlIGNyZWF0ZWQgdGV4dHVyZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShnbCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cy50ZXh0dXJlT3B0aW9ucztcbiAgdmFyIHRleCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgdmFyIHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IFRFWFRVUkVfMkQ7XG4gIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgMTtcbiAgdmFyIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IDE7XG4gIHZhciBpbnRlcm5hbEZvcm1hdCA9IG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgfHwgUkdCQTtcbiAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuXG4gIGlmICh0YXJnZXQgPT09IFRFWFRVUkVfQ1VCRV9NQVApIHtcbiAgICAvLyB0aGlzIHNob3VsZCBoYXZlIGJlZW4gdGhlIGRlZmF1bHQgZm9yIGN1YmVtYXBzIDooXG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIFRFWFRVUkVfV1JBUF9TLCBDTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgVEVYVFVSRV9XUkFQX1QsIENMQU1QX1RPX0VER0UpO1xuICB9XG5cbiAgdmFyIHNyYyA9IG9wdGlvbnMuc3JjO1xuXG4gIGlmIChzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBzcmMgPSBzcmMoZ2wsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3JjID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBsb2FkVGV4dHVyZUZyb21VcmwoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihzcmMpIHx8IEFycmF5LmlzQXJyYXkoc3JjKSAmJiAodHlwZW9mIHNyY1swXSA9PT0gJ251bWJlcicgfHwgQXJyYXkuaXNBcnJheShzcmNbMF0pIHx8IGlzQXJyYXlCdWZmZXIoc3JjWzBdKSkpIHtcbiAgICAgIHZhciBkaW1lbnNpb25zID0gc2V0VGV4dHVyZUZyb21BcnJheShnbCwgdGV4LCBzcmMsIG9wdGlvbnMpO1xuICAgICAgd2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNyYykgJiYgKHR5cGVvZiBzcmNbMF0gPT09ICdzdHJpbmcnIHx8IGlzVGV4SW1hZ2VTb3VyY2Uoc3JjWzBdKSkpIHtcbiAgICAgIGlmICh0YXJnZXQgPT09IFRFWFRVUkVfQ1VCRV9NQVApIHtcbiAgICAgICAgbG9hZEN1YmVtYXBGcm9tVXJscyhnbCwgdGV4LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkU2xpY2VzRnJvbVVybHMoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiAoaXNUZXhJbWFnZVNvdXJjZShzcmMpKVxuICAgICAgc2V0VGV4dHVyZUZyb21FbGVtZW50KGdsLCB0ZXgsIHNyYywgb3B0aW9ucyk7XG4gICAgICB3aWR0aCA9IHNyYy53aWR0aDtcbiAgICAgIGhlaWdodCA9IHNyYy5oZWlnaHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNldEVtcHR5VGV4dHVyZShnbCwgdGV4LCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChzaG91bGRBdXRvbWF0aWNhbGx5U2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUob3B0aW9ucykpIHtcbiAgICBzZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShnbCwgdGV4LCBvcHRpb25zLCB3aWR0aCwgaGVpZ2h0LCBpbnRlcm5hbEZvcm1hdCk7XG4gIH1cblxuICBzZXRUZXh0dXJlUGFyYW1ldGVycyhnbCwgdGV4LCBvcHRpb25zKTtcbiAgcmV0dXJuIHRleDtcbn1cbi8qKlxuICogUmVzaXplcyBhIHRleHR1cmUgYmFzZWQgb24gdGhlIG9wdGlvbnMgcGFzc2VkIGluLlxuICpcbiAqIE5vdGU6IFRoaXMgaXMgbm90IGEgZ2VuZXJpYyByZXNpemUgYW55dGhpbmcgZnVuY3Rpb24uXG4gKiBJdCdzIG1vc3RseSB1c2VkIGJ5IHtAbGluayBtb2R1bGU6dHdnbC5yZXNpemVGcmFtZWJ1ZmZlckluZm99XG4gKiBJdCB3aWxsIHVzZSBgb3B0aW9ucy5zcmNgIGlmIGl0IGV4aXN0cyB0byB0cnkgdG8gZGV0ZXJtaW5lIGEgYHR5cGVgXG4gKiBvdGhlcndpc2UgaXQgd2lsbCBhc3N1bWUgYGdsLlVOU0lHTkVEX0JZVEVgLiBObyBkYXRhIGlzIHByb3ZpZGVkXG4gKiBmb3IgdGhlIHRleHR1cmUuIFRleHR1cmUgcGFyYW1ldGVycyB3aWxsIGJlIHNldCBhY2NvcmRpbmdseVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSB0ZXh0dXJlIHRvIHJlc2l6ZVxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gdGhlIG5ldyB3aWR0aC4gSWYgbm90IHBhc3NlZCBpbiB3aWxsIHVzZSBgb3B0aW9ucy53aWR0aGBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSB0aGUgbmV3IGhlaWdodC4gSWYgbm90IHBhc3NlZCBpbiB3aWxsIHVzZSBgb3B0aW9ucy5oZWlnaHRgXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoXSB0aGUgbmV3IGRlcHRoLiBJZiBub3QgcGFzc2VkIGluIHdpbGwgdXNlIGBvcHRpb25zLmRlcHRoYFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiByZXNpemVUZXh0dXJlKGdsLCB0ZXgsIG9wdGlvbnMsIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSB7XG4gIHdpZHRoID0gd2lkdGggfHwgb3B0aW9ucy53aWR0aDtcbiAgaGVpZ2h0ID0gaGVpZ2h0IHx8IG9wdGlvbnMuaGVpZ2h0O1xuICBkZXB0aCA9IGRlcHRoIHx8IG9wdGlvbnMuZGVwdGg7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJEO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gIHZhciBsZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwgMDtcbiAgdmFyIGludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCB8fCBvcHRpb25zLmZvcm1hdCB8fCBSR0JBO1xuICB2YXIgZm9ybWF0VHlwZSA9IGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCk7XG4gIHZhciBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBmb3JtYXRUeXBlLmZvcm1hdDtcbiAgdmFyIHR5cGU7XG4gIHZhciBzcmMgPSBvcHRpb25zLnNyYztcblxuICBpZiAoIXNyYykge1xuICAgIHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgZm9ybWF0VHlwZS50eXBlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIoc3JjKSB8fCBBcnJheS5pc0FycmF5KHNyYykgJiYgdHlwZW9mIHNyY1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB0eXBlID0gb3B0aW9ucy50eXBlIHx8IGdldFRleHR1cmVUeXBlRm9yQXJyYXlUeXBlKGdsLCBzcmMsIGZvcm1hdFR5cGUudHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBmb3JtYXRUeXBlLnR5cGU7XG4gIH1cblxuICBpZiAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDY7ICsraWkpIHtcbiAgICAgIGdsLnRleEltYWdlMkQoVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaWksIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEIHx8IHRhcmdldCA9PT0gVEVYVFVSRV8yRF9BUlJBWSkge1xuICAgIGdsLnRleEltYWdlM0QodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBzcmMgaXMgYW4gYXN5bmMgcmVxdWVzdC5cbiAqIGlmIHNyYyBpcyBhIHN0cmluZyB3ZSdyZSBnb2luZyB0byBkb3dubG9hZCBhbiBpbWFnZVxuICogaWYgc3JjIGlzIGFuIGFycmF5IG9mIHN0cmluZ3Mgd2UncmUgZ29pbmcgdG8gZG93bmxvYWQgY3ViZW1hcCBpbWFnZXNcbiAqIEBwYXJhbSB7Kn0gc3JjIFRoZSBzcmMgZnJvbSBhIFRleHR1cmVPcHRpb25zXG4gKiBAcmV0dXJucyB7Ym9vbH0gdHJ1ZSBpZiBzcmMgaXMgYXN5bmMuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gaXNBc3luY1NyYyhzcmMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoc3JjKSAmJiB0eXBlb2Ygc3JjWzBdID09PSAnc3RyaW5nJztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGJ1bmNoIG9mIHRleHR1cmVzIGJhc2VkIG9uIHRoZSBwYXNzZWQgaW4gb3B0aW9ucy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB0ZXh0dXJlcyA9IHR3Z2wuY3JlYXRlVGV4dHVyZXMoZ2wsIHtcbiAqICAgICAgIC8vIGEgcG93ZXIgb2YgMiBpbWFnZVxuICogICAgICAgaGZ0SWNvbjogeyBzcmM6IFwiaW1hZ2VzL2hmdC1pY29uLTE2LnBuZ1wiLCBtYWc6IGdsLk5FQVJFU1QgfSxcbiAqICAgICAgIC8vIGEgbm9uLXBvd2VyIG9mIDIgaW1hZ2VcbiAqICAgICAgIGNsb3ZlcjogeyBzcmM6IFwiaW1hZ2VzL2Nsb3Zlci5qcGdcIiB9LFxuICogICAgICAgLy8gRnJvbSBhIGNhbnZhc1xuICogICAgICAgZnJvbUNhbnZhczogeyBzcmM6IGN0eC5jYW52YXMgfSxcbiAqICAgICAgIC8vIEEgY3ViZW1hcCBmcm9tIDYgaW1hZ2VzXG4gKiAgICAgICB5b2tvaGFtYToge1xuICogICAgICAgICB0YXJnZXQ6IGdsLlRFWFRVUkVfQ1VCRV9NQVAsXG4gKiAgICAgICAgIHNyYzogW1xuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvcG9zeC5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvbmVneC5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvcG9zeS5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvbmVneS5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvcG9zei5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvbmVnei5qcGcnLFxuICogICAgICAgICBdLFxuICogICAgICAgfSxcbiAqICAgICAgIC8vIEEgY3ViZW1hcCBmcm9tIDEgaW1hZ2UgKGNhbiBiZSAxeDYsIDJ4MywgM3gyLCA2eDEpXG4gKiAgICAgICBnb2xkZW5nYXRlOiB7XG4gKiAgICAgICAgIHRhcmdldDogZ2wuVEVYVFVSRV9DVUJFX01BUCxcbiAqICAgICAgICAgc3JjOiAnaW1hZ2VzL2dvbGRlbmdhdGUuanBnJyxcbiAqICAgICAgIH0sXG4gKiAgICAgICAvLyBBIDJ4MiBwaXhlbCB0ZXh0dXJlIGZyb20gYSBKYXZhU2NyaXB0IGFycmF5XG4gKiAgICAgICBjaGVja2VyOiB7XG4gKiAgICAgICAgIG1hZzogZ2wuTkVBUkVTVCxcbiAqICAgICAgICAgbWluOiBnbC5MSU5FQVIsXG4gKiAgICAgICAgIHNyYzogW1xuICogICAgICAgICAgIDI1NSwyNTUsMjU1LDI1NSxcbiAqICAgICAgICAgICAxOTIsMTkyLDE5MiwyNTUsXG4gKiAgICAgICAgICAgMTkyLDE5MiwxOTIsMjU1LFxuICogICAgICAgICAgIDI1NSwyNTUsMjU1LDI1NSxcbiAqICAgICAgICAgXSxcbiAqICAgICAgIH0sXG4gKiAgICAgICAvLyBhIDF4MiBwaXhlbCB0ZXh0dXJlIGZyb20gYSB0eXBlZCBhcnJheS5cbiAqICAgICAgIHN0cmlwZToge1xuICogICAgICAgICBtYWc6IGdsLk5FQVJFU1QsXG4gKiAgICAgICAgIG1pbjogZ2wuTElORUFSLFxuICogICAgICAgICBmb3JtYXQ6IGdsLkxVTUlOQU5DRSxcbiAqICAgICAgICAgc3JjOiBuZXcgVWludDhBcnJheShbXG4gKiAgICAgICAgICAgMjU1LFxuICogICAgICAgICAgIDEyOCxcbiAqICAgICAgICAgICAyNTUsXG4gKiAgICAgICAgICAgMTI4LFxuICogICAgICAgICAgIDI1NSxcbiAqICAgICAgICAgICAxMjgsXG4gKiAgICAgICAgICAgMjU1LFxuICogICAgICAgICAgIDEyOCxcbiAqICAgICAgICAgXSksXG4gKiAgICAgICAgIHdpZHRoOiAxLFxuICogICAgICAgfSxcbiAqICAgICB9KTtcbiAqXG4gKiBOb3dcbiAqXG4gKiAqICAgYHRleHR1cmVzLmhmdEljb25gIHdpbGwgYmUgYSAyZCB0ZXh0dXJlXG4gKiAqICAgYHRleHR1cmVzLmNsb3ZlcmAgd2lsbCBiZSBhIDJkIHRleHR1cmVcbiAqICogICBgdGV4dHVyZXMuZnJvbUNhbnZhc2Agd2lsbCBiZSBhIDJkIHRleHR1cmVcbiAqICogICBgdGV4dHVyZXMueW9ob2hhbWFgIHdpbGwgYmUgYSBjdWJlbWFwIHRleHR1cmVcbiAqICogICBgdGV4dHVyZXMuZ29sZGVuZ2F0ZWAgd2lsbCBiZSBhIGN1YmVtYXAgdGV4dHVyZVxuICogKiAgIGB0ZXh0dXJlcy5jaGVja2VyYCB3aWxsIGJlIGEgMmQgdGV4dHVyZVxuICogKiAgIGB0ZXh0dXJlcy5zdHJpcGVgIHdpbGwgYmUgYSAyZCB0ZXh0dXJlXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsbW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnM+fSBvcHRpb25zIEEgb2JqZWN0IG9mIFRleHR1cmVPcHRpb25zIG9uZSBwZXIgdGV4dHVyZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZXNSZWFkeUNhbGxiYWNrfSBbY2FsbGJhY2tdIEEgY2FsbGJhY2sgY2FsbGVkIHdoZW4gYWxsIHRleHR1cmVzIGhhdmUgYmVlbiBkb3dubG9hZGVkLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsV2ViR0xUZXh0dXJlPn0gdGhlIGNyZWF0ZWQgdGV4dHVyZXMgYnkgbmFtZVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlcyhnbCwgdGV4dHVyZU9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgdmFyIG51bURvd25sb2FkaW5nID0gMDtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdGV4dHVyZXMgPSB7fTtcbiAgdmFyIGltYWdlcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGNhbGxDYWxsYmFja0lmUmVhZHkoKSB7XG4gICAgaWYgKG51bURvd25sb2FkaW5nID09PSAwKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IHVuZGVmaW5lZCwgdGV4dHVyZXMsIGltYWdlcyk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyh0ZXh0dXJlT3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBvcHRpb25zID0gdGV4dHVyZU9wdGlvbnNbbmFtZV07XG4gICAgdmFyIG9uTG9hZEZuO1xuXG4gICAgaWYgKGlzQXN5bmNTcmMob3B0aW9ucy5zcmMpKSB7XG4gICAgICBvbkxvYWRGbiA9IGZ1bmN0aW9uIG9uTG9hZEZuKGVyciwgdGV4LCBpbWcpIHtcbiAgICAgICAgaW1hZ2VzW25hbWVdID0gaW1nO1xuICAgICAgICAtLW51bURvd25sb2FkaW5nO1xuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbENhbGxiYWNrSWZSZWFkeSgpO1xuICAgICAgfTtcblxuICAgICAgKytudW1Eb3dubG9hZGluZztcbiAgICB9XG5cbiAgICB0ZXh0dXJlc1tuYW1lXSA9IGNyZWF0ZVRleHR1cmUoZ2wsIG9wdGlvbnMsIG9uTG9hZEZuKTtcbiAgfSk7IC8vIHF1ZXVlIHRoZSBjYWxsYmFjayBpZiB0aGVyZSBhcmUgbm8gaW1hZ2VzIHRvIGRvd25sb2FkLlxuICAvLyBXZSBkbyB0aGlzIGJlY2F1c2UgaWYgeW91ciBjb2RlIGlzIHN0cnVjdHVyZWQgdG8gd2FpdCBmb3JcbiAgLy8gaW1hZ2VzIHRvIGRvd25sb2FkIGJ1dCB0aGVuIHlvdSBjb21tZW50IG91dCBhbGwgdGhlIGFzeW5jXG4gIC8vIGltYWdlcyB5b3VyIGNvZGUgd291bGQgYnJlYWsuXG5cbiAgY2FsbENhbGxiYWNrSWZSZWFkeSgpO1xuICByZXR1cm4gdGV4dHVyZXM7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3R3Z2wtZnVsbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHdnbC1mdWxsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgX2V4cG9ydE5hbWVzID0ge1xuICBtNDogdHJ1ZSxcbiAgdjM6IHRydWUsXG4gIHByaW1pdGl2ZXM6IHRydWVcbn07XG5leHBvcnRzLnByaW1pdGl2ZXMgPSBleHBvcnRzLnYzID0gZXhwb3J0cy5tNCA9IHZvaWQgMDtcblxudmFyIG00ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tNC5qcyAqLyBcIi4vc3JjL200LmpzXCIpKTtcblxuZXhwb3J0cy5tNCA9IG00O1xuXG52YXIgdjMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3YzLmpzICovIFwiLi9zcmMvdjMuanNcIikpO1xuXG5leHBvcnRzLnYzID0gdjM7XG5cbnZhciBwcmltaXRpdmVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wcmltaXRpdmVzLmpzICovIFwiLi9zcmMvcHJpbWl0aXZlcy5qc1wiKSk7XG5cbmV4cG9ydHMucHJpbWl0aXZlcyA9IHByaW1pdGl2ZXM7XG5cbnZhciBfdHdnbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHdnbC5qcyAqLyBcIi4vc3JjL3R3Z2wuanNcIik7XG5cbk9iamVjdC5rZXlzKF90d2dsKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfdHdnbFtrZXldO1xufSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3R3Z2wuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90d2dsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIF9leHBvcnROYW1lcyA9IHtcbiAgYWRkRXh0ZW5zaW9uc1RvQ29udGV4dDogdHJ1ZSxcbiAgZ2V0Q29udGV4dDogdHJ1ZSxcbiAgZ2V0V2ViR0xDb250ZXh0OiB0cnVlLFxuICByZXNpemVDYW52YXNUb0Rpc3BsYXlTaXplOiB0cnVlLFxuICBzZXREZWZhdWx0czogdHJ1ZSxcbiAgYXR0cmlidXRlczogdHJ1ZSxcbiAgdGV4dHVyZXM6IHRydWUsXG4gIHV0aWxzOiB0cnVlLFxuICBkcmF3OiB0cnVlLFxuICBmcmFtZWJ1ZmZlcnM6IHRydWUsXG4gIHByb2dyYW1zOiB0cnVlLFxuICB0eXBlZGFycmF5czogdHJ1ZSxcbiAgdmVydGV4QXJyYXlzOiB0cnVlXG59O1xuZXhwb3J0cy5hZGRFeHRlbnNpb25zVG9Db250ZXh0ID0gYWRkRXh0ZW5zaW9uc1RvQ29udGV4dDtcbmV4cG9ydHMuZ2V0Q29udGV4dCA9IGdldENvbnRleHQ7XG5leHBvcnRzLmdldFdlYkdMQ29udGV4dCA9IGdldFdlYkdMQ29udGV4dDtcbmV4cG9ydHMucmVzaXplQ2FudmFzVG9EaXNwbGF5U2l6ZSA9IHJlc2l6ZUNhbnZhc1RvRGlzcGxheVNpemU7XG5leHBvcnRzLnNldERlZmF1bHRzID0gc2V0RGVmYXVsdHM7XG5leHBvcnRzLnZlcnRleEFycmF5cyA9IGV4cG9ydHMudHlwZWRhcnJheXMgPSBleHBvcnRzLnByb2dyYW1zID0gZXhwb3J0cy5mcmFtZWJ1ZmZlcnMgPSBleHBvcnRzLmRyYXcgPSBleHBvcnRzLnV0aWxzID0gZXhwb3J0cy50ZXh0dXJlcyA9IGV4cG9ydHMuYXR0cmlidXRlcyA9IHZvaWQgMDtcblxudmFyIGF0dHJpYnV0ZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2F0dHJpYnV0ZXMuanMgKi8gXCIuL3NyYy9hdHRyaWJ1dGVzLmpzXCIpKTtcblxuZXhwb3J0cy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbk9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbn0pO1xuXG52YXIgdGV4dHVyZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RleHR1cmVzLmpzICovIFwiLi9zcmMvdGV4dHVyZXMuanNcIikpO1xuXG5leHBvcnRzLnRleHR1cmVzID0gdGV4dHVyZXM7XG5PYmplY3Qua2V5cyh0ZXh0dXJlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gdGV4dHVyZXNba2V5XTtcbn0pO1xuXG52YXIgaGVscGVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9oZWxwZXIuanMgKi8gXCIuL3NyYy9oZWxwZXIuanNcIikpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIikpO1xuXG5leHBvcnRzLnV0aWxzID0gdXRpbHM7XG5PYmplY3Qua2V5cyh1dGlscykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gdXRpbHNba2V5XTtcbn0pO1xuXG52YXIgZHJhdyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZHJhdy5qcyAqLyBcIi4vc3JjL2RyYXcuanNcIikpO1xuXG5leHBvcnRzLmRyYXcgPSBkcmF3O1xuT2JqZWN0LmtleXMoZHJhdykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gZHJhd1trZXldO1xufSk7XG5cbnZhciBmcmFtZWJ1ZmZlcnMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYW1lYnVmZmVycy5qcyAqLyBcIi4vc3JjL2ZyYW1lYnVmZmVycy5qc1wiKSk7XG5cbmV4cG9ydHMuZnJhbWVidWZmZXJzID0gZnJhbWVidWZmZXJzO1xuT2JqZWN0LmtleXMoZnJhbWVidWZmZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBmcmFtZWJ1ZmZlcnNba2V5XTtcbn0pO1xuXG52YXIgcHJvZ3JhbXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Byb2dyYW1zLmpzICovIFwiLi9zcmMvcHJvZ3JhbXMuanNcIikpO1xuXG5leHBvcnRzLnByb2dyYW1zID0gcHJvZ3JhbXM7XG5PYmplY3Qua2V5cyhwcm9ncmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gcHJvZ3JhbXNba2V5XTtcbn0pO1xuXG52YXIgdHlwZWRhcnJheXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3R5cGVkYXJyYXlzLmpzICovIFwiLi9zcmMvdHlwZWRhcnJheXMuanNcIikpO1xuXG5leHBvcnRzLnR5cGVkYXJyYXlzID0gdHlwZWRhcnJheXM7XG5PYmplY3Qua2V5cyh0eXBlZGFycmF5cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gdHlwZWRhcnJheXNba2V5XTtcbn0pO1xuXG52YXIgdmVydGV4QXJyYXlzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92ZXJ0ZXgtYXJyYXlzLmpzICovIFwiLi9zcmMvdmVydGV4LWFycmF5cy5qc1wiKSk7XG5cbmV4cG9ydHMudmVydGV4QXJyYXlzID0gdmVydGV4QXJyYXlzO1xuT2JqZWN0LmtleXModmVydGV4QXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSB2ZXJ0ZXhBcnJheXNba2V5XTtcbn0pO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogVGhlIG1haW4gVFdHTCBtb2R1bGUuXG4gKlxuICogRm9yIG1vc3QgdXNlIGNhc2VzIHlvdSBzaG91bGRuJ3QgbmVlZCBhbnl0aGluZyBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuICogRXhjZXB0aW9ucyBiZXR3ZWVuIHRoZSBzdHVmZiBhZGRlZCB0byB0d2dsLWZ1bGwgKHYzLCBtNCwgcHJpbWl0aXZlcylcbiAqXG4gKiBAbW9kdWxlIHR3Z2xcbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXMuc2V0QXR0cmliSW5mb0J1ZmZlckZyb21BcnJheSBhcyBzZXRBdHRyaWJJbmZvQnVmZmVyRnJvbUFycmF5XG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9hdHRyaWJ1dGVzLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzIGFzIGNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9hdHRyaWJ1dGVzLmNyZWF0ZVZlcnRleEFycmF5SW5mbyBhcyBjcmVhdGVWZXJ0ZXhBcnJheUluZm9cbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL2RyYXcuZHJhd0J1ZmZlckluZm8gYXMgZHJhd0J1ZmZlckluZm9cbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL2RyYXcuZHJhd09iamVjdExpc3QgYXMgZHJhd09iamVjdExpc3RcbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL2ZyYW1lYnVmZmVycy5jcmVhdGVGcmFtZWJ1ZmZlckluZm8gYXMgY3JlYXRlRnJhbWVidWZmZXJJbmZvXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9mcmFtZWJ1ZmZlcnMucmVzaXplRnJhbWVidWZmZXJJbmZvIGFzIHJlc2l6ZUZyYW1lYnVmZmVySW5mb1xuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvZnJhbWVidWZmZXJzLmJpbmRGcmFtZWJ1ZmZlckluZm8gYXMgYmluZEZyYW1lYnVmZmVySW5mb1xuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvcHJvZ3JhbXMuY3JlYXRlUHJvZ3JhbUluZm8gYXMgY3JlYXRlUHJvZ3JhbUluZm9cbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL3Byb2dyYW1zLmNyZWF0ZVVuaWZvcm1CbG9ja0luZm8gYXMgY3JlYXRlVW5pZm9ybUJsb2NrSW5mb1xuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvcHJvZ3JhbXMuYmluZFVuaWZvcm1CbG9jayBhcyBiaW5kVW5pZm9ybUJsb2NrXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9wcm9ncmFtcy5zZXRVbmlmb3JtQmxvY2sgYXMgc2V0VW5pZm9ybUJsb2NrXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9wcm9ncmFtcy5zZXRCbG9ja1VuaWZvcm1zIGFzIHNldEJsb2NrVW5pZm9ybXNcbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL3Byb2dyYW1zLnNldFVuaWZvcm1zIGFzIHNldFVuaWZvcm1zXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9wcm9ncmFtcy5zZXRCdWZmZXJzQW5kQXR0cmlidXRlcyBhcyBzZXRCdWZmZXJzQW5kQXR0cmlidXRlc1xuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvdGV4dHVyZXMuc2V0VGV4dHVyZUZyb21BcnJheSBhcyBzZXRUZXh0dXJlRnJvbUFycmF5XG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC90ZXh0dXJlcy5jcmVhdGVUZXh0dXJlIGFzIGNyZWF0ZVRleHR1cmVcbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL3RleHR1cmVzLnJlc2l6ZVRleHR1cmUgYXMgcmVzaXplVGV4dHVyZVxuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvdGV4dHVyZXMuY3JlYXRlVGV4dHVyZXMgYXMgY3JlYXRlVGV4dHVyZXNcbiAqL1xuLy8gbWFrZSBzdXJlIHdlIGRvbid0IHNlZSBhIGdsb2JhbCBnbFxudmFyIGdsID0gdW5kZWZpbmVkO1xuLyogZXNsaW50LWRpc2FibGUtbGluZSAqL1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkZEV4dGVuc2lvbnNUb0NvbnRleHQ6IHRydWVcbn07XG4vKipcbiAqIFZhcmlvdXMgZGVmYXVsdCBzZXR0aW5ncyBmb3IgdHdnbC5cbiAqXG4gKiBOb3RlOiBZb3UgY2FuIGNhbGwgdGhpcyBhbnkgbnVtYmVyIG9mIHRpbWVzLiBFeGFtcGxlOlxuICpcbiAqICAgICB0d2dsLnNldERlZmF1bHRzKHsgdGV4dHVyZUNvbG9yOiBbMSwgMCwgMCwgMV0gfSk7XG4gKiAgICAgdHdnbC5zZXREZWZhdWx0cyh7IGF0dHJpYlByZWZpeDogJ2FfJyB9KTtcbiAqXG4gKiBpcyBlcXVpdmFsZW50IHRvXG4gKlxuICogICAgIHR3Z2wuc2V0RGVmYXVsdHMoe1xuICogICAgICAgdGV4dHVyZUNvbG9yOiBbMSwgMCwgMCwgMV0sXG4gKiAgICAgICBhdHRyaWJQcmVmaXg6ICdhXycsXG4gKiAgICAgfSk7XG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRGVmYXVsdHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXR0cmliUHJlZml4XSBUaGUgcHJlZml4IHRvIHN0aWNrIG9uIGF0dHJpYnV0ZXNcbiAqXG4gKiAgIFdoZW4gd3JpdGluZyBzaGFkZXJzIEkgcHJlZmVyIHRvIG5hbWUgYXR0cmlidXRlcyB3aXRoIGBhX2AsIHVuaWZvcm1zIHdpdGggYHVfYCBhbmQgdmFyeWluZ3Mgd2l0aCBgdl9gXG4gKiAgIGFzIGl0IG1ha2VzIGl0IGNsZWFyIHdoZXJlIHRoZXkgY2FtZSBmcm9tLiBCdXQsIHdoZW4gYnVpbGRpbmcgZ2VvbWV0cnkgSSBwcmVmZXIgdXNpbmcgdW4tcHJlZml4ZWQgbmFtZXMuXG4gKlxuICogICBJbiBvdGhlciB3b3JkcyBJJ2xsIGNyZWF0ZSBhcnJheXMgb2YgZ2VvbWV0cnkgbGlrZSB0aGlzXG4gKlxuICogICAgICAgY29uc3QgYXJyYXlzID0ge1xuICogICAgICAgICBwb3NpdGlvbjogLi4uXG4gKiAgICAgICAgIG5vcm1hbDogLi4uXG4gKiAgICAgICAgIHRleGNvb3JkOiAuLi5cbiAqICAgICAgIH07XG4gKlxuICogICBCdXQgbmVlZCB0aG9zZSBtYXBwZWQgdG8gYXR0cmlidXRlcyBhbmQgbXkgYXR0cmlidXRlcyBzdGFydCB3aXRoIGBhX2AuXG4gKlxuICogICBEZWZhdWx0OiBgXCJcImBcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcltdfSBbdGV4dHVyZUNvbG9yXSBBcnJheSBvZiA0IHZhbHVlcyBpbiB0aGUgcmFuZ2UgMCB0byAxXG4gKlxuICogICBUaGUgZGVmYXVsdCB0ZXh0dXJlIGNvbG9yIGlzIHVzZWQgd2hlbiBsb2FkaW5nIHRleHR1cmVzIGZyb21cbiAqICAgdXJscy4gQmVjYXVzZSB0aGUgVVJMIHdpbGwgYmUgbG9hZGVkIGFzeW5jIHdlJ2QgbGlrZSB0byBiZVxuICogICBhYmxlIHRvIHVzZSB0aGUgdGV4dHVyZSBpbW1lZGlhdGVseS4gQnkgcHV0dGluZyBhIDF4MSBwaXhlbFxuICogICBjb2xvciBpbiB0aGUgdGV4dHVyZSB3ZSBjYW4gc3RhcnQgdXNpbmcgdGhlIHRleHR1cmUgYmVmb3JlXG4gKiAgIHRoZSBVUkwgaGFzIGxvYWRlZC5cbiAqXG4gKiAgIERlZmF1bHQ6IGBbMC41LCAwLjc1LCAxLCAxXWBcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2Nyb3NzT3JpZ2luXVxuICpcbiAqICAgSWYgbm90IHVuZGVmaW5lZCBzZXRzIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgb24gaW1hZ2VzXG4gKiAgIHRoYXQgdHdnbCBjcmVhdGVzIHdoZW4gZG93bmxvYWRpbmcgaW1hZ2VzIGZvciB0ZXh0dXJlcy5cbiAqXG4gKiAgIEFsc28gc2VlIHtAbGluayBtb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30uXG4gKlxuICogQHByb3BlcnR5IHtib29sfSBbYWRkRXh0ZW5zaW9uc1RvQ29udGV4dF1cbiAqXG4gKiAgIElmIHRydWUsIHRoZW4sIHdoZW4gdHdnbCB3aWxsIHRyeSB0byBhZGQgYW55IHN1cHBvcnRlZCBXZWJHTCBleHRlbnNpb25zXG4gKiAgIGRpcmVjdGx5IHRvIHRoZSBjb250ZXh0IHVuZGVyIHRoZWlyIG5vcm1hbCBHTCBuYW1lcy4gRm9yIGV4YW1wbGVcbiAqICAgaWYgQU5HTEVfaW5zdGFuY2VzX2FycmF5cyBleGlzdHMgdGhlbiB0d2dsIHdvdWxkIGVuYWJsZSBpdCxcbiAqICAgYWRkIHRoZSBmdW5jdGlvbnMgYHZlcnRleEF0dHJpYkRpdmlzb3JgLCBgZHJhd0FycmF5c0luc3RhbmNlZGAsXG4gKiAgIGBkcmF3RWxlbWVudHNJbnN0YW5jZWRgLCBhbmQgdGhlIGNvbnN0YW50IGBWRVJURVhfQVRUUklCX0FSUkFZX0RJVklTT1JgXG4gKiAgIHRvIHRoZSBgV2ViR0xSZW5kZXJpbmdDb250ZXh0YC5cbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIFNldHMgdmFyaW91cyBkZWZhdWx0cyBmb3IgdHdnbC5cbiAqXG4gKiBJbiB0aGUgaW50ZXJlc3Qgb2YgdGVyc2VuZXNzIHdoaWNoIGlzIGtpbmQgb2YgdGhlIHBvaW50XG4gKiBvZiB0d2dsIEkndmUgaW50ZWdyYXRlZCBhIGZldyBvZiB0aGUgb2xkZXIgZnVuY3Rpb25zIGhlcmVcbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkRlZmF1bHRzfSBuZXdEZWZhdWx0cyBUaGUgZGVmYXVsdCBzZXR0aW5ncy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbmZ1bmN0aW9uIHNldERlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gIGhlbHBlci5jb3B5RXhpc3RpbmdQcm9wZXJ0aWVzKG5ld0RlZmF1bHRzLCBkZWZhdWx0cyk7XG4gIGF0dHJpYnV0ZXMuc2V0QXR0cmlidXRlRGVmYXVsdHNfKG5ld0RlZmF1bHRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIHRleHR1cmVzLnNldFRleHR1cmVEZWZhdWx0c18obmV3RGVmYXVsdHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59XG5cbnZhciBwcmVmaXhSRSA9IC9eKC4qPylfLztcblxuZnVuY3Rpb24gYWRkRXh0ZW5zaW9uVG9Db250ZXh0KGdsLCBleHRlbnNpb25OYW1lKSB7XG4gIHV0aWxzLmdsRW51bVRvU3RyaW5nKGdsLCAwKTtcbiAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbihleHRlbnNpb25OYW1lKTtcblxuICBpZiAoZXh0KSB7XG4gICAgdmFyIGVudW1zID0ge307XG4gICAgdmFyIGZuU3VmZml4ID0gcHJlZml4UkUuZXhlYyhleHRlbnNpb25OYW1lKVsxXTtcbiAgICB2YXIgZW51bVN1ZmZpeCA9ICdfJyArIGZuU3VmZml4O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGV4dCkge1xuICAgICAgdmFyIHZhbHVlID0gZXh0W2tleV07XG4gICAgICB2YXIgaXNGdW5jID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgICAgdmFyIHN1ZmZpeCA9IGlzRnVuYyA/IGZuU3VmZml4IDogZW51bVN1ZmZpeDtcbiAgICAgIHZhciBuYW1lID0ga2V5OyAvLyBleGFtcGxlcyBvZiB3aGVyZSB0aGlzIGlzIG5vdCB0cnVlIGFyZSBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xuICAgICAgLy8gYW5kIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xuXG4gICAgICBpZiAoa2V5LmVuZHNXaXRoKHN1ZmZpeCkpIHtcbiAgICAgICAgbmFtZSA9IGtleS5zdWJzdHJpbmcoMCwga2V5Lmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2xbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWlzRnVuYyAmJiBnbFtuYW1lXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBoZWxwZXIud2FybihuYW1lLCBnbFtuYW1lXSwgdmFsdWUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBnbFtuYW1lXSA9IGZ1bmN0aW9uIChvcmlnRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvcmlnRm4uYXBwbHkoZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIGVudW1zW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHBhc3MgdGhlIG1vZGlmaWVkIGVudW1zIHRvIGdsRW51bVRvU3RyaW5nXG5cblxuICAgIGVudW1zLmNvbnN0cnVjdG9yID0ge1xuICAgICAgbmFtZTogZXh0LmNvbnN0cnVjdG9yLm5hbWVcbiAgICB9O1xuICAgIHV0aWxzLmdsRW51bVRvU3RyaW5nKGVudW1zLCAwKTtcbiAgfVxuXG4gIHJldHVybiBleHQ7XG59XG4vKlxuICogSWYgeW91J3JlIHdvbmRlcmluZyB3aHkgdGhlIGNvZGUgZG9lc24ndCBqdXN0IGl0ZXJhdGVcbiAqIG92ZXIgYWxsIGV4dGVuc2lvbnMgdXNpbmcgYGdsLmdldEV4dGVuc2lvbnNgIGlzIHRoYXQgaXQncyBwb3NzaWJsZVxuICogc29tZSBmdXR1cmUgZXh0ZW5zaW9uIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoaXMgY29kZS4gUmF0aGVyIHRoYW5cbiAqIGhhdmUgdGhpbmcgc3VkZGVubHkgYnJlYWsgaXQgc2VlbXMgYmV0dGVyIHRvIG1hbnVhbGx5IGFkZCB0byB0aGlzXG4gKiBsaXN0LlxuICpcbiAqL1xuXG5cbnZhciBzdXBwb3J0ZWRFeHRlbnNpb25zID0gWydBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJywgJ0VYVF9ibGVuZF9taW5tYXgnLCAnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcsICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnLCAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5JywgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInLCAnRVhUX2ZyYWdfZGVwdGgnLCAnRVhUX3NSR0InLCAnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcsICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnLCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcsICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnLCAnT0VTX3RleHR1cmVfZmxvYXQnLCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJywgJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnLCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInLCAnT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnLCAnV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JywgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hdGMnLCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnLCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJywgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJywgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2InLCAnV0VCR0xfZGVwdGhfdGV4dHVyZScsICdXRUJHTF9kcmF3X2J1ZmZlcnMnXTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gZW5hYmxlIGFsbCBvZiB0aGUgZm9sbG93aW5nIGV4dGVuc2lvbnNcbiAqIGFuZCBhZGQgdGhlaXIgZnVuY3Rpb25zIGFuZCBjb25zdGFudHMgdG8gdGhlXG4gKiBgV2ViR0xSZW5kZXJpbmdDb250ZXh0YCB1c2luZyB0aGVpciBub3JtYWwgbm9uLWV4dGVuc2lvbiBsaWtlIG5hbWVzLlxuICpcbiAqICAgICAgQU5HTEVfaW5zdGFuY2VkX2FycmF5c1xuICogICAgICBFWFRfYmxlbmRfbWlubWF4XG4gKiAgICAgIEVYVF9jb2xvcl9idWZmZXJfZmxvYXRcbiAqICAgICAgRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XG4gKiAgICAgIEVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVxuICogICAgICBFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyXG4gKiAgICAgIEVYVF9mcmFnX2RlcHRoXG4gKiAgICAgIEVYVF9zUkdCXG4gKiAgICAgIEVYVF9zaGFkZXJfdGV4dHVyZV9sb2RcbiAqICAgICAgRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXG4gKiAgICAgIE9FU19lbGVtZW50X2luZGV4X3VpbnRcbiAqICAgICAgT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXG4gKiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0XG4gKiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclxuICogICAgICBPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XG4gKiAgICAgIE9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXG4gKiAgICAgIE9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XG4gKiAgICAgIFdFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdFxuICogICAgICBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXRjXG4gKiAgICAgIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxXG4gKiAgICAgIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xuICogICAgICBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xuICogICAgICBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiXG4gKiAgICAgIFdFQkdMX2RlcHRoX3RleHR1cmVcbiAqICAgICAgV0VCR0xfZHJhd19idWZmZXJzXG4gKlxuICogRm9yIGV4YW1wbGUgaWYgYEFOR0xFX2luc3RhbmNlZF9hcnJheXNgIGV4aXN0cyB0aGVuIHRoZSBmdW5jdGlvbnNcbiAqIGBkcmF3QXJyYXlzSW5zdGFuY2VkYCwgYGRyYXdFbGVtZW50c0luc3RhbmNlZGAsIGB2ZXJ0ZXhBdHRyaWJEaXZpc29yYFxuICogYW5kIHRoZSBjb25zdGFudCBgVkVSVEVYX0FUVFJJQl9BUlJBWV9ESVZJU09SYCBhcmUgYWRkZWQgdG8gdGhlXG4gKiBgV2ViR0xSZW5kZXJpbmdDb250ZXh0YC5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgeW91IHdhbnQgdG8ga25vdyBpZiB0aGUgZXh0ZW5zaW9uIGV4aXN0cyB5b3Ugc2hvdWxkXG4gKiBwcm9iYWJseSBjYWxsIGBnbC5nZXRFeHRlbnNpb25gIGZvciBlYWNoIGV4dGVuc2lvbi4gQWx0ZXJuYXRpdmVseVxuICogeW91IGNhbiBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgZnVuY3Rpb25zIG9yIGNvbnN0YW50cyB0aGF0XG4gKiBhcmUgZXhwZWN0ZWQgdG8gYmUgYWRkZWQuIEZvciBleGFtcGxlXG4gKlxuICogICAgaWYgKGdsLmRyYXdCdWZmZXJzKSB7XG4gKiAgICAgIC8vIEVpdGhlciBXRUJHTF9kcmF3X2J1ZmZlcnMgd2FzIGVuYWJsZWQgT1IgeW91J3JlIHJ1bm5pbmcgaW4gV2ViR0wyXG4gKiAgICAgIC4uLi5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbmZ1bmN0aW9uIGFkZEV4dGVuc2lvbnNUb0NvbnRleHQoZ2wpIHtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHN1cHBvcnRlZEV4dGVuc2lvbnMubGVuZ3RoOyArK2lpKSB7XG4gICAgYWRkRXh0ZW5zaW9uVG9Db250ZXh0KGdsLCBzdXBwb3J0ZWRFeHRlbnNpb25zW2lpXSk7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIHdlYmdsIGNvbnRleHQuXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgVGhlIGNhbnZhcyB0YWcgdG8gZ2V0XG4gKiAgICAgY29udGV4dCBmcm9tLiBJZiBvbmUgaXMgbm90IHBhc3NlZCBpbiBvbmUgd2lsbCBiZVxuICogICAgIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjcmVhdGVkIGNvbnRleHQuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlM0RDb250ZXh0KGNhbnZhcywgb3B0X2F0dHJpYnMpIHtcbiAgdmFyIG5hbWVzID0gW1wid2ViZ2xcIiwgXCJleHBlcmltZW50YWwtd2ViZ2xcIl07XG4gIHZhciBjb250ZXh0ID0gbnVsbDtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmFtZXMubGVuZ3RoOyArK2lpKSB7XG4gICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KG5hbWVzW2lpXSwgb3B0X2F0dHJpYnMpO1xuXG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIGlmIChkZWZhdWx0cy5hZGRFeHRlbnNpb25zVG9Db250ZXh0KSB7XG4gICAgICAgIGFkZEV4dGVuc2lvbnNUb0NvbnRleHQoY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuLyoqXG4gKiBHZXRzIGEgV2ViR0wxIGNvbnRleHQuXG4gKlxuICogTm90ZTogV2lsbCBhdHRlbXB0IHRvIGVuYWJsZSBWZXJ0ZXggQXJyYXkgT2JqZWN0c1xuICogYW5kIGFkZCBXZWJHTDIgZW50cnkgcG9pbnRzLiAodW5sZXNzIHlvdSBmaXJzdCBzZXQgZGVmYXVsdHMgd2l0aFxuICogYHR3Z2wuc2V0RGVmYXVsdHMoe2VuYWJsZVZlcnRleEFycmF5T2JqZWN0czogZmFsc2V9KWA7XG4gKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIGEgY2FudmFzIGVsZW1lbnQuXG4gKiBAcGFyYW0ge1dlYkdMQ29udGV4dEF0dHJpYnV0ZXN9IFtvcHRfYXR0cmlic10gb3B0aW9uYWwgd2ViZ2wgY29udGV4dCBjcmVhdGlvbiBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjcmVhdGVkIGNvbnRleHQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFdlYkdMQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKSB7XG4gIHZhciBnbCA9IGNyZWF0ZTNEQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKTtcbiAgcmV0dXJuIGdsO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgd2ViZ2wgY29udGV4dC5cbiAqXG4gKiBXaWxsIHJldHVybiBhIFdlYkdMMiBjb250ZXh0IGlmIHBvc3NpYmxlLlxuICpcbiAqIFlvdSBjYW4gY2hlY2sgaWYgaXQncyBXZWJHTDIgd2l0aFxuICpcbiAqICAgICB0d2dsLmlzV2ViR0wyKGdsKTtcbiAqXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgVGhlIGNhbnZhcyB0YWcgdG8gZ2V0XG4gKiAgICAgY29udGV4dCBmcm9tLiBJZiBvbmUgaXMgbm90IHBhc3NlZCBpbiBvbmUgd2lsbCBiZVxuICogICAgIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjcmVhdGVkIGNvbnRleHQuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGNhbnZhcywgb3B0X2F0dHJpYnMpIHtcbiAgdmFyIG5hbWVzID0gW1wid2ViZ2wyXCIsIFwid2ViZ2xcIiwgXCJleHBlcmltZW50YWwtd2ViZ2xcIl07XG4gIHZhciBjb250ZXh0ID0gbnVsbDtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmFtZXMubGVuZ3RoOyArK2lpKSB7XG4gICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KG5hbWVzW2lpXSwgb3B0X2F0dHJpYnMpO1xuXG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIGlmIChkZWZhdWx0cy5hZGRFeHRlbnNpb25zVG9Db250ZXh0KSB7XG4gICAgICAgIGFkZEV4dGVuc2lvbnNUb0NvbnRleHQoY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuLyoqXG4gKiBHZXRzIGEgV2ViR0wgY29udGV4dC4gIFdpbGwgY3JlYXRlIGEgV2ViR0wyIGNvbnRleHQgaWYgcG9zc2libGUuXG4gKlxuICogWW91IGNhbiBjaGVjayBpZiBpdCdzIFdlYkdMMiB3aXRoXG4gKlxuICogICAgZnVuY3Rpb24gaXNXZWJHTDIoZ2wpIHtcbiAqICAgICAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5WRVJTSU9OKS5pbmRleE9mKFwiV2ViR0wgMi4wIFwiKSA9PSAwO1xuICogICAgfVxuICpcbiAqIE5vdGU6IEZvciBhIFdlYkdMMSBjb250ZXh0IHdpbGwgYXR0ZW1wdCB0byBlbmFibGUgVmVydGV4IEFycmF5IE9iamVjdHNcbiAqIGFuZCBhZGQgV2ViR0wyIGVudHJ5IHBvaW50cy4gKHVubGVzcyB5b3UgZmlyc3Qgc2V0IGRlZmF1bHRzIHdpdGhcbiAqIGB0d2dsLnNldERlZmF1bHRzKHtlbmFibGVWZXJ0ZXhBcnJheU9iamVjdHM6IGZhbHNlfSlgO1xuICpcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBhIGNhbnZhcyBlbGVtZW50LlxuICogQHBhcmFtIHtXZWJHTENvbnRleHRBdHRyaWJ1dGVzfSBbb3B0X2F0dHJpYnNdIG9wdGlvbmFsIHdlYmdsIGNvbnRleHQgY3JlYXRpb24gYXR0cmlidXRlc1xuICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3JlYXRlZCBjb250ZXh0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0KGNhbnZhcywgb3B0X2F0dHJpYnMpIHtcbiAgdmFyIGdsID0gY3JlYXRlQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKTtcbiAgcmV0dXJuIGdsO1xufVxuLyoqXG4gKiBSZXNpemUgYSBjYW52YXMgdG8gbWF0Y2ggdGhlIHNpemUgaXQncyBkaXNwbGF5ZWQuXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgVGhlIGNhbnZhcyB0byByZXNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gW211bHRpcGxpZXJdIFNvIHlvdSBjYW4gcGFzcyBpbiBgd2luZG93LmRldmljZVBpeGVsUmF0aW9gIG9yIG90aGVyIHNjYWxlIHZhbHVlIGlmIHlvdSB3YW50IHRvLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2FudmFzIHdhcyByZXNpemVkLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG5mdW5jdGlvbiByZXNpemVDYW52YXNUb0Rpc3BsYXlTaXplKGNhbnZhcywgbXVsdGlwbGllcikge1xuICBtdWx0aXBsaWVyID0gbXVsdGlwbGllciB8fCAxO1xuICBtdWx0aXBsaWVyID0gTWF0aC5tYXgoMCwgbXVsdGlwbGllcik7XG4gIHZhciB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aCAqIG11bHRpcGxpZXIgfCAwO1xuICB2YXIgaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodCAqIG11bHRpcGxpZXIgfCAwO1xuXG4gIGlmIChjYW52YXMud2lkdGggIT09IHdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3R5cGVkYXJyYXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3R5cGVkYXJyYXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmdldEdMVHlwZUZvclR5cGVkQXJyYXkgPSBnZXRHTFR5cGVGb3JUeXBlZEFycmF5O1xuZXhwb3J0cy5nZXRHTFR5cGVGb3JUeXBlZEFycmF5VHlwZSA9IGdldEdMVHlwZUZvclR5cGVkQXJyYXlUeXBlO1xuZXhwb3J0cy5nZXRUeXBlZEFycmF5VHlwZUZvckdMVHlwZSA9IGdldFR5cGVkQXJyYXlUeXBlRm9yR0xUeXBlO1xuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gdm9pZCAwO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogTG93IGxldmVsIHNoYWRlciB0eXBlZCBhcnJheSByZWxhdGVkIGZ1bmN0aW9uc1xuICpcbiAqIFlvdSBzaG91bGQgZ2VuZXJhbGx5IG5vdCBuZWVkIHRvIHVzZSB0aGVzZSBmdW5jdGlvbnMuIFRoZXkgYXJlIHByb3ZpZGVkXG4gKiBmb3IgdGhvc2UgY2FzZXMgd2hlcmUgeW91J3JlIGRvaW5nIHNvbWV0aGluZyBvdXQgb2YgdGhlIG9yZGluYXJ5XG4gKiBhbmQgeW91IG5lZWQgbG93ZXIgbGV2ZWwgYWNjZXNzLlxuICpcbiAqIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHRoZXkgYXJlIGF2YWlsYWJsZSBhdCBib3RoIGB0d2dsLnR5cGVkQXJyYXlgIGFuZCBgdHdnbGBcbiAqIGl0c2VsZlxuICpcbiAqIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2x9IGZvciBjb3JlIGZ1bmN0aW9uc1xuICpcbiAqIEBtb2R1bGUgdHdnbC90eXBlZEFycmF5XG4gKi9cbi8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBzZWUgYSBnbG9iYWwgZ2xcbnZhciBnbCA9IHVuZGVmaW5lZDtcbi8qIGVzbGludC1kaXNhYmxlLWxpbmUgKi9cblxuLyogRGF0YVR5cGUgKi9cblxudmFyIEJZVEUgPSAweDE0MDA7XG52YXIgVU5TSUdORURfQllURSA9IDB4MTQwMTtcbnZhciBTSE9SVCA9IDB4MTQwMjtcbnZhciBVTlNJR05FRF9TSE9SVCA9IDB4MTQwMztcbnZhciBJTlQgPSAweDE0MDQ7XG52YXIgVU5TSUdORURfSU5UID0gMHgxNDA1O1xudmFyIEZMT0FUID0gMHgxNDA2O1xudmFyIFVOU0lHTkVEX1NIT1JUXzRfNF80XzQgPSAweDgwMzM7XG52YXIgVU5TSUdORURfU0hPUlRfNV81XzVfMSA9IDB4ODAzNDtcbnZhciBVTlNJR05FRF9TSE9SVF81XzZfNSA9IDB4ODM2MztcbnZhciBIQUxGX0ZMT0FUID0gMHgxNDBCO1xudmFyIFVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFViA9IDB4ODM2ODtcbnZhciBVTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWID0gMHg4QzNCO1xudmFyIFVOU0lHTkVEX0lOVF81XzlfOV85X1JFViA9IDB4OEMzRTtcbnZhciBGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVYgPSAweDhEQUQ7XG52YXIgVU5TSUdORURfSU5UXzI0XzggPSAweDg0RkE7XG52YXIgZ2xUeXBlVG9UeXBlZEFycmF5ID0ge307XG57XG4gIHZhciB0dCA9IGdsVHlwZVRvVHlwZWRBcnJheTtcbiAgdHRbQllURV0gPSBJbnQ4QXJyYXk7XG4gIHR0W1VOU0lHTkVEX0JZVEVdID0gVWludDhBcnJheTtcbiAgdHRbU0hPUlRdID0gSW50MTZBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRdID0gVWludDE2QXJyYXk7XG4gIHR0W0lOVF0gPSBJbnQzMkFycmF5O1xuICB0dFtVTlNJR05FRF9JTlRdID0gVWludDMyQXJyYXk7XG4gIHR0W0ZMT0FUXSA9IEZsb2F0MzJBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRfNF80XzRfNF0gPSBVaW50MTZBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRfNV81XzVfMV0gPSBVaW50MTZBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRfNV82XzVdID0gVWludDE2QXJyYXk7XG4gIHR0W0hBTEZfRkxPQVRdID0gVWludDE2QXJyYXk7XG4gIHR0W1VOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVl0gPSBVaW50MzJBcnJheTtcbiAgdHRbVU5TSUdORURfSU5UXzEwRl8xMUZfMTFGX1JFVl0gPSBVaW50MzJBcnJheTtcbiAgdHRbVU5TSUdORURfSU5UXzVfOV85XzlfUkVWXSA9IFVpbnQzMkFycmF5O1xuICB0dFtGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVZdID0gVWludDMyQXJyYXk7XG4gIHR0W1VOU0lHTkVEX0lOVF8yNF84XSA9IFVpbnQzMkFycmF5O1xufVxuLyoqXG4gKiBHZXQgdGhlIEdMIHR5cGUgZm9yIGEgdHlwZWRBcnJheVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IHR5cGVkQXJyYXkgYSB0eXBlZEFycmF5XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBHTCB0eXBlIGZvciBhcnJheS4gRm9yIGV4YW1wbGUgcGFzcyBpbiBhbiBgSW50OEFycmF5YCBhbmQgYGdsLkJZVEVgIHdpbGxcbiAqICAgYmUgcmV0dXJuZWQuIFBhc3MgaW4gYSBgVWludDMyQXJyYXlgIGFuZCBgZ2wuVU5TSUdORURfSU5UYCB3aWxsIGJlIHJldHVybmVkXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdHlwZWRBcnJheVxuICovXG5cbmZ1bmN0aW9uIGdldEdMVHlwZUZvclR5cGVkQXJyYXkodHlwZWRBcnJheSkge1xuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSkge1xuICAgIHJldHVybiBCWVRFO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBVTlNJR05FRF9CWVRFO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICByZXR1cm4gVU5TSUdORURfQllURTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkpIHtcbiAgICByZXR1cm4gU0hPUlQ7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgIHJldHVybiBVTlNJR05FRF9TSE9SVDtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkpIHtcbiAgICByZXR1cm4gSU5UO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcbiAgICByZXR1cm4gVU5TSUdORURfSU5UO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgcmV0dXJuIEZMT0FUO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgdHlwZWQgYXJyYXkgdHlwZScpO1xufVxuLyoqXG4gKiBHZXQgdGhlIEdMIHR5cGUgZm9yIGEgdHlwZWRBcnJheSB0eXBlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gdHlwZWRBcnJheVR5cGUgYSB0eXBlZEFycmF5IGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBHTCB0eXBlIGZvciB0eXBlLiBGb3IgZXhhbXBsZSBwYXNzIGluIGBJbnQ4QXJyYXlgIGFuZCBgZ2wuQllURWAgd2lsbFxuICogICBiZSByZXR1cm5lZC4gUGFzcyBpbiBgVWludDMyQXJyYXlgIGFuZCBgZ2wuVU5TSUdORURfSU5UYCB3aWxsIGJlIHJldHVybmVkXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdHlwZWRBcnJheVxuICovXG5cblxuZnVuY3Rpb24gZ2V0R0xUeXBlRm9yVHlwZWRBcnJheVR5cGUodHlwZWRBcnJheVR5cGUpIHtcbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBJbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gQllURTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gVU5TSUdORURfQllURTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgcmV0dXJuIFVOU0lHTkVEX0JZVEU7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBJbnQxNkFycmF5KSB7XG4gICAgcmV0dXJuIFNIT1JUO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5VHlwZSA9PT0gVWludDE2QXJyYXkpIHtcbiAgICByZXR1cm4gVU5TSUdORURfU0hPUlQ7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBJbnQzMkFycmF5KSB7XG4gICAgcmV0dXJuIElOVDtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IFVpbnQzMkFycmF5KSB7XG4gICAgcmV0dXJuIFVOU0lHTkVEX0lOVDtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IEZsb2F0MzJBcnJheSkge1xuICAgIHJldHVybiBGTE9BVDtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHR5cGVkIGFycmF5IHR5cGUnKTtcbn1cbi8qKlxuICogR2V0IHRoZSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciBmb3IgYSBnaXZlbiBHTCB0eXBlXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSB0aGUgR0wgdHlwZS4gKGVnOiBgZ2wuVU5TSUdORURfSU5UYClcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSB0aGUgY29uc3RydWN0b3IgZm9yIGEgdGhlIGNvcnJlc3BvbmRpbmcgdHlwZWQgYXJyYXkuIChlZy4gYFVpbnQzMkFycmF5YCkuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdHlwZWRBcnJheVxuICovXG5cblxuZnVuY3Rpb24gZ2V0VHlwZWRBcnJheVR5cGVGb3JHTFR5cGUodHlwZSkge1xuICB2YXIgQ1RPUiA9IGdsVHlwZVRvVHlwZWRBcnJheVt0eXBlXTtcblxuICBpZiAoIUNUT1IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZ2wgdHlwZScpO1xuICB9XG5cbiAgcmV0dXJuIENUT1I7XG59XG5cbnZhciBpc0FycmF5QnVmZmVyID0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJPclNoYXJlZEFycmF5QnVmZmVyKGEpIHtcbiAgcmV0dXJuIGEgJiYgYS5idWZmZXIgJiYgKGEuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgYS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcik7XG59IDogZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcihhKSB7XG4gIHJldHVybiBhICYmIGEuYnVmZmVyICYmIGEuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59O1xuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuaXNXZWJHTDEgPSBpc1dlYkdMMTtcbmV4cG9ydHMuaXNXZWJHTDIgPSBpc1dlYkdMMjtcbmV4cG9ydHMuZ2xFbnVtVG9TdHJpbmcgPSB2b2lkIDA7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBnbCB2ZXJzaW9uIGFzIGEgbnVtYmVyXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEByZXR1cm4ge251bWJlcn0gdmVyc2lvbiBvZiBnbFxuICogQHByaXZhdGVcbiAqL1xuLy9mdW5jdGlvbiBnZXRWZXJzaW9uQXNOdW1iZXIoZ2wpIHtcbi8vICByZXR1cm4gcGFyc2VGbG9hdChnbC5nZXRQYXJhbWV0ZXIoZ2wuVkVSU0lPTikuc3Vic3RyKDYpKTtcbi8vfVxuXG4vKipcbiAqIENoZWNrIGlmIGNvbnRleHQgaXMgV2ViR0wgMi4wXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEByZXR1cm4ge2Jvb2x9IHRydWUgaWYgaXQncyBXZWJHTCAyLjBcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5mdW5jdGlvbiBpc1dlYkdMMihnbCkge1xuICAvLyBUaGlzIGlzIHRoZSBjb3JyZWN0IGNoZWNrIGJ1dCBpdCdzIHNsb3dcbiAgLy8gIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuVkVSU0lPTikuaW5kZXhPZihcIldlYkdMIDIuMFwiKSA9PT0gMDtcbiAgLy8gVGhpcyBtaWdodCBhbHNvIGJlIHRoZSBjb3JyZWN0IGNoZWNrIGJ1dCBJJ20gYXNzdW1pbmcgaXQncyBzbG93LWlzaFxuICAvLyByZXR1cm4gZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICByZXR1cm4gISFnbC50ZXhTdG9yYWdlMkQ7XG59XG4vKipcbiAqIENoZWNrIGlmIGNvbnRleHQgaXMgV2ViR0wgMS4wXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEByZXR1cm4ge2Jvb2x9IHRydWUgaWYgaXQncyBXZWJHTCAxLjBcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cblxuZnVuY3Rpb24gaXNXZWJHTDEoZ2wpIHtcbiAgLy8gVGhpcyBpcyB0aGUgY29ycmVjdCBjaGVjayBidXQgaXQncyBzbG93XG4gIC8vIGNvbnN0IHZlcnNpb24gPSBnZXRWZXJzaW9uQXNOdW1iZXIoZ2wpO1xuICAvLyByZXR1cm4gdmVyc2lvbiA8PSAxLjAgJiYgdmVyc2lvbiA+IDAuMDsgIC8vIGJlY2F1c2UgYXMgb2YgMjAxNi81IEVkZ2UgcmV0dXJucyAwLjk2XG4gIC8vIFRoaXMgbWlnaHQgYWxzbyBiZSB0aGUgY29ycmVjdCBjaGVjayBidXQgSSdtIGFzc3VtaW5nIGl0J3Mgc2xvdy1pc2hcbiAgLy8gcmV0dXJuIGdsIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICByZXR1cm4gIWdsLnRleFN0b3JhZ2UyRDtcbn1cbi8qKlxuICogR2V0cyBhIHN0cmluZyBmb3IgV2ViR0wgZW51bVxuICpcbiAqIE5vdGU6IFNldmVyYWwgZW51bXMgYXJlIHRoZSBzYW1lLiBXaXRob3V0IG1vcmVcbiAqIGNvbnRleHQgKHdoaWNoIGZ1bmN0aW9uKSBpdCdzIGltcG9zc2libGUgdG8gYWx3YXlzXG4gKiBnaXZlIHRoZSBjb3JyZWN0IGVudW0uIEFzIGl0IGlzLCBmb3IgbWF0Y2hpbmcgdmFsdWVzXG4gKiBpdCBnaXZlcyBhbGwgZW51bXMuIENoZWNraW5nIHRoZSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0XG4gKiB0aGF0IG1lYW5zXG4gKlxuICogICAgICAwICAgICA9IFpFUk8gfCBQT0lOVCB8IE5PTkUgfCBOT19FUlJPUlxuICogICAgICAxICAgICA9IE9ORSB8IExJTkVTIHwgU1lOQ19GTFVTSF9DT01NQU5EU19CSVRcbiAqICAgICAgMzI3NzcgPSBCTEVORF9FUVVBVElPTl9SR0IgfCBCTEVORF9FUVVBVElPTl9SR0JcbiAqICAgICAgMzY2NjIgPSBDT1BZX1JFQURfQlVGRkVSIHwgQ09QWV9SRUFEX0JVRkZFUl9CSU5ESU5HXG4gKiAgICAgIDM2NjYzID0gQ09QWV9XUklURV9CVUZGRVIgfCBDT1BZX1dSSVRFX0JVRkZFUl9CSU5ESU5HXG4gKiAgICAgIDM2MDA2ID0gRlJBTUVCVUZGRVJfQklORElORyB8IERSQVdfRlJBTUVCVUZGRVJfQklORElOR1xuICpcbiAqIEl0J3MgYWxzbyBub3QgdXNlZnVsIGZvciBiaXRzIHJlYWxseSB1bmxlc3MgeW91IHBhc3MgaW4gaW5kaXZpZHVhbCBiaXRzLlxuICogSW4gb3RoZXIgd29yZHNcbiAqXG4gKiAgICAgY29uc3QgYml0cyA9IGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUO1xuICogICAgIHR3Z2wuZ2xFbnVtVG9TdHJpbmcoZ2wsIGJpdHMpOyAgLy8gbm90IGdvaW5nIHRvIHdvcmtcbiAqXG4gKiBOb3RlIHRoYXQgc29tZSBlbnVtcyBvbmx5IGV4aXN0IG9uIGV4dGVuc2lvbnMuIElmIHlvdVxuICogd2FudCB0aGVtIHRvIHNob3cgdXAgeW91IG5lZWQgdG8gcGFzcyB0aGUgZXh0ZW5zaW9uIGF0IGxlYXN0XG4gKiBvbmNlLiBGb3IgZXhhbXBsZVxuICpcbiAqICAgICBjb25zdCBleHQgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyk7XG4gKiAgICAgaWYgKGV4dCkge1xuICogICAgICAgIHR3Z2wuZ2xFbnVtVG9TdHJpbmcoZXh0LCAwKTsgIC8vIGp1c3QgcHJpbWUgdGhlIGZ1bmN0aW9uXG4gKlxuICogICAgICAgIC4ubGF0ZXIuLlxuICpcbiAqICAgICAgICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IGV4dC5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xuICogICAgICAgIGNvbnNvbGUubG9nKHR3Z2wuZ2xFbnVtVG9TdHJpbmcoZ2wsIGludGVybmFsRm9ybWF0KSk7XG4gKlxuICogTm90aWNlIEkgZGlkbid0IGhhdmUgdG8gcGFzcyB0aGUgZXh0ZW5zaW9uIHRoZSBzZWNvbmQgdGltZS4gVGhpcyBtZWFuc1xuICogeW91IGNhbiBoYXZlIHBsYWNlIHRoYXQgZ2VuZXJpY2FsbHkgZ2V0cyBhbiBlbnVtIGZvciB0ZXh0dXJlIGZvcm1hdHMgZm9yIGV4YW1wbGUuXG4gKiBhbmQgYXMgbG9uZyBhcyB5b3UgcHJpbWVkIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBleHRlbnNpb25zXG4gKlxuICogSWYgeW91J3JlIHVzaW5nIGB0d2dsLmFkZEV4dGVuc2lvbnNUb0NvbnRleHRgIHRvIGVuYWJsZSB5b3VyIGV4dGVuc2lvbnNcbiAqIHRoZW4gdHdnbCB3aWxsIGF1dG9tYXRpY2FsbHkgZ2V0IHRoZSBleHRlbnNpb24ncyBlbnVtcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgb3IgYW55IGV4dGVuc2lvbiBvYmplY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB0aGUgdmFsdWUgb2YgdGhlIGVudW0geW91IHdhbnQgdG8gbG9vayB1cC5cbiAqIEByZXR1cm4ge3N0cmluZ30gZW51bSBzdHJpbmcgb3IgaGV4IHZhbHVlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqIEBmdW5jdGlvbiBnbEVudW1Ub1N0cmluZ1xuICovXG5cblxudmFyIGdsRW51bVRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGF2ZUVudW1zRm9yVHlwZSA9IHt9O1xuICB2YXIgZW51bXMgPSB7fTtcblxuICBmdW5jdGlvbiBhZGRFbnVtcyhnbCkge1xuICAgIHZhciB0eXBlID0gZ2wuY29uc3RydWN0b3IubmFtZTtcblxuICAgIGlmICghaGF2ZUVudW1zRm9yVHlwZVt0eXBlXSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGdsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2xba2V5XSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBlbnVtc1tnbFtrZXldXTtcbiAgICAgICAgICBlbnVtc1tnbFtrZXldXSA9IGV4aXN0aW5nID8gXCJcIi5jb25jYXQoZXhpc3RpbmcsIFwiIHwgXCIpLmNvbmNhdChrZXkpIDoga2V5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGhhdmVFbnVtc0ZvclR5cGVbdHlwZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBnbEVudW1Ub1N0cmluZyhnbCwgdmFsdWUpIHtcbiAgICBhZGRFbnVtcyhnbCk7XG4gICAgcmV0dXJuIGVudW1zW3ZhbHVlXSB8fCAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IFwiMHhcIi5jb25jYXQodmFsdWUudG9TdHJpbmcoMTYpKSA6IHZhbHVlKTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5nbEVudW1Ub1N0cmluZyA9IGdsRW51bVRvU3RyaW5nO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy92My5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy92My5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNyb3NzID0gY3Jvc3M7XG5leHBvcnRzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLmRpc3RhbmNlU3EgPSBkaXN0YW5jZVNxO1xuZXhwb3J0cy5kaXZpZGUgPSBkaXZpZGU7XG5leHBvcnRzLmRpdlNjYWxhciA9IGRpdlNjYWxhcjtcbmV4cG9ydHMuZG90ID0gZG90O1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMubGVycFYgPSBsZXJwVjtcbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xuZXhwb3J0cy5sZW5ndGhTcSA9IGxlbmd0aFNxO1xuZXhwb3J0cy5tYXggPSBtYXg7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubXVsU2NhbGFyID0gbXVsU2NhbGFyO1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy5uZWdhdGUgPSBuZWdhdGU7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMuc2V0RGVmYXVsdFR5cGUgPSBzZXREZWZhdWx0VHlwZTtcbmV4cG9ydHMuc3VidHJhY3QgPSBzdWJ0cmFjdDtcblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqXG4gKiBWZWMzIG1hdGggbWF0aCBmdW5jdGlvbnMuXG4gKlxuICogQWxtb3N0IGFsbCBmdW5jdGlvbnMgdGFrZSBhbiBvcHRpb25hbCBgZHN0YCBhcmd1bWVudC4gSWYgaXQgaXMgbm90IHBhc3NlZCBpbiB0aGVcbiAqIGZ1bmN0aW9ucyB3aWxsIGNyZWF0ZSBhIG5ldyBWZWMzLiBJbiBvdGhlciB3b3JkcyB5b3UgY2FuIGRvIHRoaXNcbiAqXG4gKiAgICAgdmFyIHYgPSB2My5jcm9zcyh2MSwgdjIpOyAgLy8gQ3JlYXRlcyBhIG5ldyBWZWMzIHdpdGggdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdjEgeCB2Mi5cbiAqXG4gKiBvclxuICpcbiAqICAgICB2YXIgdiA9IHYzLmNyZWF0ZSgpO1xuICogICAgIHYzLmNyb3NzKHYxLCB2Miwgdik7ICAvLyBQdXRzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHYxIHggdjIgaW4gdlxuICpcbiAqIFRoZSBmaXJzdCBzdHlsZSBpcyBvZnRlbiBlYXNpZXIgYnV0IGRlcGVuZGluZyBvbiB3aGVyZSBpdCdzIHVzZWQgaXQgZ2VuZXJhdGVzIGdhcmJhZ2Ugd2hlcmVcbiAqIGFzIHRoZXJlIGlzIGFsbW9zdCBuZXZlciBhbGxvY2F0aW9uIHdpdGggdGhlIHNlY29uZCBzdHlsZS5cbiAqXG4gKiBJdCBpcyBhbHdheXMgc2F2ZSB0byBwYXNzIGFueSB2ZWN0b3IgYXMgdGhlIGRlc3RpbmF0aW9uLiBTbyBmb3IgZXhhbXBsZVxuICpcbiAqICAgICB2My5jcm9zcyh2MSwgdjIsIHYxKTsgIC8vIFB1dHMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdjEgeCB2MiBpbiB2MVxuICpcbiAqIEBtb2R1bGUgdHdnbC92M1xuICovXG52YXIgVmVjVHlwZSA9IEZsb2F0MzJBcnJheTtcbi8qKlxuICogQSBKYXZhU2NyaXB0IGFycmF5IHdpdGggMyB2YWx1ZXMgb3IgYSBGbG9hdDMyQXJyYXkgd2l0aCAzIHZhbHVlcy5cbiAqIFdoZW4gY3JlYXRlZCBieSB0aGUgbGlicmFyeSB3aWxsIGNyZWF0ZSB0aGUgZGVmYXVsdCB0eXBlIHdoaWNoIGlzIGBGbG9hdDMyQXJyYXlgXG4gKiBidXQgY2FuIGJlIHNldCBieSBjYWxsaW5nIHtAbGluayBtb2R1bGU6dHdnbC92My5zZXREZWZhdWx0VHlwZX0uXG4gKiBAdHlwZWRlZiB7KG51bWJlcltdfEZsb2F0MzJBcnJheSl9IFZlYzNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cbi8qKlxuICogU2V0cyB0aGUgdHlwZSB0aGlzIGxpYnJhcnkgY3JlYXRlcyBmb3IgYSBWZWMzXG4gKiBAcGFyYW0ge2NvbnN0cnVjdG9yfSBjdG9yIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHR5cGUuIEVpdGhlciBgRmxvYXQzMkFycmF5YCBvciBgQXJyYXlgXG4gKiBAcmV0dXJuIHtjb25zdHJ1Y3Rvcn0gcHJldmlvdXMgY29uc3RydWN0b3IgZm9yIFZlYzNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cbmZ1bmN0aW9uIHNldERlZmF1bHRUeXBlKGN0b3IpIHtcbiAgdmFyIG9sZFR5cGUgPSBWZWNUeXBlO1xuICBWZWNUeXBlID0gY3RvcjtcbiAgcmV0dXJuIG9sZFR5cGU7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB2ZWMzOyBtYXkgYmUgY2FsbGVkIHdpdGggeCwgeSwgeiB0byBzZXQgaW5pdGlhbCB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW3hdIEluaXRpYWwgeCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gSW5pdGlhbCB5IHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt6XSBJbml0aWFsIHogdmFsdWUuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSB0aGUgY3JlYXRlZCB2ZWN0b3JcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlKHgsIHksIHopIHtcbiAgdmFyIGRzdCA9IG5ldyBWZWNUeXBlKDMpO1xuXG4gIGlmICh4KSB7XG4gICAgZHN0WzBdID0geDtcbiAgfVxuXG4gIGlmICh5KSB7XG4gICAgZHN0WzFdID0geTtcbiAgfVxuXG4gIGlmICh6KSB7XG4gICAgZHN0WzJdID0gejtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlY3RvcnM7IGFzc3VtZXMgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gQSB2ZWN0b3IgdGhhIHRpcyB0aGUgc3VtIG9mIGEgYW5kIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChhLCBiLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuICBkc3RbMF0gPSBhWzBdICsgYlswXTtcbiAgZHN0WzFdID0gYVsxXSArIGJbMV07XG4gIGRzdFsyXSA9IGFbMl0gKyBiWzJdO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBTdWJ0cmFjdHMgdHdvIHZlY3RvcnMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IEEgdmVjdG9yIHRoYXQgaXMgdGhlIGRpZmZlcmVuY2Ugb2YgYSBhbmQgYi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcbiAgZHN0WzBdID0gYVswXSAtIGJbMF07XG4gIGRzdFsxXSA9IGFbMV0gLSBiWzFdO1xuICBkc3RbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gb24gdHdvIHZlY3RvcnMuXG4gKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgYW5kIGludGVycG9sYXRpb24gY29lZmZpY2llbnQgdCwgcmV0dXJuc1xuICogYSArIHQgKiAoYiAtIGEpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBhIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBiIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIGxpbmVhciBpbnRlcnBvbGF0ZWQgcmVzdWx0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBsZXJwKGEsIGIsIHQsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IGFbMF0gKyB0ICogKGJbMF0gLSBhWzBdKTtcbiAgZHN0WzFdID0gYVsxXSArIHQgKiAoYlsxXSAtIGFbMV0pO1xuICBkc3RbMl0gPSBhWzJdICsgdCAqIChiWzJdIC0gYVsyXSk7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9uIHR3byB2ZWN0b3JzLlxuICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIGFuZCBpbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50IHZlY3RvciB0LCByZXR1cm5zXG4gKiBhICsgdCAqIChiIC0gYSkuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHQgSW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudHMgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSB0aGUgbGluZWFyIGludGVycG9sYXRlZCByZXN1bHQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlcnBWKGEsIGIsIHQsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IGFbMF0gKyB0WzBdICogKGJbMF0gLSBhWzBdKTtcbiAgZHN0WzFdID0gYVsxXSArIHRbMV0gKiAoYlsxXSAtIGFbMV0pO1xuICBkc3RbMl0gPSBhWzJdICsgdFsyXSAqIChiWzJdIC0gYVsyXSk7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFJldHVybiBtYXggdmFsdWVzIG9mIHR3byB2ZWN0b3JzLlxuICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIHJldHVybnNcbiAqIFttYXgoYVswXSwgYlswXSksIG1heChhWzFdLCBiWzFdKSwgbWF4KGFbMl0sIGJbMl0pXS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIG1heCBjb21wb25lbnRzIHZlY3Rvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gbWF4KGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBkc3RbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgZHN0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFJldHVybiBtaW4gdmFsdWVzIG9mIHR3byB2ZWN0b3JzLlxuICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIHJldHVybnNcbiAqIFttaW4oYVswXSwgYlswXSksIG1pbihhWzFdLCBiWzFdKSwgbWluKGFbMl0sIGJbMl0pXS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIG1pbiBjb21wb25lbnRzIHZlY3Rvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gbWluKGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBkc3RbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgZHN0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBrIFRoZSBzY2FsYXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSBzY2FsZWQgdmVjdG9yLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBtdWxTY2FsYXIodiwgaywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcbiAgZHN0WzBdID0gdlswXSAqIGs7XG4gIGRzdFsxXSA9IHZbMV0gKiBrO1xuICBkc3RbMl0gPSB2WzJdICogaztcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogRGl2aWRlcyBhIHZlY3RvciBieSBhIHNjYWxhci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgdmVjdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGsgVGhlIHNjYWxhci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIHNjYWxlZCB2ZWN0b3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpdlNjYWxhcih2LCBrLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuICBkc3RbMF0gPSB2WzBdIC8gaztcbiAgZHN0WzFdID0gdlsxXSAvIGs7XG4gIGRzdFsyXSA9IHZbMl0gLyBrO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjdG9yczsgYXNzdW1lcyBib3RoIHZlY3RvcnMgaGF2ZVxuICogdGhyZWUgZW50cmllcy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIHZlY3RvciBvZiBhIGNyb3NzIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyb3NzKGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIHZhciB0MSA9IGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl07XG4gIHZhciB0MiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIGRzdFswXSA9IGFbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV07XG4gIGRzdFsxXSA9IHQxO1xuICBkc3RbMl0gPSB0MjtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzOyBhc3N1bWVzIGJvdGggdmVjdG9ycyBoYXZlXG4gKiB0aHJlZSBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBhIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBiIE9wZXJhbmQgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBkb3QgcHJvZHVjdFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IHZlY3Rvci5cbiAqIEByZXR1cm4ge251bWJlcn0gbGVuZ3RoIG9mIHZlY3Rvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gbGVuZ3RoKHYpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh2WzBdICogdlswXSArIHZbMV0gKiB2WzFdICsgdlsyXSAqIHZbMl0pO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgdmVjdG9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlbmd0aFNxKHYpIHtcbiAgcmV0dXJuIHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0gKyB2WzJdICogdlsyXTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgZHggPSBhWzBdIC0gYlswXTtcbiAgdmFyIGR5ID0gYVsxXSAtIGJbMV07XG4gIHZhciBkeiA9IGFbMl0gLSBiWzJdO1xuICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBkaXN0YW5jZVNxKGEsIGIpIHtcbiAgdmFyIGR4ID0gYVswXSAtIGJbMF07XG4gIHZhciBkeSA9IGFbMV0gLSBiWzFdO1xuICB2YXIgZHogPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcbn1cbi8qKlxuICogRGl2aWRlcyBhIHZlY3RvciBieSBpdHMgRXVjbGlkZWFuIGxlbmd0aCBhbmQgcmV0dXJucyB0aGUgcXVvdGllbnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgVGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIG5vcm1hbGl6ZWQgdmVjdG9yLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemUoYSwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcbiAgdmFyIGxlblNxID0gYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXSArIGFbMl0gKiBhWzJdO1xuICB2YXIgbGVuID0gTWF0aC5zcXJ0KGxlblNxKTtcblxuICBpZiAobGVuID4gMC4wMDAwMSkge1xuICAgIGRzdFswXSA9IGFbMF0gLyBsZW47XG4gICAgZHN0WzFdID0gYVsxXSAvIGxlbjtcbiAgICBkc3RbMl0gPSBhWzJdIC8gbGVuO1xuICB9IGVsc2Uge1xuICAgIGRzdFswXSA9IDA7XG4gICAgZHN0WzFdID0gMDtcbiAgICBkc3RbMl0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogTmVnYXRlcyBhIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSAtdi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gbmVnYXRlKHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IC12WzBdO1xuICBkc3RbMV0gPSAtdlsxXTtcbiAgZHN0WzJdID0gLXZbMl07XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENvcGllcyBhIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBBIGNvcHkgb2Ygdi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gY29weSh2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuICBkc3RbMF0gPSB2WzBdO1xuICBkc3RbMV0gPSB2WzFdO1xuICBkc3RbMl0gPSB2WzJdO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSB2ZWN0b3Igb2YgcHJvZHVjdHMgb2YgZW50cmllcyBvZiBhIGFuZFxuICogICAgIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IGFbMF0gKiBiWzBdO1xuICBkc3RbMV0gPSBhWzFdICogYlsxXTtcbiAgZHN0WzJdID0gYVsyXSAqIGJbMl07XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICogYiBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIHZlY3RvciBvZiBxdW90aWVudHMgb2YgZW50cmllcyBvZiBhIGFuZFxuICogICAgIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpdmlkZShhLCBiLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuICBkc3RbMF0gPSBhWzBdIC8gYlswXTtcbiAgZHN0WzFdID0gYVsxXSAvIGJbMV07XG4gIGRzdFsyXSA9IGFbMl0gLyBiWzJdO1xuICByZXR1cm4gZHN0O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy92ZXJ0ZXgtYXJyYXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdmVydGV4LWFycmF5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlVmVydGV4QXJyYXlJbmZvID0gY3JlYXRlVmVydGV4QXJyYXlJbmZvO1xuZXhwb3J0cy5jcmVhdGVWQU9BbmRTZXRBdHRyaWJ1dGVzID0gY3JlYXRlVkFPQW5kU2V0QXR0cmlidXRlcztcbmV4cG9ydHMuY3JlYXRlVkFPRnJvbUJ1ZmZlckluZm8gPSBjcmVhdGVWQU9Gcm9tQnVmZmVySW5mbztcblxudmFyIHByb2dyYW1zID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wcm9ncmFtcy5qcyAqLyBcIi4vc3JjL3Byb2dyYW1zLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIHZlcnRleCBhcnJheSBvYmplY3QgcmVsYXRlZCBmdW5jdGlvbnNcbiAqXG4gKiBZb3Ugc2hvdWxkIGdlbmVyYWxseSBub3QgbmVlZCB0byB1c2UgdGhlc2UgZnVuY3Rpb25zLiBUaGV5IGFyZSBwcm92aWRlZFxuICogZm9yIHRob3NlIGNhc2VzIHdoZXJlIHlvdSdyZSBkb2luZyBzb21ldGhpbmcgb3V0IG9mIHRoZSBvcmRpbmFyeVxuICogYW5kIHlvdSBuZWVkIGxvd2VyIGxldmVsIGFjY2Vzcy5cbiAqXG4gKiBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB0aGV5IGFyZSBhdmFpbGFibGUgYXQgYm90aCBgdHdnbC5hdHRyaWJ1dGVzYCBhbmQgYHR3Z2xgXG4gKiBpdHNlbGZcbiAqXG4gKiBTZWUge0BsaW5rIG1vZHVsZTp0d2dsfSBmb3IgY29yZSBmdW5jdGlvbnNcbiAqXG4gKiBAbW9kdWxlIHR3Z2wvdmVydGV4QXJyYXlzXG4gKi9cbnZhciBFTEVNRU5UX0FSUkFZX0JVRkZFUiA9IDB4ODg5Mztcbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVmVydGV4QXJyYXlJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gbnVtRWxlbWVudHMgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBwYXNzIHRvIGBnbC5kcmF3QXJyYXlzYCBvciBgZ2wuZHJhd0VsZW1lbnRzYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZWxlbWVudFR5cGVdIFRoZSB0eXBlIG9mIGluZGljZXMgYFVOU0lHTkVEX0JZVEVgLCBgVU5TSUdORURfU0hPUlRgIGV0Yy4uXG4gKiBAcHJvcGVydHkge1dlYkdMVmVydGV4QXJyYXlPYmplY3R9IFt2ZXJ0ZXhBcnJheU9iamVjdF0gYSB2ZXJ0ZXggYXJyYXkgb2JqZWN0XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBWZXJ0ZXhBcnJheUluZm8gZnJvbSBhIEJ1ZmZlckluZm8gYW5kIG9uZSBvciBtb3JlIFByb2dyYW1JbmZvc1xuICpcbiAqIFRoaXMgY2FuIGJlIHBhc3NlZCB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXN9IGFuZCB0b1xuICoge0BsaW5rIG1vZHVsZTp0d2dsOmRyYXdCdWZmZXJJbmZvfS5cbiAqXG4gKiA+ICoqSU1QT1JUQU5UOioqIFZlcnRleCBBcnJheSBPYmplY3RzIGFyZSAqKm5vdCoqIGEgZGlyZWN0IGFuYWxvZyBmb3IgYSBCdWZmZXJJbmZvLiBWZXJ0ZXggQXJyYXkgT2JqZWN0c1xuICogICBhc3NpZ24gYnVmZmVycyB0byBzcGVjaWZpYyBhdHRyaWJ1dGVzIGF0IGNyZWF0aW9uIHRpbWUuIFRoYXQgbWVhbnMgdGhleSBjYW4gb25seSBiZSB1c2VkIHdpdGggcHJvZ3JhbXNcbiAqICAgd2hvJ3MgYXR0cmlidXRlcyB1c2UgdGhlIHNhbWUgYXR0cmlidXRlIGxvY2F0aW9ucyBmb3IgdGhlIHNhbWUgcHVycG9zZXMuXG4gKlxuICogPiBCaW5kIHlvdXIgYXR0cmlidXRlIGxvY2F0aW9ucyBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlUHJvZ3JhbUluZm99XG4gKiAgIG9yIHVzZSBXZWJHTCAyJ3MgR0xTTCBFUyAzJ3MgYGxheW91dChsb2NhdGlvbiA9IDxudW0+KWAgdG8gbWFrZSBzdXJlIGxvY2F0aW9ucyBtYXRjaC5cbiAqXG4gKiBhbHNvXG4gKlxuICogPiAqKklNUE9SVEFOVDoqKiBBZnRlciBjYWxsaW5nIHR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZSB3aXRoIGEgQnVmZmVySW5mbyB0aGF0IHVzZXMgYSBWZXJ0ZXggQXJyYXkgT2JqZWN0XG4gKiAgIHRoYXQgVmVydGV4IEFycmF5IE9iamVjdCB3aWxsIGJlIGJvdW5kLiBUaGF0IG1lYW5zICoqQU5ZIE1BTklQVUxBVElPTiBPRiBFTEVNRU5UX0FSUkFZX0JVRkZFUiBvciBBVFRSSUJVVEVTKipcbiAqICAgd2lsbCBhZmZlY3QgdGhlIFZlcnRleCBBcnJheSBPYmplY3Qgc3RhdGUuXG4gKlxuICogPiBDYWxsIGBnbC5iaW5kVmVydGV4QXJyYXkobnVsbClgIHRvIGdldCBiYWNrIG1hbmlwdWxhdGluZyB0aGUgZ2xvYmFsIGF0dHJpYnV0ZXMgYW5kIEVMRU1FTlRfQVJSQVlfQlVGRkVSLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb1tdfSBwcm9ncmFtSW5mbyBhIHByb2dyYW1JbmZvIG9yIGFycmF5IG9mIHByb2dyYW1JbmZvc1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBidWZmZXJJbmZvIEJ1ZmZlckluZm8gYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyBldGMuLi5cbiAqXG4gKiAgICBZb3UgbmVlZCB0byBtYWtlIHN1cmUgZXZlcnkgYXR0cmlidXRlIHRoYXQgd2lsbCBiZSB1c2VkIGlzIGJvdW5kLiBTbyBmb3IgZXhhbXBsZSBhc3N1bWUgc2hhZGVyIDFcbiAqICAgIHVzZXMgYXR0cmlidXRlcyBBLCBCLCBDIGFuZCBzaGFkZXIgMiB1c2VzIGF0dHJpYnV0ZXMgQSwgQiwgRC4gSWYgeW91IG9ubHkgcGFzcyBpbiB0aGUgcHJvZ3JhbUluZm9cbiAqICAgIGZvciBzaGFkZXIgMSB0aGVuIG9ubHkgYXR0cmlidXRlcyBBLCBCLCBhbmQgQyB3aWxsIGhhdmUgdGhlaXIgYXR0cmlidXRlcyBzZXQgYmVjYXVzZSBUV0dMIGRvZXNuJ3RcbiAqICAgIG5vdyBhdHRyaWJ1dGUgRCdzIGxvY2F0aW9uLlxuICpcbiAqICAgIFNvLCB5b3UgY2FuIHBhc3MgaW4gYm90aCBzaGFkZXIgMSBhbmQgc2hhZGVyIDIncyBwcm9ncmFtSW5mb1xuICpcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLlZlcnRleEFycmF5SW5mb30gVGhlIGNyZWF0ZWQgVmVydGV4QXJyYXlJbmZvXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ZlcnRleEFycmF5c1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleEFycmF5SW5mbyhnbCwgcHJvZ3JhbUluZm9zLCBidWZmZXJJbmZvKSB7XG4gIHZhciB2YW8gPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuICBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcblxuICBpZiAoIXByb2dyYW1JbmZvcy5sZW5ndGgpIHtcbiAgICBwcm9ncmFtSW5mb3MgPSBbcHJvZ3JhbUluZm9zXTtcbiAgfVxuXG4gIHByb2dyYW1JbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtSW5mbykge1xuICAgIHByb2dyYW1zLnNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzKGdsLCBwcm9ncmFtSW5mbywgYnVmZmVySW5mbyk7XG4gIH0pO1xuICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gIHJldHVybiB7XG4gICAgbnVtRWxlbWVudHM6IGJ1ZmZlckluZm8ubnVtRWxlbWVudHMsXG4gICAgZWxlbWVudFR5cGU6IGJ1ZmZlckluZm8uZWxlbWVudFR5cGUsXG4gICAgdmVydGV4QXJyYXlPYmplY3Q6IHZhb1xuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgdmVydGV4IGFycmF5IG9iamVjdCBhbmQgdGhlbiBzZXRzIHRoZSBhdHRyaWJ1dGVzIG9uIGl0XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBzZXR0ZXJzIEF0dHJpYnV0ZSBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20gY3JlYXRlQXR0cmlidXRlU2V0dGVyc1xuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnR3Z2wuQXR0cmliSW5mbz59IGF0dHJpYnMgQXR0cmliSW5mb3MgbWFwcGVkIGJ5IGF0dHJpYnV0ZSBuYW1lLlxuICogQHBhcmFtIHtXZWJHTEJ1ZmZlcn0gW2luZGljZXNdIGFuIG9wdGlvbmFsIEVMRU1FTlRfQVJSQVlfQlVGRkVSIG9mIGluZGljZXNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92ZXJ0ZXhBcnJheXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVZBT0FuZFNldEF0dHJpYnV0ZXMoZ2wsIHNldHRlcnMsIGF0dHJpYnMsIGluZGljZXMpIHtcbiAgdmFyIHZhbyA9IGdsLmNyZWF0ZVZlcnRleEFycmF5KCk7XG4gIGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xuICBwcm9ncmFtcy5zZXRBdHRyaWJ1dGVzKHNldHRlcnMsIGF0dHJpYnMpO1xuXG4gIGlmIChpbmRpY2VzKSB7XG4gICAgZ2wuYmluZEJ1ZmZlcihFTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kaWNlcyk7XG4gIH0gLy8gV2UgdW5iaW5kIHRoaXMgYmVjYXVzZSBvdGhlcndpc2UgYW55IGNoYW5nZSB0byBFTEVNRU5UX0FSUkFZX0JVRkZFUlxuICAvLyBsaWtlIHdoZW4gY3JlYXRpbmcgYnVmZmVycyBmb3Igb3RoZXIgc3R1ZmYgd2lsbCBtZXNzIHVwIHRoaXMgVkFPJ3MgYmluZGluZ1xuXG5cbiAgZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuICByZXR1cm4gdmFvO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgdmVydGV4IGFycmF5IG9iamVjdCBhbmQgdGhlbiBzZXRzIHRoZSBhdHRyaWJ1dGVzXG4gKiBvbiBpdFxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiAgICAgICAgdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fCBtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb30gcHJvZ3JhbUluZm8gYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVQcm9ncmFtSW5mbyBvciBBdHRyaWJ1dGUgc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUF0dHJpYnV0ZVNldHRlcnNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gYnVmZmVySW5mbyBCdWZmZXJJbmZvIGFzIHJldHVybmVkIGZyb20gY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMgZXRjLi4uXG4gKiBAcGFyYW0ge1dlYkdMQnVmZmVyfSBbaW5kaWNlc10gYW4gb3B0aW9uYWwgRUxFTUVOVF9BUlJBWV9CVUZGRVIgb2YgaW5kaWNlc1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ZlcnRleEFycmF5c1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlVkFPRnJvbUJ1ZmZlckluZm8oZ2wsIHByb2dyYW1JbmZvLCBidWZmZXJJbmZvKSB7XG4gIHJldHVybiBjcmVhdGVWQU9BbmRTZXRBdHRyaWJ1dGVzKGdsLCBwcm9ncmFtSW5mby5hdHRyaWJTZXR0ZXJzIHx8IHByb2dyYW1JbmZvLCBidWZmZXJJbmZvLmF0dHJpYnMsIGJ1ZmZlckluZm8uaW5kaWNlcyk7XG59XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10d2dsLWZ1bGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGxvYWRNYXAgPSByZXF1aXJlKFwiLi9sb2FkTWFwXCIpO1xuY29uc3QgbWF0MyA9IHJlcXVpcmUoXCJnbC1tYXRyaXgvbWF0M1wiKTtcbmNvbnN0IGNyZWF0ZURyYXdpbmcgPSByZXF1aXJlKFwiLi9yZW5kZXJlclwiKTtcbmNvbnN0IGluaXRTaGFwZXMgPSByZXF1aXJlKFwiLi9zaGFwZXNcIik7XG5jb25zdCBpbml0Vml6Q3RybCA9IHJlcXVpcmUoXCIuL3BhdGh2aXpcIik7XG5jb25zdCB0d2dsID0gcmVxdWlyZShcInR3Z2wuanNcIik7XG5cbmNvbnN0IGNvbG9ycyA9IHJlcXVpcmUoXCIuL3RoZW1lXCIpLmRlZmF1bHQ7XG5cbmNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG5cbmNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKTtcbmNvbnN0IHNoYXBlcyA9IGluaXRTaGFwZXMoZ2wpO1xuXG5jb25zdCBzY2VuZSA9IGNyZWF0ZURyYXdpbmcoZ2wpO1xuc2NlbmUuZHJhdygpO1xuXG4vLyBXZWJHTCBtYXAgZGF0YVxubGV0IG5vZGVzO1xubGV0IGVkZ2VzO1xuXG4vLyBQYXRoZmluZGluZyBcbmxldCBncmFwaDtcbmxldCBjb250cm9sbGVyO1xuXG5sb2FkTWFwKFwidG9yb250b1wiLCB1cGRhdGVMb2FkaW5nVGV4dClcbiAgLnRoZW4oKHJlcykgPT4ge1xuICAgIG5vZGVzID0gcmVzLm5vZGVzO1xuICAgIGVkZ2VzID0gcmVzLmVkZ2VzO1xuICAgIGdyYXBoID0gcmVzLm1hcEdyYXBoO1xuICAgIG1haW4oKTtcbiAgfSlcblxuZnVuY3Rpb24gbWFpbigpe1xuICAvLyBUT0RPOiB0aGlzLCBidXQgcHJvcGVybHkgKGFzeW5jIGZvci1sb29wPylcbiAgdXBkYXRlTG9hZGluZ1RleHQoe21lc3NhZ2U6IFwiQ3JlYXRpbmcgUXVhZHRyZWVcIiwgY29tcGxldGVkOiAxNH0pO1xuICBcbiAgY29udHJvbGxlciA9IGluaXRWaXpDdHJsKGdsLCBncmFwaCwgbm9kZXMsIHNjZW5lLCBzaGFwZXMpO1xuXG4gIC8vIFRPRE86IHRoaXMsIGJ1dCBwcm9wZXJseSAoYXN5bmMgZm9yLWxvb3A/KVxuICB1cGRhdGVMb2FkaW5nVGV4dCh7bWVzc2FnZTogXCJDcmVhdGluZyBRdWFkdHJlZVwiLCBjb21wbGV0ZWQ6IDEwMH0pO1xuICBcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdmVybGF5XCIpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgLy8gZHJhdyBtYXBcbiAgc2NlbmUuYWRkT2JqZWN0KG5vZGVzLCBlZGdlcywge1xuICAgICBjb2xvcjogY29sb3JzLmJhc2VNYXAsIFxuICAgICB0eXBlOiBnbC5MSU5FUywgXG4gICAgIGxheWVyOiBcImJhc2VcIixcbiAgICB9KTtcbiAgXG4gIGF0dGFjaEhhbmRsZXJzKCk7XG4gIHNjZW5lLmRyYXcoKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTG9hZGluZ1RleHQocHJvZ3Jlc3MpIHtcbiAgbGV0IG1zZyA9IHByb2dyZXNzLm1lc3NhZ2U7XG4gIGxldCBwY3QgPSBwcm9ncmVzcy5jb21wbGV0ZWQ7XG4gIGNvbnNvbGUubG9nKHBjdCk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJvZ3Jlc3NcIikuaW5uZXJIVE1MID0gYCR7bXNnfTogJHtwY3R9JWA7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaEhhbmRsZXJzKCkge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZU1vdXNlRG93bik7XG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGhhbmRsZU1vdXNlV2hlZWwpO1xuICBcbiAgLy8gaGFuZGxlIHdpbmRvdyByZXNpemVcbiAgZnVuY3Rpb24gaGFuZGxlUmVzaXplKGUpIHtcbiAgICBzY2VuZS5kcmF3KCk7XG4gIH1cbiAgXG4gIGxldCBjYW1lcmEgPSBzY2VuZS5jYW1lcmE7XG4gIGxldCB2aWV3UHJvamVjdGlvbk1hdCA9IHNjZW5lLnZpZXdQcm9qZWN0aW9uTWF0O1xuICBsZXQgdXBkYXRlVmlld1Byb2plY3Rpb24gPSBzY2VuZS51cGRhdGVWaWV3UHJvamVjdGlvbjtcbiAgbGV0IHN0YXJ0SW52Vmlld1Byb2pNYXQgPSBtYXQzLmNyZWF0ZSgpO1xuICBsZXQgc3RhcnRDYW1lcmE7XG4gIGxldCBzdGFydFBvcztcbiAgbGV0IHN0YXJ0Q2xpcFBvcztcbiAgXG4gIGxldCBtb3ZlZCA9IGZhbHNlO1xuICBcbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKTtcbiAgXG4gICAgbWF0My5pbnZlcnQoc3RhcnRJbnZWaWV3UHJvak1hdCwgdmlld1Byb2plY3Rpb25NYXQpO1xuICAgIFxuICAgIHN0YXJ0Q2FtZXJhID0gT2JqZWN0LmFzc2lnbih7fSwgY2FtZXJhKTtcbiAgICBzdGFydENsaXBQb3MgPSBnZXRDbGlwU3BhY2VNb3VzZVBvc2l0aW9uKGUpO1xuICAgIHN0YXJ0UG9zID0gdHJhbnNmb3JtUG9pbnQoXG4gICAgICAgIHN0YXJ0SW52Vmlld1Byb2pNYXQsXG4gICAgICAgIHN0YXJ0Q2xpcFBvcyk7XG4gICAgc2NlbmUuZHJhdygpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vdXNlV2hlZWwoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTsgIFxuICAgIGNvbnN0IFtjbGlwWCwgY2xpcFldID0gZ2V0Q2xpcFNwYWNlTW91c2VQb3NpdGlvbihlKTtcbiAgICAvLyBwb3NpdGlvbiBiZWZvcmUgem9vbWluZ1xuICAgIGxldCB0ZW1wID0gbWF0My5jcmVhdGUoKTtcbiAgICBtYXQzLmludmVydCh0ZW1wLCB2aWV3UHJvamVjdGlvbk1hdCk7IFxuICAgIGNvbnN0IFtwcmVab29tWCwgcHJlWm9vbVldID0gdHJhbnNmb3JtUG9pbnQoXG4gICAgICAgIHRlbXAsXG4gICAgICAgIFtjbGlwWCwgY2xpcFldKTtcbiAgICAgIFxuICAgIC8vIG11bHRpcGx5IHRoZSB3aGVlbCBtb3ZlbWVudCBieSB0aGUgY3VycmVudCB6b29tIGxldmVsXG4gICAgLy8gc28gd2Ugem9vbSBsZXNzIHdoZW4gem9vbWVkIGluIGFuZCBtb3JlIHdoZW4gem9vbWVkIG91dFxuICAgIGNvbnN0IG5ld1pvb20gPSBjYW1lcmEuem9vbSAqIE1hdGgucG93KDIsIGUuZGVsdGFZICogLTAuMDEpO1xuICAgIGNhbWVyYS56b29tID0gTWF0aC5tYXgoMC4wMiwgTWF0aC5taW4oMTAwLCBuZXdab29tKSk7XG4gICAgXG4gICAgdXBkYXRlVmlld1Byb2plY3Rpb24oKTtcbiAgICBcbiAgICAvLyBwb3NpdGlvbiBhZnRlciB6b29taW5nXG4gICAgbWF0My5pbnZlcnQodGVtcCwgdmlld1Byb2plY3Rpb25NYXQpOyBcbiAgICBjb25zdCBbcG9zdFpvb21YLCBwb3N0Wm9vbVldID0gdHJhbnNmb3JtUG9pbnQoXG4gICAgICAgIHRlbXAsXG4gICAgICAgIFtjbGlwWCwgY2xpcFldKTtcbiAgXG4gICAgLy8gY2FtZXJhIG5lZWRzIHRvIGJlIG1vdmVkIHRoZSBkaWZmZXJlbmNlIG9mIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICBjYW1lcmEueCArPSBwcmVab29tWCAtIHBvc3Rab29tWDtcbiAgICBjYW1lcmEueSArPSBwcmVab29tWSAtIHBvc3Rab29tWTsgIFxuICAgIFxuICAgIHNjZW5lLmRyYXcoKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZSkge1xuICAgIG1vdmVkID0gdHJ1ZTtcbiAgICBtb3ZlQ2FtZXJhKGUpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGUpIHtcbiAgICBzY2VuZS5kcmF3KCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKTtcbiAgICBcbiAgICAvLyBjaGVjayBpZiBtb3VzZSBjbGljayAobm90IGRyYWcpXG4gICAgaWYgKCFtb3ZlZCkge1xuICAgICAgY29uc29sZS5sb2coXCJtb3VzZSB0YXAhXCIpO1xuICAgICAgaGFuZGxlQ2xpY2soZSk7XG4gICAgfVxuICAgIG1vdmVkID0gZmFsc2U7XG4gIH1cbiAgXG4gIHZhciBuYW1lID0gXCJzdGFydFwiO1xuICBmdW5jdGlvbiBoYW5kbGVDbGljayhlKSB7XG4gICAgY29uc3QgcG9zID0gdHJhbnNmb3JtUG9pbnQoXG4gICAgICAgIHN0YXJ0SW52Vmlld1Byb2pNYXQsXG4gICAgICAgIGdldENsaXBTcGFjZU1vdXNlUG9zaXRpb24oZSkpO1xuICAgIFxuICAgIGNvbnRyb2xsZXIuc2V0Tm9kZShwb3MsIG5hbWUpO1xuICAgIG5hbWUgPSBuYW1lID09IFwic3RhcnRcIiA/IFwidGFyZ2V0XCIgOiBcInN0YXJ0XCI7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIG1vdmVDYW1lcmEoZSkge1xuICAgIGNvbnN0IHBvcyA9IHRyYW5zZm9ybVBvaW50KFxuICAgICAgICBzdGFydEludlZpZXdQcm9qTWF0LFxuICAgICAgICBnZXRDbGlwU3BhY2VNb3VzZVBvc2l0aW9uKGUpKTtcbiAgICBcbiAgICBjYW1lcmEueCA9IHN0YXJ0Q2FtZXJhLnggKyBzdGFydFBvc1swXSAtIHBvc1swXTtcbiAgICBjYW1lcmEueSA9IHN0YXJ0Q2FtZXJhLnkgKyBzdGFydFBvc1sxXSAtIHBvc1sxXTtcbiAgICBzY2VuZS5kcmF3KCk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KG0sIHYpIHtcbiAgICB2YXIgdjAgPSB2WzBdO1xuICAgIHZhciB2MSA9IHZbMV07XG4gICAgdmFyIGQgPSB2MCAqIG1bMCAqIDMgKyAyXSArIHYxICogbVsxICogMyArIDJdICsgbVsyICogMyArIDJdO1xuICAgIHJldHVybiBbXG4gICAgICAodjAgKiBtWzAgKiAzICsgMF0gKyB2MSAqIG1bMSAqIDMgKyAwXSArIG1bMiAqIDMgKyAwXSkgLyBkLFxuICAgICAgKHYwICogbVswICogMyArIDFdICsgdjEgKiBtWzEgKiAzICsgMV0gKyBtWzIgKiAzICsgMV0pIC8gZCxcbiAgICBdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENsaXBTcGFjZU1vdXNlUG9zaXRpb24oZSkge1xuICAvLyBnZXQgY2FudmFzIHJlbGF0aXZlIGNzcyBwb3NpdGlvblxuICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBjc3NYID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICBjb25zdCBjc3NZID0gZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gIFxuICAvLyBnZXQgbm9ybWFsaXplZCAwIHRvIDEgcG9zaXRpb24gYWNyb3NzIGFuZCBkb3duIGNhbnZhc1xuICBjb25zdCBub3JtYWxpemVkWCA9IGNzc1ggLyBjYW52YXMuY2xpZW50V2lkdGg7XG4gIGNvbnN0IG5vcm1hbGl6ZWRZID0gY3NzWSAvIGNhbnZhcy5jbGllbnRIZWlnaHQ7XG5cbiAgLy8gY29udmVydCB0byBjbGlwIHNwYWNlXG4gIGNvbnN0IGNsaXBYID0gbm9ybWFsaXplZFggKiAgMiAtIDE7XG4gIGNvbnN0IGNsaXBZID0gbm9ybWFsaXplZFkgKiAtMiArIDE7XG4gIFxuICByZXR1cm4gW2NsaXBYLCBjbGlwWV07XG59XG4iLCJjb25zdCByZXF1ZXN0ID0gcmVxdWlyZShcIi4vcmVxdWVzdFwiKTtcbmNvbnN0IGNyZWF0ZUdyYXBoID0gcmVxdWlyZShcIm5ncmFwaC5ncmFwaFwiKTtcbmNvbnN0IGVuZHBvaW50ID0gXCIuL2RhdGEvXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSwgcHJvZ3Jlc3MpIHtcbiAgbGV0IG5vZGVzO1xuICBsZXQgZWRnZXM7XG4gIGxldCBtYXBHcmFwaCA9IGNyZWF0ZUdyYXBoKCk7XG4gIFxuICByZXR1cm4gbG9hZE5vZGVzKClcbiAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICBzZXROb2RlQ29vcmRpbmF0ZXMocmVzKTtcbiAgICAgICAgICAgIHJldHVybiBsb2FkRWRnZXMoKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgIHNldEVkZ2VMaW5rcyhyZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbm9kZXMsIGVkZ2VzLCBtYXBHcmFwaFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gIFxuICBmdW5jdGlvbiBsb2FkTm9kZXMoKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QoZW5kcG9pbnQgKyBgJHtuYW1lfS5jby5iaW5gLCB7XG4gICAgICByZXNwb25zZVR5cGU6IFwiYXJyYXlidWZmZXJcIixcbiAgICAgIHByb2dyZXNzOiByZXBvcnRQcm9ncmVzcyhcIkxvYWRpbmcgbWFwIG5vZGVzXCIpXG4gICAgfSlcbiAgfVxuICBcbiAgZnVuY3Rpb24gbG9hZEVkZ2VzKCkge1xuICAgIHJldHVybiByZXF1ZXN0KGVuZHBvaW50ICsgYCR7bmFtZX0uZ3IuYmluYCwge1xuICAgICAgcmVzcG9uc2VUeXBlOiBcImFycmF5YnVmZmVyXCIsXG4gICAgICBwcm9ncmVzczogcmVwb3J0UHJvZ3Jlc3MoXCJMb2FkaW5nIG1hcCBlZGdlc1wiKVxuICAgIH0pXG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHNldE5vZGVDb29yZGluYXRlcyhidWZmZXIpIHtcbiAgICBub2RlcyA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7ICAgXG4gICAgLy8gYWRkIHRvIGdyYXBoIHN0cnVjdHVyZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoIC8gMjsgKytpKSB7XG4gICAgICBtYXBHcmFwaC5hZGROb2RlKGksIHtcbiAgICAgICAgeDogbm9kZXNbaSoyXSwgXG4gICAgICAgIHk6IG5vZGVzW2kqMiArIDFdXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHNldEVkZ2VMaW5rcyhidWZmZXIpIHtcbiAgICBlZGdlcyA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGggLyAyOyArK2kpIHtcbiAgICAgIGVkZ2VzW2kqMl0gLT0gMTtcbiAgICAgIGVkZ2VzW2kqMiArIDFdIC09IDE7XG4gICAgICBtYXBHcmFwaC5hZGRMaW5rKGVkZ2VzW2kqMl0sIGVkZ2VzW2kqMiArIDFdKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBvcnRQcm9ncmVzcyhtc2cpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgbGV0IHByb2cgPSB7fVxuICAgICAgcHJvZy5tZXNzYWdlID0gbXNnO1xuICAgICAgcHJvZy5jb21wbGV0ZWQgPSBNYXRoLnJvdW5kKGUucGVyY2VudCAqIDEwMCk7XG4gICAgICBwcm9ncmVzcyhwcm9nKTtcbiAgICB9IFxuICB9XG59IiwiY29uc3QgZDMgPSByZXF1aXJlKFwiZDMtcXVhZHRyZWVcIik7XG5jb25zdCBhU3RhciA9IHJlcXVpcmUoXCJuZ3JhcGgucGF0aFwiKS5hU3RhcjtcbmNvbnN0IGNvbG9ycyA9IHJlcXVpcmUoXCIuL3RoZW1lXCIpLmRlZmF1bHQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZ2wsIGdyYXBoLCB2ZXJ0cywgc2NlbmUsIHNoYXBlcykge1xuICAvLyBpbml0IHBhdGhmaW5kZXJcbiAgY29uc3QgcGF0aGZpbmRlciA9IGFTdGFyKGdyYXBoLCB7XG4gICAgZGlzdGFuY2U6IHB5dGhhZ29yZWFuRGlzdCxcbiAgICBoZXVyaXN0aWM6IHB5dGhhZ29yZWFuRGlzdFxuICB9KTtcbiAgXG4gIC8vIGluaXQgcXVhZHRyZWVcbiAgY29uc3QgcXVhZHRyZWUgPSBkMy5xdWFkdHJlZSgpXG4gICAgLngobiA9PiB7XG4gICAgICByZXR1cm4gbi5kYXRhLng7IFxuICAgIH0pXG4gICAgLnkobiA9PiB7XG4gICAgICByZXR1cm4gbi5kYXRhLnk7IFxuICAgIH0pO1xuXG4gIGdyYXBoLmZvckVhY2hOb2RlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBxdWFkdHJlZS5hZGQobm9kZSk7XG4gIH0pO1xuICBcbiAgY29uc3QgU1ROb2RlcyA9IHt9O1xuICB2YXIgc2VhcmNoRHJhd2luZztcbiAgXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGRlbGV0ZShTVE5vZGVzLnN0YXJ0KTsgXG4gICAgZGVsZXRlKFNUTm9kZXMudGFyZ2V0KTsgXG4gICAgc2NlbmUuY2xlYXJMYXllcihcIm1pZFwiKTtcbiAgICBzY2VuZS5jbGVhckxheWVyKFwidG9wXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHNldE5vZGUocG9zLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT0gXCJzdGFydFwiKSByZXNldCgpO1xuXG4gICAgY29uc3Qgbm9kZSA9IHF1YWR0cmVlLmZpbmQocG9zWzBdLCBwb3NbMV0pOyBcbiAgICBjb25zdCBbeCwgeV0gPSBbbm9kZS5kYXRhLngsIG5vZGUuZGF0YS55XTtcblxuICAgIGlmICghU1ROb2Rlc1tuYW1lXSkge1xuICAgICAgU1ROb2Rlc1tuYW1lXSA9IHtcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgc2NlbmVPYmpzOiBpbml0UGluKHgsIHksIG5hbWUpIFxuICAgICAgfVxuICAgIH0gXG4gICAgXG4gICAgU1ROb2Rlc1tuYW1lXS5ub2RlID0gbm9kZTtcbiAgICB1cGRhdGVQaW4oeCwgeSwgbmFtZSk7XG4gICAgc2NlbmUuZHJhdygpO1xuICAgIFxuICAgIGlmIChuYW1lID09IFwidGFyZ2V0XCIpIHN0YXJ0RmluZCgpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBpbml0UGluKHgsIHksIG5hbWUpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHNoYXBlc1tuYW1lXS5lbGVtZW50cztcbiAgICBjb25zdCBzY2VuZU9ianMgPSBbXTtcbiAgICBcbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGxldCB0cmFuc2Zvcm1zID0ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBzY2FsZTogZWwuc2NhbGUsXG4gICAgICAgIHpvb206IGZhbHNlIFxuICAgICAgfVxuICAgICAgXG4gICAgICBzY2VuZU9ianMucHVzaChcbiAgICAgICAgc2NlbmUuYWRkT2JqZWN0KGVsLnZlcnRzLCBlbC5pbmRpY2VzLCB7XG4gICAgICAgICAgY29sb3I6IGVsLmNvbG9yLFxuICAgICAgICAgIHR5cGU6IGVsLmRyYXdUeXBlLFxuICAgICAgICAgIGxheWVyOiBcInRvcFwiLFxuICAgICAgICAgIHRyYW5zZm9ybXM6IHRyYW5zZm9ybXNcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9KTtcblxuICAgIHJldHVybiBzY2VuZU9ianM7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHVwZGF0ZVBpbih4LCB5LCBuYW1lKSB7XG4gICAgU1ROb2Rlc1tuYW1lXS5zY2VuZU9ianMuZm9yRWFjaChvYmogPT4ge1xuICAgICAgb2JqLnRyYW5zZm9ybXMueCA9IHg7XG4gICAgICBvYmoudHJhbnNmb3Jtcy55ID0geTtcbiAgICB9KTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gc3RhcnRGaW5kKCkge1xuICAgIGlmICghU1ROb2Rlcy5zdGFydCB8fCAhU1ROb2Rlcy50YXJnZXQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJNaXNzaW5nIHN0YXJ0L3RhcmdldCBub2RlXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBsZXQgYSA9IFNUTm9kZXMuc3RhcnQ7XG4gICAgbGV0IGIgPSBTVE5vZGVzLnRhcmdldDtcbiAgICBjb25zdCBzZWFyY2hEYXRhID0gcGF0aGZpbmRlci5maW5kKGEubm9kZS5pZCwgYi5ub2RlLmlkKTtcbiAgICBjb25zdCBhbmltRGF0YSA9IG5ldyBVaW50MzJBcnJheShzZWFyY2hEYXRhLnZpc2l0ZWQucmV2ZXJzZSgpKTtcbiAgICBzZWFyY2hEcmF3aW5nID0gc2NlbmUuYWRkT2JqZWN0KHZlcnRzLCBhbmltRGF0YSwge1xuICAgICAgY29sb3I6IGNvbG9ycy5zZWFyY2hQYXRoLFxuICAgICAgdHlwZTogZ2wuTElORVMsXG4gICAgICBsYXllcjogXCJtaWRcIixcbiAgICB9KTtcblxuICAgIHZhciBvZmZzZXQgPSBhbmltRGF0YS5sZW5ndGggKiAgNDtcbiAgICBhbmltYXRlU2VhcmNoKCk7XG5cbiAgICBmdW5jdGlvbiBhbmltYXRlU2VhcmNoKCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IDwgMCA/IDAgOiBvZmZzZXQ7XG4gICAgICBzY2VuZS51cGRhdGVJbmRleE9mZnNldChhbmltRGF0YSwgb2Zmc2V0LCBzZWFyY2hEcmF3aW5nKTtcbiAgICAgIHNjZW5lLmRyYXcoKTtcbiAgICAgIFxuICAgICAgaWYgKG9mZnNldCAhPSAwKSB7XG4gICAgICAgIG9mZnNldCAtPSAxMDAgKiA0O1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZVNlYXJjaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcmF3UGF0aCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBkcmF3UGF0aCgpIHtcbiAgICAgIGRlYnVnZ2VyOyAgIFxuICAgIH1cbiAgfVxuICBcbiAgXG4gIHJldHVybiB7XG4gICAgc2V0Tm9kZSxcbiAgICBzdGFydEZpbmRcbiAgfVxufVxuXG5jb25zdCBtYW5oYXR0YW5EaXN0ID0gKGEsIGIpID0+IHtcbiAgbGV0IGR4ID0gYS5kYXRhLnggLSBiLmRhdGEueDtcbiAgbGV0IGR5ID0gYS5kYXRhLnkgLSBiLmRhdGEueTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59XG5cbmNvbnN0IHB5dGhhZ29yZWFuRGlzdCA9IChhLCBiKSA9PiB7XG4gIGxldCBkeCA9IGEuZGF0YS54IC0gYi5kYXRhLng7XG4gIGxldCBkeSA9IGEuZGF0YS55IC0gYi5kYXRhLnk7XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBnbHNsID0gcmVxdWlyZShcImdsc2xpZnlcIik7XG5jb25zdCB0d2dsID0gcmVxdWlyZShcInR3Z2wuanNcIik7XG5jb25zdCBtYXQzID0gcmVxdWlyZShcImdsLW1hdHJpeC9tYXQzXCIpO1xuXG5jb25zdCB2ZXJ0ZXhTaGFkZXIgPSBnbHNsKFtcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XFxuXFxudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgodV9tYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxKSkueHksIDAsIDEpO1xcbn1cIl0pO1xuY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBnbHNsKFtcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxuXFxudm9pZCBtYWluKCl7XFxuXFxuICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yO1xcblxcbn1cIl0pO1xuXG5jb25zdCBjb2xvcnMgPSByZXF1aXJlKFwiLi90aGVtZVwiKS5kZWZhdWx0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGdsKSB7XG4gIGNvbnN0IHByb2dyYW1JbmZvID0gdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdKTtcbiAgY29uc3QgcmVzb2x1dGlvbiA9IFtnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHRdOyBcbiAgY29uc3Qgdmlld1Byb2plY3Rpb25NYXQgPSBtYXQzLmNyZWF0ZSgpO1xuICBjb25zdCBzY2VuZUxheWVycyA9IHsgYmFzZTogW10sIG1pZDogW10sIHRvcDogW10gfTtcblxuICBjb25zdCBjYW1lcmEgPSB7XG4gICAgeDogLTMzOTQ4LFxuICAgIHk6IC0xNzY4OSxcbiAgICB6b29tOiAwLjAyNzEzMTFcbiAgIH1cblxuICB0d2dsLmFkZEV4dGVuc2lvbnNUb0NvbnRleHQoZ2wpO1xuICBcbiAgZnVuY3Rpb24gdXBkYXRlVmlld1Byb2plY3Rpb24oKSB7XG4gICAgbWF0My5wcm9qZWN0aW9uKHZpZXdQcm9qZWN0aW9uTWF0LCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIC8vIG1ha2UgY2FtZXJhIG1hdHJpeFxuICAgIGNvbnN0IHpvb21TY2FsZSA9IDEgLyBjYW1lcmEuem9vbTtcbiAgICBsZXQgY2FtZXJhTWF0ID0gbWF0My5jcmVhdGUoKTsgXG4gICAgbWF0My50cmFuc2xhdGUoY2FtZXJhTWF0LCBjYW1lcmFNYXQsIFtjYW1lcmEueCwgY2FtZXJhLnldKTtcbiAgICBtYXQzLnNjYWxlKGNhbWVyYU1hdCwgY2FtZXJhTWF0LCBbem9vbVNjYWxlLCB6b29tU2NhbGVdKTtcbiAgICBcbiAgICBsZXQgdmlld01hdCA9IG1hdDMuY3JlYXRlKCk7XG4gICAgbWF0My5pbnZlcnQodmlld01hdCwgY2FtZXJhTWF0KTtcbiAgICBtYXQzLm11bHRpcGx5KHZpZXdQcm9qZWN0aW9uTWF0LCB2aWV3UHJvamVjdGlvbk1hdCwgdmlld01hdCk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGNvbXB1dGVNYXRyaXhVbmlmb3JtKHRyYW5zZm9ybXMpIHtcbiAgICBsZXQgbWF0ID0gbWF0My5jcmVhdGUoKTtcbiAgICBtYXQzLmlkZW50aXR5KG1hdCk7XG4gICAgbWF0My50cmFuc2xhdGUobWF0LCBtYXQsIFt0cmFuc2Zvcm1zLngsIHRyYW5zZm9ybXMueV0pO1xuICAgIG1hdDMuc2NhbGUobWF0LCBtYXQsIFt0cmFuc2Zvcm1zLnNjYWxlLCB0cmFuc2Zvcm1zLnNjYWxlXSk7XG4gICAgXG4gICAgaWYgKCF0cmFuc2Zvcm1zLnpvb20pIHtcbiAgICAgIG1hdDMuc2NhbGUobWF0LCBtYXQsIFsxL2NhbWVyYS56b29tLCAxL2NhbWVyYS56b29tXSk7XG4gICAgfVxuICAgIFxuICAgIG1hdDMubXVsdGlwbHkobWF0LCB2aWV3UHJvamVjdGlvbk1hdCwgbWF0KTtcbiAgICByZXR1cm4gbWF0O1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkT2JqZWN0KHZlcnRzLCBpbmRzLCBwcm9wcykge1xuICAgIHByb3BzLnRyYW5zZm9ybXMgPSBwcm9wcy50cmFuc2Zvcm1zID8gcHJvcHMudHJhbnNmb3JtcyA6IHsgeDogMCwgeTogMCwgc2NhbGU6IDEsIHpvb206IHRydWUgfTtcbiAgICBwcm9wcy5sYXllciA9IHByb3BzLmxheWVyID8gcHJvcHMubGF5ZXIgOiBcIm1pZFwiO1xuICAgIHByb3BzLm9mZnNldCA9IHByb3BzLm9mZnNldCA/IHByb3BzLm9mZnNldCA6IDA7XG5cbiAgICBjb25zdCBidWZmZXJEYXRhID0ge1xuICAgICAgcG9zaXRpb246IHsgbnVtQ29tcG9uZW50czogMiwgZGF0YTogbmV3IEZsb2F0MzJBcnJheSh2ZXJ0cykgfSxcbiAgICAgIGluZGljZXM6ICB7IG51bUNvbXBvbmVudHM6IDIsIGRhdGE6IG5ldyBVaW50MzJBcnJheShpbmRzKSB9XG4gICAgfTtcbiAgICBjb25zdCBidWZmZXJJbmZvID0gdHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwgYnVmZmVyRGF0YSk7XG4gICAgY29uc3Qgb2JqID0ge1xuICAgICAgYnVmZmVySW5mbzogYnVmZmVySW5mbyxcbiAgICAgIGNvbG9yOiBwcm9wcy5jb2xvcixcbiAgICAgIGRyYXdUeXBlOiBwcm9wcy50eXBlLFxuICAgICAgdHJhbnNmb3JtczogcHJvcHMudHJhbnNmb3JtcyxcbiAgICAgIG9mZnNldDogcHJvcHMub2Zmc2V0XG4gICAgfTtcbiAgICBcbiAgICBpZiAodHlwZW9mIHByb3BzLmxheWVySW5kZXggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHNjZW5lTGF5ZXJzW3Byb3BzLmxheWVyXSA9IG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NlbmVMYXllcnNbcHJvcHMubGF5ZXJdLnB1c2gob2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBcbiAgZnVuY3Rpb24gdXBkYXRlSW5kZXhPZmZzZXQoaW5kcywgb2Zmc2V0LCBvYmopIHtcbiAgICBjb25zdCBidWZmZXJEYXRhID0ge1xuICAgICAgaW5kaWNlczogIHsgbnVtQ29tcG9uZW50czogMiwgZGF0YTogbmV3IFVpbnQzMkFycmF5KGluZHMuYnVmZmVyLCBvZmZzZXQpIH1cbiAgICB9O1xuICAgIG9iai5idWZmZXJJbmZvID0gdHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwgYnVmZmVyRGF0YSwgb2JqLmJ1ZmZlckluZm8pO1xuICB9XG4gIFxuICBmdW5jdGlvbiBkcmF3T2JqZWN0KG9iaikge1xuICAgIGNvbnN0IHVuaWZvcm1zID0ge1xuICAgICAgdV9jb2xvcjogb2JqLmNvbG9yLFxuICAgICAgdV9tYXRyaXg6IGNvbXB1dGVNYXRyaXhVbmlmb3JtKG9iai50cmFuc2Zvcm1zKVxuICAgIH1cbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW1JbmZvLnByb2dyYW0pO1xuICAgIHR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXMoZ2wsIHByb2dyYW1JbmZvLCBvYmouYnVmZmVySW5mbyk7XG4gICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgdW5pZm9ybXMpO1xuICAgIHR3Z2wuZHJhd0J1ZmZlckluZm8oZ2wsIG9iai5idWZmZXJJbmZvLCBvYmouZHJhd1R5cGUsIG9iai5idWZmZXJJbmZvLm51bUVsZW1lbnRzLCBvYmoub2Zmc2V0KTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gY2xlYXJMYXllcihsYXllcikge1xuICAgIHNjZW5lTGF5ZXJzW2xheWVyXS5sZW5ndGggPSAwO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIGFkZE9iamVjdCxcbiAgICB1cGRhdGVJbmRleE9mZnNldCxcbiAgICB1cGRhdGVWaWV3UHJvamVjdGlvbixcbiAgICBjbGVhckxheWVyLFxuICAgIGNhbWVyYSxcbiAgICB2aWV3UHJvamVjdGlvbk1hdCxcblxuICAgIGRyYXcoKSB7XG4gICAgICByZXNvbHV0aW9uWzBdID0gZ2wuY2FudmFzLndpZHRoOyBcbiAgICAgIHJlc29sdXRpb25bMV0gPSBnbC5jYW52YXMuaGVpZ2h0OyBcbiAgICAgIFxuICAgICAgdHdnbC5yZXNpemVDYW52YXNUb0Rpc3BsYXlTaXplKGdsLmNhbnZhcyk7XG5cbiAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7XG4gICAgICBnbC5jbGVhckNvbG9yKC4uLmNvbG9ycy5iYWNrZ3JvdW5kKTtcbiAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgXG4gICAgICB1cGRhdGVWaWV3UHJvamVjdGlvbigpO1xuICAgICAgXG4gICAgICBzY2VuZUxheWVycy5iYXNlLmZvckVhY2goZHJhd09iamVjdCk7XG4gICAgICBzY2VuZUxheWVycy5taWQuZm9yRWFjaChkcmF3T2JqZWN0KTtcbiAgICAgIHNjZW5lTGF5ZXJzLnRvcC5mb3JFYWNoKGRyYXdPYmplY3QpO1xuICAgIH1cbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWVzdDtcblxuZnVuY3Rpb24gcmVxdWVzdCh1cmwsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGRvd25sb2FkKTtcblxuICBmdW5jdGlvbiBkb3dubG9hZChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcS5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgdXBkYXRlUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXEuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdHJhbnNmZXJDb21wbGV0ZSwgZmFsc2UpO1xuICAgIHJlcS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdHJhbnNmZXJGYWlsZWQsIGZhbHNlKTtcbiAgICByZXEuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRyYW5zZmVyQ2FuY2VsZWQsIGZhbHNlKTtcblxuICAgIHJlcS5vcGVuKCdHRVQnLCB1cmwpO1xuICAgIGlmIChvcHRpb25zLnJlc3BvbnNlVHlwZSkge1xuICAgICAgcmVxLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlO1xuICAgIH1cbiAgICByZXEuc2VuZChudWxsKTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVByb2dyZXNzKGUpIHtcbiAgICAgIGlmIChlLmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmVzcyh7XG4gICAgICAgICAgbG9hZGVkOiBlLmxvYWRlZCxcbiAgICAgICAgICB0b3RhbDogZS50b3RhbCxcbiAgICAgICAgICBwZXJjZW50OiBlLmxvYWRlZCAvIGUudG90YWxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNmZXJDb21wbGV0ZSgpIHtcbiAgICAgIGlmIChyZXEuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgcmVqZWN0KGBVbmV4cGVjdGVkIHN0YXR1cyBjb2RlICR7cmVxLnN0YXR1c30gd2hlbiBjYWxsaW5nICR7dXJsfWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmVzcG9uc2UgPSByZXEucmVzcG9uc2U7XG5cbiAgICAgIGlmIChvcHRpb25zLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nICYmIHR5cGVvZiByZXNwb25zZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSUVcbiAgICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNmZXJGYWlsZWQoKSB7XG4gICAgICByZWplY3QoYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH1gKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2ZlckNhbmNlbGVkKCkge1xuICAgICAgcmVqZWN0KGBDYW5jZWxsZWQgZG93bmxvYWQgb2YgJHt1cmx9YCk7XG4gICAgfVxuICB9XG59IiwiY29uc3QgY29sb3JzID0gcmVxdWlyZShcIi4vdGhlbWVcIikuZGVmYXVsdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZ2wpIHtcbiAgcmV0dXJuIHtcbiAgICB0YXJnZXQ6IHtcbiAgICAgIGVsZW1lbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB2ZXJ0czogcHJpbWl0aXZlcy5waW4udmVydHMsXG4gICAgICAgICAgaW5kaWNlczogcHJpbWl0aXZlcy5waW4uaW5kaWNlcyxcbiAgICAgICAgICBjb2xvcjogY29sb3JzLnRhcmdldFBpbixcbiAgICAgICAgICBzY2FsZTogNSxcbiAgICAgICAgICBkcmF3VHlwZTogZ2wuVFJJQU5HTEVfRkFOXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB2ZXJ0czogcHJpbWl0aXZlcy5waW4xLnZlcnRzLFxuICAgICAgICAgIGluZGljZXM6IHByaW1pdGl2ZXMucGluMS5pbmRpY2VzLFxuICAgICAgICAgIGNvbG9yOiBjb2xvcnMudGFyZ2V0UGluMSxcbiAgICAgICAgICBzY2FsZTogNC4zLFxuICAgICAgICAgIGRyYXdUeXBlOiBnbC5UUklBTkdMRV9GQU5cbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSxcbiAgICBzdGFydDoge1xuICAgICAgZWxlbWVudHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHZlcnRzOiBwcmltaXRpdmVzLmNpcmNsZS52ZXJ0cyxcbiAgICAgICAgICBpbmRpY2VzOiBwcmltaXRpdmVzLmNpcmNsZS5pbmRpY2VzLFxuICAgICAgICAgIGNvbG9yOiBjb2xvcnMuc3RhcnRQaW4sXG4gICAgICAgICAgc2NhbGU6IDUsXG4gICAgICAgICAgZHJhd1R5cGU6IGdsLlRSSUFOR0xFX0ZBTiBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHZlcnRzOiBwcmltaXRpdmVzLmNpcmNsZS52ZXJ0cyxcbiAgICAgICAgICBpbmRpY2VzOiBwcmltaXRpdmVzLmNpcmNsZS5pbmRpY2VzLFxuICAgICAgICAgIGNvbG9yOiBjb2xvcnMuc3RhcnRQaW4xLFxuICAgICAgICAgIHNjYWxlOiA0LjUsXG4gICAgICAgICAgZHJhd1R5cGU6IGdsLlRSSUFOR0xFX0ZBTiBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHZlcnRzOiBwcmltaXRpdmVzLmNpcmNsZS52ZXJ0cyxcbiAgICAgICAgICBpbmRpY2VzOiBwcmltaXRpdmVzLmNpcmNsZS5pbmRpY2VzLFxuICAgICAgICAgIGNvbG9yOiBjb2xvcnMuc3RhcnRQaW4yLFxuICAgICAgICAgIHNjYWxlOiAyLFxuICAgICAgICAgIGRyYXdUeXBlOiBnbC5UUklBTkdMRV9GQU4gXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBwcmltaXRpdmVzID0ge1xuICBjaXJjbGU6IHtcbiAgICB2ZXJ0czogWzAsIDAsXG4gICAgICAgICAgICAwLCAtMy4wLFxuICAgICAgICAgICAgMS4wNCwgLTIuODE0LFxuICAgICAgICAgICAgMi4xMjEzLCAtMi4xMjEzLFxuICAgICAgICAgICAgMi44MTQsIC0xLjA0LFxuICAgICAgICAgICAgMy4wLCAwLFxuICAgICAgICAgICAgMi44MTQsIDEuMDQsIFxuICAgICAgICAgICAgMi4xMjEzLCAyLjEyMTMsXG4gICAgICAgICAgICAxLjA0LCAyLjgxNCwgXG4gICAgICAgICAgICAwLCAzLjAsXG4gICAgICAgICAgICAtMS4wNCwgMi44MTQsXG4gICAgICAgICAgICAtMi4xMjEzLCAyLjEyMTMsXG4gICAgICAgICAgICAtMi44MTQsIDEuMDQsXG4gICAgICAgICAgICAtMy4wLCAtMCxcbiAgICAgICAgICAgIC0yLjgxNCwgLTEuMDQsIFxuICAgICAgICAgICAgLTIuMTIxMywgLTIuMTIxMyxcbiAgICAgICAgICAgIC0xLjA0LCAtMi44MTRdLFxuICAgIGluZGljZXM6IFswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDFdLFxuICB9LFxuICBwaW46IHtcbiAgICB2ZXJ0czogWzAsIC03LFxuICAgICAgICAgICAgLTIuNiwgLTYuMCxcbiAgICAgICAgICAgIC0yLjYsIC03LFxuICAgICAgICAgICAgLTIuMCwgLTguNSxcbiAgICAgICAgICAgIC0wLjcsIC05LjQsXG4gICAgICAgICAgICAwLjcsIC05LjQsXG4gICAgICAgICAgICAyLjAsIC04LjUsXG4gICAgICAgICAgICAyLjYsIC03LFxuICAgICAgICAgICAgMi42LCAtNi4wLFxuICAgICAgICAgICAgMCwgMF0sXG4gICAgaW5kaWNlczogWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDFdLFxuICB9LFxuICBwaW4xOiB7XG4gICAgdmVydHM6IFswLCAtOCxcbiAgICAgICAgICAgIC0yLjYsIC03LjAsXG4gICAgICAgICAgICAtMi42LCAtOCxcbiAgICAgICAgICAgIC0yLjAsIC05LjUsXG4gICAgICAgICAgICAtMC43LCAtMTAuNCxcbiAgICAgICAgICAgIDAuNywgLTEwLjQsXG4gICAgICAgICAgICAyLjAsIC05LjUsXG4gICAgICAgICAgICAyLjYsIC04LFxuICAgICAgICAgICAgMi42LCAtNy4wLFxuICAgICAgICAgICAgMCwgLTFdLFxuICAgIGluZGljZXM6IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxXSxcbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWZhdWx0OiB7XG4gICAgYmFja2dyb3VuZDogWzAuMTU3LCAwLjE3MywgMC4yMDQsIDFdLFxuICAgIGJhc2VNYXA6IFsxLjAsIDEuMCwgMS4wLCAxXSxcbiAgICBzZWFyY2hQYXRoOiBbMC4yMjMsIDEsIDAuMDcsIDFdLFxuICAgIHBhdGg6IFtdLFxuXG4gICAgLy8gc3RhcnQgcGluIGNvbG9yc1xuICAgIHN0YXJ0UGluOiBbMC4wNSwgMC4zMCwgMC42NjksIDFdLFxuICAgIHN0YXJ0UGluMTogWzAuMiwgMC41NywgMC45NjksIDFdLFxuICAgIHN0YXJ0UGluMjogWzEsIDEsIDEsIDFdLFxuICAgIFxuICAgIC8vIHRhcmdldCBwaW4gY29sb3JzXG4gICAgdGFyZ2V0UGluOiBbMC40NSwgMC4wNywgMC4wNywgMV0sXG4gICAgdGFyZ2V0UGluMTogWzAuODAsIDAuMTcsIDAuMTcsIDFdLFxuICAgIHRhcmdldFBpbjI6IFswLjc1LCAwLjE3LCAwLjE3LCAxXSxcbiAgfVxufSJdfQ==
