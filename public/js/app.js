(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
exports.equals = equals;
exports.RANDOM = exports.ARRAY_TYPE = exports.EPSILON = void 0;

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

exports.RANDOM = RANDOM;

function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */


function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};
},{}],2:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.fromMat4 = fromMat4;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromMat2d = fromMat2d;
exports.fromQuat = fromQuat;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(9);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */


function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */


function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */


function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */


function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/


function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */


function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */


function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":1}],3:[function(require,module,exports){
module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}

},{}],4:[function(require,module,exports){
/*!
 * @license twgl.js 4.19.1 Copyright (c) 2015, Gregg Tavares All Rights Reserved.
 * Available via the MIT license.
 * see: http://github.com/greggman/twgl.js for details
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["twgl"] = factory();
	else
		root["twgl"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/twgl-full.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/attributes.js":
/*!***************************!*\
  !*** ./src/attributes.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.createAttribsFromArrays = createAttribsFromArrays;
exports.createBuffersFromArrays = createBuffersFromArrays;
exports.createBufferFromArray = createBufferFromArray;
exports.createBufferFromTypedArray = createBufferFromTypedArray;
exports.createBufferInfoFromArrays = createBufferInfoFromArrays;
exports.setAttribInfoBufferFromArray = setAttribInfoBufferFromArray;
exports.setAttributePrefix = setAttributePrefix;
exports.setAttributeDefaults_ = setDefaults;
exports.getNumComponents_ = getNumComponents;
exports.getArray_ = getArray;

var typedArrays = _interopRequireWildcard(__webpack_require__(/*! ./typedarrays.js */ "./src/typedarrays.js"));

var helper = _interopRequireWildcard(__webpack_require__(/*! ./helper.js */ "./src/helper.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
var STATIC_DRAW = 0x88e4;
var ARRAY_BUFFER = 0x8892;
var ELEMENT_ARRAY_BUFFER = 0x8893;
var BUFFER_SIZE = 0x8764;
var BYTE = 0x1400;
var UNSIGNED_BYTE = 0x1401;
var SHORT = 0x1402;
var UNSIGNED_SHORT = 0x1403;
var INT = 0x1404;
var UNSIGNED_INT = 0x1405;
var FLOAT = 0x1406;
/**
 * Low level attribute and buffer related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.attributes` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/attributes
 */
// make sure we don't see a global gl

var gl = undefined;
/* eslint-disable-line */

var defaults = {
  attribPrefix: ""
};
/**
 * Sets the default attrib prefix
 *
 * When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`
 * as it makes it clear where they came from. But, when building geometry I prefer using un-prefixed names.
 *
 * In other words I'll create arrays of geometry like this
 *
 *     var arrays = {
 *       position: ...
 *       normal: ...
 *       texcoord: ...
 *     };
 *
 * But need those mapped to attributes and my attributes start with `a_`.
 *
 * @deprecated see {@link module:twgl.setDefaults}
 * @param {string} prefix prefix for attribs
 * @memberOf module:twgl/attributes
 */

function setAttributePrefix(prefix) {
  defaults.attribPrefix = prefix;
}

function setDefaults(newDefaults) {
  helper.copyExistingProperties(newDefaults, defaults);
}

function setBufferFromTypedArray(gl, type, buffer, array, drawType) {
  gl.bindBuffer(type, buffer);
  gl.bufferData(type, array, drawType || STATIC_DRAW);
}
/**
 * Given typed array creates a WebGLBuffer and copies the typed array
 * into it.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {ArrayBuffer|SharedArrayBuffer|ArrayBufferView|WebGLBuffer} typedArray the typed array. Note: If a WebGLBuffer is passed in it will just be returned. No action will be taken
 * @param {number} [type] the GL bind type for the buffer. Default = `gl.ARRAY_BUFFER`.
 * @param {number} [drawType] the GL draw type for the buffer. Default = 'gl.STATIC_DRAW`.
 * @return {WebGLBuffer} the created WebGLBuffer
 * @memberOf module:twgl/attributes
 */


function createBufferFromTypedArray(gl, typedArray, type, drawType) {
  if (helper.isBuffer(gl, typedArray)) {
    return typedArray;
  }

  type = type || ARRAY_BUFFER;
  var buffer = gl.createBuffer();
  setBufferFromTypedArray(gl, type, buffer, typedArray, drawType);
  return buffer;
}

function isIndices(name) {
  return name === "indices";
} // This is really just a guess. Though I can't really imagine using
// anything else? Maybe for some compression?


function getNormalizationForTypedArray(typedArray) {
  if (typedArray instanceof Int8Array) {
    return true;
  } // eslint-disable-line


  if (typedArray instanceof Uint8Array) {
    return true;
  } // eslint-disable-line


  return false;
} // This is really just a guess. Though I can't really imagine using
// anything else? Maybe for some compression?


function getNormalizationForTypedArrayType(typedArrayType) {
  if (typedArrayType === Int8Array) {
    return true;
  } // eslint-disable-line


  if (typedArrayType === Uint8Array) {
    return true;
  } // eslint-disable-line


  return false;
}

function getArray(array) {
  return array.length ? array : array.data;
}

var texcoordRE = /coord|texture/i;
var colorRE = /color|colour/i;

function guessNumComponentsFromName(name, length) {
  var numComponents;

  if (texcoordRE.test(name)) {
    numComponents = 2;
  } else if (colorRE.test(name)) {
    numComponents = 4;
  } else {
    numComponents = 3; // position, normals, indices ...
  }

  if (length % numComponents > 0) {
    throw new Error("Can not guess numComponents for attribute '".concat(name, "'. Tried ").concat(numComponents, " but ").concat(length, " values is not evenly divisible by ").concat(numComponents, ". You should specify it."));
  }

  return numComponents;
}

function getNumComponents(array, arrayName) {
  return array.numComponents || array.size || guessNumComponentsFromName(arrayName, getArray(array).length);
}

function makeTypedArray(array, name) {
  if (typedArrays.isArrayBuffer(array)) {
    return array;
  }

  if (typedArrays.isArrayBuffer(array.data)) {
    return array.data;
  }

  if (Array.isArray(array)) {
    array = {
      data: array
    };
  }

  var Type = array.type;

  if (!Type) {
    if (isIndices(name)) {
      Type = Uint16Array;
    } else {
      Type = Float32Array;
    }
  }

  return new Type(array.data);
}
/**
 * The info for an attribute. This is effectively just the arguments to `gl.vertexAttribPointer` plus the WebGLBuffer
 * for the attribute.
 *
 * @typedef {Object} AttribInfo
 * @property {number[]|ArrayBufferView} [value] a constant value for the attribute. Note: if this is set the attribute will be
 *    disabled and set to this constant value and all other values will be ignored.
 * @property {number} [numComponents] the number of components for this attribute.
 * @property {number} [size] synonym for `numComponents`.
 * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`
 * @property {boolean} [normalize] whether or not to normalize the data. Default = false
 * @property {number} [offset] offset into buffer in bytes. Default = 0
 * @property {number} [stride] the stride in bytes per element. Default = 0
 * @property {number} [divisor] the divisor in instances. Default = undefined. Note: undefined = don't call gl.vertexAttribDivisor
 *    where as anything else = do call it with this value
 * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute
 * @property {number} [drawType] the draw type passed to gl.bufferData. Default = gl.STATIC_DRAW
 * @memberOf module:twgl
 */

/**
 * Use this type of array spec when TWGL can't guess the type or number of components of an array
 * @typedef {Object} FullArraySpec
 * @property {number[]|ArrayBufferView} [value] a constant value for the attribute. Note: if this is set the attribute will be
 *    disabled and set to this constant value and all other values will be ignored.
 * @property {(number|number[]|ArrayBufferView)} data The data of the array. A number alone becomes the number of elements of type.
 * @property {number} [numComponents] number of components for `vertexAttribPointer`. Default is based on the name of the array.
 *    If `coord` is in the name assumes `numComponents = 2`.
 *    If `color` is in the name assumes `numComponents = 4`.
 *    otherwise assumes `numComponents = 3`
 * @property {constructor} [type] type. This is only used if `data` is a JavaScript array. It is the constructor for the typedarray. (eg. `Uint8Array`).
 * For example if you want colors in a `Uint8Array` you might have a `FullArraySpec` like `{ type: Uint8Array, data: [255,0,255,255, ...], }`.
 * @property {number} [size] synonym for `numComponents`.
 * @property {boolean} [normalize] normalize for `vertexAttribPointer`. Default is true if type is `Int8Array` or `Uint8Array` otherwise false.
 * @property {number} [stride] stride for `vertexAttribPointer`. Default = 0
 * @property {number} [offset] offset for `vertexAttribPointer`. Default = 0
 * @property {number} [divisor] divisor for `vertexAttribDivisor`. Default = undefined. Note: undefined = don't call gl.vertexAttribDivisor
 *    where as anything else = do call it with this value
 * @property {string} [attrib] name of attribute this array maps to. Defaults to same name as array prefixed by the default attribPrefix.
 * @property {string} [name] synonym for `attrib`.
 * @property {string} [attribName] synonym for `attrib`.
 * @property {WebGLBuffer} [buffer] Buffer to use for this attribute. This lets you use your own buffer
 *    but you will need to supply `numComponents` and `type`. You can effectively pass an `AttribInfo`
 *    to provide this. Example:
 *
 *         const bufferInfo1 = twgl.createBufferInfoFromArrays(gl, {
 *           position: [1, 2, 3, ... ],
 *         });
 *         const bufferInfo2 = twgl.createBufferInfoFromArrays(gl, {
 *           position: bufferInfo1.attribs.position,  // use the same buffer from bufferInfo1
 *         });
 *
 * @memberOf module:twgl
 */

/**
 * An individual array in {@link module:twgl.Arrays}
 *
 * When passed to {@link module:twgl.createBufferInfoFromArrays} if an ArraySpec is `number[]` or `ArrayBufferView`
 * the types will be guessed based on the name. `indices` will be `Uint16Array`, everything else will
 * be `Float32Array`. If an ArraySpec is a number it's the number of floats for an empty (zeroed) buffer.
 *
 * @typedef {(number|number[]|ArrayBufferView|module:twgl.FullArraySpec)} ArraySpec
 * @memberOf module:twgl
 */

/**
 * This is a JavaScript object of arrays by name. The names should match your shader's attributes. If your
 * attributes have a common prefix you can specify it by calling {@link module:twgl.setAttributePrefix}.
 *
 *     Bare JavaScript Arrays
 *
 *         var arrays = {
 *            position: [-1, 1, 0],
 *            normal: [0, 1, 0],
 *            ...
 *         }
 *
 *     Bare TypedArrays
 *
 *         var arrays = {
 *            position: new Float32Array([-1, 1, 0]),
 *            color: new Uint8Array([255, 128, 64, 255]),
 *            ...
 *         }
 *
 * *   Will guess at `numComponents` if not specified based on name.
 *
 *     If `coord` is in the name assumes `numComponents = 2`
 *
 *     If `color` is in the name assumes `numComponents = 4`
 *
 *     otherwise assumes `numComponents = 3`
 *
 * Objects with various fields. See {@link module:twgl.FullArraySpec}.
 *
 *     var arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *     };
 *
 * @typedef {Object.<string, module:twgl.ArraySpec>} Arrays
 * @memberOf module:twgl
 */

/**
 * Creates a set of attribute data and WebGLBuffers from set of arrays
 *
 * Given
 *
 *      var arrays = {
 *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },
 *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *      };
 *
 * returns something like
 *
 *      var attribs = {
 *        position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },
 *      };
 *
 * notes:
 *
 * *   Arrays can take various forms
 *
 *     Bare JavaScript Arrays
 *
 *         var arrays = {
 *            position: [-1, 1, 0],
 *            normal: [0, 1, 0],
 *            ...
 *         }
 *
 *     Bare TypedArrays
 *
 *         var arrays = {
 *            position: new Float32Array([-1, 1, 0]),
 *            color: new Uint8Array([255, 128, 64, 255]),
 *            ...
 *         }
 *
 * *   Will guess at `numComponents` if not specified based on name.
 *
 *     If `coord` is in the name assumes `numComponents = 2`
 *
 *     If `color` is in the name assumes `numComponents = 4`
 *
 *     otherwise assumes `numComponents = 3`
 *
 * @param {WebGLRenderingContext} gl The webgl rendering context.
 * @param {module:twgl.Arrays} arrays The arrays
 * @param {module:twgl.BufferInfo} [srcBufferInfo] a BufferInfo to copy from
 *   This lets you share buffers. Any arrays you supply will override
 *   the buffers from srcBufferInfo.
 * @return {Object.<string, module:twgl.AttribInfo>} the attribs
 * @memberOf module:twgl/attributes
 */


function createAttribsFromArrays(gl, arrays) {
  var attribs = {};
  Object.keys(arrays).forEach(function (arrayName) {
    if (!isIndices(arrayName)) {
      var array = arrays[arrayName];
      var attribName = array.attrib || array.name || array.attribName || defaults.attribPrefix + arrayName;

      if (array.value) {
        if (!Array.isArray(array.value) && !typedArrays.isArrayBuffer(array.value)) {
          throw new Error('array.value is not array or typedarray');
        }

        attribs[attribName] = {
          value: array.value
        };
      } else {
        var buffer;
        var type;
        var normalization;
        var numComponents;

        if (array.buffer && array.buffer instanceof WebGLBuffer) {
          buffer = array.buffer;
          numComponents = array.numComponents || array.size;
          type = array.type;
          normalization = array.normalize;
        } else if (typeof array === "number" || typeof array.data === "number") {
          var numValues = array.data || array;
          var arrayType = array.type || Float32Array;
          var numBytes = numValues * arrayType.BYTES_PER_ELEMENT;
          type = typedArrays.getGLTypeForTypedArrayType(arrayType);
          normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArrayType(arrayType);
          numComponents = array.numComponents || array.size || guessNumComponentsFromName(arrayName, numValues);
          buffer = gl.createBuffer();
          gl.bindBuffer(ARRAY_BUFFER, buffer);
          gl.bufferData(ARRAY_BUFFER, numBytes, array.drawType || STATIC_DRAW);
        } else {
          var typedArray = makeTypedArray(array, arrayName);
          buffer = createBufferFromTypedArray(gl, typedArray, undefined, array.drawType);
          type = typedArrays.getGLTypeForTypedArray(typedArray);
          normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArray(typedArray);
          numComponents = getNumComponents(array, arrayName);
        }

        attribs[attribName] = {
          buffer: buffer,
          numComponents: numComponents,
          type: type,
          normalize: normalization,
          stride: array.stride || 0,
          offset: array.offset || 0,
          divisor: array.divisor === undefined ? undefined : array.divisor,
          drawType: array.drawType
        };
      }
    }
  });
  gl.bindBuffer(ARRAY_BUFFER, null);
  return attribs;
}
/**
 * Sets the contents of a buffer attached to an attribInfo
 *
 * This is helper function to dynamically update a buffer.
 *
 * Let's say you make a bufferInfo
 *
 *     var arrays = {
 *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),
 *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),
 *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),
 *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),
 *     };
 *     var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
 *
 *  And you want to dynamically update the positions. You could do this
 *
 *     // assuming arrays.position has already been updated with new data.
 *     twgl.setAttribInfoBufferFromArray(gl, bufferInfo.attribs.position, arrays.position);
 *
 * @param {WebGLRenderingContext} gl
 * @param {AttribInfo} attribInfo The attribInfo who's buffer contents to set. NOTE: If you have an attribute prefix
 *   the name of the attribute will include the prefix.
 * @param {ArraySpec} array Note: it is arguably inefficient to pass in anything but a typed array because anything
 *    else will have to be converted to a typed array before it can be used by WebGL. During init time that
 *    inefficiency is usually not important but if you're updating data dynamically best to be efficient.
 * @param {number} [offset] an optional offset into the buffer. This is only an offset into the WebGL buffer
 *    not the array. To pass in an offset into the array itself use a typed array and create an `ArrayBufferView`
 *    for the portion of the array you want to use.
 *
 *        var someArray = new Float32Array(1000); // an array with 1000 floats
 *        var someSubArray = new Float32Array(someArray.buffer, offsetInBytes, sizeInUnits); // a view into someArray
 *
 *    Now you can pass `someSubArray` into setAttribInfoBufferFromArray`
 * @memberOf module:twgl/attributes
 */


function setAttribInfoBufferFromArray(gl, attribInfo, array, offset) {
  array = makeTypedArray(array);

  if (offset !== undefined) {
    gl.bindBuffer(ARRAY_BUFFER, attribInfo.buffer);
    gl.bufferSubData(ARRAY_BUFFER, offset, array);
  } else {
    setBufferFromTypedArray(gl, ARRAY_BUFFER, attribInfo.buffer, array, attribInfo.drawType);
  }
}

function getBytesPerValueForGLType(gl, type) {
  if (type === BYTE) return 1; // eslint-disable-line

  if (type === UNSIGNED_BYTE) return 1; // eslint-disable-line

  if (type === SHORT) return 2; // eslint-disable-line

  if (type === UNSIGNED_SHORT) return 2; // eslint-disable-line

  if (type === INT) return 4; // eslint-disable-line

  if (type === UNSIGNED_INT) return 4; // eslint-disable-line

  if (type === FLOAT) return 4; // eslint-disable-line

  return 0;
} // Tries to get the number of elements from a set of arrays.


var positionKeys = ['position', 'positions', 'a_position'];

function getNumElementsFromNonIndexedArrays(arrays) {
  var key;
  var ii;

  for (ii = 0; ii < positionKeys.length; ++ii) {
    key = positionKeys[ii];

    if (key in arrays) {
      break;
    }
  }

  if (ii === positionKeys.length) {
    key = Object.keys(arrays)[0];
  }

  var array = arrays[key];
  var length = getArray(array).length;
  var numComponents = getNumComponents(array, key);
  var numElements = length / numComponents;

  if (length % numComponents > 0) {
    throw new Error("numComponents ".concat(numComponents, " not correct for length ").concat(length));
  }

  return numElements;
}

function getNumElementsFromAttributes(gl, attribs) {
  var key;
  var ii;

  for (ii = 0; ii < positionKeys.length; ++ii) {
    key = positionKeys[ii];

    if (key in attribs) {
      break;
    }

    key = defaults.attribPrefix + key;

    if (key in attribs) {
      break;
    }
  }

  if (ii === positionKeys.length) {
    key = Object.keys(attribs)[0];
  }

  var attrib = attribs[key];
  gl.bindBuffer(ARRAY_BUFFER, attrib.buffer);
  var numBytes = gl.getBufferParameter(ARRAY_BUFFER, BUFFER_SIZE);
  gl.bindBuffer(ARRAY_BUFFER, null);
  var bytesPerValue = getBytesPerValueForGLType(gl, attrib.type);
  var totalElements = numBytes / bytesPerValue;
  var numComponents = attrib.numComponents || attrib.size; // TODO: check stride

  var numElements = totalElements / numComponents;

  if (numElements % 1 !== 0) {
    throw new Error("numComponents ".concat(numComponents, " not correct for length ").concat(length));
  }

  return numElements;
}
/**
 * @typedef {Object} BufferInfo
 * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.
 * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..
 * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.
 * @property {Object.<string, module:twgl.AttribInfo>} [attribs] The attribs appropriate to call `setAttributes`
 * @memberOf module:twgl
 */

/**
 * Creates a BufferInfo from an object of arrays.
 *
 * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to
 * {@link module:twgl:drawBufferInfo}.
 *
 * Given an object like
 *
 *     var arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *     };
 *
 *  Creates an BufferInfo like this
 *
 *     bufferInfo = {
 *       numElements: 4,        // or whatever the number of elements is
 *       indices: WebGLBuffer,  // this property will not exist if there are no indices
 *       attribs: {
 *         position: { buffer: WebGLBuffer, numComponents: 3, },
 *         normal:   { buffer: WebGLBuffer, numComponents: 3, },
 *         texcoord: { buffer: WebGLBuffer, numComponents: 2, },
 *       },
 *     };
 *
 *  The properties of arrays can be JavaScript arrays in which case the number of components
 *  will be guessed.
 *
 *     var arrays = {
 *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],
 *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],
 *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
 *        indices:  [0, 1, 2, 1, 2, 3],
 *     };
 *
 *  They can also be TypedArrays
 *
 *     var arrays = {
 *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),
 *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),
 *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),
 *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),
 *     };
 *
 *  Or AugmentedTypedArrays
 *
 *     var positions = createAugmentedTypedArray(3, 4);
 *     var texcoords = createAugmentedTypedArray(2, 4);
 *     var normals   = createAugmentedTypedArray(3, 4);
 *     var indices   = createAugmentedTypedArray(3, 2, Uint16Array);
 *
 *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);
 *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);
 *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
 *     indices.push([0, 1, 2, 1, 2, 3]);
 *
 *     var arrays = {
 *        position: positions,
 *        texcoord: texcoords,
 *        normal:   normals,
 *        indices:  indices,
 *     };
 *
 * For the last example it is equivalent to
 *
 *     var bufferInfo = {
 *       attribs: {
 *         position: { numComponents: 3, buffer: gl.createBuffer(), },
 *         texcoord: { numComponents: 2, buffer: gl.createBuffer(), },
 *         normal: { numComponents: 3, buffer: gl.createBuffer(), },
 *       },
 *       indices: gl.createBuffer(),
 *       numElements: 6,
 *     };
 *
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.position.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.texcoord.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.normal.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);
 *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.Arrays} arrays Your data
 * @param {module:twgl.BufferInfo} [srcBufferInfo] An existing
 *        buffer info to start from. WebGLBuffers etc specified
 *        in the srcBufferInfo will be used in a new BufferInfo
 *        with any arrays specified overriding the ones in
 *        srcBufferInfo.
 * @return {module:twgl.BufferInfo} A BufferInfo
 * @memberOf module:twgl/attributes
 */


function createBufferInfoFromArrays(gl, arrays, srcBufferInfo) {
  var newAttribs = createAttribsFromArrays(gl, arrays);
  var bufferInfo = Object.assign({}, srcBufferInfo ? srcBufferInfo : {});
  bufferInfo.attribs = Object.assign({}, srcBufferInfo ? srcBufferInfo.attribs : {}, newAttribs);
  var indices = arrays.indices;

  if (indices) {
    var newIndices = makeTypedArray(indices, "indices");
    bufferInfo.indices = createBufferFromTypedArray(gl, newIndices, ELEMENT_ARRAY_BUFFER);
    bufferInfo.numElements = newIndices.length;
    bufferInfo.elementType = typedArrays.getGLTypeForTypedArray(newIndices);
  } else if (!bufferInfo.numElements) {
    bufferInfo.numElements = getNumElementsFromAttributes(gl, bufferInfo.attribs);
  }

  return bufferInfo;
}
/**
 * Creates a buffer from an array, typed array, or array spec
 *
 * Given something like this
 *
 *     [1, 2, 3],
 *
 * or
 *
 *     new Uint16Array([1,2,3]);
 *
 * or
 *
 *     {
 *        data: [1, 2, 3],
 *        type: Uint8Array,
 *     }
 *
 * returns a WebGLBuffer that contains the given data.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {module:twgl.ArraySpec} array an array, typed array, or array spec.
 * @param {string} arrayName name of array. Used to guess the type if type can not be derived otherwise.
 * @return {WebGLBuffer} a WebGLBuffer containing the data in array.
 * @memberOf module:twgl/attributes
 */


function createBufferFromArray(gl, array, arrayName) {
  var type = arrayName === "indices" ? ELEMENT_ARRAY_BUFFER : ARRAY_BUFFER;
  var typedArray = makeTypedArray(array, arrayName);
  return createBufferFromTypedArray(gl, typedArray, type);
}
/**
 * Creates buffers from arrays or typed arrays
 *
 * Given something like this
 *
 *     var arrays = {
 *        positions: [1, 2, 3],
 *        normals: [0, 0, 1],
 *     }
 *
 * returns something like
 *
 *     buffers = {
 *       positions: WebGLBuffer,
 *       normals: WebGLBuffer,
 *     }
 *
 * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {module:twgl.Arrays} arrays
 * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array
 * @memberOf module:twgl/attributes
 */


function createBuffersFromArrays(gl, arrays) {
  var buffers = {};
  Object.keys(arrays).forEach(function (key) {
    buffers[key] = createBufferFromArray(gl, arrays[key], key);
  }); // Ugh!

  if (arrays.indices) {
    buffers.numElements = arrays.indices.length;
    buffers.elementType = typedArrays.getGLTypeForTypedArray(makeTypedArray(arrays.indices), 'indices');
  } else {
    buffers.numElements = getNumElementsFromNonIndexedArrays(arrays);
  }

  return buffers;
}

/***/ }),

/***/ "./src/draw.js":
/*!*********************!*\
  !*** ./src/draw.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.drawBufferInfo = drawBufferInfo;
exports.drawObjectList = drawObjectList;

var programs = _interopRequireWildcard(__webpack_require__(/*! ./programs.js */ "./src/programs.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
var TRIANGLES = 0x0004;
var UNSIGNED_SHORT = 0x1403;
/**
 * Drawing related functions
 *
 * For backward compatibility they are available at both `twgl.draw` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/draw
 */

/**
 * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate
 *
 * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself
 * but calling this means if you switch from indexed data to non-indexed
 * data you don't have to remember to update your draw call.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} bufferInfo A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays} or
 *   a VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}
 * @param {number} [type] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...). Defaults to `gl.TRIANGLES`
 * @param {number} [count] An optional count. Defaults to bufferInfo.numElements
 * @param {number} [offset] An optional offset. Defaults to 0.
 * @param {number} [instanceCount] An optional instanceCount. if set then `drawArraysInstanced` or `drawElementsInstanced` will be called
 * @memberOf module:twgl/draw
 */

function drawBufferInfo(gl, bufferInfo, type, count, offset, instanceCount) {
  type = type === undefined ? TRIANGLES : type;
  var indices = bufferInfo.indices;
  var elementType = bufferInfo.elementType;
  var numElements = count === undefined ? bufferInfo.numElements : count;
  offset = offset === undefined ? 0 : offset;

  if (elementType || indices) {
    if (instanceCount !== undefined) {
      gl.drawElementsInstanced(type, numElements, elementType === undefined ? UNSIGNED_SHORT : bufferInfo.elementType, offset, instanceCount);
    } else {
      gl.drawElements(type, numElements, elementType === undefined ? UNSIGNED_SHORT : bufferInfo.elementType, offset);
    }
  } else {
    if (instanceCount !== undefined) {
      gl.drawArraysInstanced(type, offset, numElements, instanceCount);
    } else {
      gl.drawArrays(type, offset, numElements);
    }
  }
}
/**
 * A DrawObject is useful for putting objects in to an array and passing them to {@link module:twgl.drawObjectList}.
 *
 * You need either a `BufferInfo` or a `VertexArrayInfo`.
 *
 * @typedef {Object} DrawObject
 * @property {boolean} [active] whether or not to draw. Default = `true` (must be `false` to be not true). In other words `undefined` = `true`
 * @property {number} [type] type to draw eg. `gl.TRIANGLES`, `gl.LINES`, etc...
 * @property {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}
 * @property {module:twgl.BufferInfo} [bufferInfo] A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays}
 * @property {module:twgl.VertexArrayInfo} [vertexArrayInfo] A VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}
 * @property {Object<string, ?>} uniforms The values for the uniforms.
 *   You can pass multiple objects by putting them in an array. For example
 *
 *     var sharedUniforms = {
 *       u_fogNear: 10,
 *       u_projection: ...
 *       ...
 *     };
 *
 *     var localUniforms = {
 *       u_world: ...
 *       u_diffuseColor: ...
 *     };
 *
 *     var drawObj = {
 *       ...
 *       uniforms: [sharedUniforms, localUniforms],
 *     };
 *
 * @property {number} [offset] the offset to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to 0.
 * @property {number} [count] the count to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to bufferInfo.numElements.
 * @property {number} [instanceCount] the number of instances. Defaults to undefined.
 * @memberOf module:twgl
 */

/**
 * Draws a list of objects
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {DrawObject[]} objectsToDraw an array of objects to draw.
 * @memberOf module:twgl/draw
 */


function drawObjectList(gl, objectsToDraw) {
  var lastUsedProgramInfo = null;
  var lastUsedBufferInfo = null;
  objectsToDraw.forEach(function (object) {
    if (object.active === false) {
      return;
    }

    var programInfo = object.programInfo;
    var bufferInfo = object.vertexArrayInfo || object.bufferInfo;
    var bindBuffers = false;
    var type = object.type === undefined ? TRIANGLES : object.type;

    if (programInfo !== lastUsedProgramInfo) {
      lastUsedProgramInfo = programInfo;
      gl.useProgram(programInfo.program); // We have to rebind buffers when changing programs because we
      // only bind buffers the program uses. So if 2 programs use the same
      // bufferInfo but the 1st one uses only positions the when the
      // we switch to the 2nd one some of the attributes will not be on.

      bindBuffers = true;
    } // Setup all the needed attributes.


    if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {
      if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject && !bufferInfo.vertexArrayObject) {
        gl.bindVertexArray(null);
      }

      lastUsedBufferInfo = bufferInfo;
      programs.setBuffersAndAttributes(gl, programInfo, bufferInfo);
    } // Set the uniforms.


    programs.setUniforms(programInfo, object.uniforms); // Draw

    drawBufferInfo(gl, bufferInfo, type, object.count, object.offset, object.instanceCount);
  });

  if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject) {
    gl.bindVertexArray(null);
  }
}

/***/ }),

/***/ "./src/framebuffers.js":
/*!*****************************!*\
  !*** ./src/framebuffers.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.bindFramebufferInfo = bindFramebufferInfo;
exports.createFramebufferInfo = createFramebufferInfo;
exports.resizeFramebufferInfo = resizeFramebufferInfo;

var textures = _interopRequireWildcard(__webpack_require__(/*! ./textures.js */ "./src/textures.js"));

var helper = _interopRequireWildcard(__webpack_require__(/*! ./helper.js */ "./src/helper.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Framebuffer related functions
 *
 * For backward compatibility they are available at both `twgl.framebuffer` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/framebuffers
 */
// make sure we don't see a global gl
var gl = undefined;
/* eslint-disable-line */

var FRAMEBUFFER = 0x8d40;
var RENDERBUFFER = 0x8d41;
var TEXTURE_2D = 0x0de1;
var UNSIGNED_BYTE = 0x1401;
/* PixelFormat */

var DEPTH_COMPONENT = 0x1902;
var RGBA = 0x1908;
var DEPTH_COMPONENT24 = 0x81a6;
var DEPTH_COMPONENT32F = 0x8cac;
var DEPTH24_STENCIL8 = 0x88f0;
var DEPTH32F_STENCIL8 = 0x8cad;
/* Framebuffer Object. */

var RGBA4 = 0x8056;
var RGB5_A1 = 0x8057;
var RGB565 = 0x8D62;
var DEPTH_COMPONENT16 = 0x81A5;
var STENCIL_INDEX = 0x1901;
var STENCIL_INDEX8 = 0x8D48;
var DEPTH_STENCIL = 0x84F9;
var COLOR_ATTACHMENT0 = 0x8CE0;
var DEPTH_ATTACHMENT = 0x8D00;
var STENCIL_ATTACHMENT = 0x8D20;
var DEPTH_STENCIL_ATTACHMENT = 0x821A;
/* TextureWrapMode */

var CLAMP_TO_EDGE = 0x812F;
/* TextureMagFilter */

var LINEAR = 0x2601;
/**
 * The options for a framebuffer attachment.
 *
 * Note: For a `format` that is a texture include all the texture
 * options from {@link module:twgl.TextureOptions} for example
 * `min`, `mag`, `clamp`, etc... Note that unlike {@link module:twgl.TextureOptions}
 * `auto` defaults to `false` for attachment textures but `min` and `mag` default
 * to `gl.LINEAR` and `wrap` defaults to `CLAMP_TO_EDGE`
 *
 * @typedef {Object} AttachmentOptions
 * @property {number} [attachmentPoint] The attachment point. Defaults
 *   to `gl.COLOR_ATTACHMENT0 + ndx` unless type is a depth or stencil type
 *   then it's gl.DEPTH_ATTACHMENT or `gl.DEPTH_STENCIL_ATTACHMENT` depending
 *   on the format or attachment type.
 * @property {number} [format] The format. If one of `gl.RGBA4`,
 *   `gl.RGB565`, `gl.RGB5_A1`, `gl.DEPTH_COMPONENT16`,
 *   `gl.STENCIL_INDEX8` or `gl.DEPTH_STENCIL` then will create a
 *   renderbuffer. Otherwise will create a texture. Default = `gl.RGBA`
 * @property {number} [type] The type. Used for texture. Default = `gl.UNSIGNED_BYTE`.
 * @property {number} [target] The texture target for `gl.framebufferTexture2D`.
 *   Defaults to `gl.TEXTURE_2D`. Set to appropriate face for cube maps.
 * @property {number} [level] level for `gl.framebufferTexture2D`. Defaults to 0.
 * @property {number} [layer] layer for `gl.framebufferTextureLayer`. Defaults to undefined.
 *   If set then `gl.framebufferTextureLayer` is called, if not then `gl.framebufferTexture2D`
 * @property {WebGLObject} [attachment] An existing renderbuffer or texture.
 *    If provided will attach this Object. This allows you to share
 *    attachments across framebuffers.
 * @memberOf module:twgl
 * @mixes module:twgl.TextureOptions
 */

var defaultAttachments = [{
  format: RGBA,
  type: UNSIGNED_BYTE,
  min: LINEAR,
  wrap: CLAMP_TO_EDGE
}, {
  format: DEPTH_STENCIL
}];
var attachmentsByFormat = {};
attachmentsByFormat[DEPTH_STENCIL] = DEPTH_STENCIL_ATTACHMENT;
attachmentsByFormat[STENCIL_INDEX] = STENCIL_ATTACHMENT;
attachmentsByFormat[STENCIL_INDEX8] = STENCIL_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT16] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT24] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT32F] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH24_STENCIL8] = DEPTH_STENCIL_ATTACHMENT;
attachmentsByFormat[DEPTH32F_STENCIL8] = DEPTH_STENCIL_ATTACHMENT;

function getAttachmentPointForFormat(format, internalFormat) {
  return attachmentsByFormat[format] || attachmentsByFormat[internalFormat];
}

var renderbufferFormats = {};
renderbufferFormats[RGBA4] = true;
renderbufferFormats[RGB5_A1] = true;
renderbufferFormats[RGB565] = true;
renderbufferFormats[DEPTH_STENCIL] = true;
renderbufferFormats[DEPTH_COMPONENT16] = true;
renderbufferFormats[STENCIL_INDEX] = true;
renderbufferFormats[STENCIL_INDEX8] = true;

function isRenderbufferFormat(format) {
  return renderbufferFormats[format];
}
/**
 * @typedef {Object} FramebufferInfo
 * @property {WebGLFramebuffer} framebuffer The WebGLFramebuffer for this framebufferInfo
 * @property {WebGLObject[]} attachments The created attachments in the same order as passed in to {@link module:twgl.createFramebufferInfo}.
 * @property {number} width The width of the framebuffer and its attachments
 * @property {number} height The width of the framebuffer and its attachments
 * @memberOf module:twgl
 */

/**
 * Creates a framebuffer and attachments.
 *
 * This returns a {@link module:twgl.FramebufferInfo} because it needs to return the attachments as well as the framebuffer.
 *
 * The simplest usage
 *
 *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer
 *     const fbi = twgl.createFramebufferInfo(gl);
 *
 * More complex usage
 *
 *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer
 *     const attachments = [
 *       { format: RGB565, mag: NEAREST },
 *       { format: STENCIL_INDEX8 },
 *     ]
 *     const fbi = twgl.createFramebufferInfo(gl, attachments);
 *
 * Passing in a specific size
 *
 *     const width = 256;
 *     const height = 256;
 *     const fbi = twgl.createFramebufferInfo(gl, attachments, width, height);
 *
 * **Note!!** It is up to you to check if the framebuffer is renderable by calling `gl.checkFramebufferStatus`.
 * [WebGL1 only guarantees 3 combinations of attachments work](https://www.khronos.org/registry/webgl/specs/latest/1.0/#6.6).
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.AttachmentOptions[]} [attachments] which attachments to create. If not provided the default is a framebuffer with an
 *    `RGBA`, `UNSIGNED_BYTE` texture `COLOR_ATTACHMENT0` and a `DEPTH_STENCIL` renderbuffer `DEPTH_STENCIL_ATTACHMENT`.
 * @param {number} [width] the width for the attachments. Default = size of drawingBuffer
 * @param {number} [height] the height for the attachments. Default = size of drawingBuffer
 * @return {module:twgl.FramebufferInfo} the framebuffer and attachments.
 * @memberOf module:twgl/framebuffers
 */


function createFramebufferInfo(gl, attachments, width, height) {
  var target = FRAMEBUFFER;
  var fb = gl.createFramebuffer();
  gl.bindFramebuffer(target, fb);
  width = width || gl.drawingBufferWidth;
  height = height || gl.drawingBufferHeight;
  attachments = attachments || defaultAttachments;
  var colorAttachmentCount = 0;
  var framebufferInfo = {
    framebuffer: fb,
    attachments: [],
    width: width,
    height: height
  };
  attachments.forEach(function (attachmentOptions) {
    var attachment = attachmentOptions.attachment;
    var format = attachmentOptions.format;
    var attachmentPoint = attachmentOptions.attachmentPoint || getAttachmentPointForFormat(format, attachmentOptions.internalFormat);

    if (!attachmentPoint) {
      attachmentPoint = COLOR_ATTACHMENT0 + colorAttachmentCount++;
    }

    if (!attachment) {
      if (isRenderbufferFormat(format)) {
        attachment = gl.createRenderbuffer();
        gl.bindRenderbuffer(RENDERBUFFER, attachment);
        gl.renderbufferStorage(RENDERBUFFER, format, width, height);
      } else {
        var textureOptions = Object.assign({}, attachmentOptions);
        textureOptions.width = width;
        textureOptions.height = height;

        if (textureOptions.auto === undefined) {
          textureOptions.auto = false;
          textureOptions.min = textureOptions.min || textureOptions.minMag || LINEAR;
          textureOptions.mag = textureOptions.mag || textureOptions.minMag || LINEAR;
          textureOptions.wrapS = textureOptions.wrapS || textureOptions.wrap || CLAMP_TO_EDGE;
          textureOptions.wrapT = textureOptions.wrapT || textureOptions.wrap || CLAMP_TO_EDGE;
        }

        attachment = textures.createTexture(gl, textureOptions);
      }
    }

    if (helper.isRenderbuffer(gl, attachment)) {
      gl.framebufferRenderbuffer(target, attachmentPoint, RENDERBUFFER, attachment);
    } else if (helper.isTexture(gl, attachment)) {
      if (attachmentOptions.layer !== undefined) {
        gl.framebufferTextureLayer(target, attachmentPoint, attachment, attachmentOptions.level || 0, attachmentOptions.layer);
      } else {
        gl.framebufferTexture2D(target, attachmentPoint, attachmentOptions.target || TEXTURE_2D, attachment, attachmentOptions.level || 0);
      }
    } else {
      throw new Error('unknown attachment type');
    }

    framebufferInfo.attachments.push(attachment);
  });
  return framebufferInfo;
}
/**
 * Resizes the attachments of a framebuffer.
 *
 * You need to pass in the same `attachments` as you passed in {@link module:twgl.createFramebufferInfo}
 * because TWGL has no idea the format/type of each attachment.
 *
 * The simplest usage
 *
 *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer
 *     const fbi = twgl.createFramebufferInfo(gl);
 *
 *     ...
 *
 *     function render() {
 *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {
 *         // resize the attachments
 *         twgl.resizeFramebufferInfo(gl, fbi);
 *       }
 *
 * More complex usage
 *
 *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer
 *     const attachments = [
 *       { format: RGB565, mag: NEAREST },
 *       { format: STENCIL_INDEX8 },
 *     ]
 *     const fbi = twgl.createFramebufferInfo(gl, attachments);
 *
 *     ...
 *
 *     function render() {
 *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {
 *         // resize the attachments to match
 *         twgl.resizeFramebufferInfo(gl, fbi, attachments);
 *       }
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.FramebufferInfo} framebufferInfo a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.
 * @param {module:twgl.AttachmentOptions[]} [attachments] the same attachments options as passed to {@link module:twgl.createFramebufferInfo}.
 * @param {number} [width] the width for the attachments. Default = size of drawingBuffer
 * @param {number} [height] the height for the attachments. Default = size of drawingBuffer
 * @memberOf module:twgl/framebuffers
 */


function resizeFramebufferInfo(gl, framebufferInfo, attachments, width, height) {
  width = width || gl.drawingBufferWidth;
  height = height || gl.drawingBufferHeight;
  framebufferInfo.width = width;
  framebufferInfo.height = height;
  attachments = attachments || defaultAttachments;
  attachments.forEach(function (attachmentOptions, ndx) {
    var attachment = framebufferInfo.attachments[ndx];
    var format = attachmentOptions.format;

    if (helper.isRenderbuffer(gl, attachment)) {
      gl.bindRenderbuffer(RENDERBUFFER, attachment);
      gl.renderbufferStorage(RENDERBUFFER, format, width, height);
    } else if (helper.isTexture(gl, attachment)) {
      textures.resizeTexture(gl, attachment, attachmentOptions, width, height);
    } else {
      throw new Error('unknown attachment type');
    }
  });
}
/**
 * Binds a framebuffer
 *
 * This function pretty much solely exists because I spent hours
 * trying to figure out why something I wrote wasn't working only
 * to realize I forget to set the viewport dimensions.
 * My hope is this function will fix that.
 *
 * It is effectively the same as
 *
 *     gl.bindFramebuffer(gl.FRAMEBUFFER, someFramebufferInfo.framebuffer);
 *     gl.viewport(0, 0, someFramebufferInfo.width, someFramebufferInfo.height);
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.FramebufferInfo|null} [framebufferInfo] a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.
 *   If falsy will bind the canvas.
 * @param {number} [target] The target. If not passed `gl.FRAMEBUFFER` will be used.
 * @memberOf module:twgl/framebuffers
 */


function bindFramebufferInfo(gl, framebufferInfo, target) {
  target = target || FRAMEBUFFER;

  if (framebufferInfo) {
    gl.bindFramebuffer(target, framebufferInfo.framebuffer);
    gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);
  } else {
    gl.bindFramebuffer(target, null);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }
}

/***/ }),

/***/ "./src/helper.js":
/*!***********************!*\
  !*** ./src/helper.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.copyExistingProperties = copyExistingProperties;
exports.copyNamedProperties = copyNamedProperties;
exports.error = error;
exports.warn = warn;
exports.isBuffer = isBuffer;
exports.isRenderbuffer = isRenderbuffer;
exports.isShader = isShader;
exports.isTexture = isTexture;
exports.isSampler = isSampler;

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/* eslint no-console: "off" */

/**
 * Copy named properties
 *
 * @param {string[]} names names of properties to copy
 * @param {object} src object to copy properties from
 * @param {object} dst object to copy properties to
 * @private
 */
function copyNamedProperties(names, src, dst) {
  names.forEach(function (name) {
    var value = src[name];

    if (value !== undefined) {
      dst[name] = value;
    }
  });
}
/**
 * Copies properties from source to dest only if a matching key is in dest
 *
 * @param {Object.<string, ?>} src the source
 * @param {Object.<string, ?>} dst the dest
 * @private
 */


function copyExistingProperties(src, dst) {
  Object.keys(dst).forEach(function (key) {
    if (dst.hasOwnProperty(key) && src.hasOwnProperty(key)) {
      /* eslint no-prototype-builtins: 0 */
      dst[key] = src[key];
    }
  });
}

function error() {
  var _console;

  (_console = console).error.apply(_console, arguments);
}

function warn() {
  var _console2;

  (_console2 = console).warn.apply(_console2, arguments);
}

function isBuffer(gl, t) {
  return typeof WebGLBuffer !== 'undefined' && t instanceof WebGLBuffer;
}

function isRenderbuffer(gl, t) {
  return typeof WebGLRenderbuffer !== 'undefined' && t instanceof WebGLRenderbuffer;
}

function isShader(gl, t) {
  return typeof WebGLShader !== 'undefined' && t instanceof WebGLShader;
}

function isTexture(gl, t) {
  return typeof WebGLTexture !== 'undefined' && t instanceof WebGLTexture;
}

function isSampler(gl, t) {
  return typeof WebGLSampler !== 'undefined' && t instanceof WebGLSampler;
}

/***/ }),

/***/ "./src/m4.js":
/*!*******************!*\
  !*** ./src/m4.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.axisRotate = axisRotate;
exports.axisRotation = axisRotation;
exports.copy = copy;
exports.frustum = frustum;
exports.getAxis = getAxis;
exports.getTranslation = getTranslation;
exports.identity = identity;
exports.inverse = inverse;
exports.lookAt = lookAt;
exports.multiply = multiply;
exports.negate = negate;
exports.ortho = ortho;
exports.perspective = perspective;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.rotationX = rotationX;
exports.rotationY = rotationY;
exports.rotationZ = rotationZ;
exports.scale = scale;
exports.scaling = scaling;
exports.setAxis = setAxis;
exports.setDefaultType = setDefaultType;
exports.setTranslation = setTranslation;
exports.transformDirection = transformDirection;
exports.transformNormal = transformNormal;
exports.transformPoint = transformPoint;
exports.translate = translate;
exports.translation = translation;
exports.transpose = transpose;

var v3 = _interopRequireWildcard(__webpack_require__(/*! ./v3.js */ "./src/v3.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * 4x4 Matrix math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new matrix. In other words you can do this
 *
 *     const mat = m4.translation([1, 2, 3]);  // Creates a new translation matrix
 *
 * or
 *
 *     const mat = m4.create();
 *     m4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any matrix as the destination. So for example
 *
 *     const mat = m4.identity();
 *     const trans = m4.translation([1, 2, 3]);
 *     m4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.
 *
 * @module twgl/m4
 */
var MatType = Float32Array;
/**
 * A JavaScript array with 16 values or a Float32Array with 16 values.
 * When created by the library will create the default type which is `Float32Array`
 * but can be set by calling {@link module:twgl/m4.setDefaultType}.
 * @typedef {(number[]|Float32Array)} Mat4
 * @memberOf module:twgl/m4
 */

/**
 * Sets the type this library creates for a Mat4
 * @param {constructor} ctor the constructor for the type. Either `Float32Array` or `Array`
 * @return {constructor} previous constructor for Mat4
 * @memberOf module:twgl/m4
 */

function setDefaultType(ctor) {
  var oldType = MatType;
  MatType = ctor;
  return oldType;
}
/**
 * Negates a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} -m.
 * @memberOf module:twgl/m4
 */


function negate(m, dst) {
  dst = dst || new MatType(16);
  dst[0] = -m[0];
  dst[1] = -m[1];
  dst[2] = -m[2];
  dst[3] = -m[3];
  dst[4] = -m[4];
  dst[5] = -m[5];
  dst[6] = -m[6];
  dst[7] = -m[7];
  dst[8] = -m[8];
  dst[9] = -m[9];
  dst[10] = -m[10];
  dst[11] = -m[11];
  dst[12] = -m[12];
  dst[13] = -m[13];
  dst[14] = -m[14];
  dst[15] = -m[15];
  return dst;
}
/**
 * Copies a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] The matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} A copy of m.
 * @memberOf module:twgl/m4
 */


function copy(m, dst) {
  dst = dst || new MatType(16);
  dst[0] = m[0];
  dst[1] = m[1];
  dst[2] = m[2];
  dst[3] = m[3];
  dst[4] = m[4];
  dst[5] = m[5];
  dst[6] = m[6];
  dst[7] = m[7];
  dst[8] = m[8];
  dst[9] = m[9];
  dst[10] = m[10];
  dst[11] = m[11];
  dst[12] = m[12];
  dst[13] = m[13];
  dst[14] = m[14];
  dst[15] = m[15];
  return dst;
}
/**
 * Creates an n-by-n identity matrix.
 *
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} An n-by-n identity matrix.
 * @memberOf module:twgl/m4
 */


function identity(dst) {
  dst = dst || new MatType(16);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Takes the transpose of a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The transpose of m.
 * @memberOf module:twgl/m4
 */


function transpose(m, dst) {
  dst = dst || new MatType(16);

  if (dst === m) {
    var t;
    t = m[1];
    m[1] = m[4];
    m[4] = t;
    t = m[2];
    m[2] = m[8];
    m[8] = t;
    t = m[3];
    m[3] = m[12];
    m[12] = t;
    t = m[6];
    m[6] = m[9];
    m[9] = t;
    t = m[7];
    m[7] = m[13];
    m[13] = t;
    t = m[11];
    m[11] = m[14];
    m[14] = t;
    return dst;
  }

  var m00 = m[0 * 4 + 0];
  var m01 = m[0 * 4 + 1];
  var m02 = m[0 * 4 + 2];
  var m03 = m[0 * 4 + 3];
  var m10 = m[1 * 4 + 0];
  var m11 = m[1 * 4 + 1];
  var m12 = m[1 * 4 + 2];
  var m13 = m[1 * 4 + 3];
  var m20 = m[2 * 4 + 0];
  var m21 = m[2 * 4 + 1];
  var m22 = m[2 * 4 + 2];
  var m23 = m[2 * 4 + 3];
  var m30 = m[3 * 4 + 0];
  var m31 = m[3 * 4 + 1];
  var m32 = m[3 * 4 + 2];
  var m33 = m[3 * 4 + 3];
  dst[0] = m00;
  dst[1] = m10;
  dst[2] = m20;
  dst[3] = m30;
  dst[4] = m01;
  dst[5] = m11;
  dst[6] = m21;
  dst[7] = m31;
  dst[8] = m02;
  dst[9] = m12;
  dst[10] = m22;
  dst[11] = m32;
  dst[12] = m03;
  dst[13] = m13;
  dst[14] = m23;
  dst[15] = m33;
  return dst;
}
/**
 * Computes the inverse of a 4-by-4 matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The inverse of m.
 * @memberOf module:twgl/m4
 */


function inverse(m, dst) {
  dst = dst || new MatType(16);
  var m00 = m[0 * 4 + 0];
  var m01 = m[0 * 4 + 1];
  var m02 = m[0 * 4 + 2];
  var m03 = m[0 * 4 + 3];
  var m10 = m[1 * 4 + 0];
  var m11 = m[1 * 4 + 1];
  var m12 = m[1 * 4 + 2];
  var m13 = m[1 * 4 + 3];
  var m20 = m[2 * 4 + 0];
  var m21 = m[2 * 4 + 1];
  var m22 = m[2 * 4 + 2];
  var m23 = m[2 * 4 + 3];
  var m30 = m[3 * 4 + 0];
  var m31 = m[3 * 4 + 1];
  var m32 = m[3 * 4 + 2];
  var m33 = m[3 * 4 + 3];
  var tmp_0 = m22 * m33;
  var tmp_1 = m32 * m23;
  var tmp_2 = m12 * m33;
  var tmp_3 = m32 * m13;
  var tmp_4 = m12 * m23;
  var tmp_5 = m22 * m13;
  var tmp_6 = m02 * m33;
  var tmp_7 = m32 * m03;
  var tmp_8 = m02 * m23;
  var tmp_9 = m22 * m03;
  var tmp_10 = m02 * m13;
  var tmp_11 = m12 * m03;
  var tmp_12 = m20 * m31;
  var tmp_13 = m30 * m21;
  var tmp_14 = m10 * m31;
  var tmp_15 = m30 * m11;
  var tmp_16 = m10 * m21;
  var tmp_17 = m20 * m11;
  var tmp_18 = m00 * m31;
  var tmp_19 = m30 * m01;
  var tmp_20 = m00 * m21;
  var tmp_21 = m20 * m01;
  var tmp_22 = m00 * m11;
  var tmp_23 = m10 * m01;
  var t0 = tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31 - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
  var t1 = tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31 - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
  var t2 = tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31 - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
  var t3 = tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21 - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);
  var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
  dst[0] = d * t0;
  dst[1] = d * t1;
  dst[2] = d * t2;
  dst[3] = d * t3;
  dst[4] = d * (tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30 - (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));
  dst[5] = d * (tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30 - (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));
  dst[6] = d * (tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30 - (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));
  dst[7] = d * (tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20 - (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));
  dst[8] = d * (tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33 - (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));
  dst[9] = d * (tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33 - (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));
  dst[10] = d * (tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33 - (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));
  dst[11] = d * (tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23 - (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));
  dst[12] = d * (tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12 - (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));
  dst[13] = d * (tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22 - (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));
  dst[14] = d * (tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02 - (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));
  dst[15] = d * (tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12 - (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));
  return dst;
}
/**
 * Multiplies two 4-by-4 matrices with a on the left and b on the right
 * @param {module:twgl/m4.Mat4} a The matrix on the left.
 * @param {module:twgl/m4.Mat4} b The matrix on the right.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix product of a and b.
 * @memberOf module:twgl/m4
 */


function multiply(a, b, dst) {
  dst = dst || new MatType(16);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4 + 0];
  var a11 = a[4 + 1];
  var a12 = a[4 + 2];
  var a13 = a[4 + 3];
  var a20 = a[8 + 0];
  var a21 = a[8 + 1];
  var a22 = a[8 + 2];
  var a23 = a[8 + 3];
  var a30 = a[12 + 0];
  var a31 = a[12 + 1];
  var a32 = a[12 + 2];
  var a33 = a[12 + 3];
  var b00 = b[0];
  var b01 = b[1];
  var b02 = b[2];
  var b03 = b[3];
  var b10 = b[4 + 0];
  var b11 = b[4 + 1];
  var b12 = b[4 + 2];
  var b13 = b[4 + 3];
  var b20 = b[8 + 0];
  var b21 = b[8 + 1];
  var b22 = b[8 + 2];
  var b23 = b[8 + 3];
  var b30 = b[12 + 0];
  var b31 = b[12 + 1];
  var b32 = b[12 + 2];
  var b33 = b[12 + 3];
  dst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
  dst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
  dst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
  dst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
  dst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
  dst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
  dst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
  dst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
  dst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
  dst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
  dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
  dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
  dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
  dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
  dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
  dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
  return dst;
}
/**
 * Sets the translation component of a 4-by-4 matrix to the given
 * vector.
 * @param {module:twgl/m4.Mat4} a The matrix.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix with translation set.
 * @memberOf module:twgl/m4
 */


function setTranslation(a, v, dst) {
  dst = dst || identity();

  if (a !== dst) {
    dst[0] = a[0];
    dst[1] = a[1];
    dst[2] = a[2];
    dst[3] = a[3];
    dst[4] = a[4];
    dst[5] = a[5];
    dst[6] = a[6];
    dst[7] = a[7];
    dst[8] = a[8];
    dst[9] = a[9];
    dst[10] = a[10];
    dst[11] = a[11];
  }

  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}
/**
 * Returns the translation component of a 4-by-4 matrix as a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The translation component of m.
 * @memberOf module:twgl/m4
 */


function getTranslation(m, dst) {
  dst = dst || v3.create();
  dst[0] = m[12];
  dst[1] = m[13];
  dst[2] = m[14];
  return dst;
}
/**
 * Returns an axis of a 4x4 matrix as a vector with 3 entries
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} axis The axis 0 = x, 1 = y, 2 = z;
 * @return {module:twgl/v3.Vec3} [dst] vector.
 * @return {module:twgl/v3.Vec3} The axis component of m.
 * @memberOf module:twgl/m4
 */


function getAxis(m, axis, dst) {
  dst = dst || v3.create();
  var off = axis * 4;
  dst[0] = m[off + 0];
  dst[1] = m[off + 1];
  dst[2] = m[off + 2];
  return dst;
}
/**
 * Sets an axis of a 4x4 matrix as a vector with 3 entries
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v the axis vector
 * @param {number} axis The axis  0 = x, 1 = y, 2 = z;
 * @param {module:twgl/m4.Mat4} [dst] The matrix to set. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix with axis set.
 * @memberOf module:twgl/m4
 */


function setAxis(a, v, axis, dst) {
  if (dst !== a) {
    dst = copy(a, dst);
  }

  var off = axis * 4;
  dst[off + 0] = v[0];
  dst[off + 1] = v[1];
  dst[off + 2] = v[2];
  return dst;
}
/**
 * Computes a 4-by-4 perspective transformation matrix given the angular height
 * of the frustum, the aspect ratio, and the near and far clipping planes.  The
 * arguments define a frustum extending in the negative z direction.  The given
 * angle is the vertical angle of the frustum, and the horizontal angle is
 * determined to produce the given aspect ratio.  The arguments near and far are
 * the distances to the near and far clipping planes.  Note that near and far
 * are not z coordinates, but rather they are distances along the negative
 * z-axis.  The matrix generated sends the viewing frustum to the unit box.
 * We assume a unit box extending from -1 to 1 in the x and y dimensions and
 * from 0 to 1 in the z dimension.
 * @param {number} fieldOfViewYInRadians The camera angle from top to bottom (in radians).
 * @param {number} aspect The aspect ratio width / height.
 * @param {number} zNear The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param {number} zFar The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective matrix.
 * @memberOf module:twgl/m4
 */


function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {
  dst = dst || new MatType(16);
  var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);
  var rangeInv = 1.0 / (zNear - zFar);
  dst[0] = f / aspect;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = f;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = (zNear + zFar) * rangeInv;
  dst[11] = -1;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = zNear * zFar * rangeInv * 2;
  dst[15] = 0;
  return dst;
}
/**
 * Computes a 4-by-4 orthogonal transformation matrix given the left, right,
 * bottom, and top dimensions of the near clipping plane as well as the
 * near and far clipping plane distances.
 * @param {number} left Left side of the near clipping plane viewport.
 * @param {number} right Right side of the near clipping plane viewport.
 * @param {number} bottom Bottom of the near clipping plane viewport.
 * @param {number} top Top of the near clipping plane viewport.
 * @param {number} near The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param {number} far The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param {module:twgl/m4.Mat4} [dst] Output matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective matrix.
 * @memberOf module:twgl/m4
 */


function ortho(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);
  dst[0] = 2 / (right - left);
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 2 / (top - bottom);
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 2 / (near - far);
  dst[11] = 0;
  dst[12] = (right + left) / (left - right);
  dst[13] = (top + bottom) / (bottom - top);
  dst[14] = (far + near) / (near - far);
  dst[15] = 1;
  return dst;
}
/**
 * Computes a 4-by-4 perspective transformation matrix given the left, right,
 * top, bottom, near and far clipping planes. The arguments define a frustum
 * extending in the negative z direction. The arguments near and far are the
 * distances to the near and far clipping planes. Note that near and far are not
 * z coordinates, but rather they are distances along the negative z-axis. The
 * matrix generated sends the viewing frustum to the unit box. We assume a unit
 * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z
 * dimension.
 * @param {number} left The x coordinate of the left plane of the box.
 * @param {number} right The x coordinate of the right plane of the box.
 * @param {number} bottom The y coordinate of the bottom plane of the box.
 * @param {number} top The y coordinate of the right plane of the box.
 * @param {number} near The negative z coordinate of the near plane of the box.
 * @param {number} far The negative z coordinate of the far plane of the box.
 * @param {module:twgl/m4.Mat4} [dst] Output matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective projection matrix.
 * @memberOf module:twgl/m4
 */


function frustum(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);
  var dx = right - left;
  var dy = top - bottom;
  var dz = near - far;
  dst[0] = 2 * near / dx;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 2 * near / dy;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = (left + right) / dx;
  dst[9] = (top + bottom) / dy;
  dst[10] = far / dz;
  dst[11] = -1;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = near * far / dz;
  dst[15] = 0;
  return dst;
}

var xAxis;
var yAxis;
var zAxis;
/**
 * Computes a 4-by-4 look-at transformation.
 *
 * This is a matrix which positions the camera itself. If you want
 * a view matrix (a matrix which moves things in front of the camera)
 * take the inverse of this.
 *
 * @param {module:twgl/v3.Vec3} eye The position of the eye.
 * @param {module:twgl/v3.Vec3} target The position meant to be viewed.
 * @param {module:twgl/v3.Vec3} up A vector pointing up.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The look-at matrix.
 * @memberOf module:twgl/m4
 */

function lookAt(eye, target, up, dst) {
  dst = dst || new MatType(16);
  xAxis = xAxis || v3.create();
  yAxis = yAxis || v3.create();
  zAxis = zAxis || v3.create();
  v3.normalize(v3.subtract(eye, target, zAxis), zAxis);
  v3.normalize(v3.cross(up, zAxis, xAxis), xAxis);
  v3.normalize(v3.cross(zAxis, xAxis, yAxis), yAxis);
  dst[0] = xAxis[0];
  dst[1] = xAxis[1];
  dst[2] = xAxis[2];
  dst[3] = 0;
  dst[4] = yAxis[0];
  dst[5] = yAxis[1];
  dst[6] = yAxis[2];
  dst[7] = 0;
  dst[8] = zAxis[0];
  dst[9] = zAxis[1];
  dst[10] = zAxis[2];
  dst[11] = 0;
  dst[12] = eye[0];
  dst[13] = eye[1];
  dst[14] = eye[2];
  dst[15] = 1;
  return dst;
}
/**
 * Creates a 4-by-4 matrix which translates by the given vector v.
 * @param {module:twgl/v3.Vec3} v The vector by
 *     which to translate.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The translation matrix.
 * @memberOf module:twgl/m4
 */


function translation(v, dst) {
  dst = dst || new MatType(16);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}
/**
 * Translates the given 4-by-4 matrix by the given vector v.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The vector by
 *     which to translate.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The translated matrix.
 * @memberOf module:twgl/m4
 */


function translate(m, v, dst) {
  dst = dst || new MatType(16);
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  var m00 = m[0];
  var m01 = m[1];
  var m02 = m[2];
  var m03 = m[3];
  var m10 = m[1 * 4 + 0];
  var m11 = m[1 * 4 + 1];
  var m12 = m[1 * 4 + 2];
  var m13 = m[1 * 4 + 3];
  var m20 = m[2 * 4 + 0];
  var m21 = m[2 * 4 + 1];
  var m22 = m[2 * 4 + 2];
  var m23 = m[2 * 4 + 3];
  var m30 = m[3 * 4 + 0];
  var m31 = m[3 * 4 + 1];
  var m32 = m[3 * 4 + 2];
  var m33 = m[3 * 4 + 3];

  if (m !== dst) {
    dst[0] = m00;
    dst[1] = m01;
    dst[2] = m02;
    dst[3] = m03;
    dst[4] = m10;
    dst[5] = m11;
    dst[6] = m12;
    dst[7] = m13;
    dst[8] = m20;
    dst[9] = m21;
    dst[10] = m22;
    dst[11] = m23;
  }

  dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;
  dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;
  dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;
  dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;
  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */


function rotationX(angleInRadians, dst) {
  dst = dst || new MatType(16);
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = c;
  dst[6] = s;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = -s;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the x-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */


function rotateX(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var m10 = m[4];
  var m11 = m[5];
  var m12 = m[6];
  var m13 = m[7];
  var m20 = m[8];
  var m21 = m[9];
  var m22 = m[10];
  var m23 = m[11];
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[4] = c * m10 + s * m20;
  dst[5] = c * m11 + s * m21;
  dst[6] = c * m12 + s * m22;
  dst[7] = c * m13 + s * m23;
  dst[8] = c * m20 - s * m10;
  dst[9] = c * m21 - s * m11;
  dst[10] = c * m22 - s * m12;
  dst[11] = c * m23 - s * m13;

  if (m !== dst) {
    dst[0] = m[0];
    dst[1] = m[1];
    dst[2] = m[2];
    dst[3] = m[3];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */


function rotationY(angleInRadians, dst) {
  dst = dst || new MatType(16);
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = c;
  dst[1] = 0;
  dst[2] = -s;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = s;
  dst[9] = 0;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the y-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */


function rotateY(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var m00 = m[0 * 4 + 0];
  var m01 = m[0 * 4 + 1];
  var m02 = m[0 * 4 + 2];
  var m03 = m[0 * 4 + 3];
  var m20 = m[2 * 4 + 0];
  var m21 = m[2 * 4 + 1];
  var m22 = m[2 * 4 + 2];
  var m23 = m[2 * 4 + 3];
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = c * m00 - s * m20;
  dst[1] = c * m01 - s * m21;
  dst[2] = c * m02 - s * m22;
  dst[3] = c * m03 - s * m23;
  dst[8] = c * m20 + s * m00;
  dst[9] = c * m21 + s * m01;
  dst[10] = c * m22 + s * m02;
  dst[11] = c * m23 + s * m03;

  if (m !== dst) {
    dst[4] = m[4];
    dst[5] = m[5];
    dst[6] = m[6];
    dst[7] = m[7];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */


function rotationZ(angleInRadians, dst) {
  dst = dst || new MatType(16);
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = c;
  dst[1] = s;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = -s;
  dst[5] = c;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the z-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */


function rotateZ(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var m00 = m[0 * 4 + 0];
  var m01 = m[0 * 4 + 1];
  var m02 = m[0 * 4 + 2];
  var m03 = m[0 * 4 + 3];
  var m10 = m[1 * 4 + 0];
  var m11 = m[1 * 4 + 1];
  var m12 = m[1 * 4 + 2];
  var m13 = m[1 * 4 + 3];
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = c * m00 + s * m10;
  dst[1] = c * m01 + s * m11;
  dst[2] = c * m02 + s * m12;
  dst[3] = c * m03 + s * m13;
  dst[4] = c * m10 - s * m00;
  dst[5] = c * m11 - s * m01;
  dst[6] = c * m12 - s * m02;
  dst[7] = c * m13 - s * m03;

  if (m !== dst) {
    dst[8] = m[8];
    dst[9] = m[9];
    dst[10] = m[10];
    dst[11] = m[11];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the given axis by the given
 * angle.
 * @param {module:twgl/v3.Vec3} axis The axis
 *     about which to rotate.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} A matrix which rotates angle radians
 *     around the axis.
 * @memberOf module:twgl/m4
 */


function axisRotation(axis, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var x = axis[0];
  var y = axis[1];
  var z = axis[2];
  var n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  var xx = x * x;
  var yy = y * y;
  var zz = z * z;
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  var oneMinusCosine = 1 - c;
  dst[0] = xx + (1 - xx) * c;
  dst[1] = x * y * oneMinusCosine + z * s;
  dst[2] = x * z * oneMinusCosine - y * s;
  dst[3] = 0;
  dst[4] = x * y * oneMinusCosine - z * s;
  dst[5] = yy + (1 - yy) * c;
  dst[6] = y * z * oneMinusCosine + x * s;
  dst[7] = 0;
  dst[8] = x * z * oneMinusCosine + y * s;
  dst[9] = y * z * oneMinusCosine - x * s;
  dst[10] = zz + (1 - zz) * c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the given axis by the
 * given angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} axis The axis
 *     about which to rotate.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */


function axisRotate(m, axis, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var x = axis[0];
  var y = axis[1];
  var z = axis[2];
  var n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  var xx = x * x;
  var yy = y * y;
  var zz = z * z;
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  var oneMinusCosine = 1 - c;
  var r00 = xx + (1 - xx) * c;
  var r01 = x * y * oneMinusCosine + z * s;
  var r02 = x * z * oneMinusCosine - y * s;
  var r10 = x * y * oneMinusCosine - z * s;
  var r11 = yy + (1 - yy) * c;
  var r12 = y * z * oneMinusCosine + x * s;
  var r20 = x * z * oneMinusCosine + y * s;
  var r21 = y * z * oneMinusCosine - x * s;
  var r22 = zz + (1 - zz) * c;
  var m00 = m[0];
  var m01 = m[1];
  var m02 = m[2];
  var m03 = m[3];
  var m10 = m[4];
  var m11 = m[5];
  var m12 = m[6];
  var m13 = m[7];
  var m20 = m[8];
  var m21 = m[9];
  var m22 = m[10];
  var m23 = m[11];
  dst[0] = r00 * m00 + r01 * m10 + r02 * m20;
  dst[1] = r00 * m01 + r01 * m11 + r02 * m21;
  dst[2] = r00 * m02 + r01 * m12 + r02 * m22;
  dst[3] = r00 * m03 + r01 * m13 + r02 * m23;
  dst[4] = r10 * m00 + r11 * m10 + r12 * m20;
  dst[5] = r10 * m01 + r11 * m11 + r12 * m21;
  dst[6] = r10 * m02 + r11 * m12 + r12 * m22;
  dst[7] = r10 * m03 + r11 * m13 + r12 * m23;
  dst[8] = r20 * m00 + r21 * m10 + r22 * m20;
  dst[9] = r20 * m01 + r21 * m11 + r22 * m21;
  dst[10] = r20 * m02 + r21 * m12 + r22 * m22;
  dst[11] = r20 * m03 + r21 * m13 + r22 * m23;

  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Creates a 4-by-4 matrix which scales in each dimension by an amount given by
 * the corresponding entry in the given vector; assumes the vector has three
 * entries.
 * @param {module:twgl/v3.Vec3} v A vector of
 *     three entries specifying the factor by which to scale in each dimension.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The scaling matrix.
 * @memberOf module:twgl/m4
 */


function scaling(v, dst) {
  dst = dst || new MatType(16);
  dst[0] = v[0];
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = v[1];
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = v[2];
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Scales the given 4-by-4 matrix in each dimension by an amount
 * given by the corresponding entry in the given vector; assumes the vector has
 * three entries.
 * @param {module:twgl/m4.Mat4} m The matrix to be modified.
 * @param {module:twgl/v3.Vec3} v A vector of three entries specifying the
 *     factor by which to scale in each dimension.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The scaled matrix.
 * @memberOf module:twgl/m4
 */


function scale(m, v, dst) {
  dst = dst || new MatType(16);
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  dst[0] = v0 * m[0 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2];
  dst[3] = v0 * m[0 * 4 + 3];
  dst[4] = v1 * m[1 * 4 + 0];
  dst[5] = v1 * m[1 * 4 + 1];
  dst[6] = v1 * m[1 * 4 + 2];
  dst[7] = v1 * m[1 * 4 + 3];
  dst[8] = v2 * m[2 * 4 + 0];
  dst[9] = v2 * m[2 * 4 + 1];
  dst[10] = v2 * m[2 * 4 + 2];
  dst[11] = v2 * m[2 * 4 + 3];

  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Takes a 4-by-4 matrix and a vector with 3 entries,
 * interprets the vector as a point, transforms that point by the matrix, and
 * returns the result as a vector with 3 entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The point.
 * @param {module:twgl/v3.Vec3} [dst] optional vec3 to store result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed point.
 * @memberOf module:twgl/m4
 */


function transformPoint(m, v, dst) {
  dst = dst || v3.create();
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  var d = v0 * m[0 * 4 + 3] + v1 * m[1 * 4 + 3] + v2 * m[2 * 4 + 3] + m[3 * 4 + 3];
  dst[0] = (v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0] + m[3 * 4 + 0]) / d;
  dst[1] = (v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1] + m[3 * 4 + 1]) / d;
  dst[2] = (v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2] + m[3 * 4 + 2]) / d;
  return dst;
}
/**
 * Takes a 4-by-4 matrix and a vector with 3 entries, interprets the vector as a
 * direction, transforms that direction by the matrix, and returns the result;
 * assumes the transformation of 3-dimensional space represented by the matrix
 * is parallel-preserving, i.e. any combination of rotation, scaling and
 * translation, but not a perspective distortion. Returns a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The direction.
 * @param {module:twgl/v3.Vec3} [dst] optional Vec3 to store result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed direction.
 * @memberOf module:twgl/m4
 */


function transformDirection(m, v, dst) {
  dst = dst || v3.create();
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];
  return dst;
}
/**
 * Takes a 4-by-4 matrix m and a vector v with 3 entries, interprets the vector
 * as a normal to a surface, and computes a vector which is normal upon
 * transforming that surface by the matrix. The effect of this function is the
 * same as transforming v (as a direction) by the inverse-transpose of m.  This
 * function assumes the transformation of 3-dimensional space represented by the
 * matrix is parallel-preserving, i.e. any combination of rotation, scaling and
 * translation, but not a perspective distortion.  Returns a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The normal.
 * @param {module:twgl/v3.Vec3} [dst] The direction. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed normal.
 * @memberOf module:twgl/m4
 */


function transformNormal(m, v, dst) {
  dst = dst || v3.create();
  var mi = inverse(m);
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];
  dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];
  dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];
  return dst;
}

/***/ }),

/***/ "./src/primitives.js":
/*!***************************!*\
  !*** ./src/primitives.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.create3DFVertices = create3DFVertices;
exports.createAugmentedTypedArray = createAugmentedTypedArray;
exports.createCubeVertices = createCubeVertices;
exports.createPlaneVertices = createPlaneVertices;
exports.createSphereVertices = createSphereVertices;
exports.createTruncatedConeVertices = createTruncatedConeVertices;
exports.createXYQuadVertices = createXYQuadVertices;
exports.createCrescentVertices = createCrescentVertices;
exports.createCylinderVertices = createCylinderVertices;
exports.createTorusVertices = createTorusVertices;
exports.createDiscVertices = createDiscVertices;
exports.deindexVertices = deindexVertices;
exports.flattenNormals = flattenNormals;
exports.makeRandomVertexColors = makeRandomVertexColors;
exports.reorientDirections = reorientDirections;
exports.reorientNormals = reorientNormals;
exports.reorientPositions = reorientPositions;
exports.reorientVertices = reorientVertices;
exports.concatVertices = concatVertices;
exports.duplicateVertices = duplicateVertices;
exports.createDiscBuffers = exports.createDiscBufferInfo = exports.createTorusBuffers = exports.createTorusBufferInfo = exports.createCylinderBuffers = exports.createCylinderBufferInfo = exports.createCrescentBuffers = exports.createCrescentBufferInfo = exports.createCresentVertices = exports.createCresentBuffers = exports.createCresentBufferInfo = exports.createXYQuadBuffers = exports.createXYQuadBufferInfo = exports.createTruncatedConeBuffers = exports.createTruncatedConeBufferInfo = exports.createSphereBuffers = exports.createSphereBufferInfo = exports.createPlaneBuffers = exports.createPlaneBufferInfo = exports.createCubeBuffers = exports.createCubeBufferInfo = exports.create3DFBuffers = exports.create3DFBufferInfo = void 0;

var attributes = _interopRequireWildcard(__webpack_require__(/*! ./attributes.js */ "./src/attributes.js"));

var helper = _interopRequireWildcard(__webpack_require__(/*! ./helper.js */ "./src/helper.js"));

var typedArrays = _interopRequireWildcard(__webpack_require__(/*! ./typedarrays.js */ "./src/typedarrays.js"));

var m4 = _interopRequireWildcard(__webpack_require__(/*! ./m4.js */ "./src/m4.js"));

var v3 = _interopRequireWildcard(__webpack_require__(/*! ./v3.js */ "./src/v3.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Various functions to make simple primitives
 *
 * note: Most primitive functions come in 3 styles
 *
 * *  `createSomeShapeBufferInfo`
 *
 *    These functions are almost always the functions you want to call. They
 *    create vertices then make WebGLBuffers and create {@link module:twgl.AttribInfo}s
 *    returning a {@link module:twgl.BufferInfo} you can pass to {@link module:twgl.setBuffersAndAttributes}
 *    and {@link module:twgl.drawBufferInfo} etc...
 *
 * *  `createSomeShapeBuffers`
 *
 *    These create WebGLBuffers and put your data in them but nothing else.
 *    It's a shortcut to doing it yourself if you don't want to use
 *    the higher level functions.
 *
 * *  `createSomeShapeVertices`
 *
 *    These just create vertices, no buffers. This allows you to manipulate the vertices
 *    or add more data before generating a {@link module:twgl.BufferInfo}. Once you're finished
 *    manipulating the vertices call {@link module:twgl.createBufferInfoFromArrays}.
 *
 *    example:
 *
 *        const arrays = twgl.primitives.createPlaneArrays(1);
 *        twgl.primitives.reorientVertices(arrays, m4.rotationX(Math.PI * 0.5));
 *        const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
 *
 * @module twgl/primitives
 */
var getArray = attributes.getArray_; // eslint-disable-line

var getNumComponents = attributes.getNumComponents_; // eslint-disable-line

/**
 * @typedef {(Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array)} TypedArray
 */

/**
 * Add `push` to a typed array. It just keeps a 'cursor'
 * and allows use to `push` values into the array so we
 * don't have to manually compute offsets
 * @param {TypedArray} typedArray TypedArray to augment
 * @param {number} numComponents number of components.
 * @private
 */

function augmentTypedArray(typedArray, numComponents) {
  var cursor = 0;

  typedArray.push = function () {
    for (var ii = 0; ii < arguments.length; ++ii) {
      var value = arguments[ii];

      if (value instanceof Array || typedArrays.isArrayBuffer(value)) {
        for (var jj = 0; jj < value.length; ++jj) {
          typedArray[cursor++] = value[jj];
        }
      } else {
        typedArray[cursor++] = value;
      }
    }
  };

  typedArray.reset = function (opt_index) {
    cursor = opt_index || 0;
  };

  typedArray.numComponents = numComponents;
  Object.defineProperty(typedArray, 'numElements', {
    get: function get() {
      return this.length / this.numComponents | 0;
    }
  });
  return typedArray;
}
/**
 * creates a typed array with a `push` function attached
 * so that you can easily *push* values.
 *
 * `push` can take multiple arguments. If an argument is an array each element
 * of the array will be added to the typed array.
 *
 * Example:
 *
 *     const array = createAugmentedTypedArray(3, 2);  // creates a Float32Array with 6 values
 *     array.push(1, 2, 3);
 *     array.push([4, 5, 6]);
 *     // array now contains [1, 2, 3, 4, 5, 6]
 *
 * Also has `numComponents` and `numElements` properties.
 *
 * @param {number} numComponents number of components
 * @param {number} numElements number of elements. The total size of the array will be `numComponents * numElements`.
 * @param {constructor} opt_type A constructor for the type. Default = `Float32Array`.
 * @return {ArrayBufferView} A typed array.
 * @memberOf module:twgl/primitives
 */


function createAugmentedTypedArray(numComponents, numElements, opt_type) {
  var Type = opt_type || Float32Array;
  return augmentTypedArray(new Type(numComponents * numElements), numComponents);
}

function allButIndices(name) {
  return name !== "indices";
}
/**
 * Given indexed vertices creates a new set of vertices un-indexed by expanding the indexed vertices.
 * @param {Object.<string, TypedArray>} vertices The indexed vertices to deindex
 * @return {Object.<string, TypedArray>} The deindexed vertices
 * @memberOf module:twgl/primitives
 */


function deindexVertices(vertices) {
  var indices = vertices.indices;
  var newVertices = {};
  var numElements = indices.length;

  function expandToUnindexed(channel) {
    var srcBuffer = vertices[channel];
    var numComponents = srcBuffer.numComponents;
    var dstBuffer = createAugmentedTypedArray(numComponents, numElements, srcBuffer.constructor);

    for (var ii = 0; ii < numElements; ++ii) {
      var ndx = indices[ii];
      var offset = ndx * numComponents;

      for (var jj = 0; jj < numComponents; ++jj) {
        dstBuffer.push(srcBuffer[offset + jj]);
      }
    }

    newVertices[channel] = dstBuffer;
  }

  Object.keys(vertices).filter(allButIndices).forEach(expandToUnindexed);
  return newVertices;
}
/**
 * flattens the normals of deindexed vertices in place.
 * @param {Object.<string, TypedArray>} vertices The deindexed vertices who's normals to flatten
 * @return {Object.<string, TypedArray>} The flattened vertices (same as was passed in)
 * @memberOf module:twgl/primitives
 */


function flattenNormals(vertices) {
  if (vertices.indices) {
    throw new Error('can not flatten normals of indexed vertices. deindex them first');
  }

  var normals = vertices.normal;
  var numNormals = normals.length;

  for (var ii = 0; ii < numNormals; ii += 9) {
    // pull out the 3 normals for this triangle
    var nax = normals[ii + 0];
    var nay = normals[ii + 1];
    var naz = normals[ii + 2];
    var nbx = normals[ii + 3];
    var nby = normals[ii + 4];
    var nbz = normals[ii + 5];
    var ncx = normals[ii + 6];
    var ncy = normals[ii + 7];
    var ncz = normals[ii + 8]; // add them

    var nx = nax + nbx + ncx;
    var ny = nay + nby + ncy;
    var nz = naz + nbz + ncz; // normalize them

    var length = Math.sqrt(nx * nx + ny * ny + nz * nz);
    nx /= length;
    ny /= length;
    nz /= length; // copy them back in

    normals[ii + 0] = nx;
    normals[ii + 1] = ny;
    normals[ii + 2] = nz;
    normals[ii + 3] = nx;
    normals[ii + 4] = ny;
    normals[ii + 5] = nz;
    normals[ii + 6] = nx;
    normals[ii + 7] = ny;
    normals[ii + 8] = nz;
  }

  return vertices;
}

function applyFuncToV3Array(array, matrix, fn) {
  var len = array.length;
  var tmp = new Float32Array(3);

  for (var ii = 0; ii < len; ii += 3) {
    fn(matrix, [array[ii], array[ii + 1], array[ii + 2]], tmp);
    array[ii] = tmp[0];
    array[ii + 1] = tmp[1];
    array[ii + 2] = tmp[2];
  }
}

function transformNormal(mi, v, dst) {
  dst = dst || v3.create();
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];
  dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];
  dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];
  return dst;
}
/**
 * Reorients directions by the given matrix..
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */


function reorientDirections(array, matrix) {
  applyFuncToV3Array(array, matrix, m4.transformDirection);
  return array;
}
/**
 * Reorients normals by the inverse-transpose of the given
 * matrix..
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */


function reorientNormals(array, matrix) {
  applyFuncToV3Array(array, m4.inverse(matrix), transformNormal);
  return array;
}
/**
 * Reorients positions by the given matrix. In other words, it
 * multiplies each vertex by the given matrix.
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */


function reorientPositions(array, matrix) {
  applyFuncToV3Array(array, matrix, m4.transformPoint);
  return array;
}
/**
 * @typedef {(number[]|TypedArray)} NativeArrayOrTypedArray
 */

/**
 * Reorients arrays by the given matrix. Assumes arrays have
 * names that contains 'pos' could be reoriented as positions,
 * 'binorm' or 'tan' as directions, and 'norm' as normals.
 *
 * @param {Object.<string, NativeArrayOrTypedArray>} arrays The vertices to reorient
 * @param {module:twgl/m4.Mat4} matrix matrix to reorient by.
 * @return {Object.<string, NativeArrayOrTypedArray>} same arrays that were passed in.
 * @memberOf module:twgl/primitives
 */


function reorientVertices(arrays, matrix) {
  Object.keys(arrays).forEach(function (name) {
    var array = arrays[name];

    if (name.indexOf("pos") >= 0) {
      reorientPositions(array, matrix);
    } else if (name.indexOf("tan") >= 0 || name.indexOf("binorm") >= 0) {
      reorientDirections(array, matrix);
    } else if (name.indexOf("norm") >= 0) {
      reorientNormals(array, matrix);
    }
  });
  return arrays;
}
/**
 * Creates XY quad BufferInfo
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0, 0.5);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {Object.<string, WebGLBuffer>} the created XY Quad BufferInfo
 * @memberOf module:twgl/primitives
 * @function createXYQuadBuffers
 */

/**
 * Creates XY quad Buffers
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0, 0.5);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {module:twgl.BufferInfo} the created XY Quad buffers
 * @memberOf module:twgl/primitives
 * @function createXYQuadBufferInfo
 */

/**
 * Creates XY quad vertices
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadVertices(1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadVertices(1, 0, 0.5);
 *
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {Object.<string, TypedArray>} the created XY Quad vertices
 * @memberOf module:twgl/primitives
 */


function createXYQuadVertices(size, xOffset, yOffset) {
  size = size || 2;
  xOffset = xOffset || 0;
  yOffset = yOffset || 0;
  size *= 0.5;
  return {
    position: {
      numComponents: 2,
      data: [xOffset + -1 * size, yOffset + -1 * size, xOffset + 1 * size, yOffset + -1 * size, xOffset + -1 * size, yOffset + 1 * size, xOffset + 1 * size, yOffset + 1 * size]
    },
    normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
    texcoord: [0, 0, 1, 0, 0, 1, 1, 1],
    indices: [0, 1, 2, 2, 1, 3]
  };
}
/**
 * Creates XZ plane BufferInfo.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {module:twgl.BufferInfo} The created plane BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createPlaneBufferInfo
 */

/**
 * Creates XZ plane buffers.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {Object.<string, WebGLBuffer>} The created plane buffers.
 * @memberOf module:twgl/primitives
 * @function createPlaneBuffers
 */

/**
 * Creates XZ plane vertices.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {Object.<string, TypedArray>} The created plane vertices.
 * @memberOf module:twgl/primitives
 */


function createPlaneVertices(width, depth, subdivisionsWidth, subdivisionsDepth, matrix) {
  width = width || 1;
  depth = depth || 1;
  subdivisionsWidth = subdivisionsWidth || 1;
  subdivisionsDepth = subdivisionsDepth || 1;
  matrix = matrix || m4.identity();
  var numVertices = (subdivisionsWidth + 1) * (subdivisionsDepth + 1);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);

  for (var z = 0; z <= subdivisionsDepth; z++) {
    for (var x = 0; x <= subdivisionsWidth; x++) {
      var u = x / subdivisionsWidth;
      var v = z / subdivisionsDepth;
      positions.push(width * u - width * 0.5, 0, depth * v - depth * 0.5);
      normals.push(0, 1, 0);
      texcoords.push(u, v);
    }
  }

  var numVertsAcross = subdivisionsWidth + 1;
  var indices = createAugmentedTypedArray(3, subdivisionsWidth * subdivisionsDepth * 2, Uint16Array);

  for (var _z = 0; _z < subdivisionsDepth; _z++) {
    // eslint-disable-line
    for (var _x = 0; _x < subdivisionsWidth; _x++) {
      // eslint-disable-line
      // Make triangle 1 of quad.
      indices.push((_z + 0) * numVertsAcross + _x, (_z + 1) * numVertsAcross + _x, (_z + 0) * numVertsAcross + _x + 1); // Make triangle 2 of quad.

      indices.push((_z + 1) * numVertsAcross + _x, (_z + 1) * numVertsAcross + _x + 1, (_z + 0) * numVertsAcross + _x + 1);
    }
  }

  var arrays = reorientVertices({
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  }, matrix);
  return arrays;
}
/**
 * Creates sphere BufferInfo.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {module:twgl.BufferInfo} The created sphere BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createSphereBufferInfo
 */

/**
 * Creates sphere buffers.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {Object.<string, WebGLBuffer>} The created sphere buffers.
 * @memberOf module:twgl/primitives
 * @function createSphereBuffers
 */

/**
 * Creates sphere vertices.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {Object.<string, TypedArray>} The created sphere vertices.
 * @memberOf module:twgl/primitives
 */


function createSphereVertices(radius, subdivisionsAxis, subdivisionsHeight, opt_startLatitudeInRadians, opt_endLatitudeInRadians, opt_startLongitudeInRadians, opt_endLongitudeInRadians) {
  if (subdivisionsAxis <= 0 || subdivisionsHeight <= 0) {
    throw new Error('subdivisionAxis and subdivisionHeight must be > 0');
  }

  opt_startLatitudeInRadians = opt_startLatitudeInRadians || 0;
  opt_endLatitudeInRadians = opt_endLatitudeInRadians || Math.PI;
  opt_startLongitudeInRadians = opt_startLongitudeInRadians || 0;
  opt_endLongitudeInRadians = opt_endLongitudeInRadians || Math.PI * 2;
  var latRange = opt_endLatitudeInRadians - opt_startLatitudeInRadians;
  var longRange = opt_endLongitudeInRadians - opt_startLongitudeInRadians; // We are going to generate our sphere by iterating through its
  // spherical coordinates and generating 2 triangles for each quad on a
  // ring of the sphere.

  var numVertices = (subdivisionsAxis + 1) * (subdivisionsHeight + 1);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices); // Generate the individual vertices in our vertex buffer.

  for (var y = 0; y <= subdivisionsHeight; y++) {
    for (var x = 0; x <= subdivisionsAxis; x++) {
      // Generate a vertex based on its spherical coordinates
      var u = x / subdivisionsAxis;
      var v = y / subdivisionsHeight;
      var theta = longRange * u + opt_startLongitudeInRadians;
      var phi = latRange * v + opt_startLatitudeInRadians;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var sinPhi = Math.sin(phi);
      var cosPhi = Math.cos(phi);
      var ux = cosTheta * sinPhi;
      var uy = cosPhi;
      var uz = sinTheta * sinPhi;
      positions.push(radius * ux, radius * uy, radius * uz);
      normals.push(ux, uy, uz);
      texcoords.push(1 - u, v);
    }
  }

  var numVertsAround = subdivisionsAxis + 1;
  var indices = createAugmentedTypedArray(3, subdivisionsAxis * subdivisionsHeight * 2, Uint16Array);

  for (var _x2 = 0; _x2 < subdivisionsAxis; _x2++) {
    // eslint-disable-line
    for (var _y = 0; _y < subdivisionsHeight; _y++) {
      // eslint-disable-line
      // Make triangle 1 of quad.
      indices.push((_y + 0) * numVertsAround + _x2, (_y + 0) * numVertsAround + _x2 + 1, (_y + 1) * numVertsAround + _x2); // Make triangle 2 of quad.

      indices.push((_y + 1) * numVertsAround + _x2, (_y + 0) * numVertsAround + _x2 + 1, (_y + 1) * numVertsAround + _x2 + 1);
    }
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Array of the indices of corners of each face of a cube.
 * @type {Array.<number[]>}
 * @private
 */


var CUBE_FACE_INDICES = [[3, 7, 5, 1], // right
[6, 2, 0, 4], // left
[6, 7, 3, 2], // ??
[0, 1, 5, 4], // ??
[7, 6, 4, 5], // front
[2, 3, 1, 0] // back
];
/**
 * Creates a BufferInfo for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] width, height and depth of the cube.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCubeBufferInfo
 */

/**
 * Creates the buffers and indices for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] width, height and depth of the cube.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCubeBuffers
 */

/**
 * Creates the vertices and indices for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {number} [size] width, height and depth of the cube.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */

function createCubeVertices(size) {
  size = size || 1;
  var k = size / 2;
  var cornerVertices = [[-k, -k, -k], [+k, -k, -k], [-k, +k, -k], [+k, +k, -k], [-k, -k, +k], [+k, -k, +k], [-k, +k, +k], [+k, +k, +k]];
  var faceNormals = [[+1, +0, +0], [-1, +0, +0], [+0, +1, +0], [+0, -1, +0], [+0, +0, +1], [+0, +0, -1]];
  var uvCoords = [[1, 0], [0, 0], [0, 1], [1, 1]];
  var numVertices = 6 * 4;
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);
  var indices = createAugmentedTypedArray(3, 6 * 2, Uint16Array);

  for (var f = 0; f < 6; ++f) {
    var faceIndices = CUBE_FACE_INDICES[f];

    for (var v = 0; v < 4; ++v) {
      var position = cornerVertices[faceIndices[v]];
      var normal = faceNormals[f];
      var uv = uvCoords[v]; // Each face needs all four vertices because the normals and texture
      // coordinates are not all the same.

      positions.push(position);
      normals.push(normal);
      texcoords.push(uv);
    } // Two triangles make a square face.


    var offset = 4 * f;
    indices.push(offset + 0, offset + 1, offset + 2);
    indices.push(offset + 0, offset + 2, offset + 3);
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Creates a BufferInfo for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {module:twgl.BufferInfo} The created cone BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createTruncatedConeBufferInfo
 */

/**
 * Creates buffers for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, WebGLBuffer>} The created cone buffers.
 * @memberOf module:twgl/primitives
 * @function createTruncatedConeBuffers
 */

/**
 * Creates vertices for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis. .
 *
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, TypedArray>} The created cone vertices.
 * @memberOf module:twgl/primitives
 */


function createTruncatedConeVertices(bottomRadius, topRadius, height, radialSubdivisions, verticalSubdivisions, opt_topCap, opt_bottomCap) {
  if (radialSubdivisions < 3) {
    throw new Error('radialSubdivisions must be 3 or greater');
  }

  if (verticalSubdivisions < 1) {
    throw new Error('verticalSubdivisions must be 1 or greater');
  }

  var topCap = opt_topCap === undefined ? true : opt_topCap;
  var bottomCap = opt_bottomCap === undefined ? true : opt_bottomCap;
  var extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
  var numVertices = (radialSubdivisions + 1) * (verticalSubdivisions + 1 + extra);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);
  var indices = createAugmentedTypedArray(3, radialSubdivisions * (verticalSubdivisions + extra / 2) * 2, Uint16Array);
  var vertsAroundEdge = radialSubdivisions + 1; // The slant of the cone is constant across its surface

  var slant = Math.atan2(bottomRadius - topRadius, height);
  var cosSlant = Math.cos(slant);
  var sinSlant = Math.sin(slant);
  var start = topCap ? -2 : 0;
  var end = verticalSubdivisions + (bottomCap ? 2 : 0);

  for (var yy = start; yy <= end; ++yy) {
    var v = yy / verticalSubdivisions;
    var y = height * v;
    var ringRadius = void 0;

    if (yy < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (yy > verticalSubdivisions) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius + (topRadius - bottomRadius) * (yy / verticalSubdivisions);
    }

    if (yy === -2 || yy === verticalSubdivisions + 2) {
      ringRadius = 0;
      v = 0;
    }

    y -= height / 2;

    for (var ii = 0; ii < vertsAroundEdge; ++ii) {
      var sin = Math.sin(ii * Math.PI * 2 / radialSubdivisions);
      var cos = Math.cos(ii * Math.PI * 2 / radialSubdivisions);
      positions.push(sin * ringRadius, y, cos * ringRadius);

      if (yy < 0) {
        normals.push(0, -1, 0);
      } else if (yy > verticalSubdivisions) {
        normals.push(0, 1, 0);
      } else if (ringRadius === 0.0) {
        normals.push(0, 0, 0);
      } else {
        normals.push(sin * cosSlant, sinSlant, cos * cosSlant);
      }

      texcoords.push(ii / radialSubdivisions, 1 - v);
    }
  }

  for (var _yy = 0; _yy < verticalSubdivisions + extra; ++_yy) {
    // eslint-disable-line
    if (_yy === 1 && topCap || _yy === verticalSubdivisions + extra - 2 && bottomCap) {
      continue;
    }

    for (var _ii = 0; _ii < radialSubdivisions; ++_ii) {
      // eslint-disable-line
      indices.push(vertsAroundEdge * (_yy + 0) + 0 + _ii, vertsAroundEdge * (_yy + 0) + 1 + _ii, vertsAroundEdge * (_yy + 1) + 1 + _ii);
      indices.push(vertsAroundEdge * (_yy + 0) + 0 + _ii, vertsAroundEdge * (_yy + 1) + 1 + _ii, vertsAroundEdge * (_yy + 1) + 0 + _ii);
    }
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Expands RLE data
 * @param {number[]} rleData data in format of run-length, x, y, z, run-length, x, y, z
 * @param {number[]} [padding] value to add each entry with.
 * @return {number[]} the expanded rleData
 * @private
 */


function expandRLEData(rleData, padding) {
  padding = padding || [];
  var data = [];

  for (var ii = 0; ii < rleData.length; ii += 4) {
    var runLength = rleData[ii];
    var element = rleData.slice(ii + 1, ii + 4);
    element.push.apply(element, padding);

    for (var jj = 0; jj < runLength; ++jj) {
      data.push.apply(data, element);
    }
  }

  return data;
}
/**
 * Creates 3D 'F' BufferInfo.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function create3DFBufferInfo
 */

/**
 * Creates 3D 'F' buffers.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function create3DFBuffers
 */

/**
 * Creates 3D 'F' vertices.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color arrays.
 *
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function create3DFVertices() {
  var positions = [// left column front
  0, 0, 0, 0, 150, 0, 30, 0, 0, 0, 150, 0, 30, 150, 0, 30, 0, 0, // top rung front
  30, 0, 0, 30, 30, 0, 100, 0, 0, 30, 30, 0, 100, 30, 0, 100, 0, 0, // middle rung front
  30, 60, 0, 30, 90, 0, 67, 60, 0, 30, 90, 0, 67, 90, 0, 67, 60, 0, // left column back
  0, 0, 30, 30, 0, 30, 0, 150, 30, 0, 150, 30, 30, 0, 30, 30, 150, 30, // top rung back
  30, 0, 30, 100, 0, 30, 30, 30, 30, 30, 30, 30, 100, 0, 30, 100, 30, 30, // middle rung back
  30, 60, 30, 67, 60, 30, 30, 90, 30, 30, 90, 30, 67, 60, 30, 67, 90, 30, // top
  0, 0, 0, 100, 0, 0, 100, 0, 30, 0, 0, 0, 100, 0, 30, 0, 0, 30, // top rung front
  100, 0, 0, 100, 30, 0, 100, 30, 30, 100, 0, 0, 100, 30, 30, 100, 0, 30, // under top rung
  30, 30, 0, 30, 30, 30, 100, 30, 30, 30, 30, 0, 100, 30, 30, 100, 30, 0, // between top rung and middle
  30, 30, 0, 30, 60, 30, 30, 30, 30, 30, 30, 0, 30, 60, 0, 30, 60, 30, // top of middle rung
  30, 60, 0, 67, 60, 30, 30, 60, 30, 30, 60, 0, 67, 60, 0, 67, 60, 30, // front of middle rung
  67, 60, 0, 67, 90, 30, 67, 60, 30, 67, 60, 0, 67, 90, 0, 67, 90, 30, // bottom of middle rung.
  30, 90, 0, 30, 90, 30, 67, 90, 30, 30, 90, 0, 67, 90, 30, 67, 90, 0, // front of bottom
  30, 90, 0, 30, 150, 30, 30, 90, 30, 30, 90, 0, 30, 150, 0, 30, 150, 30, // bottom
  0, 150, 0, 0, 150, 30, 30, 150, 30, 0, 150, 0, 30, 150, 30, 30, 150, 0, // left side
  0, 0, 0, 0, 0, 30, 0, 150, 30, 0, 0, 0, 0, 150, 30, 0, 150, 0];
  var texcoords = [// left column front
  0.22, 0.19, 0.22, 0.79, 0.34, 0.19, 0.22, 0.79, 0.34, 0.79, 0.34, 0.19, // top rung front
  0.34, 0.19, 0.34, 0.31, 0.62, 0.19, 0.34, 0.31, 0.62, 0.31, 0.62, 0.19, // middle rung front
  0.34, 0.43, 0.34, 0.55, 0.49, 0.43, 0.34, 0.55, 0.49, 0.55, 0.49, 0.43, // left column back
  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, // top rung back
  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, // middle rung back
  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, // top
  0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, // top rung front
  0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, // under top rung
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, // between top rung and middle
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, // top of middle rung
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, // front of middle rung
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, // bottom of middle rung.
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, // front of bottom
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, // bottom
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, // left side
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0];
  var normals = expandRLEData([// left column front
  // top rung front
  // middle rung front
  18, 0, 0, 1, // left column back
  // top rung back
  // middle rung back
  18, 0, 0, -1, // top
  6, 0, 1, 0, // top rung front
  6, 1, 0, 0, // under top rung
  6, 0, -1, 0, // between top rung and middle
  6, 1, 0, 0, // top of middle rung
  6, 0, 1, 0, // front of middle rung
  6, 1, 0, 0, // bottom of middle rung.
  6, 0, -1, 0, // front of bottom
  6, 1, 0, 0, // bottom
  6, 0, -1, 0, // left side
  6, -1, 0, 0]);
  var colors = expandRLEData([// left column front
  // top rung front
  // middle rung front
  18, 200, 70, 120, // left column back
  // top rung back
  // middle rung back
  18, 80, 70, 200, // top
  6, 70, 200, 210, // top rung front
  6, 200, 200, 70, // under top rung
  6, 210, 100, 70, // between top rung and middle
  6, 210, 160, 70, // top of middle rung
  6, 70, 180, 210, // front of middle rung
  6, 100, 70, 210, // bottom of middle rung.
  6, 76, 210, 100, // front of bottom
  6, 140, 210, 80, // bottom
  6, 90, 130, 110, // left side
  6, 160, 160, 220], [255]);
  var numVerts = positions.length / 3;
  var arrays = {
    position: createAugmentedTypedArray(3, numVerts),
    texcoord: createAugmentedTypedArray(2, numVerts),
    normal: createAugmentedTypedArray(3, numVerts),
    color: createAugmentedTypedArray(4, numVerts, Uint8Array),
    indices: createAugmentedTypedArray(3, numVerts / 3, Uint16Array)
  };
  arrays.position.push(positions);
  arrays.texcoord.push(texcoords);
  arrays.normal.push(normals);
  arrays.color.push(colors);

  for (var ii = 0; ii < numVerts; ++ii) {
    arrays.indices.push(ii);
  }

  return arrays;
}
/**
 * Creates crescent BufferInfo.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCresentBufferInfo
 */

/**
 * Creates crescent buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCresentBuffers
 */

/**
 * Creates crescent vertices.
 *
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 * @function createCresentBuffers
 */

/**
 * Creates crescent BufferInfo.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCrescentBufferInfo
 */

/**
 * Creates crescent buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCrescentBuffers
 */

/**
 * Creates crescent vertices.
 *
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function createCrescentVertices(verticalRadius, outerRadius, innerRadius, thickness, subdivisionsDown, startOffset, endOffset) {
  if (subdivisionsDown <= 0) {
    throw new Error('subdivisionDown must be > 0');
  }

  startOffset = startOffset || 0;
  endOffset = endOffset || 1;
  var subdivisionsThick = 2;
  var offsetRange = endOffset - startOffset;
  var numVertices = (subdivisionsDown + 1) * 2 * (2 + subdivisionsThick);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);

  function lerp(a, b, s) {
    return a + (b - a) * s;
  }

  function createArc(arcRadius, x, normalMult, normalAdd, uMult, uAdd) {
    for (var z = 0; z <= subdivisionsDown; z++) {
      var uBack = x / (subdivisionsThick - 1);
      var v = z / subdivisionsDown;
      var xBack = (uBack - 0.5) * 2;
      var angle = (startOffset + v * offsetRange) * Math.PI;
      var s = Math.sin(angle);
      var c = Math.cos(angle);
      var radius = lerp(verticalRadius, arcRadius, s);
      var px = xBack * thickness;
      var py = c * verticalRadius;
      var pz = s * radius;
      positions.push(px, py, pz);
      var n = v3.add(v3.multiply([0, s, c], normalMult), normalAdd);
      normals.push(n);
      texcoords.push(uBack * uMult + uAdd, v);
    }
  } // Generate the individual vertices in our vertex buffer.


  for (var x = 0; x < subdivisionsThick; x++) {
    var uBack = (x / (subdivisionsThick - 1) - 0.5) * 2;
    createArc(outerRadius, x, [1, 1, 1], [0, 0, 0], 1, 0);
    createArc(outerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 0);
    createArc(innerRadius, x, [1, 1, 1], [0, 0, 0], 1, 0);
    createArc(innerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 1);
  } // Do outer surface.


  var indices = createAugmentedTypedArray(3, subdivisionsDown * 2 * (2 + subdivisionsThick), Uint16Array);

  function createSurface(leftArcOffset, rightArcOffset) {
    for (var z = 0; z < subdivisionsDown; ++z) {
      // Make triangle 1 of quad.
      indices.push(leftArcOffset + z + 0, leftArcOffset + z + 1, rightArcOffset + z + 0); // Make triangle 2 of quad.

      indices.push(leftArcOffset + z + 1, rightArcOffset + z + 1, rightArcOffset + z + 0);
    }
  }

  var numVerticesDown = subdivisionsDown + 1; // front

  createSurface(numVerticesDown * 0, numVerticesDown * 4); // right

  createSurface(numVerticesDown * 5, numVerticesDown * 7); // back

  createSurface(numVerticesDown * 6, numVerticesDown * 2); // left

  createSurface(numVerticesDown * 3, numVerticesDown * 1);
  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Creates cylinder BufferInfo. The cylinder will be created around the origin
 * along the y-axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of cylinder.
 * @param {number} height Height of cylinder.
 * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
 * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
 * @param {boolean} [topCap] Create top cap. Default = true.
 * @param {boolean} [bottomCap] Create bottom cap. Default = true.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCylinderBufferInfo
 */

/**
 * Creates cylinder buffers. The cylinder will be created around the origin
 * along the y-axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of cylinder.
 * @param {number} height Height of cylinder.
 * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
 * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
 * @param {boolean} [topCap] Create top cap. Default = true.
 * @param {boolean} [bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCylinderBuffers
 */

/**
 * Creates cylinder vertices. The cylinder will be created around the origin
 * along the y-axis.
 *
 * @param {number} radius Radius of cylinder.
 * @param {number} height Height of cylinder.
 * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
 * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
 * @param {boolean} [topCap] Create top cap. Default = true.
 * @param {boolean} [bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function createCylinderVertices(radius, height, radialSubdivisions, verticalSubdivisions, topCap, bottomCap) {
  return createTruncatedConeVertices(radius, radius, height, radialSubdivisions, verticalSubdivisions, topCap, bottomCap);
}
/**
 * Creates BufferInfo for a torus
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createTorusBufferInfo
 */

/**
 * Creates buffers for a torus
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createTorusBuffers
 */

/**
 * Creates vertices for a torus
 *
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function createTorusVertices(radius, thickness, radialSubdivisions, bodySubdivisions, startAngle, endAngle) {
  if (radialSubdivisions < 3) {
    throw new Error('radialSubdivisions must be 3 or greater');
  }

  if (bodySubdivisions < 3) {
    throw new Error('verticalSubdivisions must be 3 or greater');
  }

  startAngle = startAngle || 0;
  endAngle = endAngle || Math.PI * 2;
  var range = endAngle - startAngle;
  var radialParts = radialSubdivisions + 1;
  var bodyParts = bodySubdivisions + 1;
  var numVertices = radialParts * bodyParts;
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);
  var indices = createAugmentedTypedArray(3, radialSubdivisions * bodySubdivisions * 2, Uint16Array);

  for (var slice = 0; slice < bodyParts; ++slice) {
    var v = slice / bodySubdivisions;
    var sliceAngle = v * Math.PI * 2;
    var sliceSin = Math.sin(sliceAngle);
    var ringRadius = radius + sliceSin * thickness;
    var ny = Math.cos(sliceAngle);
    var y = ny * thickness;

    for (var ring = 0; ring < radialParts; ++ring) {
      var u = ring / radialSubdivisions;
      var ringAngle = startAngle + u * range;
      var xSin = Math.sin(ringAngle);
      var zCos = Math.cos(ringAngle);
      var x = xSin * ringRadius;
      var z = zCos * ringRadius;
      var nx = xSin * sliceSin;
      var nz = zCos * sliceSin;
      positions.push(x, y, z);
      normals.push(nx, ny, nz);
      texcoords.push(u, 1 - v);
    }
  }

  for (var _slice = 0; _slice < bodySubdivisions; ++_slice) {
    // eslint-disable-line
    for (var _ring = 0; _ring < radialSubdivisions; ++_ring) {
      // eslint-disable-line
      var nextRingIndex = 1 + _ring;
      var nextSliceIndex = 1 + _slice;
      indices.push(radialParts * _slice + _ring, radialParts * nextSliceIndex + _ring, radialParts * _slice + nextRingIndex);
      indices.push(radialParts * nextSliceIndex + _ring, radialParts * nextSliceIndex + nextRingIndex, radialParts * _slice + nextRingIndex);
    }
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Creates a disc BufferInfo. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createDiscBufferInfo
 */

/**
 * Creates disc buffers. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createDiscBuffers
 */

/**
 * Creates disc vertices. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function createDiscVertices(radius, divisions, stacks, innerRadius, stackPower) {
  if (divisions < 3) {
    throw new Error('divisions must be at least 3');
  }

  stacks = stacks ? stacks : 1;
  stackPower = stackPower ? stackPower : 1;
  innerRadius = innerRadius ? innerRadius : 0; // Note: We don't share the center vertex because that would
  // mess up texture coordinates.

  var numVertices = (divisions + 1) * (stacks + 1);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);
  var indices = createAugmentedTypedArray(3, stacks * divisions * 2, Uint16Array);
  var firstIndex = 0;
  var radiusSpan = radius - innerRadius;
  var pointsPerStack = divisions + 1; // Build the disk one stack at a time.

  for (var stack = 0; stack <= stacks; ++stack) {
    var stackRadius = innerRadius + radiusSpan * Math.pow(stack / stacks, stackPower);

    for (var i = 0; i <= divisions; ++i) {
      var theta = 2.0 * Math.PI * i / divisions;
      var x = stackRadius * Math.cos(theta);
      var z = stackRadius * Math.sin(theta);
      positions.push(x, 0, z);
      normals.push(0, 1, 0);
      texcoords.push(1 - i / divisions, stack / stacks);

      if (stack > 0 && i !== divisions) {
        // a, b, c and d are the indices of the vertices of a quad.  unless
        // the current stack is the one closest to the center, in which case
        // the vertices a and b connect to the center vertex.
        var a = firstIndex + (i + 1);
        var b = firstIndex + i;
        var c = firstIndex + i - pointsPerStack;
        var d = firstIndex + (i + 1) - pointsPerStack; // Make a quad of the vertices a, b, c, d.

        indices.push(a, b, c);
        indices.push(a, c, d);
      }
    }

    firstIndex += divisions + 1;
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * creates a random integer between 0 and range - 1 inclusive.
 * @param {number} range
 * @return {number} random value between 0 and range - 1 inclusive.
 * @private
 */


function randInt(range) {
  return Math.random() * range | 0;
}
/**
 * Used to supply random colors
 * @callback RandomColorFunc
 * @param {number} ndx index of triangle/quad if unindexed or index of vertex if indexed
 * @param {number} channel 0 = red, 1 = green, 2 = blue, 3 = alpha
 * @return {number} a number from 0 to 255
 * @memberOf module:twgl/primitives
 */

/**
 * @typedef {Object} RandomVerticesOptions
 * @property {number} [vertsPerColor] Defaults to 3 for non-indexed vertices
 * @property {module:twgl/primitives.RandomColorFunc} [rand] A function to generate random numbers
 * @memberOf module:twgl/primitives
 */

/**
 * Creates an augmentedTypedArray of random vertex colors.
 * If the vertices are indexed (have an indices array) then will
 * just make random colors. Otherwise assumes they are triangles
 * and makes one random color for every 3 vertices.
 * @param {Object.<string, AugmentedTypedArray>} vertices Vertices as returned from one of the createXXXVertices functions.
 * @param {module:twgl/primitives.RandomVerticesOptions} [options] options.
 * @return {Object.<string, AugmentedTypedArray>} same vertices as passed in with `color` added.
 * @memberOf module:twgl/primitives
 */


function makeRandomVertexColors(vertices, options) {
  options = options || {};
  var numElements = vertices.position.numElements;
  var vColors = createAugmentedTypedArray(4, numElements, Uint8Array);

  var rand = options.rand || function (ndx, channel) {
    return channel < 3 ? randInt(256) : 255;
  };

  vertices.color = vColors;

  if (vertices.indices) {
    // just make random colors if index
    for (var ii = 0; ii < numElements; ++ii) {
      vColors.push(rand(ii, 0), rand(ii, 1), rand(ii, 2), rand(ii, 3));
    }
  } else {
    // make random colors per triangle
    var numVertsPerColor = options.vertsPerColor || 3;
    var numSets = numElements / numVertsPerColor;

    for (var _ii2 = 0; _ii2 < numSets; ++_ii2) {
      // eslint-disable-line
      var color = [rand(_ii2, 0), rand(_ii2, 1), rand(_ii2, 2), rand(_ii2, 3)];

      for (var jj = 0; jj < numVertsPerColor; ++jj) {
        vColors.push(color);
      }
    }
  }

  return vertices;
}
/**
 * creates a function that calls fn to create vertices and then
 * creates a buffers for them
 * @private
 */


function createBufferFunc(fn) {
  return function (gl) {
    var arrays = fn.apply(this, Array.prototype.slice.call(arguments, 1));
    return attributes.createBuffersFromArrays(gl, arrays);
  };
}
/**
 * creates a function that calls fn to create vertices and then
 * creates a bufferInfo object for them
 * @private
 */


function createBufferInfoFunc(fn) {
  return function (gl) {
    var arrays = fn.apply(null, Array.prototype.slice.call(arguments, 1));
    return attributes.createBufferInfoFromArrays(gl, arrays);
  };
}

var arraySpecPropertyNames = ["numComponents", "size", "type", "normalize", "stride", "offset", "attrib", "name", "attribName"];
/**
 * Copy elements from one array to another
 *
 * @param {Array|TypedArray} src source array
 * @param {Array|TypedArray} dst dest array
 * @param {number} dstNdx index in dest to copy src
 * @param {number} [offset] offset to add to copied values
 * @private
 */

function copyElements(src, dst, dstNdx, offset) {
  offset = offset || 0;
  var length = src.length;

  for (var ii = 0; ii < length; ++ii) {
    dst[dstNdx + ii] = src[ii] + offset;
  }
}
/**
 * Creates an array of the same time
 *
 * @param {(number[]|ArrayBufferView|module:twgl.FullArraySpec)} srcArray array who's type to copy
 * @param {number} length size of new array
 * @return {(number[]|ArrayBufferView|module:twgl.FullArraySpec)} array with same type as srcArray
 * @private
 */


function createArrayOfSameType(srcArray, length) {
  var arraySrc = getArray(srcArray);
  var newArray = new arraySrc.constructor(length);
  var newArraySpec = newArray; // If it appears to have been augmented make new one augmented

  if (arraySrc.numComponents && arraySrc.numElements) {
    augmentTypedArray(newArray, arraySrc.numComponents);
  } // If it was a full spec make new one a full spec


  if (srcArray.data) {
    newArraySpec = {
      data: newArray
    };
    helper.copyNamedProperties(arraySpecPropertyNames, srcArray, newArraySpec);
  }

  return newArraySpec;
}
/**
 * Concatenates sets of vertices
 *
 * Assumes the vertices match in composition. For example
 * if one set of vertices has positions, normals, and indices
 * all sets of vertices must have positions, normals, and indices
 * and of the same type.
 *
 * Example:
 *
 *      const cubeVertices = twgl.primitives.createCubeVertices(2);
 *      const sphereVertices = twgl.primitives.createSphereVertices(1, 10, 10);
 *      // move the sphere 2 units up
 *      twgl.primitives.reorientVertices(
 *          sphereVertices, twgl.m4.translation([0, 2, 0]));
 *      // merge the sphere with the cube
 *      const cubeSphereVertices = twgl.primitives.concatVertices(
 *          [cubeVertices, sphereVertices]);
 *      // turn them into WebGL buffers and attrib data
 *      const bufferInfo = twgl.createBufferInfoFromArrays(gl, cubeSphereVertices);
 *
 * @param {module:twgl.Arrays[]} arrays Array of arrays of vertices
 * @return {module:twgl.Arrays} The concatenated vertices.
 * @memberOf module:twgl/primitives
 */


function concatVertices(arrayOfArrays) {
  var names = {};
  var baseName; // get names of all arrays.
  // and numElements for each set of vertices

  var _loop = function _loop(ii) {
    var arrays = arrayOfArrays[ii];
    Object.keys(arrays).forEach(function (name) {
      // eslint-disable-line
      if (!names[name]) {
        names[name] = [];
      }

      if (!baseName && name !== 'indices') {
        baseName = name;
      }

      var arrayInfo = arrays[name];
      var numComponents = getNumComponents(arrayInfo, name);
      var array = getArray(arrayInfo);
      var numElements = array.length / numComponents;
      names[name].push(numElements);
    });
  };

  for (var ii = 0; ii < arrayOfArrays.length; ++ii) {
    _loop(ii);
  } // compute length of combined array
  // and return one for reference


  function getLengthOfCombinedArrays(name) {
    var length = 0;
    var arraySpec;

    for (var _ii3 = 0; _ii3 < arrayOfArrays.length; ++_ii3) {
      var arrays = arrayOfArrays[_ii3];
      var arrayInfo = arrays[name];
      var array = getArray(arrayInfo);
      length += array.length;

      if (!arraySpec || arrayInfo.data) {
        arraySpec = arrayInfo;
      }
    }

    return {
      length: length,
      spec: arraySpec
    };
  }

  function copyArraysToNewArray(name, base, newArray) {
    var baseIndex = 0;
    var offset = 0;

    for (var _ii4 = 0; _ii4 < arrayOfArrays.length; ++_ii4) {
      var arrays = arrayOfArrays[_ii4];
      var arrayInfo = arrays[name];
      var array = getArray(arrayInfo);

      if (name === 'indices') {
        copyElements(array, newArray, offset, baseIndex);
        baseIndex += base[_ii4];
      } else {
        copyElements(array, newArray, offset);
      }

      offset += array.length;
    }
  }

  var base = names[baseName];
  var newArrays = {};
  Object.keys(names).forEach(function (name) {
    var info = getLengthOfCombinedArrays(name);
    var newArraySpec = createArrayOfSameType(info.spec, info.length);
    copyArraysToNewArray(name, base, getArray(newArraySpec));
    newArrays[name] = newArraySpec;
  });
  return newArrays;
}
/**
 * Creates a duplicate set of vertices
 *
 * This is useful for calling reorientVertices when you
 * also want to keep the original available
 *
 * @param {module:twgl.Arrays} arrays of vertices
 * @return {module:twgl.Arrays} The duplicated vertices.
 * @memberOf module:twgl/primitives
 */


function duplicateVertices(arrays) {
  var newArrays = {};
  Object.keys(arrays).forEach(function (name) {
    var arraySpec = arrays[name];
    var srcArray = getArray(arraySpec);
    var newArraySpec = createArrayOfSameType(arraySpec, srcArray.length);
    copyElements(srcArray, getArray(newArraySpec), 0);
    newArrays[name] = newArraySpec;
  });
  return newArrays;
}

var create3DFBufferInfo = createBufferInfoFunc(create3DFVertices);
exports.create3DFBufferInfo = create3DFBufferInfo;
var create3DFBuffers = createBufferFunc(create3DFVertices);
exports.create3DFBuffers = create3DFBuffers;
var createCubeBufferInfo = createBufferInfoFunc(createCubeVertices);
exports.createCubeBufferInfo = createCubeBufferInfo;
var createCubeBuffers = createBufferFunc(createCubeVertices);
exports.createCubeBuffers = createCubeBuffers;
var createPlaneBufferInfo = createBufferInfoFunc(createPlaneVertices);
exports.createPlaneBufferInfo = createPlaneBufferInfo;
var createPlaneBuffers = createBufferFunc(createPlaneVertices);
exports.createPlaneBuffers = createPlaneBuffers;
var createSphereBufferInfo = createBufferInfoFunc(createSphereVertices);
exports.createSphereBufferInfo = createSphereBufferInfo;
var createSphereBuffers = createBufferFunc(createSphereVertices);
exports.createSphereBuffers = createSphereBuffers;
var createTruncatedConeBufferInfo = createBufferInfoFunc(createTruncatedConeVertices);
exports.createTruncatedConeBufferInfo = createTruncatedConeBufferInfo;
var createTruncatedConeBuffers = createBufferFunc(createTruncatedConeVertices);
exports.createTruncatedConeBuffers = createTruncatedConeBuffers;
var createXYQuadBufferInfo = createBufferInfoFunc(createXYQuadVertices);
exports.createXYQuadBufferInfo = createXYQuadBufferInfo;
var createXYQuadBuffers = createBufferFunc(createXYQuadVertices);
exports.createXYQuadBuffers = createXYQuadBuffers;
var createCrescentBufferInfo = createBufferInfoFunc(createCrescentVertices);
exports.createCrescentBufferInfo = createCrescentBufferInfo;
var createCrescentBuffers = createBufferFunc(createCrescentVertices);
exports.createCrescentBuffers = createCrescentBuffers;
var createCylinderBufferInfo = createBufferInfoFunc(createCylinderVertices);
exports.createCylinderBufferInfo = createCylinderBufferInfo;
var createCylinderBuffers = createBufferFunc(createCylinderVertices);
exports.createCylinderBuffers = createCylinderBuffers;
var createTorusBufferInfo = createBufferInfoFunc(createTorusVertices);
exports.createTorusBufferInfo = createTorusBufferInfo;
var createTorusBuffers = createBufferFunc(createTorusVertices);
exports.createTorusBuffers = createTorusBuffers;
var createDiscBufferInfo = createBufferInfoFunc(createDiscVertices);
exports.createDiscBufferInfo = createDiscBufferInfo;
var createDiscBuffers = createBufferFunc(createDiscVertices); // these were mis-spelled until 4.12

exports.createDiscBuffers = createDiscBuffers;
var createCresentBufferInfo = createCrescentBufferInfo;
exports.createCresentBufferInfo = createCresentBufferInfo;
var createCresentBuffers = createCrescentBuffers;
exports.createCresentBuffers = createCresentBuffers;
var createCresentVertices = createCrescentVertices;
exports.createCresentVertices = createCresentVertices;

/***/ }),

/***/ "./src/programs.js":
/*!*************************!*\
  !*** ./src/programs.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.createAttributeSetters = createAttributeSetters;
exports.createProgram = createProgram;
exports.createProgramFromScripts = createProgramFromScripts;
exports.createProgramFromSources = createProgramFromSources;
exports.createProgramInfo = createProgramInfo;
exports.createProgramInfoFromProgram = createProgramInfoFromProgram;
exports.createUniformSetters = createUniformSetters;
exports.createUniformBlockSpecFromProgram = createUniformBlockSpecFromProgram;
exports.createUniformBlockInfoFromProgram = createUniformBlockInfoFromProgram;
exports.createUniformBlockInfo = createUniformBlockInfo;
exports.createTransformFeedback = createTransformFeedback;
exports.createTransformFeedbackInfo = createTransformFeedbackInfo;
exports.bindTransformFeedbackInfo = bindTransformFeedbackInfo;
exports.setAttributes = setAttributes;
exports.setBuffersAndAttributes = setBuffersAndAttributes;
exports.setUniforms = setUniforms;
exports.setUniformBlock = setUniformBlock;
exports.setBlockUniforms = setBlockUniforms;
exports.bindUniformBlock = bindUniformBlock;
exports.setUniformsAndBindTextures = void 0;

var utils = _interopRequireWildcard(__webpack_require__(/*! ./utils.js */ "./src/utils.js"));

var helper = _interopRequireWildcard(__webpack_require__(/*! ./helper.js */ "./src/helper.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Low level shader program related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.programs` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/programs
 */
var error = helper.error;
var warn = helper.warn;

function getElementById(id) {
  return typeof document !== 'undefined' && document.getElementById ? document.getElementById(id) : null;
}

var TEXTURE0 = 0x84c0;
var DYNAMIC_DRAW = 0x88e8;
var ARRAY_BUFFER = 0x8892;
var ELEMENT_ARRAY_BUFFER = 0x8893;
var UNIFORM_BUFFER = 0x8a11;
var TRANSFORM_FEEDBACK_BUFFER = 0x8c8e;
var TRANSFORM_FEEDBACK = 0x8e22;
var COMPILE_STATUS = 0x8b81;
var LINK_STATUS = 0x8b82;
var FRAGMENT_SHADER = 0x8b30;
var VERTEX_SHADER = 0x8b31;
var SEPARATE_ATTRIBS = 0x8c8d;
var ACTIVE_UNIFORMS = 0x8b86;
var ACTIVE_ATTRIBUTES = 0x8b89;
var TRANSFORM_FEEDBACK_VARYINGS = 0x8c83;
var ACTIVE_UNIFORM_BLOCKS = 0x8a36;
var UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8a44;
var UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8a46;
var UNIFORM_BLOCK_DATA_SIZE = 0x8a40;
var UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8a43;
var FLOAT = 0x1406;
var FLOAT_VEC2 = 0x8B50;
var FLOAT_VEC3 = 0x8B51;
var FLOAT_VEC4 = 0x8B52;
var INT = 0x1404;
var INT_VEC2 = 0x8B53;
var INT_VEC3 = 0x8B54;
var INT_VEC4 = 0x8B55;
var BOOL = 0x8B56;
var BOOL_VEC2 = 0x8B57;
var BOOL_VEC3 = 0x8B58;
var BOOL_VEC4 = 0x8B59;
var FLOAT_MAT2 = 0x8B5A;
var FLOAT_MAT3 = 0x8B5B;
var FLOAT_MAT4 = 0x8B5C;
var SAMPLER_2D = 0x8B5E;
var SAMPLER_CUBE = 0x8B60;
var SAMPLER_3D = 0x8B5F;
var SAMPLER_2D_SHADOW = 0x8B62;
var FLOAT_MAT2x3 = 0x8B65;
var FLOAT_MAT2x4 = 0x8B66;
var FLOAT_MAT3x2 = 0x8B67;
var FLOAT_MAT3x4 = 0x8B68;
var FLOAT_MAT4x2 = 0x8B69;
var FLOAT_MAT4x3 = 0x8B6A;
var SAMPLER_2D_ARRAY = 0x8DC1;
var SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;
var SAMPLER_CUBE_SHADOW = 0x8DC5;
var UNSIGNED_INT = 0x1405;
var UNSIGNED_INT_VEC2 = 0x8DC6;
var UNSIGNED_INT_VEC3 = 0x8DC7;
var UNSIGNED_INT_VEC4 = 0x8DC8;
var INT_SAMPLER_2D = 0x8DCA;
var INT_SAMPLER_3D = 0x8DCB;
var INT_SAMPLER_CUBE = 0x8DCC;
var INT_SAMPLER_2D_ARRAY = 0x8DCF;
var UNSIGNED_INT_SAMPLER_2D = 0x8DD2;
var UNSIGNED_INT_SAMPLER_3D = 0x8DD3;
var UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;
var UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;
var TEXTURE_2D = 0x0DE1;
var TEXTURE_CUBE_MAP = 0x8513;
var TEXTURE_3D = 0x806F;
var TEXTURE_2D_ARRAY = 0x8C1A;
var typeMap = {};
/**
 * Returns the corresponding bind point for a given sampler type
 */

function getBindPointForSamplerType(gl, type) {
  return typeMap[type].bindPoint;
} // This kind of sucks! If you could compose functions as in `var fn = gl[name];`
// this code could be a lot smaller but that is sadly really slow (T_T)


function floatSetter(gl, location) {
  return function (v) {
    gl.uniform1f(location, v);
  };
}

function floatArraySetter(gl, location) {
  return function (v) {
    gl.uniform1fv(location, v);
  };
}

function floatVec2Setter(gl, location) {
  return function (v) {
    gl.uniform2fv(location, v);
  };
}

function floatVec3Setter(gl, location) {
  return function (v) {
    gl.uniform3fv(location, v);
  };
}

function floatVec4Setter(gl, location) {
  return function (v) {
    gl.uniform4fv(location, v);
  };
}

function intSetter(gl, location) {
  return function (v) {
    gl.uniform1i(location, v);
  };
}

function intArraySetter(gl, location) {
  return function (v) {
    gl.uniform1iv(location, v);
  };
}

function intVec2Setter(gl, location) {
  return function (v) {
    gl.uniform2iv(location, v);
  };
}

function intVec3Setter(gl, location) {
  return function (v) {
    gl.uniform3iv(location, v);
  };
}

function intVec4Setter(gl, location) {
  return function (v) {
    gl.uniform4iv(location, v);
  };
}

function uintSetter(gl, location) {
  return function (v) {
    gl.uniform1ui(location, v);
  };
}

function uintArraySetter(gl, location) {
  return function (v) {
    gl.uniform1uiv(location, v);
  };
}

function uintVec2Setter(gl, location) {
  return function (v) {
    gl.uniform2uiv(location, v);
  };
}

function uintVec3Setter(gl, location) {
  return function (v) {
    gl.uniform3uiv(location, v);
  };
}

function uintVec4Setter(gl, location) {
  return function (v) {
    gl.uniform4uiv(location, v);
  };
}

function floatMat2Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix2fv(location, false, v);
  };
}

function floatMat3Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix3fv(location, false, v);
  };
}

function floatMat4Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix4fv(location, false, v);
  };
}

function floatMat23Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix2x3fv(location, false, v);
  };
}

function floatMat32Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix3x2fv(location, false, v);
  };
}

function floatMat24Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix2x4fv(location, false, v);
  };
}

function floatMat42Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix4x2fv(location, false, v);
  };
}

function floatMat34Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix3x4fv(location, false, v);
  };
}

function floatMat43Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix4x3fv(location, false, v);
  };
}

function samplerSetter(gl, type, unit, location) {
  var bindPoint = getBindPointForSamplerType(gl, type);
  return utils.isWebGL2(gl) ? function (textureOrPair) {
    var texture;
    var sampler;

    if (helper.isTexture(gl, textureOrPair)) {
      texture = textureOrPair;
      sampler = null;
    } else {
      texture = textureOrPair.texture;
      sampler = textureOrPair.sampler;
    }

    gl.uniform1i(location, unit);
    gl.activeTexture(TEXTURE0 + unit);
    gl.bindTexture(bindPoint, texture);
    gl.bindSampler(unit, sampler);
  } : function (texture) {
    gl.uniform1i(location, unit);
    gl.activeTexture(TEXTURE0 + unit);
    gl.bindTexture(bindPoint, texture);
  };
}

function samplerArraySetter(gl, type, unit, location, size) {
  var bindPoint = getBindPointForSamplerType(gl, type);
  var units = new Int32Array(size);

  for (var ii = 0; ii < size; ++ii) {
    units[ii] = unit + ii;
  }

  return utils.isWebGL2(gl) ? function (textures) {
    gl.uniform1iv(location, units);
    textures.forEach(function (textureOrPair, index) {
      gl.activeTexture(TEXTURE0 + units[index]);
      var texture;
      var sampler;

      if (helper.isTexture(gl, textureOrPair)) {
        texture = textureOrPair;
        sampler = null;
      } else {
        texture = textureOrPair.texture;
        sampler = textureOrPair.sampler;
      }

      gl.bindSampler(unit, sampler);
      gl.bindTexture(bindPoint, texture);
    });
  } : function (textures) {
    gl.uniform1iv(location, units);
    textures.forEach(function (texture, index) {
      gl.activeTexture(TEXTURE0 + units[index]);
      gl.bindTexture(bindPoint, texture);
    });
  };
}

typeMap[FLOAT] = {
  Type: Float32Array,
  size: 4,
  setter: floatSetter,
  arraySetter: floatArraySetter
};
typeMap[FLOAT_VEC2] = {
  Type: Float32Array,
  size: 8,
  setter: floatVec2Setter
};
typeMap[FLOAT_VEC3] = {
  Type: Float32Array,
  size: 12,
  setter: floatVec3Setter
};
typeMap[FLOAT_VEC4] = {
  Type: Float32Array,
  size: 16,
  setter: floatVec4Setter
};
typeMap[INT] = {
  Type: Int32Array,
  size: 4,
  setter: intSetter,
  arraySetter: intArraySetter
};
typeMap[INT_VEC2] = {
  Type: Int32Array,
  size: 8,
  setter: intVec2Setter
};
typeMap[INT_VEC3] = {
  Type: Int32Array,
  size: 12,
  setter: intVec3Setter
};
typeMap[INT_VEC4] = {
  Type: Int32Array,
  size: 16,
  setter: intVec4Setter
};
typeMap[UNSIGNED_INT] = {
  Type: Uint32Array,
  size: 4,
  setter: uintSetter,
  arraySetter: uintArraySetter
};
typeMap[UNSIGNED_INT_VEC2] = {
  Type: Uint32Array,
  size: 8,
  setter: uintVec2Setter
};
typeMap[UNSIGNED_INT_VEC3] = {
  Type: Uint32Array,
  size: 12,
  setter: uintVec3Setter
};
typeMap[UNSIGNED_INT_VEC4] = {
  Type: Uint32Array,
  size: 16,
  setter: uintVec4Setter
};
typeMap[BOOL] = {
  Type: Uint32Array,
  size: 4,
  setter: intSetter,
  arraySetter: intArraySetter
};
typeMap[BOOL_VEC2] = {
  Type: Uint32Array,
  size: 8,
  setter: intVec2Setter
};
typeMap[BOOL_VEC3] = {
  Type: Uint32Array,
  size: 12,
  setter: intVec3Setter
};
typeMap[BOOL_VEC4] = {
  Type: Uint32Array,
  size: 16,
  setter: intVec4Setter
};
typeMap[FLOAT_MAT2] = {
  Type: Float32Array,
  size: 16,
  setter: floatMat2Setter
};
typeMap[FLOAT_MAT3] = {
  Type: Float32Array,
  size: 36,
  setter: floatMat3Setter
};
typeMap[FLOAT_MAT4] = {
  Type: Float32Array,
  size: 64,
  setter: floatMat4Setter
};
typeMap[FLOAT_MAT2x3] = {
  Type: Float32Array,
  size: 24,
  setter: floatMat23Setter
};
typeMap[FLOAT_MAT2x4] = {
  Type: Float32Array,
  size: 32,
  setter: floatMat24Setter
};
typeMap[FLOAT_MAT3x2] = {
  Type: Float32Array,
  size: 24,
  setter: floatMat32Setter
};
typeMap[FLOAT_MAT3x4] = {
  Type: Float32Array,
  size: 48,
  setter: floatMat34Setter
};
typeMap[FLOAT_MAT4x2] = {
  Type: Float32Array,
  size: 32,
  setter: floatMat42Setter
};
typeMap[FLOAT_MAT4x3] = {
  Type: Float32Array,
  size: 48,
  setter: floatMat43Setter
};
typeMap[SAMPLER_2D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D
};
typeMap[SAMPLER_CUBE] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP
};
typeMap[SAMPLER_3D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_3D
};
typeMap[SAMPLER_2D_SHADOW] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D
};
typeMap[SAMPLER_2D_ARRAY] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY
};
typeMap[SAMPLER_2D_ARRAY_SHADOW] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY
};
typeMap[SAMPLER_CUBE_SHADOW] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP
};
typeMap[INT_SAMPLER_2D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D
};
typeMap[INT_SAMPLER_3D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_3D
};
typeMap[INT_SAMPLER_CUBE] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP
};
typeMap[INT_SAMPLER_2D_ARRAY] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY
};
typeMap[UNSIGNED_INT_SAMPLER_2D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D
};
typeMap[UNSIGNED_INT_SAMPLER_3D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_3D
};
typeMap[UNSIGNED_INT_SAMPLER_CUBE] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP
};
typeMap[UNSIGNED_INT_SAMPLER_2D_ARRAY] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY
};

function floatAttribSetter(gl, index) {
  return function (b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);

      switch (b.value.length) {
        case 4:
          gl.vertexAttrib4fv(index, b.value);
          break;

        case 3:
          gl.vertexAttrib3fv(index, b.value);
          break;

        case 2:
          gl.vertexAttrib2fv(index, b.value);
          break;

        case 1:
          gl.vertexAttrib1fv(index, b.value);
          break;

        default:
          throw new Error('the length of a float constant value must be between 1 and 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribPointer(index, b.numComponents || b.size, b.type || FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);

      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index, b.divisor);
      }
    }
  };
}

function intAttribSetter(gl, index) {
  return function (b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);

      if (b.value.length === 4) {
        gl.vertexAttrib4iv(index, b.value);
      } else {
        throw new Error('The length of an integer constant value must be 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribIPointer(index, b.numComponents || b.size, b.type || INT, b.stride || 0, b.offset || 0);

      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index, b.divisor);
      }
    }
  };
}

function uintAttribSetter(gl, index) {
  return function (b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);

      if (b.value.length === 4) {
        gl.vertexAttrib4uiv(index, b.value);
      } else {
        throw new Error('The length of an unsigned integer constant value must be 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribIPointer(index, b.numComponents || b.size, b.type || UNSIGNED_INT, b.stride || 0, b.offset || 0);

      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index, b.divisor);
      }
    }
  };
}

function matAttribSetter(gl, index, typeInfo) {
  var defaultSize = typeInfo.size;
  var count = typeInfo.count;
  return function (b) {
    gl.bindBuffer(ARRAY_BUFFER, b.buffer);
    var numComponents = b.size || b.numComponents || defaultSize;
    var size = numComponents / count;
    var type = b.type || FLOAT;
    var typeInfo = typeMap[type];
    var stride = typeInfo.size * numComponents;
    var normalize = b.normalize || false;
    var offset = b.offset || 0;
    var rowOffset = stride / count;

    for (var i = 0; i < count; ++i) {
      gl.enableVertexAttribArray(index + i);
      gl.vertexAttribPointer(index + i, size, type, normalize, stride, offset + rowOffset * i);

      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index + i, b.divisor);
      }
    }
  };
}

var attrTypeMap = {};
attrTypeMap[FLOAT] = {
  size: 4,
  setter: floatAttribSetter
};
attrTypeMap[FLOAT_VEC2] = {
  size: 8,
  setter: floatAttribSetter
};
attrTypeMap[FLOAT_VEC3] = {
  size: 12,
  setter: floatAttribSetter
};
attrTypeMap[FLOAT_VEC4] = {
  size: 16,
  setter: floatAttribSetter
};
attrTypeMap[INT] = {
  size: 4,
  setter: intAttribSetter
};
attrTypeMap[INT_VEC2] = {
  size: 8,
  setter: intAttribSetter
};
attrTypeMap[INT_VEC3] = {
  size: 12,
  setter: intAttribSetter
};
attrTypeMap[INT_VEC4] = {
  size: 16,
  setter: intAttribSetter
};
attrTypeMap[UNSIGNED_INT] = {
  size: 4,
  setter: uintAttribSetter
};
attrTypeMap[UNSIGNED_INT_VEC2] = {
  size: 8,
  setter: uintAttribSetter
};
attrTypeMap[UNSIGNED_INT_VEC3] = {
  size: 12,
  setter: uintAttribSetter
};
attrTypeMap[UNSIGNED_INT_VEC4] = {
  size: 16,
  setter: uintAttribSetter
};
attrTypeMap[BOOL] = {
  size: 4,
  setter: intAttribSetter
};
attrTypeMap[BOOL_VEC2] = {
  size: 8,
  setter: intAttribSetter
};
attrTypeMap[BOOL_VEC3] = {
  size: 12,
  setter: intAttribSetter
};
attrTypeMap[BOOL_VEC4] = {
  size: 16,
  setter: intAttribSetter
};
attrTypeMap[FLOAT_MAT2] = {
  size: 4,
  setter: matAttribSetter,
  count: 2
};
attrTypeMap[FLOAT_MAT3] = {
  size: 9,
  setter: matAttribSetter,
  count: 3
};
attrTypeMap[FLOAT_MAT4] = {
  size: 16,
  setter: matAttribSetter,
  count: 4
}; // make sure we don't see a global gl

var gl = undefined;
/* eslint-disable-line */

var errorRE = /ERROR:\s*\d+:(\d+)/gi;

function addLineNumbersWithError(src) {
  var log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var lineOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  // Note: Error message formats are not defined by any spec so this may or may not work.
  var matches = _toConsumableArray(log.matchAll(errorRE));

  var lineNoToErrorMap = new Map(matches.map(function (m, ndx) {
    var lineNo = parseInt(m[1]);
    var next = matches[ndx + 1];
    var end = next ? next.index : log.length;
    var msg = log.substring(m.index, end);
    return [lineNo - 1, msg];
  }));
  return src.split('\n').map(function (line, lineNo) {
    var err = lineNoToErrorMap.get(lineNo);
    return "".concat(lineNo + 1 + lineOffset, ": ").concat(line).concat(err ? "\n\n^^^ ".concat(err) : '');
  }).join('\n');
}
/**
 * Error Callback
 * @callback ErrorCallback
 * @param {string} msg error message.
 * @param {number} [lineOffset] amount to add to line number
 * @memberOf module:twgl
 */


var spaceRE = /^[ \t]*\n/;
/**
 * Loads a shader.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {string} shaderSource The shader source.
 * @param {number} shaderType The type of shader.
 * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors.
 * @return {WebGLShader} The created shader.
 * @private
 */

function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {
  var errFn = opt_errorCallback || error; // Create the shader object

  var shader = gl.createShader(shaderType); // Remove the first end of line because WebGL 2.0 requires
  // #version 300 es
  // as the first line. No whitespace allowed before that line
  // so
  //
  // <script>
  // #version 300 es
  // </script>
  //
  // Has one line before it which is invalid according to GLSL ES 3.00
  //

  var lineOffset = 0;

  if (spaceRE.test(shaderSource)) {
    lineOffset = 1;
    shaderSource = shaderSource.replace(spaceRE, '');
  } // Load the shader source


  gl.shaderSource(shader, shaderSource); // Compile the shader

  gl.compileShader(shader); // Check the compile status

  var compiled = gl.getShaderParameter(shader, COMPILE_STATUS);

  if (!compiled) {
    // Something went wrong during compilation; get the error
    var lastError = gl.getShaderInfoLog(shader);
    errFn("".concat(addLineNumbersWithError(shaderSource, lastError, lineOffset), "\nError compiling ").concat(utils.glEnumToString(gl, shaderType), ": ").concat(lastError));
    gl.deleteShader(shader);
    return null;
  }

  return shader;
}
/**
 * @typedef {Object} ProgramOptions
 * @property {function(string)} [errorCallback] callback for errors
 * @property {Object.<string,number>} [attribLocations] a attribute name to location map
 * @property {(module:twgl.BufferInfo|Object.<string,module:twgl.AttribInfo>|string[])} [transformFeedbackVaryings] If passed
 *   a BufferInfo will use the attribs names inside. If passed an object of AttribInfos will use the names from that object. Otherwise
 *   you can pass an array of names.
 * @property {number} [transformFeedbackMode] the mode to pass `gl.transformFeedbackVaryings`. Defaults to `SEPARATE_ATTRIBS`.
 * @memberOf module:twgl
 */

/**
 * Gets the program options based on all these optional arguments
 * @param {module:twgl.ProgramOptions|string[]} [opt_attribs] Options for the program or an array of attribs names. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {module:twgl.ProgramOptions} an instance of ProgramOptions based on the arguments passed in
 * @private
 */


function getProgramOptions(opt_attribs, opt_locations, opt_errorCallback) {
  var transformFeedbackVaryings;
  var transformFeedbackMode;

  if (typeof opt_locations === 'function') {
    opt_errorCallback = opt_locations;
    opt_locations = undefined;
  }

  if (typeof opt_attribs === 'function') {
    opt_errorCallback = opt_attribs;
    opt_attribs = undefined;
  } else if (opt_attribs && !Array.isArray(opt_attribs)) {
    // If we have an errorCallback we can just return this object
    // Otherwise we need to construct one with default errorCallback
    if (opt_attribs.errorCallback) {
      return opt_attribs;
    }

    var opt = opt_attribs;
    opt_errorCallback = opt.errorCallback;
    opt_attribs = opt.attribLocations;
    transformFeedbackVaryings = opt.transformFeedbackVaryings;
    transformFeedbackMode = opt.transformFeedbackMode;
  }

  var options = {
    errorCallback: opt_errorCallback || error,
    transformFeedbackVaryings: transformFeedbackVaryings,
    transformFeedbackMode: transformFeedbackMode
  };

  if (opt_attribs) {
    var attribLocations = {};

    if (Array.isArray(opt_attribs)) {
      opt_attribs.forEach(function (attrib, ndx) {
        attribLocations[attrib] = opt_locations ? opt_locations[ndx] : ndx;
      });
    } else {
      attribLocations = opt_attribs;
    }

    options.attribLocations = attribLocations;
  }

  return options;
}

var defaultShaderType = ["VERTEX_SHADER", "FRAGMENT_SHADER"];

function getShaderTypeFromScriptType(gl, scriptType) {
  if (scriptType.indexOf("frag") >= 0) {
    return FRAGMENT_SHADER;
  } else if (scriptType.indexOf("vert") >= 0) {
    return VERTEX_SHADER;
  }

  return undefined;
}

function deleteShaders(gl, shaders) {
  shaders.forEach(function (shader) {
    gl.deleteShader(shader);
  });
}
/**
 * Creates a program, attaches (and/or compiles) shaders, binds attrib locations, links the
 * program and calls useProgram.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgram(gl, [vs, fs], options);
 *     twgl.createProgram(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLShader[]|string[]} shaders The shaders to attach, or element ids for their source, or strings that contain their source
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error.
 * @memberOf module:twgl/programs
 */


function createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {
  var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  var realShaders = [];
  var newShaders = [];

  for (var ndx = 0; ndx < shaders.length; ++ndx) {
    var shader = shaders[ndx];

    if (typeof shader === 'string') {
      var elem = getElementById(shader);
      var src = elem ? elem.text : shader;
      var type = gl[defaultShaderType[ndx]];

      if (elem && elem.type) {
        type = getShaderTypeFromScriptType(gl, elem.type) || type;
      }

      shader = loadShader(gl, src, type, progOptions.errorCallback);
      newShaders.push(shader);
    }

    if (helper.isShader(gl, shader)) {
      realShaders.push(shader);
    }
  }

  if (realShaders.length !== shaders.length) {
    progOptions.errorCallback("not enough shaders for program");
    deleteShaders(gl, newShaders);
    return null;
  }

  var program = gl.createProgram();
  realShaders.forEach(function (shader) {
    gl.attachShader(program, shader);
  });

  if (progOptions.attribLocations) {
    Object.keys(progOptions.attribLocations).forEach(function (attrib) {
      gl.bindAttribLocation(program, progOptions.attribLocations[attrib], attrib);
    });
  }

  var varyings = progOptions.transformFeedbackVaryings;

  if (varyings) {
    if (varyings.attribs) {
      varyings = varyings.attribs;
    }

    if (!Array.isArray(varyings)) {
      varyings = Object.keys(varyings);
    }

    gl.transformFeedbackVaryings(program, varyings, progOptions.transformFeedbackMode || SEPARATE_ATTRIBS);
  }

  gl.linkProgram(program); // Check the link status

  var linked = gl.getProgramParameter(program, LINK_STATUS);

  if (!linked) {
    // something went wrong with the link
    var lastError = gl.getProgramInfoLog(program);
    progOptions.errorCallback("".concat(realShaders.map(function (shader) {
      var src = addLineNumbersWithError(gl.getShaderSource(shader), '', 0);
      var type = gl.getShaderParameter(shader, gl.SHADER_TYPE);
      return "".concat(utils.glEnumToString(gl, type), "\n").concat(src, "}");
    }).join('\n'), "\nError in program linking: ").concat(lastError));
    gl.deleteProgram(program);
    deleteShaders(gl, newShaders);
    return null;
  }

  return program;
}
/**
 * Loads a shader from a script tag.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {string} scriptId The id of the script tag.
 * @param {number} [opt_shaderType] The type of shader. If not passed in it will
 *     be derived from the type of the script tag.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors.
 * @return {WebGLShader?} The created shader or null if error.
 * @private
 */


function createShaderFromScript(gl, scriptId, opt_shaderType, opt_errorCallback) {
  var shaderSource = "";
  var shaderScript = getElementById(scriptId);

  if (!shaderScript) {
    throw new Error("unknown script element: ".concat(scriptId));
  }

  shaderSource = shaderScript.text;
  var shaderType = opt_shaderType || getShaderTypeFromScriptType(gl, shaderScript.type);

  if (!shaderType) {
    throw new Error('unknown shader type');
  }

  return loadShader(gl, shaderSource, shaderType, opt_errorCallback);
}
/**
 * Creates a program from 2 script tags.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_options);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderScriptIds Array of ids of the script
 *        tags for the shaders. The first is assumed to be the
 *        vertex shader, the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error.
 * @memberOf module:twgl/programs
 */


function createProgramFromScripts(gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {
  var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  var shaders = [];

  for (var ii = 0; ii < shaderScriptIds.length; ++ii) {
    var shader = createShaderFromScript(gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], progOptions.errorCallback);

    if (!shader) {
      return null;
    }

    shaders.push(shader);
  }

  return createProgram(gl, shaders, progOptions);
}
/**
 * Creates a program from 2 sources.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_options);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderSources Array of sources for the
 *        shaders. The first is assumed to be the vertex shader,
 *        the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error.
 * @memberOf module:twgl/programs
 */


function createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
  var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  var shaders = [];

  for (var ii = 0; ii < shaderSources.length; ++ii) {
    var shader = loadShader(gl, shaderSources[ii], gl[defaultShaderType[ii]], progOptions.errorCallback);

    if (!shader) {
      return null;
    }

    shaders.push(shader);
  }

  return createProgram(gl, shaders, progOptions);
}
/**
 * Returns true if attribute/uniform is a reserved/built in
 *
 * It makes no sense to me why GL returns these because it's
 * illegal to call `gl.getUniformLocation` and `gl.getAttribLocation`
 * with names that start with `gl_` (and `webgl_` in WebGL)
 *
 * I can only assume they are there because they might count
 * when computing the number of uniforms/attributes used when you want to
 * know if you are near the limit. That doesn't really make sense
 * to me but the fact that these get returned are in the spec.
 *
 * @param {WebGLActiveInfo} info As returned from `gl.getActiveUniform` or
 *    `gl.getActiveAttrib`.
 * @return {bool} true if it's reserved
 * @private
 */


function isBuiltIn(info) {
  var name = info.name;
  return name.startsWith("gl_") || name.startsWith("webgl_");
}
/**
 * Creates setter functions for all uniforms of a shader
 * program.
 *
 * @see {@link module:twgl.setUniforms}
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program the program to create setters for.
 * @returns {Object.<string, function>} an object with a setter by name for each uniform
 * @memberOf module:twgl/programs
 */


function createUniformSetters(gl, program) {
  var textureUnit = 0;
  /**
   * Creates a setter for a uniform of the given program with it's
   * location embedded in the setter.
   * @param {WebGLProgram} program
   * @param {WebGLUniformInfo} uniformInfo
   * @returns {function} the created setter.
   */

  function createUniformSetter(program, uniformInfo, location) {
    var isArray = uniformInfo.name.endsWith("[0]");
    var type = uniformInfo.type;
    var typeInfo = typeMap[type];

    if (!typeInfo) {
      throw new Error("unknown type: 0x".concat(type.toString(16))); // we should never get here.
    }

    var setter;

    if (typeInfo.bindPoint) {
      // it's a sampler
      var unit = textureUnit;
      textureUnit += uniformInfo.size;

      if (isArray) {
        setter = typeInfo.arraySetter(gl, type, unit, location, uniformInfo.size);
      } else {
        setter = typeInfo.setter(gl, type, unit, location, uniformInfo.size);
      }
    } else {
      if (typeInfo.arraySetter && isArray) {
        setter = typeInfo.arraySetter(gl, location);
      } else {
        setter = typeInfo.setter(gl, location);
      }
    }

    setter.location = location;
    return setter;
  }

  var uniformSetters = {};
  var numUniforms = gl.getProgramParameter(program, ACTIVE_UNIFORMS);

  for (var ii = 0; ii < numUniforms; ++ii) {
    var uniformInfo = gl.getActiveUniform(program, ii);

    if (isBuiltIn(uniformInfo)) {
      continue;
    }

    var name = uniformInfo.name; // remove the array suffix.

    if (name.endsWith("[0]")) {
      name = name.substr(0, name.length - 3);
    }

    var location = gl.getUniformLocation(program, uniformInfo.name); // the uniform will have no location if it's in a uniform block

    if (location) {
      uniformSetters[name] = createUniformSetter(program, uniformInfo, location);
    }
  }

  return uniformSetters;
}
/**
 * @typedef {Object} TransformFeedbackInfo
 * @property {number} index index of transform feedback
 * @property {number} type GL type
 * @property {number} size 1 - 4
 * @memberOf module:twgl
 */

/**
 * Create TransformFeedbackInfo for passing to bindTransformFeedbackInfo.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program an existing WebGLProgram.
 * @return {Object<string, module:twgl.TransformFeedbackInfo>}
 * @memberOf module:twgl
 */


function createTransformFeedbackInfo(gl, program) {
  var info = {};
  var numVaryings = gl.getProgramParameter(program, TRANSFORM_FEEDBACK_VARYINGS);

  for (var ii = 0; ii < numVaryings; ++ii) {
    var varying = gl.getTransformFeedbackVarying(program, ii);
    info[varying.name] = {
      index: ii,
      type: varying.type,
      size: varying.size
    };
  }

  return info;
}
/**
 * Binds buffers for transform feedback.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {(module:twgl.ProgramInfo|Object<string, module:twgl.TransformFeedbackInfo>)} transformFeedbackInfo A ProgramInfo or TransformFeedbackInfo.
 * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.
 * @memberOf module:twgl
 */


function bindTransformFeedbackInfo(gl, transformFeedbackInfo, bufferInfo) {
  if (transformFeedbackInfo.transformFeedbackInfo) {
    transformFeedbackInfo = transformFeedbackInfo.transformFeedbackInfo;
  }

  if (bufferInfo.attribs) {
    bufferInfo = bufferInfo.attribs;
  }

  for (var name in bufferInfo) {
    var varying = transformFeedbackInfo[name];

    if (varying) {
      var buf = bufferInfo[name];

      if (buf.offset) {
        gl.bindBufferRange(TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer, buf.offset, buf.size);
      } else {
        gl.bindBufferBase(TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer);
      }
    }
  }
}
/**
 * Creates a transform feedback and sets the buffers
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}
 * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.
 * @return {WebGLTransformFeedback} the created transform feedback
 * @memberOf module:twgl
 */


function createTransformFeedback(gl, programInfo, bufferInfo) {
  var tf = gl.createTransformFeedback();
  gl.bindTransformFeedback(TRANSFORM_FEEDBACK, tf);
  gl.useProgram(programInfo.program);
  bindTransformFeedbackInfo(gl, programInfo, bufferInfo);
  gl.bindTransformFeedback(TRANSFORM_FEEDBACK, null);
  return tf;
}
/**
 * @typedef {Object} UniformData
 * @property {number} type The WebGL type enum for this uniform
 * @property {number} size The number of elements for this uniform
 * @property {number} blockNdx The block index this uniform appears in
 * @property {number} offset The byte offset in the block for this uniform's value
 * @memberOf module:twgl
 */

/**
 * The specification for one UniformBlockObject
 *
 * @typedef {Object} BlockSpec
 * @property {number} index The index of the block.
 * @property {number} size The size in bytes needed for the block
 * @property {number[]} uniformIndices The indices of the uniforms used by the block. These indices
 *    correspond to entries in a UniformData array in the {@link module:twgl.UniformBlockSpec}.
 * @property {bool} usedByVertexShader Self explanatory
 * @property {bool} usedByFragmentShader Self explanatory
 * @property {bool} used Self explanatory
 * @memberOf module:twgl
 */

/**
 * A `UniformBlockSpec` represents the data needed to create and bind
 * UniformBlockObjects for a given program
 *
 * @typedef {Object} UniformBlockSpec
 * @property {Object.<string, module:twgl.BlockSpec> blockSpecs The BlockSpec for each block by block name
 * @property {UniformData[]} uniformData An array of data for each uniform by uniform index.
 * @memberOf module:twgl
 */

/**
 * Creates a UniformBlockSpec for the given program.
 *
 * A UniformBlockSpec represents the data needed to create and bind
 * UniformBlockObjects
 *
 * @param {WebGL2RenderingContext} gl A WebGL2 Rendering Context
 * @param {WebGLProgram} program A WebGLProgram for a successfully linked program
 * @return {module:twgl.UniformBlockSpec} The created UniformBlockSpec
 * @memberOf module:twgl/programs
 */


function createUniformBlockSpecFromProgram(gl, program) {
  var numUniforms = gl.getProgramParameter(program, ACTIVE_UNIFORMS);
  var uniformData = [];
  var uniformIndices = [];

  for (var ii = 0; ii < numUniforms; ++ii) {
    uniformIndices.push(ii);
    uniformData.push({});
    var uniformInfo = gl.getActiveUniform(program, ii);

    if (isBuiltIn(uniformInfo)) {
      break;
    }

    uniformData[ii].name = uniformInfo.name;
  }

  [["UNIFORM_TYPE", "type"], ["UNIFORM_SIZE", "size"], // num elements
  ["UNIFORM_BLOCK_INDEX", "blockNdx"], ["UNIFORM_OFFSET", "offset"]].forEach(function (pair) {
    var pname = pair[0];
    var key = pair[1];
    gl.getActiveUniforms(program, uniformIndices, gl[pname]).forEach(function (value, ndx) {
      uniformData[ndx][key] = value;
    });
  });
  var blockSpecs = {};
  var numUniformBlocks = gl.getProgramParameter(program, ACTIVE_UNIFORM_BLOCKS);

  for (var _ii = 0; _ii < numUniformBlocks; ++_ii) {
    var name = gl.getActiveUniformBlockName(program, _ii);
    var blockSpec = {
      index: gl.getUniformBlockIndex(program, name),
      usedByVertexShader: gl.getActiveUniformBlockParameter(program, _ii, UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),
      usedByFragmentShader: gl.getActiveUniformBlockParameter(program, _ii, UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),
      size: gl.getActiveUniformBlockParameter(program, _ii, UNIFORM_BLOCK_DATA_SIZE),
      uniformIndices: gl.getActiveUniformBlockParameter(program, _ii, UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES)
    };
    blockSpec.used = blockSpec.usedByVertexShader || blockSpec.usedByFragmentShader;
    blockSpecs[name] = blockSpec;
  }

  return {
    blockSpecs: blockSpecs,
    uniformData: uniformData
  };
}

var arraySuffixRE = /\[\d+\]\.$/; // better way to check?

var pad = function pad(v, padding) {
  return ((v + (padding - 1)) / padding | 0) * padding;
};

function createUniformBlockUniformSetter(view, Type, typeSize, paddedSize, isArray) {
  if (isArray) {
    var numElements = typeSize / Type.BYTES_PER_ELEMENT;
    var numPaddedElements = paddedSize / Type.BYTES_PER_ELEMENT;
    return function (value) {
      var dst = 0;

      for (var src = 0; src < value.length; src += numElements) {
        for (var i = 0; i < numElements; ++i) {
          view[dst + i] = value[src + i];
        }

        dst += numPaddedElements;
      }
    };
  } else {
    return function (value) {
      if (value.length) {
        view.set(value);
      } else {
        view[0] = value;
      }
    };
  }
}
/**
 * Represents a UniformBlockObject including an ArrayBuffer with all the uniform values
 * and a corresponding WebGLBuffer to hold those values on the GPU
 *
 * @typedef {Object} UniformBlockInfo
 * @property {string} name The name of the block
 * @property {ArrayBuffer} array The array buffer that contains the uniform values
 * @property {Float32Array} asFloat A float view on the array buffer. This is useful
 *    inspecting the contents of the buffer in the debugger.
 * @property {WebGLBuffer} buffer A WebGL buffer that will hold a copy of the uniform values for rendering.
 * @property {number} [offset] offset into buffer
 * @property {Object<string, ArrayBufferView>} uniforms A uniform name to ArrayBufferView map.
 *   each Uniform has a correctly typed `ArrayBufferView` into array at the correct offset
 *   and length of that uniform. So for example a float uniform would have a 1 float `Float32Array`
 *   view. A single mat4 would have a 16 element `Float32Array` view. An ivec2 would have an
 *   `Int32Array` view, etc.
 * @property {Object<string, function>} setters A setter for this uniform.
 *   The reason to use setters is elements of arrays are padded to vec4 sizes which
 *   means if you want to set an array of 4 floats you'd need to set 16 values
 *   (or set elements 0, 4, 8, 12). In other words
 *   `someBlockInfo.uniforms.some4FloatArrayUniform.set([0, , , , 1, , , , 2, , , , 3])`
 *   where as the setter handles just passing in [0, 1, 2, 3] either directly as in
 *   `someBlockInfo.setter.some4FloatArrayUniform.set([0, 1, 2, 3])` (not recommended)
 *   or via {@link module:twgl.setBlockUniforms}
 * @memberOf module:twgl
 */

/**
 * Creates a `UniformBlockInfo` for the specified block
 *
 * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy
 * `UniformBlockInfo` is returned**. This is because when debugging GLSL
 * it is common to comment out large portions of a shader or for example set
 * the final output to a constant. When that happens blocks get optimized out.
 * If this function did not create dummy blocks your code would crash when debugging.
 *
 * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext
 * @param {WebGLProgram} program A WebGLProgram
 * @param {module:twgl.UniformBlockSpec} uniformBlockSpec. A UniformBlockSpec as returned
 *     from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {string} blockName The name of the block.
 * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo
 * @memberOf module:twgl/programs
 */


function createUniformBlockInfoFromProgram(gl, program, uniformBlockSpec, blockName) {
  var blockSpecs = uniformBlockSpec.blockSpecs;
  var uniformData = uniformBlockSpec.uniformData;
  var blockSpec = blockSpecs[blockName];

  if (!blockSpec) {
    warn("no uniform block object named:", blockName);
    return {
      name: blockName,
      uniforms: {}
    };
  }

  var array = new ArrayBuffer(blockSpec.size);
  var buffer = gl.createBuffer();
  var uniformBufferIndex = blockSpec.index;
  gl.bindBuffer(UNIFORM_BUFFER, buffer);
  gl.uniformBlockBinding(program, blockSpec.index, uniformBufferIndex);
  var prefix = blockName + ".";

  if (arraySuffixRE.test(prefix)) {
    prefix = prefix.replace(arraySuffixRE, ".");
  }

  var uniforms = {};
  var setters = {};
  blockSpec.uniformIndices.forEach(function (uniformNdx) {
    var data = uniformData[uniformNdx];
    var typeInfo = typeMap[data.type];
    var Type = typeInfo.Type;
    var paddedSize = pad(typeInfo.size, 16);
    var length = typeInfo.size + (data.size - 1) * paddedSize;
    var name = data.name;

    if (name.startsWith(prefix)) {
      name = name.substr(prefix.length);
    }

    var isArray = name.endsWith('[0]');

    if (isArray) {
      name = name.substr(0, name.length - 3);
    }

    var uniformView = new Type(array, data.offset, length / Type.BYTES_PER_ELEMENT);
    uniforms[name] = uniformView;
    setters[name] = createUniformBlockUniformSetter(uniformView, Type, typeInfo.size, paddedSize, isArray);
  });
  return {
    name: blockName,
    array: array,
    asFloat: new Float32Array(array),
    // for debugging
    buffer: buffer,
    uniforms: uniforms,
    setters: setters
  };
}
/**
 * Creates a `UniformBlockInfo` for the specified block
 *
 * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy
 * `UniformBlockInfo` is returned**. This is because when debugging GLSL
 * it is common to comment out large portions of a shader or for example set
 * the final output to a constant. When that happens blocks get optimized out.
 * If this function did not create dummy blocks your code would crash when debugging.
 *
 * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext
 * @param {module:twgl.ProgramInfo} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo}
 * @param {string} blockName The name of the block.
 * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo
 * @memberOf module:twgl/programs
 */


function createUniformBlockInfo(gl, programInfo, blockName) {
  return createUniformBlockInfoFromProgram(gl, programInfo.program, programInfo.uniformBlockSpec, blockName);
}
/**
 * Binds a uniform block to the matching uniform block point.
 * Matches by blocks by name so blocks must have the same name not just the same
 * structure.
 *
 * If you have changed any values and you upload the values into the corresponding WebGLBuffer
 * call {@link module:twgl.setUniformBlock} instead.
 *
 * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.
 * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as
 *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from
 *     {@link module:twgl.createUniformBlockInfo}.
 * @return {bool} true if buffer was bound. If the programInfo has no block with the same block name
 *     no buffer is bound.
 * @memberOf module:twgl/programs
 */


function bindUniformBlock(gl, programInfo, uniformBlockInfo) {
  var uniformBlockSpec = programInfo.uniformBlockSpec || programInfo;
  var blockSpec = uniformBlockSpec.blockSpecs[uniformBlockInfo.name];

  if (blockSpec) {
    var bufferBindIndex = blockSpec.index;
    gl.bindBufferRange(UNIFORM_BUFFER, bufferBindIndex, uniformBlockInfo.buffer, uniformBlockInfo.offset || 0, uniformBlockInfo.array.byteLength);
    return true;
  }

  return false;
}
/**
 * Uploads the current uniform values to the corresponding WebGLBuffer
 * and binds that buffer to the program's corresponding bind point for the uniform block object.
 *
 * If you haven't changed any values and you only need to bind the uniform block object
 * call {@link module:twgl.bindUniformBlock} instead.
 *
 * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.
 * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as
 *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from
 *     {@link module:twgl.createUniformBlockInfo}.
 * @memberOf module:twgl/programs
 */


function setUniformBlock(gl, programInfo, uniformBlockInfo) {
  if (bindUniformBlock(gl, programInfo, uniformBlockInfo)) {
    gl.bufferData(UNIFORM_BUFFER, uniformBlockInfo.array, DYNAMIC_DRAW);
  }
}
/**
 * Sets values of a uniform block object
 *
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo A UniformBlockInfo as returned by {@link module:twgl.createUniformBlockInfo}.
 * @param {Object.<string, ?>} values A uniform name to value map where the value is correct for the given
 *    type of uniform. So for example given a block like
 *
 *       uniform SomeBlock {
 *         float someFloat;
 *         vec2 someVec2;
 *         vec3 someVec3Array[2];
 *         int someInt;
 *       }
 *
 *  You can set the values of the uniform block with
 *
 *       twgl.setBlockUniforms(someBlockInfo, {
 *          someFloat: 12.3,
 *          someVec2: [1, 2],
 *          someVec3Array: [1, 2, 3, 4, 5, 6],
 *          someInt: 5,
 *       }
 *
 *  Arrays can be JavaScript arrays or typed arrays
 *
 *  Any name that doesn't match will be ignored
 * @memberOf module:twgl/programs
 */


function setBlockUniforms(uniformBlockInfo, values) {
  var setters = uniformBlockInfo.setters;

  for (var name in values) {
    var setter = setters[name];

    if (setter) {
      var value = values[name];
      setter(value);
    }
  }
}
/**
 * Set uniforms and binds related textures.
 *
 * example:
 *
 *     const programInfo = createProgramInfo(
 *         gl, ["some-vs", "some-fs"]);
 *
 *     const tex1 = gl.createTexture();
 *     const tex2 = gl.createTexture();
 *
 *     ... assume we setup the textures with data ...
 *
 *     const uniforms = {
 *       u_someSampler: tex1,
 *       u_someOtherSampler: tex2,
 *       u_someColor: [1,0,0,1],
 *       u_somePosition: [0,1,1],
 *       u_someMatrix: [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ],
 *     };
 *
 *     gl.useProgram(program);
 *
 * This will automatically bind the textures AND set the
 * uniforms.
 *
 *     twgl.setUniforms(programInfo, uniforms);
 *
 * For the example above it is equivalent to
 *
 *     var texUnit = 0;
 *     gl.activeTexture(gl.TEXTURE0 + texUnit);
 *     gl.bindTexture(gl.TEXTURE_2D, tex1);
 *     gl.uniform1i(u_someSamplerLocation, texUnit++);
 *     gl.activeTexture(gl.TEXTURE0 + texUnit);
 *     gl.bindTexture(gl.TEXTURE_2D, tex2);
 *     gl.uniform1i(u_someSamplerLocation, texUnit++);
 *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);
 *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);
 *     gl.uniformMatrix4fv(u_someMatrix, false, [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ]);
 *
 * Note it is perfectly reasonable to call `setUniforms` multiple times. For example
 *
 *     const uniforms = {
 *       u_someSampler: tex1,
 *       u_someOtherSampler: tex2,
 *     };
 *
 *     const moreUniforms {
 *       u_someColor: [1,0,0,1],
 *       u_somePosition: [0,1,1],
 *       u_someMatrix: [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ],
 *     };
 *
 *     twgl.setUniforms(programInfo, uniforms);
 *     twgl.setUniforms(programInfo, moreUniforms);
 *
 * You can also add WebGLSamplers to uniform samplers as in
 *
 *     const uniforms = {
 *       u_someSampler: {
 *         texture: someWebGLTexture,
 *         sampler: someWebGLSampler,
 *       },
 *     };
 *
 * In which case both the sampler and texture will be bound to the
 * same unit.
 *
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from
 *        `createUniformSetters`.
 * @param {Object.<string, ?>} values an object with values for the
 *        uniforms.
 *   You can pass multiple objects by putting them in an array or by calling with more arguments.For example
 *
 *     const sharedUniforms = {
 *       u_fogNear: 10,
 *       u_projection: ...
 *       ...
 *     };
 *
 *     const localUniforms = {
 *       u_world: ...
 *       u_diffuseColor: ...
 *     };
 *
 *     twgl.setUniforms(programInfo, sharedUniforms, localUniforms);
 *
 *     // is the same as
 *
 *     twgl.setUniforms(programInfo, [sharedUniforms, localUniforms]);
 *
 *     // is the same as
 *
 *     twgl.setUniforms(programInfo, sharedUniforms);
 *     twgl.setUniforms(programInfo, localUniforms};
 *
 * @memberOf module:twgl/programs
 */


function setUniforms(setters, values) {
  // eslint-disable-line
  var actualSetters = setters.uniformSetters || setters;
  var numArgs = arguments.length;

  for (var aNdx = 1; aNdx < numArgs; ++aNdx) {
    var _values = arguments[aNdx];

    if (Array.isArray(_values)) {
      var numValues = _values.length;

      for (var ii = 0; ii < numValues; ++ii) {
        setUniforms(actualSetters, _values[ii]);
      }
    } else {
      for (var name in _values) {
        var setter = actualSetters[name];

        if (setter) {
          setter(_values[name]);
        }
      }
    }
  }
}
/**
 * Alias for `setUniforms`
 * @function
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from
 *        `createUniformSetters`.
 * @param {Object.<string, ?>} values an object with values for the
 * @memberOf module:twgl/programs
 */


var setUniformsAndBindTextures = setUniforms;
/**
 * Creates setter functions for all attributes of a shader
 * program. You can pass this to {@link module:twgl.setBuffersAndAttributes} to set all your buffers and attributes.
 *
 * @see {@link module:twgl.setAttributes} for example
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program the program to create setters for.
 * @return {Object.<string, function>} an object with a setter for each attribute by name.
 * @memberOf module:twgl/programs
 */

exports.setUniformsAndBindTextures = setUniformsAndBindTextures;

function createAttributeSetters(gl, program) {
  var attribSetters = {};
  var numAttribs = gl.getProgramParameter(program, ACTIVE_ATTRIBUTES);

  for (var ii = 0; ii < numAttribs; ++ii) {
    var attribInfo = gl.getActiveAttrib(program, ii);

    if (isBuiltIn(attribInfo)) {
      continue;
    }

    var index = gl.getAttribLocation(program, attribInfo.name);
    var typeInfo = attrTypeMap[attribInfo.type];
    var setter = typeInfo.setter(gl, index, typeInfo);
    setter.location = index;
    attribSetters[attribInfo.name] = setter;
  }

  return attribSetters;
}
/**
 * Sets attributes and binds buffers (deprecated... use {@link module:twgl.setBuffersAndAttributes})
 *
 * Example:
 *
 *     const program = createProgramFromScripts(
 *         gl, ["some-vs", "some-fs");
 *
 *     const attribSetters = createAttributeSetters(program);
 *
 *     const positionBuffer = gl.createBuffer();
 *     const texcoordBuffer = gl.createBuffer();
 *
 *     const attribs = {
 *       a_position: {buffer: positionBuffer, numComponents: 3},
 *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
 *     };
 *
 *     gl.useProgram(program);
 *
 * This will automatically bind the buffers AND set the
 * attributes.
 *
 *     setAttributes(attribSetters, attribs);
 *
 * Properties of attribs. For each attrib you can add
 * properties:
 *
 * *   type: the type of data in the buffer. Default = gl.FLOAT
 * *   normalize: whether or not to normalize the data. Default = false
 * *   stride: the stride. Default = 0
 * *   offset: offset into the buffer. Default = 0
 * *   divisor: the divisor for instances. Default = undefined
 *
 * For example if you had 3 value float positions, 2 value
 * float texcoord and 4 value uint8 colors you'd setup your
 * attribs like this
 *
 *     const attribs = {
 *       a_position: {buffer: positionBuffer, numComponents: 3},
 *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
 *       a_color: {
 *         buffer: colorBuffer,
 *         numComponents: 4,
 *         type: gl.UNSIGNED_BYTE,
 *         normalize: true,
 *       },
 *     };
 *
 * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters
 * @param {Object.<string, module:twgl.AttribInfo>} buffers AttribInfos mapped by attribute name.
 * @memberOf module:twgl/programs
 * @deprecated use {@link module:twgl.setBuffersAndAttributes}
 */


function setAttributes(setters, buffers) {
  for (var name in buffers) {
    var setter = setters[name];

    if (setter) {
      setter(buffers[name]);
    }
  }
}
/**
 * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate
 *
 * Example:
 *
 *     const programInfo = createProgramInfo(
 *         gl, ["some-vs", "some-fs");
 *
 *     const arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *     };
 *
 *     const bufferInfo = createBufferInfoFromArrays(gl, arrays);
 *
 *     gl.useProgram(programInfo.program);
 *
 * This will automatically bind the buffers AND set the
 * attributes.
 *
 *     setBuffersAndAttributes(gl, programInfo, bufferInfo);
 *
 * For the example above it is equivalent to
 *
 *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
 *     gl.enableVertexAttribArray(a_positionLocation);
 *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
 *     gl.enableVertexAttribArray(a_texcoordLocation);
 *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters A `ProgramInfo` as returned from {@link module:twgl.createProgramInfo} or Attribute setters as returned from {@link module:twgl.createAttributeSetters}
 * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} buffers a `BufferInfo` as returned from {@link module:twgl.createBufferInfoFromArrays}.
 *   or a `VertexArrayInfo` as returned from {@link module:twgl.createVertexArrayInfo}
 * @memberOf module:twgl/programs
 */


function setBuffersAndAttributes(gl, programInfo, buffers) {
  if (buffers.vertexArrayObject) {
    gl.bindVertexArray(buffers.vertexArrayObject);
  } else {
    setAttributes(programInfo.attribSetters || programInfo, buffers.attribs);

    if (buffers.indices) {
      gl.bindBuffer(ELEMENT_ARRAY_BUFFER, buffers.indices);
    }
  }
}
/**
 * @typedef {Object} ProgramInfo
 * @property {WebGLProgram} program A shader program
 * @property {Object<string, function>} uniformSetters object of setters as returned from createUniformSetters,
 * @property {Object<string, function>} attribSetters object of setters as returned from createAttribSetters,
 * @property {module:twgl.UniformBlockSpec} [uniformBlockSpace] a uniform block spec for making UniformBlockInfos with createUniformBlockInfo etc..
 * @property {Object<string, module:twgl.TransformFeedbackInfo>} [transformFeedbackInfo] info for transform feedbacks
 * @memberOf module:twgl
 */

/**
 * Creates a ProgramInfo from an existing program.
 *
 * A ProgramInfo contains
 *
 *     programInfo = {
 *        program: WebGLProgram,
 *        uniformSetters: object of setters as returned from createUniformSetters,
 *        attribSetters: object of setters as returned from createAttribSetters,
 *     }
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {WebGLProgram} program an existing WebGLProgram.
 * @return {module:twgl.ProgramInfo} The created ProgramInfo.
 * @memberOf module:twgl/programs
 */


function createProgramInfoFromProgram(gl, program) {
  var uniformSetters = createUniformSetters(gl, program);
  var attribSetters = createAttributeSetters(gl, program);
  var programInfo = {
    program: program,
    uniformSetters: uniformSetters,
    attribSetters: attribSetters
  };

  if (utils.isWebGL2(gl)) {
    programInfo.uniformBlockSpec = createUniformBlockSpecFromProgram(gl, program);
    programInfo.transformFeedbackInfo = createTransformFeedbackInfo(gl, program);
  }

  return programInfo;
}
/**
 * Creates a ProgramInfo from 2 sources.
 *
 * A ProgramInfo contains
 *
 *     programInfo = {
 *        program: WebGLProgram,
 *        uniformSetters: object of setters as returned from createUniformSetters,
 *        attribSetters: object of setters as returned from createAttribSetters,
 *     }
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramInfo(gl, [vs, fs], options);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderSources Array of sources for the
 *        shaders or ids. The first is assumed to be the vertex shader,
 *        the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {module:twgl.ProgramInfo?} The created ProgramInfo or null if it failed to link or compile
 * @memberOf module:twgl/programs
 */


function createProgramInfo(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
  var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  var good = true;
  shaderSources = shaderSources.map(function (source) {
    // Lets assume if there is no \n it's an id
    if (source.indexOf("\n") < 0) {
      var script = getElementById(source);

      if (!script) {
        progOptions.errorCallback("no element with id: " + source);
        good = false;
      } else {
        source = script.text;
      }
    }

    return source;
  });

  if (!good) {
    return null;
  }

  var program = createProgramFromSources(gl, shaderSources, progOptions);

  if (!program) {
    return null;
  }

  return createProgramInfoFromProgram(gl, program);
}

/***/ }),

/***/ "./src/textures.js":
/*!*************************!*\
  !*** ./src/textures.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.setTextureDefaults_ = setDefaults;
exports.createSampler = createSampler;
exports.createSamplers = createSamplers;
exports.setSamplerParameters = setSamplerParameters;
exports.createTexture = createTexture;
exports.setEmptyTexture = setEmptyTexture;
exports.setTextureFromArray = setTextureFromArray;
exports.loadTextureFromUrl = loadTextureFromUrl;
exports.setTextureFromElement = setTextureFromElement;
exports.setTextureFilteringForSize = setTextureFilteringForSize;
exports.setTextureParameters = setTextureParameters;
exports.setDefaultTextureColor = setDefaultTextureColor;
exports.createTextures = createTextures;
exports.resizeTexture = resizeTexture;
exports.canGenerateMipmap = canGenerateMipmap;
exports.canFilter = canFilter;
exports.getNumComponentsForFormat = getNumComponentsForFormat;
exports.getBytesPerElementForInternalFormat = getBytesPerElementForInternalFormat;
exports.getFormatAndTypeForInternalFormat = getFormatAndTypeForInternalFormat;

var utils = _interopRequireWildcard(__webpack_require__(/*! ./utils.js */ "./src/utils.js"));

var typedArrays = _interopRequireWildcard(__webpack_require__(/*! ./typedarrays.js */ "./src/typedarrays.js"));

var helper = _interopRequireWildcard(__webpack_require__(/*! ./helper.js */ "./src/helper.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Low level texture related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.textures` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/textures
 */
// make sure we don't see a global gl
var gl = undefined;
/* eslint-disable-line */

var defaults = {
  textureColor: new Uint8Array([128, 192, 255, 255]),
  textureOptions: {},
  crossOrigin: undefined
};
var isArrayBuffer = typedArrays.isArrayBuffer; // Should we make this on demand?

var getShared2DContext = function () {
  var s_ctx;
  return function getShared2DContext() {
    s_ctx = s_ctx || (typeof document !== 'undefined' && document.createElement ? document.createElement("canvas").getContext("2d") : null);
    return s_ctx;
  };
}(); // NOTE: Chrome supports 2D canvas in a Worker (behind flag as of v64 but
//       not only does Firefox NOT support it but Firefox freezes immediately
//       if you try to create one instead of just returning null and continuing.
//  : (global.OffscreenCanvas && (new global.OffscreenCanvas(1, 1)).getContext("2d"));  // OffscreenCanvas may not support 2d
// NOTE: We can maybe remove some of the need for the 2d canvas. In WebGL2
// we can use the various unpack settings. Otherwise we could try using
// the ability of an ImageBitmap to be cut. Unfortunately cutting an ImageBitmap
// is async and the current TWGL code expects a non-Async result though that
// might not be a problem. ImageBitmap though is not available in Edge or Safari
// as of 2018-01-02

/* PixelFormat */


var ALPHA = 0x1906;
var RGB = 0x1907;
var RGBA = 0x1908;
var LUMINANCE = 0x1909;
var LUMINANCE_ALPHA = 0x190A;
var DEPTH_COMPONENT = 0x1902;
var DEPTH_STENCIL = 0x84F9;
/* TextureWrapMode */
// const REPEAT                         = 0x2901;
// const MIRRORED_REPEAT                = 0x8370;

var CLAMP_TO_EDGE = 0x812f;
/* TextureMagFilter */

var NEAREST = 0x2600;
var LINEAR = 0x2601;
/* TextureMinFilter */
// const NEAREST_MIPMAP_NEAREST         = 0x2700;
// const LINEAR_MIPMAP_NEAREST          = 0x2701;
// const NEAREST_MIPMAP_LINEAR          = 0x2702;
// const LINEAR_MIPMAP_LINEAR           = 0x2703;

/* Texture Target */

var TEXTURE_2D = 0x0de1;
var TEXTURE_CUBE_MAP = 0x8513;
var TEXTURE_3D = 0x806f;
var TEXTURE_2D_ARRAY = 0x8c1a;
/* Cubemap Targets */

var TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
var TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
var TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
var TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
var TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
var TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a;
/* Texture Parameters */

var TEXTURE_MIN_FILTER = 0x2801;
var TEXTURE_MAG_FILTER = 0x2800;
var TEXTURE_WRAP_S = 0x2802;
var TEXTURE_WRAP_T = 0x2803;
var TEXTURE_WRAP_R = 0x8072;
var TEXTURE_MIN_LOD = 0x813a;
var TEXTURE_MAX_LOD = 0x813b;
var TEXTURE_BASE_LEVEL = 0x813c;
var TEXTURE_MAX_LEVEL = 0x813d;
/* Pixel store */

var UNPACK_ALIGNMENT = 0x0cf5;
var UNPACK_ROW_LENGTH = 0x0cf2;
var UNPACK_IMAGE_HEIGHT = 0x806e;
var UNPACK_SKIP_PIXELS = 0x0cf4;
var UNPACK_SKIP_ROWS = 0x0cf3;
var UNPACK_SKIP_IMAGES = 0x806d;
var UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
var UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
var UNPACK_FLIP_Y_WEBGL = 0x9240;
var R8 = 0x8229;
var R8_SNORM = 0x8F94;
var R16F = 0x822D;
var R32F = 0x822E;
var R8UI = 0x8232;
var R8I = 0x8231;
var RG16UI = 0x823A;
var RG16I = 0x8239;
var RG32UI = 0x823C;
var RG32I = 0x823B;
var RG8 = 0x822B;
var RG8_SNORM = 0x8F95;
var RG16F = 0x822F;
var RG32F = 0x8230;
var RG8UI = 0x8238;
var RG8I = 0x8237;
var R16UI = 0x8234;
var R16I = 0x8233;
var R32UI = 0x8236;
var R32I = 0x8235;
var RGB8 = 0x8051;
var SRGB8 = 0x8C41;
var RGB565 = 0x8D62;
var RGB8_SNORM = 0x8F96;
var R11F_G11F_B10F = 0x8C3A;
var RGB9_E5 = 0x8C3D;
var RGB16F = 0x881B;
var RGB32F = 0x8815;
var RGB8UI = 0x8D7D;
var RGB8I = 0x8D8F;
var RGB16UI = 0x8D77;
var RGB16I = 0x8D89;
var RGB32UI = 0x8D71;
var RGB32I = 0x8D83;
var RGBA8 = 0x8058;
var SRGB8_ALPHA8 = 0x8C43;
var RGBA8_SNORM = 0x8F97;
var RGB5_A1 = 0x8057;
var RGBA4 = 0x8056;
var RGB10_A2 = 0x8059;
var RGBA16F = 0x881A;
var RGBA32F = 0x8814;
var RGBA8UI = 0x8D7C;
var RGBA8I = 0x8D8E;
var RGB10_A2UI = 0x906F;
var RGBA16UI = 0x8D76;
var RGBA16I = 0x8D88;
var RGBA32I = 0x8D82;
var RGBA32UI = 0x8D70;
var DEPTH_COMPONENT16 = 0x81A5;
var DEPTH_COMPONENT24 = 0x81A6;
var DEPTH_COMPONENT32F = 0x8CAC;
var DEPTH32F_STENCIL8 = 0x8CAD;
var DEPTH24_STENCIL8 = 0x88F0;
/* DataType */

var BYTE = 0x1400;
var UNSIGNED_BYTE = 0x1401;
var SHORT = 0x1402;
var UNSIGNED_SHORT = 0x1403;
var INT = 0x1404;
var UNSIGNED_INT = 0x1405;
var FLOAT = 0x1406;
var UNSIGNED_SHORT_4_4_4_4 = 0x8033;
var UNSIGNED_SHORT_5_5_5_1 = 0x8034;
var UNSIGNED_SHORT_5_6_5 = 0x8363;
var HALF_FLOAT = 0x140B;
var HALF_FLOAT_OES = 0x8D61; // Thanks Khronos for making this different >:(

var UNSIGNED_INT_2_10_10_10_REV = 0x8368;
var UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;
var UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;
var FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;
var UNSIGNED_INT_24_8 = 0x84FA;
var RG = 0x8227;
var RG_INTEGER = 0x8228;
var RED = 0x1903;
var RED_INTEGER = 0x8D94;
var RGB_INTEGER = 0x8D98;
var RGBA_INTEGER = 0x8D99;
var formatInfo = {};
{
  // NOTE: this is named `numColorComponents` vs `numComponents` so we can let Uglify mangle
  // the name.
  var f = formatInfo;
  f[ALPHA] = {
    numColorComponents: 1
  };
  f[LUMINANCE] = {
    numColorComponents: 1
  };
  f[LUMINANCE_ALPHA] = {
    numColorComponents: 2
  };
  f[RGB] = {
    numColorComponents: 3
  };
  f[RGBA] = {
    numColorComponents: 4
  };
  f[RED] = {
    numColorComponents: 1
  };
  f[RED_INTEGER] = {
    numColorComponents: 1
  };
  f[RG] = {
    numColorComponents: 2
  };
  f[RG_INTEGER] = {
    numColorComponents: 2
  };
  f[RGB] = {
    numColorComponents: 3
  };
  f[RGB_INTEGER] = {
    numColorComponents: 3
  };
  f[RGBA] = {
    numColorComponents: 4
  };
  f[RGBA_INTEGER] = {
    numColorComponents: 4
  };
  f[DEPTH_COMPONENT] = {
    numColorComponents: 1
  };
  f[DEPTH_STENCIL] = {
    numColorComponents: 2
  };
}
/**
 * @typedef {Object} TextureFormatDetails
 * @property {number} textureFormat format to pass texImage2D and similar functions.
 * @property {boolean} colorRenderable true if you can render to this format of texture.
 * @property {boolean} textureFilterable true if you can filter the texture, false if you can ony use `NEAREST`.
 * @property {number[]} type Array of possible types you can pass to texImage2D and similar function
 * @property {Object.<number,number>} bytesPerElementMap A map of types to bytes per element
 * @private
 */

var s_textureInternalFormatInfo;

function getTextureInternalFormatInfo(internalFormat) {
  if (!s_textureInternalFormatInfo) {
    // NOTE: these properties need unique names so we can let Uglify mangle the name.
    var t = {}; // unsized formats

    t[ALPHA] = {
      textureFormat: ALPHA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [1, 2, 2, 4],
      type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT]
    };
    t[LUMINANCE] = {
      textureFormat: LUMINANCE,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [1, 2, 2, 4],
      type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT]
    };
    t[LUMINANCE_ALPHA] = {
      textureFormat: LUMINANCE_ALPHA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [2, 4, 4, 8],
      type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT]
    };
    t[RGB] = {
      textureFormat: RGB,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [3, 6, 6, 12, 2],
      type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_5_6_5]
    };
    t[RGBA] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4, 8, 8, 16, 2, 2],
      type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_4_4_4_4, UNSIGNED_SHORT_5_5_5_1]
    };
    t[DEPTH_COMPONENT] = {
      textureFormat: DEPTH_COMPONENT,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2, 4],
      type: [UNSIGNED_INT, UNSIGNED_SHORT]
    }; // sized formats

    t[R8] = {
      textureFormat: RED,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [1],
      type: [UNSIGNED_BYTE]
    };
    t[R8_SNORM] = {
      textureFormat: RED,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [1],
      type: [BYTE]
    };
    t[R16F] = {
      textureFormat: RED,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [4, 2],
      type: [FLOAT, HALF_FLOAT]
    };
    t[R32F] = {
      textureFormat: RED,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [FLOAT]
    };
    t[R8UI] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [1],
      type: [UNSIGNED_BYTE]
    };
    t[R8I] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [1],
      type: [BYTE]
    };
    t[R16UI] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2],
      type: [UNSIGNED_SHORT]
    };
    t[R16I] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2],
      type: [SHORT]
    };
    t[R32UI] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_INT]
    };
    t[R32I] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [INT]
    };
    t[RG8] = {
      textureFormat: RG,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [2],
      type: [UNSIGNED_BYTE]
    };
    t[RG8_SNORM] = {
      textureFormat: RG,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [2],
      type: [BYTE]
    };
    t[RG16F] = {
      textureFormat: RG,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [8, 4],
      type: [FLOAT, HALF_FLOAT]
    };
    t[RG32F] = {
      textureFormat: RG,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [FLOAT]
    };
    t[RG8UI] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2],
      type: [UNSIGNED_BYTE]
    };
    t[RG8I] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2],
      type: [BYTE]
    };
    t[RG16UI] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_SHORT]
    };
    t[RG16I] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [SHORT]
    };
    t[RG32UI] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [UNSIGNED_INT]
    };
    t[RG32I] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [INT]
    };
    t[RGB8] = {
      textureFormat: RGB,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [3],
      type: [UNSIGNED_BYTE]
    };
    t[SRGB8] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [3],
      type: [UNSIGNED_BYTE]
    };
    t[RGB565] = {
      textureFormat: RGB,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [3, 2],
      type: [UNSIGNED_BYTE, UNSIGNED_SHORT_5_6_5]
    };
    t[RGB8_SNORM] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [3],
      type: [BYTE]
    };
    t[R11F_G11F_B10F] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [12, 6, 4],
      type: [FLOAT, HALF_FLOAT, UNSIGNED_INT_10F_11F_11F_REV]
    };
    t[RGB9_E5] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [12, 6, 4],
      type: [FLOAT, HALF_FLOAT, UNSIGNED_INT_5_9_9_9_REV]
    };
    t[RGB16F] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [12, 6],
      type: [FLOAT, HALF_FLOAT]
    };
    t[RGB32F] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [12],
      type: [FLOAT]
    };
    t[RGB8UI] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [3],
      type: [UNSIGNED_BYTE]
    };
    t[RGB8I] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [3],
      type: [BYTE]
    };
    t[RGB16UI] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [6],
      type: [UNSIGNED_SHORT]
    };
    t[RGB16I] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [6],
      type: [SHORT]
    };
    t[RGB32UI] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [12],
      type: [UNSIGNED_INT]
    };
    t[RGB32I] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [12],
      type: [INT]
    };
    t[RGBA8] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4],
      type: [UNSIGNED_BYTE]
    };
    t[SRGB8_ALPHA8] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4],
      type: [UNSIGNED_BYTE]
    };
    t[RGBA8_SNORM] = {
      textureFormat: RGBA,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [4],
      type: [BYTE]
    };
    t[RGB5_A1] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4, 2, 4],
      type: [UNSIGNED_BYTE, UNSIGNED_SHORT_5_5_5_1, UNSIGNED_INT_2_10_10_10_REV]
    };
    t[RGBA4] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4, 2],
      type: [UNSIGNED_BYTE, UNSIGNED_SHORT_4_4_4_4]
    };
    t[RGB10_A2] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4],
      type: [UNSIGNED_INT_2_10_10_10_REV]
    };
    t[RGBA16F] = {
      textureFormat: RGBA,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [16, 8],
      type: [FLOAT, HALF_FLOAT]
    };
    t[RGBA32F] = {
      textureFormat: RGBA,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [16],
      type: [FLOAT]
    };
    t[RGBA8UI] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_BYTE]
    };
    t[RGBA8I] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [BYTE]
    };
    t[RGB10_A2UI] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_INT_2_10_10_10_REV]
    };
    t[RGBA16UI] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [UNSIGNED_SHORT]
    };
    t[RGBA16I] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [SHORT]
    };
    t[RGBA32I] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [16],
      type: [INT]
    };
    t[RGBA32UI] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [16],
      type: [UNSIGNED_INT]
    }; // Sized Internal

    t[DEPTH_COMPONENT16] = {
      textureFormat: DEPTH_COMPONENT,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2, 4],
      type: [UNSIGNED_SHORT, UNSIGNED_INT]
    };
    t[DEPTH_COMPONENT24] = {
      textureFormat: DEPTH_COMPONENT,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_INT]
    };
    t[DEPTH_COMPONENT32F] = {
      textureFormat: DEPTH_COMPONENT,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [FLOAT]
    };
    t[DEPTH24_STENCIL8] = {
      textureFormat: DEPTH_STENCIL,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_INT_24_8]
    };
    t[DEPTH32F_STENCIL8] = {
      textureFormat: DEPTH_STENCIL,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [FLOAT_32_UNSIGNED_INT_24_8_REV]
    };
    Object.keys(t).forEach(function (internalFormat) {
      var info = t[internalFormat];
      info.bytesPerElementMap = {};
      info.bytesPerElement.forEach(function (bytesPerElement, ndx) {
        var type = info.type[ndx];
        info.bytesPerElementMap[type] = bytesPerElement;
      });
    });
    s_textureInternalFormatInfo = t;
  }

  return s_textureInternalFormatInfo[internalFormat];
}
/**
 * Gets the number of bytes per element for a given internalFormat / type
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @param {number} type The type parameter for texImage2D etc..
 * @return {number} the number of bytes per element for the given internalFormat, type combo
 * @memberOf module:twgl/textures
 */


function getBytesPerElementForInternalFormat(internalFormat, type) {
  var info = getTextureInternalFormatInfo(internalFormat);

  if (!info) {
    throw "unknown internal format";
  }

  var bytesPerElement = info.bytesPerElementMap[type];

  if (bytesPerElement === undefined) {
    throw "unknown internal format";
  }

  return bytesPerElement;
}
/**
 * Info related to a specific texture internalFormat as returned
 * from {@link module:twgl/textures.getFormatAndTypeForInternalFormat}.
 *
 * @typedef {Object} TextureFormatInfo
 * @property {number} format Format to pass to texImage2D and related functions
 * @property {number} type Type to pass to texImage2D and related functions
 * @memberOf module:twgl/textures
 */

/**
 * Gets the format and type for a given internalFormat
 *
 * @param {number} internalFormat The internal format
 * @return {module:twgl/textures.TextureFormatInfo} the corresponding format and type,
 * @memberOf module:twgl/textures
 */


function getFormatAndTypeForInternalFormat(internalFormat) {
  var info = getTextureInternalFormatInfo(internalFormat);

  if (!info) {
    throw "unknown internal format";
  }

  return {
    format: info.textureFormat,
    type: info.type[0]
  };
}
/**
 * Returns true if value is power of 2
 * @param {number} value number to check.
 * @return true if value is power of 2
 * @private
 */


function isPowerOf2(value) {
  return (value & value - 1) === 0;
}
/**
 * Gets whether or not we can generate mips for the given
 * internal format.
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {number} width The width parameter from texImage2D etc..
 * @param {number} height The height parameter from texImage2D etc..
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @return {boolean} true if we can generate mips
 * @memberOf module:twgl/textures
 */


function canGenerateMipmap(gl, width, height, internalFormat) {
  if (!utils.isWebGL2(gl)) {
    return isPowerOf2(width) && isPowerOf2(height);
  }

  var info = getTextureInternalFormatInfo(internalFormat);

  if (!info) {
    throw "unknown internal format";
  }

  return info.colorRenderable && info.textureFilterable;
}
/**
 * Gets whether or not we can generate mips for the given format
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @return {boolean} true if we can generate mips
 * @memberOf module:twgl/textures
 */


function canFilter(internalFormat) {
  var info = getTextureInternalFormatInfo(internalFormat);

  if (!info) {
    throw "unknown internal format";
  }

  return info.textureFilterable;
}
/**
 * Gets the number of components for a given image format.
 * @param {number} format the format.
 * @return {number} the number of components for the format.
 * @memberOf module:twgl/textures
 */


function getNumComponentsForFormat(format) {
  var info = formatInfo[format];

  if (!info) {
    throw "unknown format: " + format;
  }

  return info.numColorComponents;
}
/**
 * Gets the texture type for a given array type.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @return {number} the gl texture type
 * @private
 */


function getTextureTypeForArrayType(gl, src, defaultType) {
  if (isArrayBuffer(src)) {
    return typedArrays.getGLTypeForTypedArray(src);
  }

  return defaultType || UNSIGNED_BYTE;
}

function guessDimensions(gl, target, width, height, numElements) {
  if (numElements % 1 !== 0) {
    throw "can't guess dimensions";
  }

  if (!width && !height) {
    var size = Math.sqrt(numElements / (target === TEXTURE_CUBE_MAP ? 6 : 1));

    if (size % 1 === 0) {
      width = size;
      height = size;
    } else {
      width = numElements;
      height = 1;
    }
  } else if (!height) {
    height = numElements / width;

    if (height % 1) {
      throw "can't guess dimensions";
    }
  } else if (!width) {
    width = numElements / height;

    if (width % 1) {
      throw "can't guess dimensions";
    }
  }

  return {
    width: width,
    height: height
  };
}
/**
 * Sets the default texture color.
 *
 * The default texture color is used when loading textures from
 * urls. Because the URL will be loaded async we'd like to be
 * able to use the texture immediately. By putting a 1x1 pixel
 * color in the texture we can start using the texture before
 * the URL has loaded.
 *
 * @param {number[]} color Array of 4 values in the range 0 to 1
 * @deprecated see {@link module:twgl.setDefaults}
 * @memberOf module:twgl/textures
 */


function setDefaultTextureColor(color) {
  defaults.textureColor = new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);
}

function setDefaults(newDefaults) {
  helper.copyExistingProperties(newDefaults, defaults);

  if (newDefaults.textureColor) {
    setDefaultTextureColor(newDefaults.textureColor);
  }
}
/**
 * A function to generate the source for a texture.
 * @callback TextureFunc
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options the texture options
 * @return {*} Returns any of the things documented for `src` for {@link module:twgl.TextureOptions}.
 * @memberOf module:twgl
 */

/**
 * Texture options passed to most texture functions. Each function will use whatever options
 * are appropriate for its needs. This lets you pass the same options to all functions.
 *
 * Note: A `TexImageSource` is defined in the WebGL spec as a `HTMLImageElement`, `HTMLVideoElement`,
 * `HTMLCanvasElement`, `ImageBitmap`, or `ImageData`.
 *
 * @typedef {Object} TextureOptions
 * @property {number} [target] the type of texture `gl.TEXTURE_2D` or `gl.TEXTURE_CUBE_MAP`. Defaults to `gl.TEXTURE_2D`.
 * @property {number} [level] the mip level to affect. Defaults to 0. Note, if set auto will be considered false unless explicitly set to true.
 * @property {number} [width] the width of the texture. Only used if src is an array or typed array or null.
 * @property {number} [height] the height of a texture. Only used if src is an array or typed array or null.
 * @property {number} [depth] the depth of a texture. Only used if src is an array or type array or null and target is `TEXTURE_3D` .
 * @property {number} [min] the min filter setting (eg. `gl.LINEAR`). Defaults to `gl.NEAREST_MIPMAP_LINEAR`
 *     or if texture is not a power of 2 on both dimensions then defaults to `gl.LINEAR`.
 * @property {number} [mag] the mag filter setting (eg. `gl.LINEAR`). Defaults to `gl.LINEAR`
 * @property {number} [minMag] both the min and mag filter settings.
 * @property {number} [internalFormat] internal format for texture. Defaults to `gl.RGBA`
 * @property {number} [format] format for texture. Defaults to `gl.RGBA`.
 * @property {number} [type] type for texture. Defaults to `gl.UNSIGNED_BYTE` unless `src` is ArrayBufferView. If `src`
 *     is ArrayBufferView defaults to type that matches ArrayBufferView type.
 * @property {number} [wrap] Texture wrapping for both S and T (and R if TEXTURE_3D or WebGLSampler). Defaults to `gl.REPEAT` for 2D unless src is WebGL1 and src not npot and `gl.CLAMP_TO_EDGE` for cube
 * @property {number} [wrapS] Texture wrapping for S. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [wrapT] Texture wrapping for T. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [wrapR] Texture wrapping for R. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [minLod] TEXTURE_MIN_LOD setting
 * @property {number} [maxLod] TEXTURE_MAX_LOD setting
 * @property {number} [baseLevel] TEXTURE_BASE_LEVEL setting
 * @property {number} [maxLevel] TEXTURE_MAX_LEVEL setting
 * @property {number} [unpackAlignment] The `gl.UNPACK_ALIGNMENT` used when uploading an array. Defaults to 1.
 * @property {number[]|ArrayBufferView} [color] Color to initialize this texture with if loading an image asynchronously.
 *     The default use a blue 1x1 pixel texture. You can set another default by calling `twgl.setDefaults`
 *     or you can set an individual texture's initial color by setting this property. Example: `[1, .5, .5, 1]` = pink
 * @property {number} [premultiplyAlpha] Whether or not to premultiply alpha. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {number} [flipY] Whether or not to flip the texture vertically on upload. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {number} [colorspaceConversion] Whether or not to let the browser do colorspace conversion of the texture on upload. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {boolean} [auto] If `undefined` or `true`, in WebGL1, texture filtering is set automatically for non-power of 2 images and
 *    mips are generated for power of 2 images. In WebGL2 mips are generated if they can be. Note: if `level` is set above
 *    then then `auto` is assumed to be `false` unless explicity set to `true`.
 * @property {number[]} [cubeFaceOrder] The order that cube faces are pulled out of an img or set of images. The default is
 *
 *     [gl.TEXTURE_CUBE_MAP_POSITIVE_X,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
 *      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
 *      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]
 *
 * @property {(number[]|ArrayBufferView|TexImageSource|TexImageSource[]|string|string[]|module:twgl.TextureFunc)} [src] source for texture
 *
 *    If `string` then it's assumed to be a URL to an image. The image will be downloaded async. A usable
 *    1x1 pixel texture will be returned immediately. The texture will be updated once the image has downloaded.
 *    If `target` is `gl.TEXTURE_CUBE_MAP` will attempt to divide image into 6 square pieces. 1x6, 6x1, 3x2, 2x3.
 *    The pieces will be uploaded in `cubeFaceOrder`
 *
 *    If `string[]` or `TexImageSource[]` and target is `gl.TEXTURE_CUBE_MAP` then it must have 6 entries, one for each face of a cube map.
 *
 *    If `string[]` or `TexImageSource[]` and target is `gl.TEXTURE_2D_ARRAY` then each entry is a slice of the a 2d array texture
 *    and will be scaled to the specified width and height OR to the size of the first image that loads.
 *
 *    If `TexImageSource` then it wil be used immediately to create the contents of the texture. Examples `HTMLImageElement`,
 *    `HTMLCanvasElement`, `HTMLVideoElement`.
 *
 *    If `number[]` or `ArrayBufferView` it's assumed to be data for a texture. If `width` or `height` is
 *    not specified it is guessed as follows. First the number of elements is computed by `src.length / numComponents`
 *    where `numComponents` is derived from `format`. If `target` is `gl.TEXTURE_CUBE_MAP` then `numElements` is divided
 *    by 6. Then
 *
 *    *   If neither `width` nor `height` are specified and `sqrt(numElements)` is an integer then width and height
 *        are set to `sqrt(numElements)`. Otherwise `width = numElements` and `height = 1`.
 *
 *    *   If only one of `width` or `height` is specified then the other equals `numElements / specifiedDimension`.
 *
 * If `number[]` will be converted to `type`.
 *
 * If `src` is a function it will be called with a `WebGLRenderingContext` and these options.
 * Whatever it returns is subject to these rules. So it can return a string url, an `HTMLElement`
 * an array etc...
 *
 * If `src` is undefined then an empty texture will be created of size `width` by `height`.
 *
 * @property {string} [crossOrigin] What to set the crossOrigin property of images when they are downloaded.
 *    default: undefined. Also see {@link module:twgl.setDefaults}.
 *
 * @memberOf module:twgl
 */

/**
 * Sets any packing state that will be set based on the options.
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @private
 */


function setPackState(gl, options) {
  if (options.colorspaceConversion !== undefined) {
    gl.pixelStorei(UNPACK_COLORSPACE_CONVERSION_WEBGL, options.colorspaceConversion);
  }

  if (options.premultiplyAlpha !== undefined) {
    gl.pixelStorei(UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.premultiplyAlpha);
  }

  if (options.flipY !== undefined) {
    gl.pixelStorei(UNPACK_FLIP_Y_WEBGL, options.flipY);
  }
}
/**
 * Set skip state to defaults
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @private
 */


function setSkipStateToDefault(gl) {
  gl.pixelStorei(UNPACK_ALIGNMENT, 4);

  if (utils.isWebGL2(gl)) {
    gl.pixelStorei(UNPACK_ROW_LENGTH, 0);
    gl.pixelStorei(UNPACK_IMAGE_HEIGHT, 0);
    gl.pixelStorei(UNPACK_SKIP_PIXELS, 0);
    gl.pixelStorei(UNPACK_SKIP_ROWS, 0);
    gl.pixelStorei(UNPACK_SKIP_IMAGES, 0);
  }
}
/**
 * Sets the parameters of a texture or sampler
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {number|WebGLSampler} target texture target or sampler
 * @param {function()} parameteriFn texParameteri or samplerParameteri fn
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @private
 */


function setTextureSamplerParameters(gl, target, parameteriFn, options) {
  if (options.minMag) {
    parameteriFn.call(gl, target, TEXTURE_MIN_FILTER, options.minMag);
    parameteriFn.call(gl, target, TEXTURE_MAG_FILTER, options.minMag);
  }

  if (options.min) {
    parameteriFn.call(gl, target, TEXTURE_MIN_FILTER, options.min);
  }

  if (options.mag) {
    parameteriFn.call(gl, target, TEXTURE_MAG_FILTER, options.mag);
  }

  if (options.wrap) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_S, options.wrap);
    parameteriFn.call(gl, target, TEXTURE_WRAP_T, options.wrap);

    if (target === TEXTURE_3D || helper.isSampler(gl, target)) {
      parameteriFn.call(gl, target, TEXTURE_WRAP_R, options.wrap);
    }
  }

  if (options.wrapR) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_R, options.wrapR);
  }

  if (options.wrapS) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_S, options.wrapS);
  }

  if (options.wrapT) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_T, options.wrapT);
  }

  if (options.minLod) {
    parameteriFn.call(gl, target, TEXTURE_MIN_LOD, options.minLod);
  }

  if (options.maxLod) {
    parameteriFn.call(gl, target, TEXTURE_MAX_LOD, options.maxLod);
  }

  if (options.baseLevel) {
    parameteriFn.call(gl, target, TEXTURE_BASE_LEVEL, options.baseLevel);
  }

  if (options.maxLevel) {
    parameteriFn.call(gl, target, TEXTURE_MAX_LEVEL, options.maxLevel);
  }
}
/**
 * Sets the texture parameters of a texture.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */


function setTextureParameters(gl, tex, options) {
  var target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  setTextureSamplerParameters(gl, target, gl.texParameteri, options);
}
/**
 * Sets the sampler parameters of a sampler.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLSampler} sampler the WebGLSampler to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @memberOf module:twgl/textures
 */


function setSamplerParameters(gl, sampler, options) {
  setTextureSamplerParameters(gl, sampler, gl.samplerParameteri, options);
}
/**
 * Creates a new sampler object and sets parameters.
 *
 * Example:
 *
 *      const sampler = twgl.createSampler(gl, {
 *        minMag: gl.NEAREST,         // sets both TEXTURE_MIN_FILTER and TEXTURE_MAG_FILTER
 *        wrap: gl.CLAMP_TO_NEAREST,  // sets both TEXTURE_WRAP_S and TEXTURE_WRAP_T and TEXTURE_WRAP_R
 *      });
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per sampler.
 * @return {Object.<string,WebGLSampler>} the created samplers by name
 * @private
 */


function createSampler(gl, options) {
  var sampler = gl.createSampler();
  setSamplerParameters(gl, sampler, options);
  return sampler;
}
/**
 * Creates a multiple sampler objects and sets parameters on each.
 *
 * Example:
 *
 *      const samplers = twgl.createSamplers(gl, {
 *        nearest: {
 *          minMag: gl.NEAREST,
 *        },
 *        nearestClampS: {
 *          minMag: gl.NEAREST,
 *          wrapS: gl.CLAMP_TO_NEAREST,
 *        },
 *        linear: {
 *          minMag: gl.LINEAR,
 *        },
 *        nearestClamp: {
 *          minMag: gl.NEAREST,
 *          wrap: gl.CLAMP_TO_EDGE,
 *        },
 *        linearClamp: {
 *          minMag: gl.LINEAR,
 *          wrap: gl.CLAMP_TO_EDGE,
 *        },
 *        linearClampT: {
 *          minMag: gl.LINEAR,
 *          wrapT: gl.CLAMP_TO_EDGE,
 *        },
 *      });
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set on the sampler
 * @private
 */


function createSamplers(gl, samplerOptions) {
  var samplers = {};
  Object.keys(samplerOptions).forEach(function (name) {
    samplers[name] = createSampler(gl, samplerOptions[name]);
  });
  return samplers;
}
/**
 * Makes a 1x1 pixel
 * If no color is passed in uses the default color which can be set by calling `setDefaultTextureColor`.
 * @param {(number[]|ArrayBufferView)} [color] The color using 0-1 values
 * @return {Uint8Array} Unit8Array with color.
 * @private
 */


function make1Pixel(color) {
  color = color || defaults.textureColor;

  if (isArrayBuffer(color)) {
    return color;
  }

  return new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);
}
/**
 * Sets filtering or generates mips for texture based on width or height
 * If width or height is not passed in uses `options.width` and//or `options.height`
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @param {number} [width] width of texture
 * @param {number} [height] height of texture
 * @param {number} [internalFormat] The internalFormat parameter from texImage2D etc..
 * @memberOf module:twgl/textures
 */


function setTextureFilteringForSize(gl, tex, options, width, height, internalFormat) {
  options = options || defaults.textureOptions;
  internalFormat = internalFormat || RGBA;
  var target = options.target || TEXTURE_2D;
  width = width || options.width;
  height = height || options.height;
  gl.bindTexture(target, tex);

  if (canGenerateMipmap(gl, width, height, internalFormat)) {
    gl.generateMipmap(target);
  } else {
    var filtering = canFilter(internalFormat) ? LINEAR : NEAREST;
    gl.texParameteri(target, TEXTURE_MIN_FILTER, filtering);
    gl.texParameteri(target, TEXTURE_MAG_FILTER, filtering);
    gl.texParameteri(target, TEXTURE_WRAP_S, CLAMP_TO_EDGE);
    gl.texParameteri(target, TEXTURE_WRAP_T, CLAMP_TO_EDGE);
  }
}

function shouldAutomaticallySetTextureFilteringForSize(options) {
  return options.auto === true || options.auto === undefined && options.level === undefined;
}
/**
 * Gets an array of cubemap face enums
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @return {number[]} cubemap face enums
 * @private
 */


function getCubeFaceOrder(gl, options) {
  options = options || {};
  return options.cubeFaceOrder || [TEXTURE_CUBE_MAP_POSITIVE_X, TEXTURE_CUBE_MAP_NEGATIVE_X, TEXTURE_CUBE_MAP_POSITIVE_Y, TEXTURE_CUBE_MAP_NEGATIVE_Y, TEXTURE_CUBE_MAP_POSITIVE_Z, TEXTURE_CUBE_MAP_NEGATIVE_Z];
}
/**
 * @typedef {Object} FaceInfo
 * @property {number} face gl enum for texImage2D
 * @property {number} ndx face index (0 - 5) into source data
 * @ignore
 */

/**
 * Gets an array of FaceInfos
 * There's a bug in some NVidia drivers that will crash the driver if
 * `gl.TEXTURE_CUBE_MAP_POSITIVE_X` is not uploaded first. So, we take
 * the user's desired order from his faces to WebGL and make sure we
 * do the faces in WebGL order
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @return {FaceInfo[]} cubemap face infos. Arguably the `face` property of each element is redundant but
 *    it's needed internally to sort the array of `ndx` properties by `face`.
 * @private
 */


function getCubeFacesWithNdx(gl, options) {
  var faces = getCubeFaceOrder(gl, options); // work around bug in NVidia drivers. We have to upload the first face first else the driver crashes :(

  var facesWithNdx = faces.map(function (face, ndx) {
    return {
      face: face,
      ndx: ndx
    };
  });
  facesWithNdx.sort(function (a, b) {
    return a.face - b.face;
  });
  return facesWithNdx;
}
/**
 * Set a texture from the contents of an element. Will also set
 * texture filtering or generate mips based on the dimensions of the element
 * unless `options.auto === false`. If `target === gl.TEXTURE_CUBE_MAP` will
 * attempt to slice image into 1x6, 2x3, 3x2, or 6x1 images, one for each face.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {HTMLElement} element a canvas, img, or video element.
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 * @kind function
 */


function setTextureFromElement(gl, tex, element, options) {
  options = options || defaults.textureOptions;
  var target = options.target || TEXTURE_2D;
  var level = options.level || 0;
  var width = element.width;
  var height = element.height;
  var internalFormat = options.internalFormat || options.format || RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || formatType.type;
  setPackState(gl, options);
  gl.bindTexture(target, tex);

  if (target === TEXTURE_CUBE_MAP) {
    // guess the parts
    var imgWidth = element.width;
    var imgHeight = element.height;
    var size;
    var slices;

    if (imgWidth / 6 === imgHeight) {
      // It's 6x1
      size = imgHeight;
      slices = [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0];
    } else if (imgHeight / 6 === imgWidth) {
      // It's 1x6
      size = imgWidth;
      slices = [0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5];
    } else if (imgWidth / 3 === imgHeight / 2) {
      // It's 3x2
      size = imgWidth / 3;
      slices = [0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1];
    } else if (imgWidth / 2 === imgHeight / 3) {
      // It's 2x3
      size = imgWidth / 2;
      slices = [0, 0, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2];
    } else {
      throw "can't figure out cube map from element: " + (element.src ? element.src : element.nodeName);
    }

    var ctx = getShared2DContext();

    if (ctx) {
      ctx.canvas.width = size;
      ctx.canvas.height = size;
      width = size;
      height = size;
      getCubeFacesWithNdx(gl, options).forEach(function (f) {
        var xOffset = slices[f.ndx * 2 + 0] * size;
        var yOffset = slices[f.ndx * 2 + 1] * size;
        ctx.drawImage(element, xOffset, yOffset, size, size, 0, 0, size, size);
        gl.texImage2D(f.face, level, internalFormat, format, type, ctx.canvas);
      }); // Free up the canvas memory

      ctx.canvas.width = 1;
      ctx.canvas.height = 1;
    } else if (typeof createImageBitmap !== 'undefined') {
      // NOTE: It seems like we should prefer ImageBitmap because unlike canvas it's
      // note lossy? (alpha is not premultiplied? although I'm not sure what
      width = size;
      height = size;
      getCubeFacesWithNdx(gl, options).forEach(function (f) {
        var xOffset = slices[f.ndx * 2 + 0] * size;
        var yOffset = slices[f.ndx * 2 + 1] * size; // We can't easily use a default texture color here as it would have to match
        // the type across all faces where as with a 2D one there's only one face
        // so we're replacing everything all at once. It also has to be the correct size.
        // On the other hand we need all faces to be the same size so as one face loads
        // the rest match else the texture will be un-renderable.

        gl.texImage2D(f.face, level, internalFormat, size, size, 0, format, type, null);
        createImageBitmap(element, xOffset, yOffset, size, size, {
          premultiplyAlpha: 'none',
          colorSpaceConversion: 'none'
        }).then(function (imageBitmap) {
          setPackState(gl, options);
          gl.bindTexture(target, tex);
          gl.texImage2D(f.face, level, internalFormat, format, type, imageBitmap);

          if (shouldAutomaticallySetTextureFilteringForSize(options)) {
            setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
          }
        });
      });
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    var smallest = Math.min(element.width, element.height);
    var largest = Math.max(element.width, element.height);
    var depth = largest / smallest;

    if (depth % 1 !== 0) {
      throw "can not compute 3D dimensions of element";
    }

    var xMult = element.width === largest ? 1 : 0;
    var yMult = element.height === largest ? 1 : 0;
    gl.pixelStorei(UNPACK_ALIGNMENT, 1);
    gl.pixelStorei(UNPACK_ROW_LENGTH, element.width);
    gl.pixelStorei(UNPACK_IMAGE_HEIGHT, 0);
    gl.pixelStorei(UNPACK_SKIP_IMAGES, 0);
    gl.texImage3D(target, level, internalFormat, smallest, smallest, smallest, 0, format, type, null);

    for (var d = 0; d < depth; ++d) {
      var srcX = d * smallest * xMult;
      var srcY = d * smallest * yMult;
      gl.pixelStorei(UNPACK_SKIP_PIXELS, srcX);
      gl.pixelStorei(UNPACK_SKIP_ROWS, srcY);
      gl.texSubImage3D(target, level, 0, 0, d, smallest, smallest, 1, format, type, element);
    }

    setSkipStateToDefault(gl);
  } else {
    gl.texImage2D(target, level, internalFormat, format, type, element);
  }

  if (shouldAutomaticallySetTextureFilteringForSize(options)) {
    setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
  }

  setTextureParameters(gl, tex, options);
}

function noop() {}
/**
 * Checks whether the url's origin is the same so that we can set the `crossOrigin`
 * @param {string} url url to image
 * @returns {boolean} true if the window's origin is the same as image's url
 * @private
 */


function urlIsSameOrigin(url) {
  if (typeof document !== 'undefined') {
    // for IE really
    var a = document.createElement('a');
    a.href = url;
    return a.hostname === location.hostname && a.port === location.port && a.protocol === location.protocol;
  } else {
    var localOrigin = new URL(location.href).origin;
    var urlOrigin = new URL(url, location.href).origin;
    return urlOrigin === localOrigin;
  }
}

function setToAnonymousIfUndefinedAndURLIsNotSameOrigin(url, crossOrigin) {
  return crossOrigin === undefined && !urlIsSameOrigin(url) ? 'anonymous' : crossOrigin;
}
/**
 * Loads an image
 * @param {string} url url to image
 * @param {string} crossOrigin
 * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null
 *     if there was an error
 * @return {HTMLImageElement} the image being loaded.
 * @private
 */


function loadImage(url, crossOrigin, callback) {
  callback = callback || noop;
  var img;
  crossOrigin = crossOrigin !== undefined ? crossOrigin : defaults.crossOrigin;
  crossOrigin = setToAnonymousIfUndefinedAndURLIsNotSameOrigin(url, crossOrigin);

  if (typeof Image !== 'undefined') {
    img = new Image();

    if (crossOrigin !== undefined) {
      img.crossOrigin = crossOrigin;
    }

    var clearEventHandlers = function clearEventHandlers() {
      img.removeEventListener('error', onError); // eslint-disable-line

      img.removeEventListener('load', onLoad); // eslint-disable-line

      img = null;
    };

    var onError = function onError() {
      var msg = "couldn't load image: " + url;
      helper.error(msg);
      callback(msg, img);
      clearEventHandlers();
    };

    var onLoad = function onLoad() {
      callback(null, img);
      clearEventHandlers();
    };

    img.addEventListener('error', onError);
    img.addEventListener('load', onLoad);
    img.src = url;
    return img;
  } else if (typeof ImageBitmap !== 'undefined') {
    var err;
    var bm;

    var cb = function cb() {
      callback(err, bm);
    };

    var options = {};

    if (crossOrigin) {
      options.mode = 'cors'; // TODO: not sure how to translate image.crossOrigin
    }

    fetch(url, options).then(function (response) {
      if (!response.ok) {
        throw response;
      }

      return response.blob();
    }).then(function (blob) {
      return createImageBitmap(blob, {
        premultiplyAlpha: 'none',
        colorSpaceConversion: 'none'
      });
    }).then(function (bitmap) {
      // not sure if this works. We don't want
      // to catch the user's error. So, call
      // the callback in a timeout so we're
      // not in this scope inside the promise.
      bm = bitmap;
      setTimeout(cb);
    })["catch"](function (e) {
      err = e;
      setTimeout(cb);
    });
    img = null;
  }

  return img;
}
/**
 * check if object is a TexImageSource
 *
 * @param {Object} obj Object to test
 * @return {boolean} true if object is a TexImageSource
 * @private
 */


function isTexImageSource(obj) {
  return typeof ImageBitmap !== 'undefined' && obj instanceof ImageBitmap || typeof ImageData !== 'undefined' && obj instanceof ImageData || typeof HTMLElement !== 'undefined' && obj instanceof HTMLElement;
}
/**
 * if obj is an TexImageSource then just
 * uses it otherwise if obj is a string
 * then load it first.
 *
 * @param {string|TexImageSource} obj
 * @param {string} crossOrigin
 * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null
 *     if there was an error
 * @private
 */


function loadAndUseImage(obj, crossOrigin, callback) {
  if (isTexImageSource(obj)) {
    setTimeout(function () {
      callback(null, obj);
    });
    return obj;
  }

  return loadImage(obj, crossOrigin, callback);
}
/**
 * Sets a texture to a 1x1 pixel color. If `options.color === false` is nothing happens. If it's not set
 * the default texture color is used which can be set by calling `setDefaultTextureColor`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */


function setTextureTo1PixelColor(gl, tex, options) {
  options = options || defaults.textureOptions;
  var target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);

  if (options.color === false) {
    return;
  } // Assume it's a URL
  // Put 1x1 pixels in texture. That makes it renderable immediately regardless of filtering.


  var color = make1Pixel(options.color);

  if (target === TEXTURE_CUBE_MAP) {
    for (var ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, RGBA, 1, 1, 0, RGBA, UNSIGNED_BYTE, color);
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, 0, RGBA, 1, 1, 1, 0, RGBA, UNSIGNED_BYTE, color);
  } else {
    gl.texImage2D(target, 0, RGBA, 1, 1, 0, RGBA, UNSIGNED_BYTE, color);
  }
}
/**
 * The src image(s) used to create a texture.
 *
 * When you call {@link module:twgl.createTexture} or {@link module:twgl.createTextures}
 * you can pass in urls for images to load into the textures. If it's a single url
 * then this will be a single HTMLImageElement. If it's an array of urls used for a cubemap
 * this will be a corresponding array of images for the cubemap.
 *
 * @typedef {HTMLImageElement|HTMLImageElement[]} TextureSrc
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback TextureReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} texture the texture.
 * @param {module:twgl.TextureSrc} source image(s) used to as the src for the texture
 * @memberOf module:twgl
 */

/**
 * A callback for when all images have finished downloading and been uploaded into their respective textures
 * @callback TexturesReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {Object.<string, WebGLTexture>} textures the created textures by name. Same as returned by {@link module:twgl.createTextures}.
 * @param {Object.<string, module:twgl.TextureSrc>} sources the image(s) used for the texture by name.
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback CubemapReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} tex the texture.
 * @param {HTMLImageElement[]} imgs the images for each face.
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback ThreeDReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} tex the texture.
 * @param {HTMLImageElement[]} imgs the images for each slice.
 * @memberOf module:twgl
 */

/**
 * Loads a texture from an image from a Url as specified in `options.src`
 * If `options.color !== false` will set the texture to a 1x1 pixel color so that the texture is
 * immediately useable. It will be updated with the contents of the image once the image has finished
 * downloading. Filtering options will be set as appropriate for image unless `options.auto === false`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.TextureReadyCallback} [callback] A function to be called when the image has finished loading. err will
 *    be non null if there was an error.
 * @return {HTMLImageElement} the image being downloaded.
 * @memberOf module:twgl/textures
 */


function loadTextureFromUrl(gl, tex, options, callback) {
  callback = callback || noop;
  options = options || defaults.textureOptions;
  setTextureTo1PixelColor(gl, tex, options); // Because it's async we need to copy the options.

  options = Object.assign({}, options);
  var img = loadAndUseImage(options.src, options.crossOrigin, function (err, img) {
    if (err) {
      callback(err, tex, img);
    } else {
      setTextureFromElement(gl, tex, img, options);
      callback(null, tex, img);
    }
  });
  return img;
}
/**
 * Loads a cubemap from 6 urls or TexImageSources as specified in `options.src`. Will set the cubemap to a 1x1 pixel color
 * so that it is usable immediately unless `option.color === false`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.CubemapReadyCallback} [callback] A function to be called when all the images have finished loading. err will
 *    be non null if there was an error.
 * @memberOf module:twgl/textures
 */


function loadCubemapFromUrls(gl, tex, options, callback) {
  callback = callback || noop;
  var urls = options.src;

  if (urls.length !== 6) {
    throw "there must be 6 urls for a cubemap";
  }

  var level = options.level || 0;
  var internalFormat = options.internalFormat || options.format || RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || UNSIGNED_BYTE;
  var target = options.target || TEXTURE_2D;

  if (target !== TEXTURE_CUBE_MAP) {
    throw "target must be TEXTURE_CUBE_MAP";
  }

  setTextureTo1PixelColor(gl, tex, options); // Because it's async we need to copy the options.

  options = Object.assign({}, options);
  var numToLoad = 6;
  var errors = [];
  var faces = getCubeFaceOrder(gl, options);
  var imgs; // eslint-disable-line

  function uploadImg(faceTarget) {
    return function (err, img) {
      --numToLoad;

      if (err) {
        errors.push(err);
      } else {
        if (img.width !== img.height) {
          errors.push("cubemap face img is not a square: " + img.src);
        } else {
          setPackState(gl, options);
          gl.bindTexture(target, tex); // So assuming this is the first image we now have one face that's img sized
          // and 5 faces that are 1x1 pixel so size the other faces

          if (numToLoad === 5) {
            // use the default order
            getCubeFaceOrder(gl).forEach(function (otherTarget) {
              // Should we re-use the same face or a color?
              gl.texImage2D(otherTarget, level, internalFormat, format, type, img);
            });
          } else {
            gl.texImage2D(faceTarget, level, internalFormat, format, type, img);
          }

          if (shouldAutomaticallySetTextureFilteringForSize(options)) {
            gl.generateMipmap(target);
          }
        }
      }

      if (numToLoad === 0) {
        callback(errors.length ? errors : undefined, tex, imgs);
      }
    };
  }

  imgs = urls.map(function (url, ndx) {
    return loadAndUseImage(url, options.crossOrigin, uploadImg(faces[ndx]));
  });
}
/**
 * Loads a 2d array or 3d texture from urls OR TexImageSources as specified in `options.src`.
 * Will set the texture to a 1x1 pixel color
 * so that it is usable immediately unless `option.color === false`.
 *
 * If the width and height is not specified the width and height of the first
 * image loaded will be used. Note that since images are loaded async
 * which image downloads first is unknown.
 *
 * If an image is not the same size as the width and height it will be scaled
 * to that width and height.
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.ThreeDReadyCallback} [callback] A function to be called when all the images have finished loading. err will
 *    be non null if there was an error.
 * @memberOf module:twgl/textures
 */


function loadSlicesFromUrls(gl, tex, options, callback) {
  callback = callback || noop;
  var urls = options.src;
  var internalFormat = options.internalFormat || options.format || RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || UNSIGNED_BYTE;
  var target = options.target || TEXTURE_2D_ARRAY;

  if (target !== TEXTURE_3D && target !== TEXTURE_2D_ARRAY) {
    throw "target must be TEXTURE_3D or TEXTURE_2D_ARRAY";
  }

  setTextureTo1PixelColor(gl, tex, options); // Because it's async we need to copy the options.

  options = Object.assign({}, options);
  var numToLoad = urls.length;
  var errors = [];
  var imgs; // eslint-disable-line

  var level = options.level || 0;
  var width = options.width;
  var height = options.height;
  var depth = urls.length;
  var firstImage = true;

  function uploadImg(slice) {
    return function (err, img) {
      --numToLoad;

      if (err) {
        errors.push(err);
      } else {
        setPackState(gl, options);
        gl.bindTexture(target, tex);

        if (firstImage) {
          firstImage = false;
          width = options.width || img.width;
          height = options.height || img.height;
          gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, null); // put it in every slice otherwise some slices will be 0,0,0,0

          for (var s = 0; s < depth; ++s) {
            gl.texSubImage3D(target, level, 0, 0, s, width, height, 1, format, type, img);
          }
        } else {
          var src = img;
          var ctx;

          if (img.width !== width || img.height !== height) {
            // Size the image to fix
            ctx = getShared2DContext();
            src = ctx.canvas;
            ctx.canvas.width = width;
            ctx.canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
          }

          gl.texSubImage3D(target, level, 0, 0, slice, width, height, 1, format, type, src); // free the canvas memory

          if (ctx && src === ctx.canvas) {
            ctx.canvas.width = 0;
            ctx.canvas.height = 0;
          }
        }

        if (shouldAutomaticallySetTextureFilteringForSize(options)) {
          gl.generateMipmap(target);
        }
      }

      if (numToLoad === 0) {
        callback(errors.length ? errors : undefined, tex, imgs);
      }
    };
  }

  imgs = urls.map(function (url, ndx) {
    return loadAndUseImage(url, options.crossOrigin, uploadImg(ndx));
  });
}
/**
 * Sets a texture from an array or typed array. If the width or height is not provided will attempt to
 * guess the size. See {@link module:twgl.TextureOptions}.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {(number[]|ArrayBufferView)} src An array or typed arry with texture data.
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */


function setTextureFromArray(gl, tex, src, options) {
  options = options || defaults.textureOptions;
  var target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  var width = options.width;
  var height = options.height;
  var depth = options.depth;
  var level = options.level || 0;
  var internalFormat = options.internalFormat || options.format || RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);

  if (!isArrayBuffer(src)) {
    var Type = typedArrays.getTypedArrayTypeForGLType(type);
    src = new Type(src);
  } else if (src instanceof Uint8ClampedArray) {
    src = new Uint8Array(src.buffer);
  }

  var bytesPerElement = getBytesPerElementForInternalFormat(internalFormat, type);
  var numElements = src.byteLength / bytesPerElement; // TODO: check UNPACK_ALIGNMENT?

  if (numElements % 1) {
    throw "length wrong size for format: " + utils.glEnumToString(gl, format);
  }

  var dimensions;

  if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    if (!width && !height && !depth) {
      var size = Math.cbrt(numElements);

      if (size % 1 !== 0) {
        throw "can't guess cube size of array of numElements: " + numElements;
      }

      width = size;
      height = size;
      depth = size;
    } else if (width && (!height || !depth)) {
      dimensions = guessDimensions(gl, target, height, depth, numElements / width);
      height = dimensions.width;
      depth = dimensions.height;
    } else if (height && (!width || !depth)) {
      dimensions = guessDimensions(gl, target, width, depth, numElements / height);
      width = dimensions.width;
      depth = dimensions.height;
    } else {
      dimensions = guessDimensions(gl, target, width, height, numElements / depth);
      width = dimensions.width;
      height = dimensions.height;
    }
  } else {
    dimensions = guessDimensions(gl, target, width, height, numElements);
    width = dimensions.width;
    height = dimensions.height;
  }

  setSkipStateToDefault(gl);
  gl.pixelStorei(UNPACK_ALIGNMENT, options.unpackAlignment || 1);
  setPackState(gl, options);

  if (target === TEXTURE_CUBE_MAP) {
    var elementsPerElement = bytesPerElement / src.BYTES_PER_ELEMENT;
    var faceSize = numElements / 6 * elementsPerElement;
    getCubeFacesWithNdx(gl, options).forEach(function (f) {
      var offset = faceSize * f.ndx;
      var data = src.subarray(offset, offset + faceSize);
      gl.texImage2D(f.face, level, internalFormat, width, height, 0, format, type, data);
    });
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, src);
  } else {
    gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, src);
  }

  return {
    width: width,
    height: height,
    depth: depth,
    type: type
  };
}
/**
 * Sets a texture with no contents of a certain size. In other words calls `gl.texImage2D` with `null`.
 * You must set `options.width` and `options.height`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @memberOf module:twgl/textures
 */


function setEmptyTexture(gl, tex, options) {
  var target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  var level = options.level || 0;
  var internalFormat = options.internalFormat || options.format || RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || formatType.type;
  setPackState(gl, options);

  if (target === TEXTURE_CUBE_MAP) {
    for (var ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, level, internalFormat, options.width, options.height, 0, format, type, null);
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, level, internalFormat, options.width, options.height, options.depth, 0, format, type, null);
  } else {
    gl.texImage2D(target, level, internalFormat, options.width, options.height, 0, format, type, null);
  }
}
/**
 * Creates a texture based on the options passed in.
 *
 * Note: may reset UNPACK_ALIGNMENT, UNPACK_ROW_LENGTH, UNPACK_IMAGE_HEIGHT, UNPACK_SKIP_IMAGES
 * UNPACK_SKIP_PIXELS, and UNPACK_SKIP_ROWS
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.TextureReadyCallback} [callback] A callback called when an image has been downloaded and uploaded to the texture.
 * @return {WebGLTexture} the created texture.
 * @memberOf module:twgl/textures
 */


function createTexture(gl, options, callback) {
  callback = callback || noop;
  options = options || defaults.textureOptions;
  var tex = gl.createTexture();
  var target = options.target || TEXTURE_2D;
  var width = options.width || 1;
  var height = options.height || 1;
  var internalFormat = options.internalFormat || RGBA;
  gl.bindTexture(target, tex);

  if (target === TEXTURE_CUBE_MAP) {
    // this should have been the default for cubemaps :(
    gl.texParameteri(target, TEXTURE_WRAP_S, CLAMP_TO_EDGE);
    gl.texParameteri(target, TEXTURE_WRAP_T, CLAMP_TO_EDGE);
  }

  var src = options.src;

  if (src) {
    if (typeof src === "function") {
      src = src(gl, options);
    }

    if (typeof src === "string") {
      loadTextureFromUrl(gl, tex, options, callback);
    } else if (isArrayBuffer(src) || Array.isArray(src) && (typeof src[0] === 'number' || Array.isArray(src[0]) || isArrayBuffer(src[0]))) {
      var dimensions = setTextureFromArray(gl, tex, src, options);
      width = dimensions.width;
      height = dimensions.height;
    } else if (Array.isArray(src) && (typeof src[0] === 'string' || isTexImageSource(src[0]))) {
      if (target === TEXTURE_CUBE_MAP) {
        loadCubemapFromUrls(gl, tex, options, callback);
      } else {
        loadSlicesFromUrls(gl, tex, options, callback);
      }
    } else {
      // if (isTexImageSource(src))
      setTextureFromElement(gl, tex, src, options);
      width = src.width;
      height = src.height;
    }
  } else {
    setEmptyTexture(gl, tex, options);
  }

  if (shouldAutomaticallySetTextureFilteringForSize(options)) {
    setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
  }

  setTextureParameters(gl, tex, options);
  return tex;
}
/**
 * Resizes a texture based on the options passed in.
 *
 * Note: This is not a generic resize anything function.
 * It's mostly used by {@link module:twgl.resizeFramebufferInfo}
 * It will use `options.src` if it exists to try to determine a `type`
 * otherwise it will assume `gl.UNSIGNED_BYTE`. No data is provided
 * for the texture. Texture parameters will be set accordingly
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the texture to resize
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {number} [width] the new width. If not passed in will use `options.width`
 * @param {number} [height] the new height. If not passed in will use `options.height`
 * @param {number} [depth] the new depth. If not passed in will use `options.depth`
 * @memberOf module:twgl/textures
 */


function resizeTexture(gl, tex, options, width, height, depth) {
  width = width || options.width;
  height = height || options.height;
  depth = depth || options.depth;
  var target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  var level = options.level || 0;
  var internalFormat = options.internalFormat || options.format || RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type;
  var src = options.src;

  if (!src) {
    type = options.type || formatType.type;
  } else if (isArrayBuffer(src) || Array.isArray(src) && typeof src[0] === 'number') {
    type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);
  } else {
    type = options.type || formatType.type;
  }

  if (target === TEXTURE_CUBE_MAP) {
    for (var ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, level, internalFormat, width, height, 0, format, type, null);
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, null);
  } else {
    gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);
  }
}
/**
 * Check if a src is an async request.
 * if src is a string we're going to download an image
 * if src is an array of strings we're going to download cubemap images
 * @param {*} src The src from a TextureOptions
 * @returns {bool} true if src is async.
 * @private
 */


function isAsyncSrc(src) {
  return typeof src === 'string' || Array.isArray(src) && typeof src[0] === 'string';
}
/**
 * Creates a bunch of textures based on the passed in options.
 *
 * Example:
 *
 *     const textures = twgl.createTextures(gl, {
 *       // a power of 2 image
 *       hftIcon: { src: "images/hft-icon-16.png", mag: gl.NEAREST },
 *       // a non-power of 2 image
 *       clover: { src: "images/clover.jpg" },
 *       // From a canvas
 *       fromCanvas: { src: ctx.canvas },
 *       // A cubemap from 6 images
 *       yokohama: {
 *         target: gl.TEXTURE_CUBE_MAP,
 *         src: [
 *           'images/yokohama/posx.jpg',
 *           'images/yokohama/negx.jpg',
 *           'images/yokohama/posy.jpg',
 *           'images/yokohama/negy.jpg',
 *           'images/yokohama/posz.jpg',
 *           'images/yokohama/negz.jpg',
 *         ],
 *       },
 *       // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)
 *       goldengate: {
 *         target: gl.TEXTURE_CUBE_MAP,
 *         src: 'images/goldengate.jpg',
 *       },
 *       // A 2x2 pixel texture from a JavaScript array
 *       checker: {
 *         mag: gl.NEAREST,
 *         min: gl.LINEAR,
 *         src: [
 *           255,255,255,255,
 *           192,192,192,255,
 *           192,192,192,255,
 *           255,255,255,255,
 *         ],
 *       },
 *       // a 1x2 pixel texture from a typed array.
 *       stripe: {
 *         mag: gl.NEAREST,
 *         min: gl.LINEAR,
 *         format: gl.LUMINANCE,
 *         src: new Uint8Array([
 *           255,
 *           128,
 *           255,
 *           128,
 *           255,
 *           128,
 *           255,
 *           128,
 *         ]),
 *         width: 1,
 *       },
 *     });
 *
 * Now
 *
 * *   `textures.hftIcon` will be a 2d texture
 * *   `textures.clover` will be a 2d texture
 * *   `textures.fromCanvas` will be a 2d texture
 * *   `textures.yohohama` will be a cubemap texture
 * *   `textures.goldengate` will be a cubemap texture
 * *   `textures.checker` will be a 2d texture
 * *   `textures.stripe` will be a 2d texture
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per texture.
 * @param {module:twgl.TexturesReadyCallback} [callback] A callback called when all textures have been downloaded.
 * @return {Object.<string,WebGLTexture>} the created textures by name
 * @memberOf module:twgl/textures
 */


function createTextures(gl, textureOptions, callback) {
  callback = callback || noop;
  var numDownloading = 0;
  var errors = [];
  var textures = {};
  var images = {};

  function callCallbackIfReady() {
    if (numDownloading === 0) {
      setTimeout(function () {
        callback(errors.length ? errors : undefined, textures, images);
      }, 0);
    }
  }

  Object.keys(textureOptions).forEach(function (name) {
    var options = textureOptions[name];
    var onLoadFn;

    if (isAsyncSrc(options.src)) {
      onLoadFn = function onLoadFn(err, tex, img) {
        images[name] = img;
        --numDownloading;

        if (err) {
          errors.push(err);
        }

        callCallbackIfReady();
      };

      ++numDownloading;
    }

    textures[name] = createTexture(gl, options, onLoadFn);
  }); // queue the callback if there are no images to download.
  // We do this because if your code is structured to wait for
  // images to download but then you comment out all the async
  // images your code would break.

  callCallbackIfReady();
  return textures;
}

/***/ }),

/***/ "./src/twgl-full.js":
/*!**************************!*\
  !*** ./src/twgl-full.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
var _exportNames = {
  m4: true,
  v3: true,
  primitives: true
};
exports.primitives = exports.v3 = exports.m4 = void 0;

var m4 = _interopRequireWildcard(__webpack_require__(/*! ./m4.js */ "./src/m4.js"));

exports.m4 = m4;

var v3 = _interopRequireWildcard(__webpack_require__(/*! ./v3.js */ "./src/v3.js"));

exports.v3 = v3;

var primitives = _interopRequireWildcard(__webpack_require__(/*! ./primitives.js */ "./src/primitives.js"));

exports.primitives = primitives;

var _twgl = __webpack_require__(/*! ./twgl.js */ "./src/twgl.js");

Object.keys(_twgl).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _twgl[key];
});

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/***/ }),

/***/ "./src/twgl.js":
/*!*********************!*\
  !*** ./src/twgl.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
var _exportNames = {
  addExtensionsToContext: true,
  getContext: true,
  getWebGLContext: true,
  resizeCanvasToDisplaySize: true,
  setDefaults: true,
  attributes: true,
  textures: true,
  utils: true,
  draw: true,
  framebuffers: true,
  programs: true,
  typedarrays: true,
  vertexArrays: true
};
exports.addExtensionsToContext = addExtensionsToContext;
exports.getContext = getContext;
exports.getWebGLContext = getWebGLContext;
exports.resizeCanvasToDisplaySize = resizeCanvasToDisplaySize;
exports.setDefaults = setDefaults;
exports.vertexArrays = exports.typedarrays = exports.programs = exports.framebuffers = exports.draw = exports.utils = exports.textures = exports.attributes = void 0;

var attributes = _interopRequireWildcard(__webpack_require__(/*! ./attributes.js */ "./src/attributes.js"));

exports.attributes = attributes;
Object.keys(attributes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = attributes[key];
});

var textures = _interopRequireWildcard(__webpack_require__(/*! ./textures.js */ "./src/textures.js"));

exports.textures = textures;
Object.keys(textures).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = textures[key];
});

var helper = _interopRequireWildcard(__webpack_require__(/*! ./helper.js */ "./src/helper.js"));

var utils = _interopRequireWildcard(__webpack_require__(/*! ./utils.js */ "./src/utils.js"));

exports.utils = utils;
Object.keys(utils).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = utils[key];
});

var draw = _interopRequireWildcard(__webpack_require__(/*! ./draw.js */ "./src/draw.js"));

exports.draw = draw;
Object.keys(draw).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = draw[key];
});

var framebuffers = _interopRequireWildcard(__webpack_require__(/*! ./framebuffers.js */ "./src/framebuffers.js"));

exports.framebuffers = framebuffers;
Object.keys(framebuffers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = framebuffers[key];
});

var programs = _interopRequireWildcard(__webpack_require__(/*! ./programs.js */ "./src/programs.js"));

exports.programs = programs;
Object.keys(programs).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = programs[key];
});

var typedarrays = _interopRequireWildcard(__webpack_require__(/*! ./typedarrays.js */ "./src/typedarrays.js"));

exports.typedarrays = typedarrays;
Object.keys(typedarrays).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = typedarrays[key];
});

var vertexArrays = _interopRequireWildcard(__webpack_require__(/*! ./vertex-arrays.js */ "./src/vertex-arrays.js"));

exports.vertexArrays = vertexArrays;
Object.keys(vertexArrays).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = vertexArrays[key];
});

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * The main TWGL module.
 *
 * For most use cases you shouldn't need anything outside this module.
 * Exceptions between the stuff added to twgl-full (v3, m4, primitives)
 *
 * @module twgl
 * @borrows module:twgl/attributes.setAttribInfoBufferFromArray as setAttribInfoBufferFromArray
 * @borrows module:twgl/attributes.createBufferInfoFromArrays as createBufferInfoFromArrays
 * @borrows module:twgl/attributes.createVertexArrayInfo as createVertexArrayInfo
 * @borrows module:twgl/draw.drawBufferInfo as drawBufferInfo
 * @borrows module:twgl/draw.drawObjectList as drawObjectList
 * @borrows module:twgl/framebuffers.createFramebufferInfo as createFramebufferInfo
 * @borrows module:twgl/framebuffers.resizeFramebufferInfo as resizeFramebufferInfo
 * @borrows module:twgl/framebuffers.bindFramebufferInfo as bindFramebufferInfo
 * @borrows module:twgl/programs.createProgramInfo as createProgramInfo
 * @borrows module:twgl/programs.createUniformBlockInfo as createUniformBlockInfo
 * @borrows module:twgl/programs.bindUniformBlock as bindUniformBlock
 * @borrows module:twgl/programs.setUniformBlock as setUniformBlock
 * @borrows module:twgl/programs.setBlockUniforms as setBlockUniforms
 * @borrows module:twgl/programs.setUniforms as setUniforms
 * @borrows module:twgl/programs.setBuffersAndAttributes as setBuffersAndAttributes
 * @borrows module:twgl/textures.setTextureFromArray as setTextureFromArray
 * @borrows module:twgl/textures.createTexture as createTexture
 * @borrows module:twgl/textures.resizeTexture as resizeTexture
 * @borrows module:twgl/textures.createTextures as createTextures
 */
// make sure we don't see a global gl
var gl = undefined;
/* eslint-disable-line */

var defaults = {
  addExtensionsToContext: true
};
/**
 * Various default settings for twgl.
 *
 * Note: You can call this any number of times. Example:
 *
 *     twgl.setDefaults({ textureColor: [1, 0, 0, 1] });
 *     twgl.setDefaults({ attribPrefix: 'a_' });
 *
 * is equivalent to
 *
 *     twgl.setDefaults({
 *       textureColor: [1, 0, 0, 1],
 *       attribPrefix: 'a_',
 *     });
 *
 * @typedef {Object} Defaults
 * @property {string} [attribPrefix] The prefix to stick on attributes
 *
 *   When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`
 *   as it makes it clear where they came from. But, when building geometry I prefer using un-prefixed names.
 *
 *   In other words I'll create arrays of geometry like this
 *
 *       const arrays = {
 *         position: ...
 *         normal: ...
 *         texcoord: ...
 *       };
 *
 *   But need those mapped to attributes and my attributes start with `a_`.
 *
 *   Default: `""`
 *
 * @property {number[]} [textureColor] Array of 4 values in the range 0 to 1
 *
 *   The default texture color is used when loading textures from
 *   urls. Because the URL will be loaded async we'd like to be
 *   able to use the texture immediately. By putting a 1x1 pixel
 *   color in the texture we can start using the texture before
 *   the URL has loaded.
 *
 *   Default: `[0.5, 0.75, 1, 1]`
 *
 * @property {string} [crossOrigin]
 *
 *   If not undefined sets the crossOrigin attribute on images
 *   that twgl creates when downloading images for textures.
 *
 *   Also see {@link module:twgl.TextureOptions}.
 *
 * @property {bool} [addExtensionsToContext]
 *
 *   If true, then, when twgl will try to add any supported WebGL extensions
 *   directly to the context under their normal GL names. For example
 *   if ANGLE_instances_arrays exists then twgl would enable it,
 *   add the functions `vertexAttribDivisor`, `drawArraysInstanced`,
 *   `drawElementsInstanced`, and the constant `VERTEX_ATTRIB_ARRAY_DIVISOR`
 *   to the `WebGLRenderingContext`.
 *
 * @memberOf module:twgl
 */

/**
 * Sets various defaults for twgl.
 *
 * In the interest of terseness which is kind of the point
 * of twgl I've integrated a few of the older functions here
 *
 * @param {module:twgl.Defaults} newDefaults The default settings.
 * @memberOf module:twgl
 */

function setDefaults(newDefaults) {
  helper.copyExistingProperties(newDefaults, defaults);
  attributes.setAttributeDefaults_(newDefaults); // eslint-disable-line

  textures.setTextureDefaults_(newDefaults); // eslint-disable-line
}

var prefixRE = /^(.*?)_/;

function addExtensionToContext(gl, extensionName) {
  utils.glEnumToString(gl, 0);
  var ext = gl.getExtension(extensionName);

  if (ext) {
    var enums = {};
    var fnSuffix = prefixRE.exec(extensionName)[1];
    var enumSuffix = '_' + fnSuffix;

    for (var key in ext) {
      var value = ext[key];
      var isFunc = typeof value === 'function';
      var suffix = isFunc ? fnSuffix : enumSuffix;
      var name = key; // examples of where this is not true are WEBGL_compressed_texture_s3tc
      // and WEBGL_compressed_texture_pvrtc

      if (key.endsWith(suffix)) {
        name = key.substring(0, key.length - suffix.length);
      }

      if (gl[name] !== undefined) {
        if (!isFunc && gl[name] !== value) {
          helper.warn(name, gl[name], value, key);
        }
      } else {
        if (isFunc) {
          gl[name] = function (origFn) {
            return function () {
              return origFn.apply(ext, arguments);
            };
          }(value);
        } else {
          gl[name] = value;
          enums[name] = value;
        }
      }
    } // pass the modified enums to glEnumToString


    enums.constructor = {
      name: ext.constructor.name
    };
    utils.glEnumToString(enums, 0);
  }

  return ext;
}
/*
 * If you're wondering why the code doesn't just iterate
 * over all extensions using `gl.getExtensions` is that it's possible
 * some future extension is incompatible with this code. Rather than
 * have thing suddenly break it seems better to manually add to this
 * list.
 *
 */


var supportedExtensions = ['ANGLE_instanced_arrays', 'EXT_blend_minmax', 'EXT_color_buffer_float', 'EXT_color_buffer_half_float', 'EXT_disjoint_timer_query', 'EXT_disjoint_timer_query_webgl2', 'EXT_frag_depth', 'EXT_sRGB', 'EXT_shader_texture_lod', 'EXT_texture_filter_anisotropic', 'OES_element_index_uint', 'OES_standard_derivatives', 'OES_texture_float', 'OES_texture_float_linear', 'OES_texture_half_float', 'OES_texture_half_float_linear', 'OES_vertex_array_object', 'WEBGL_color_buffer_float', 'WEBGL_compressed_texture_atc', 'WEBGL_compressed_texture_etc1', 'WEBGL_compressed_texture_pvrtc', 'WEBGL_compressed_texture_s3tc', 'WEBGL_compressed_texture_s3tc_srgb', 'WEBGL_depth_texture', 'WEBGL_draw_buffers'];
/**
 * Attempts to enable all of the following extensions
 * and add their functions and constants to the
 * `WebGLRenderingContext` using their normal non-extension like names.
 *
 *      ANGLE_instanced_arrays
 *      EXT_blend_minmax
 *      EXT_color_buffer_float
 *      EXT_color_buffer_half_float
 *      EXT_disjoint_timer_query
 *      EXT_disjoint_timer_query_webgl2
 *      EXT_frag_depth
 *      EXT_sRGB
 *      EXT_shader_texture_lod
 *      EXT_texture_filter_anisotropic
 *      OES_element_index_uint
 *      OES_standard_derivatives
 *      OES_texture_float
 *      OES_texture_float_linear
 *      OES_texture_half_float
 *      OES_texture_half_float_linear
 *      OES_vertex_array_object
 *      WEBGL_color_buffer_float
 *      WEBGL_compressed_texture_atc
 *      WEBGL_compressed_texture_etc1
 *      WEBGL_compressed_texture_pvrtc
 *      WEBGL_compressed_texture_s3tc
 *      WEBGL_compressed_texture_s3tc_srgb
 *      WEBGL_depth_texture
 *      WEBGL_draw_buffers
 *
 * For example if `ANGLE_instanced_arrays` exists then the functions
 * `drawArraysInstanced`, `drawElementsInstanced`, `vertexAttribDivisor`
 * and the constant `VERTEX_ATTRIB_ARRAY_DIVISOR` are added to the
 * `WebGLRenderingContext`.
 *
 * Note that if you want to know if the extension exists you should
 * probably call `gl.getExtension` for each extension. Alternatively
 * you can check for the existence of the functions or constants that
 * are expected to be added. For example
 *
 *    if (gl.drawBuffers) {
 *      // Either WEBGL_draw_buffers was enabled OR you're running in WebGL2
 *      ....
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @memberOf module:twgl
 */

function addExtensionsToContext(gl) {
  for (var ii = 0; ii < supportedExtensions.length; ++ii) {
    addExtensionToContext(gl, supportedExtensions[ii]);
  }
}
/**
 * Creates a webgl context.
 * @param {HTMLCanvasElement} canvas The canvas tag to get
 *     context from. If one is not passed in one will be
 *     created.
 * @return {WebGLRenderingContext} The created context.
 * @private
 */


function create3DContext(canvas, opt_attribs) {
  var names = ["webgl", "experimental-webgl"];
  var context = null;

  for (var ii = 0; ii < names.length; ++ii) {
    context = canvas.getContext(names[ii], opt_attribs);

    if (context) {
      if (defaults.addExtensionsToContext) {
        addExtensionsToContext(context);
      }

      break;
    }
  }

  return context;
}
/**
 * Gets a WebGL1 context.
 *
 * Note: Will attempt to enable Vertex Array Objects
 * and add WebGL2 entry points. (unless you first set defaults with
 * `twgl.setDefaults({enableVertexArrayObjects: false})`;
 *
 * @param {HTMLCanvasElement} canvas a canvas element.
 * @param {WebGLContextAttributes} [opt_attribs] optional webgl context creation attributes
 * @return {WebGLRenderingContext} The created context.
 * @memberOf module:twgl
 */


function getWebGLContext(canvas, opt_attribs) {
  var gl = create3DContext(canvas, opt_attribs);
  return gl;
}
/**
 * Creates a webgl context.
 *
 * Will return a WebGL2 context if possible.
 *
 * You can check if it's WebGL2 with
 *
 *     twgl.isWebGL2(gl);
 *
 * @param {HTMLCanvasElement} canvas The canvas tag to get
 *     context from. If one is not passed in one will be
 *     created.
 * @return {WebGLRenderingContext} The created context.
 */


function createContext(canvas, opt_attribs) {
  var names = ["webgl2", "webgl", "experimental-webgl"];
  var context = null;

  for (var ii = 0; ii < names.length; ++ii) {
    context = canvas.getContext(names[ii], opt_attribs);

    if (context) {
      if (defaults.addExtensionsToContext) {
        addExtensionsToContext(context);
      }

      break;
    }
  }

  return context;
}
/**
 * Gets a WebGL context.  Will create a WebGL2 context if possible.
 *
 * You can check if it's WebGL2 with
 *
 *    function isWebGL2(gl) {
 *      return gl.getParameter(gl.VERSION).indexOf("WebGL 2.0 ") == 0;
 *    }
 *
 * Note: For a WebGL1 context will attempt to enable Vertex Array Objects
 * and add WebGL2 entry points. (unless you first set defaults with
 * `twgl.setDefaults({enableVertexArrayObjects: false})`;
 *
 * @param {HTMLCanvasElement} canvas a canvas element.
 * @param {WebGLContextAttributes} [opt_attribs] optional webgl context creation attributes
 * @return {WebGLRenderingContext} The created context.
 * @memberOf module:twgl
 */


function getContext(canvas, opt_attribs) {
  var gl = createContext(canvas, opt_attribs);
  return gl;
}
/**
 * Resize a canvas to match the size it's displayed.
 * @param {HTMLCanvasElement} canvas The canvas to resize.
 * @param {number} [multiplier] So you can pass in `window.devicePixelRatio` or other scale value if you want to.
 * @return {boolean} true if the canvas was resized.
 * @memberOf module:twgl
 */


function resizeCanvasToDisplaySize(canvas, multiplier) {
  multiplier = multiplier || 1;
  multiplier = Math.max(0, multiplier);
  var width = canvas.clientWidth * multiplier | 0;
  var height = canvas.clientHeight * multiplier | 0;

  if (canvas.width !== width || canvas.height !== height) {
    canvas.width = width;
    canvas.height = height;
    return true;
  }

  return false;
}

/***/ }),

/***/ "./src/typedarrays.js":
/*!****************************!*\
  !*** ./src/typedarrays.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getGLTypeForTypedArray = getGLTypeForTypedArray;
exports.getGLTypeForTypedArrayType = getGLTypeForTypedArrayType;
exports.getTypedArrayTypeForGLType = getTypedArrayTypeForGLType;
exports.isArrayBuffer = void 0;

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Low level shader typed array related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.typedArray` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/typedArray
 */
// make sure we don't see a global gl
var gl = undefined;
/* eslint-disable-line */

/* DataType */

var BYTE = 0x1400;
var UNSIGNED_BYTE = 0x1401;
var SHORT = 0x1402;
var UNSIGNED_SHORT = 0x1403;
var INT = 0x1404;
var UNSIGNED_INT = 0x1405;
var FLOAT = 0x1406;
var UNSIGNED_SHORT_4_4_4_4 = 0x8033;
var UNSIGNED_SHORT_5_5_5_1 = 0x8034;
var UNSIGNED_SHORT_5_6_5 = 0x8363;
var HALF_FLOAT = 0x140B;
var UNSIGNED_INT_2_10_10_10_REV = 0x8368;
var UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;
var UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;
var FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;
var UNSIGNED_INT_24_8 = 0x84FA;
var glTypeToTypedArray = {};
{
  var tt = glTypeToTypedArray;
  tt[BYTE] = Int8Array;
  tt[UNSIGNED_BYTE] = Uint8Array;
  tt[SHORT] = Int16Array;
  tt[UNSIGNED_SHORT] = Uint16Array;
  tt[INT] = Int32Array;
  tt[UNSIGNED_INT] = Uint32Array;
  tt[FLOAT] = Float32Array;
  tt[UNSIGNED_SHORT_4_4_4_4] = Uint16Array;
  tt[UNSIGNED_SHORT_5_5_5_1] = Uint16Array;
  tt[UNSIGNED_SHORT_5_6_5] = Uint16Array;
  tt[HALF_FLOAT] = Uint16Array;
  tt[UNSIGNED_INT_2_10_10_10_REV] = Uint32Array;
  tt[UNSIGNED_INT_10F_11F_11F_REV] = Uint32Array;
  tt[UNSIGNED_INT_5_9_9_9_REV] = Uint32Array;
  tt[FLOAT_32_UNSIGNED_INT_24_8_REV] = Uint32Array;
  tt[UNSIGNED_INT_24_8] = Uint32Array;
}
/**
 * Get the GL type for a typedArray
 * @param {ArrayBufferView} typedArray a typedArray
 * @return {number} the GL type for array. For example pass in an `Int8Array` and `gl.BYTE` will
 *   be returned. Pass in a `Uint32Array` and `gl.UNSIGNED_INT` will be returned
 * @memberOf module:twgl/typedArray
 */

function getGLTypeForTypedArray(typedArray) {
  if (typedArray instanceof Int8Array) {
    return BYTE;
  } // eslint-disable-line


  if (typedArray instanceof Uint8Array) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line


  if (typedArray instanceof Uint8ClampedArray) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line


  if (typedArray instanceof Int16Array) {
    return SHORT;
  } // eslint-disable-line


  if (typedArray instanceof Uint16Array) {
    return UNSIGNED_SHORT;
  } // eslint-disable-line


  if (typedArray instanceof Int32Array) {
    return INT;
  } // eslint-disable-line


  if (typedArray instanceof Uint32Array) {
    return UNSIGNED_INT;
  } // eslint-disable-line


  if (typedArray instanceof Float32Array) {
    return FLOAT;
  } // eslint-disable-line


  throw new Error('unsupported typed array type');
}
/**
 * Get the GL type for a typedArray type
 * @param {ArrayBufferView} typedArrayType a typedArray constructor
 * @return {number} the GL type for type. For example pass in `Int8Array` and `gl.BYTE` will
 *   be returned. Pass in `Uint32Array` and `gl.UNSIGNED_INT` will be returned
 * @memberOf module:twgl/typedArray
 */


function getGLTypeForTypedArrayType(typedArrayType) {
  if (typedArrayType === Int8Array) {
    return BYTE;
  } // eslint-disable-line


  if (typedArrayType === Uint8Array) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line


  if (typedArrayType === Uint8ClampedArray) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line


  if (typedArrayType === Int16Array) {
    return SHORT;
  } // eslint-disable-line


  if (typedArrayType === Uint16Array) {
    return UNSIGNED_SHORT;
  } // eslint-disable-line


  if (typedArrayType === Int32Array) {
    return INT;
  } // eslint-disable-line


  if (typedArrayType === Uint32Array) {
    return UNSIGNED_INT;
  } // eslint-disable-line


  if (typedArrayType === Float32Array) {
    return FLOAT;
  } // eslint-disable-line


  throw new Error('unsupported typed array type');
}
/**
 * Get the typed array constructor for a given GL type
 * @param {number} type the GL type. (eg: `gl.UNSIGNED_INT`)
 * @return {function} the constructor for a the corresponding typed array. (eg. `Uint32Array`).
 * @memberOf module:twgl/typedArray
 */


function getTypedArrayTypeForGLType(type) {
  var CTOR = glTypeToTypedArray[type];

  if (!CTOR) {
    throw new Error('unknown gl type');
  }

  return CTOR;
}

var isArrayBuffer = typeof SharedArrayBuffer !== 'undefined' ? function isArrayBufferOrSharedArrayBuffer(a) {
  return a && a.buffer && (a.buffer instanceof ArrayBuffer || a.buffer instanceof SharedArrayBuffer);
} : function isArrayBuffer(a) {
  return a && a.buffer && a.buffer instanceof ArrayBuffer;
};
exports.isArrayBuffer = isArrayBuffer;

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.isWebGL1 = isWebGL1;
exports.isWebGL2 = isWebGL2;
exports.glEnumToString = void 0;

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Gets the gl version as a number
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {number} version of gl
 * @private
 */
//function getVersionAsNumber(gl) {
//  return parseFloat(gl.getParameter(gl.VERSION).substr(6));
//}

/**
 * Check if context is WebGL 2.0
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {bool} true if it's WebGL 2.0
 * @memberOf module:twgl
 */
function isWebGL2(gl) {
  // This is the correct check but it's slow
  //  return gl.getParameter(gl.VERSION).indexOf("WebGL 2.0") === 0;
  // This might also be the correct check but I'm assuming it's slow-ish
  // return gl instanceof WebGL2RenderingContext;
  return !!gl.texStorage2D;
}
/**
 * Check if context is WebGL 1.0
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {bool} true if it's WebGL 1.0
 * @memberOf module:twgl
 */


function isWebGL1(gl) {
  // This is the correct check but it's slow
  // const version = getVersionAsNumber(gl);
  // return version <= 1.0 && version > 0.0;  // because as of 2016/5 Edge returns 0.96
  // This might also be the correct check but I'm assuming it's slow-ish
  // return gl instanceof WebGLRenderingContext;
  return !gl.texStorage2D;
}
/**
 * Gets a string for WebGL enum
 *
 * Note: Several enums are the same. Without more
 * context (which function) it's impossible to always
 * give the correct enum. As it is, for matching values
 * it gives all enums. Checking the WebGL2RenderingContext
 * that means
 *
 *      0     = ZERO | POINT | NONE | NO_ERROR
 *      1     = ONE | LINES | SYNC_FLUSH_COMMANDS_BIT
 *      32777 = BLEND_EQUATION_RGB | BLEND_EQUATION_RGB
 *      36662 = COPY_READ_BUFFER | COPY_READ_BUFFER_BINDING
 *      36663 = COPY_WRITE_BUFFER | COPY_WRITE_BUFFER_BINDING
 *      36006 = FRAMEBUFFER_BINDING | DRAW_FRAMEBUFFER_BINDING
 *
 * It's also not useful for bits really unless you pass in individual bits.
 * In other words
 *
 *     const bits = gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT;
 *     twgl.glEnumToString(gl, bits);  // not going to work
 *
 * Note that some enums only exist on extensions. If you
 * want them to show up you need to pass the extension at least
 * once. For example
 *
 *     const ext = gl.getExtension('WEBGL_compressed_texture_s3tc');
 *     if (ext) {
 *        twgl.glEnumToString(ext, 0);  // just prime the function
 *
 *        ..later..
 *
 *        const internalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
 *        console.log(twgl.glEnumToString(gl, internalFormat));
 *
 * Notice I didn't have to pass the extension the second time. This means
 * you can have place that generically gets an enum for texture formats for example.
 * and as long as you primed the function with the extensions
 *
 * If you're using `twgl.addExtensionsToContext` to enable your extensions
 * then twgl will automatically get the extension's enums.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext or any extension object
 * @param {number} value the value of the enum you want to look up.
 * @return {string} enum string or hex value
 * @memberOf module:twgl
 * @function glEnumToString
 */


var glEnumToString = function () {
  var haveEnumsForType = {};
  var enums = {};

  function addEnums(gl) {
    var type = gl.constructor.name;

    if (!haveEnumsForType[type]) {
      for (var key in gl) {
        if (typeof gl[key] === 'number') {
          var existing = enums[gl[key]];
          enums[gl[key]] = existing ? "".concat(existing, " | ").concat(key) : key;
        }
      }

      haveEnumsForType[type] = true;
    }
  }

  return function glEnumToString(gl, value) {
    addEnums(gl);
    return enums[value] || (typeof value === 'number' ? "0x".concat(value.toString(16)) : value);
  };
}();

exports.glEnumToString = glEnumToString;

/***/ }),

/***/ "./src/v3.js":
/*!*******************!*\
  !*** ./src/v3.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.add = add;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.distance = distance;
exports.distanceSq = distanceSq;
exports.divide = divide;
exports.divScalar = divScalar;
exports.dot = dot;
exports.lerp = lerp;
exports.lerpV = lerpV;
exports.length = length;
exports.lengthSq = lengthSq;
exports.max = max;
exports.min = min;
exports.mulScalar = mulScalar;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.setDefaultType = setDefaultType;
exports.subtract = subtract;

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 *
 * Vec3 math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new Vec3. In other words you can do this
 *
 *     var v = v3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.
 *
 * or
 *
 *     var v = v3.create();
 *     v3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any vector as the destination. So for example
 *
 *     v3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 * @module twgl/v3
 */
var VecType = Float32Array;
/**
 * A JavaScript array with 3 values or a Float32Array with 3 values.
 * When created by the library will create the default type which is `Float32Array`
 * but can be set by calling {@link module:twgl/v3.setDefaultType}.
 * @typedef {(number[]|Float32Array)} Vec3
 * @memberOf module:twgl/v3
 */

/**
 * Sets the type this library creates for a Vec3
 * @param {constructor} ctor the constructor for the type. Either `Float32Array` or `Array`
 * @return {constructor} previous constructor for Vec3
 * @memberOf module:twgl/v3
 */

function setDefaultType(ctor) {
  var oldType = VecType;
  VecType = ctor;
  return oldType;
}
/**
 * Creates a vec3; may be called with x, y, z to set initial values.
 * @param {number} [x] Initial x value.
 * @param {number} [y] Initial y value.
 * @param {number} [z] Initial z value.
 * @return {module:twgl/v3.Vec3} the created vector
 * @memberOf module:twgl/v3
 */


function create(x, y, z) {
  var dst = new VecType(3);

  if (x) {
    dst[0] = x;
  }

  if (y) {
    dst[1] = y;
  }

  if (z) {
    dst[2] = z;
  }

  return dst;
}
/**
 * Adds two vectors; assumes a and b have the same dimension.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A vector tha tis the sum of a and b.
 * @memberOf module:twgl/v3
 */


function add(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] + b[0];
  dst[1] = a[1] + b[1];
  dst[2] = a[2] + b[2];
  return dst;
}
/**
 * Subtracts two vectors.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A vector that is the difference of a and b.
 * @memberOf module:twgl/v3
 */


function subtract(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] - b[0];
  dst[1] = a[1] - b[1];
  dst[2] = a[2] - b[2];
  return dst;
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient t, returns
 * a + t * (b - a).
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {number} t Interpolation coefficient.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The linear interpolated result.
 * @memberOf module:twgl/v3
 */


function lerp(a, b, t, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] + t * (b[0] - a[0]);
  dst[1] = a[1] + t * (b[1] - a[1]);
  dst[2] = a[2] + t * (b[2] - a[2]);
  return dst;
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient vector t, returns
 * a + t * (b - a).
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} t Interpolation coefficients vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} the linear interpolated result.
 * @memberOf module:twgl/v3
 */


function lerpV(a, b, t, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] + t[0] * (b[0] - a[0]);
  dst[1] = a[1] + t[1] * (b[1] - a[1]);
  dst[2] = a[2] + t[2] * (b[2] - a[2]);
  return dst;
}
/**
 * Return max values of two vectors.
 * Given vectors a and b returns
 * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The max components vector.
 * @memberOf module:twgl/v3
 */


function max(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = Math.max(a[0], b[0]);
  dst[1] = Math.max(a[1], b[1]);
  dst[2] = Math.max(a[2], b[2]);
  return dst;
}
/**
 * Return min values of two vectors.
 * Given vectors a and b returns
 * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The min components vector.
 * @memberOf module:twgl/v3
 */


function min(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = Math.min(a[0], b[0]);
  dst[1] = Math.min(a[1], b[1]);
  dst[2] = Math.min(a[2], b[2]);
  return dst;
}
/**
 * Multiplies a vector by a scalar.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {number} k The scalar.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The scaled vector.
 * @memberOf module:twgl/v3
 */


function mulScalar(v, k, dst) {
  dst = dst || new VecType(3);
  dst[0] = v[0] * k;
  dst[1] = v[1] * k;
  dst[2] = v[2] * k;
  return dst;
}
/**
 * Divides a vector by a scalar.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {number} k The scalar.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The scaled vector.
 * @memberOf module:twgl/v3
 */


function divScalar(v, k, dst) {
  dst = dst || new VecType(3);
  dst[0] = v[0] / k;
  dst[1] = v[1] / k;
  dst[2] = v[2] / k;
  return dst;
}
/**
 * Computes the cross product of two vectors; assumes both vectors have
 * three entries.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of a cross b.
 * @memberOf module:twgl/v3
 */


function cross(a, b, dst) {
  dst = dst || new VecType(3);
  var t1 = a[2] * b[0] - a[0] * b[2];
  var t2 = a[0] * b[1] - a[1] * b[0];
  dst[0] = a[1] * b[2] - a[2] * b[1];
  dst[1] = t1;
  dst[2] = t2;
  return dst;
}
/**
 * Computes the dot product of two vectors; assumes both vectors have
 * three entries.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @return {number} dot product
 * @memberOf module:twgl/v3
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the length of vector
 * @param {module:twgl/v3.Vec3} v vector.
 * @return {number} length of vector.
 * @memberOf module:twgl/v3
 */


function length(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}
/**
 * Computes the square of the length of vector
 * @param {module:twgl/v3.Vec3} v vector.
 * @return {number} square of the length of vector.
 * @memberOf module:twgl/v3
 */


function lengthSq(v) {
  return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
}
/**
 * Computes the distance between 2 points
 * @param {module:twgl/v3.Vec3} a vector.
 * @param {module:twgl/v3.Vec3} b vector.
 * @return {number} distance between a and b
 * @memberOf module:twgl/v3
 */


function distance(a, b) {
  var dx = a[0] - b[0];
  var dy = a[1] - b[1];
  var dz = a[2] - b[2];
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}
/**
 * Computes the square of the distance between 2 points
 * @param {module:twgl/v3.Vec3} a vector.
 * @param {module:twgl/v3.Vec3} b vector.
 * @return {number} square of the distance between a and b
 * @memberOf module:twgl/v3
 */


function distanceSq(a, b) {
  var dx = a[0] - b[0];
  var dy = a[1] - b[1];
  var dz = a[2] - b[2];
  return dx * dx + dy * dy + dz * dz;
}
/**
 * Divides a vector by its Euclidean length and returns the quotient.
 * @param {module:twgl/v3.Vec3} a The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The normalized vector.
 * @memberOf module:twgl/v3
 */


function normalize(a, dst) {
  dst = dst || new VecType(3);
  var lenSq = a[0] * a[0] + a[1] * a[1] + a[2] * a[2];
  var len = Math.sqrt(lenSq);

  if (len > 0.00001) {
    dst[0] = a[0] / len;
    dst[1] = a[1] / len;
    dst[2] = a[2] / len;
  } else {
    dst[0] = 0;
    dst[1] = 0;
    dst[2] = 0;
  }

  return dst;
}
/**
 * Negates a vector.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} -v.
 * @memberOf module:twgl/v3
 */


function negate(v, dst) {
  dst = dst || new VecType(3);
  dst[0] = -v[0];
  dst[1] = -v[1];
  dst[2] = -v[2];
  return dst;
}
/**
 * Copies a vector.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A copy of v.
 * @memberOf module:twgl/v3
 */


function copy(v, dst) {
  dst = dst || new VecType(3);
  dst[0] = v[0];
  dst[1] = v[1];
  dst[2] = v[2];
  return dst;
}
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of products of entries of a and
 *     b.
 * @memberOf module:twgl/v3
 */


function multiply(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] * b[0];
  dst[1] = a[1] * b[1];
  dst[2] = a[2] * b[2];
  return dst;
}
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of quotients of entries of a and
 *     b.
 * @memberOf module:twgl/v3
 */


function divide(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] / b[0];
  dst[1] = a[1] / b[1];
  dst[2] = a[2] / b[2];
  return dst;
}

/***/ }),

/***/ "./src/vertex-arrays.js":
/*!******************************!*\
  !*** ./src/vertex-arrays.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.createVertexArrayInfo = createVertexArrayInfo;
exports.createVAOAndSetAttributes = createVAOAndSetAttributes;
exports.createVAOFromBufferInfo = createVAOFromBufferInfo;

var programs = _interopRequireWildcard(__webpack_require__(/*! ./programs.js */ "./src/programs.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * vertex array object related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.attributes` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/vertexArrays
 */
var ELEMENT_ARRAY_BUFFER = 0x8893;
/**
 * @typedef {Object} VertexArrayInfo
 * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.
 * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..
 * @property {WebGLVertexArrayObject} [vertexArrayObject] a vertex array object
 * @memberOf module:twgl
 */

/**
 * Creates a VertexArrayInfo from a BufferInfo and one or more ProgramInfos
 *
 * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to
 * {@link module:twgl:drawBufferInfo}.
 *
 * > **IMPORTANT:** Vertex Array Objects are **not** a direct analog for a BufferInfo. Vertex Array Objects
 *   assign buffers to specific attributes at creation time. That means they can only be used with programs
 *   who's attributes use the same attribute locations for the same purposes.
 *
 * > Bind your attribute locations by passing an array of attribute names to {@link module:twgl.createProgramInfo}
 *   or use WebGL 2's GLSL ES 3's `layout(location = <num>)` to make sure locations match.
 *
 * also
 *
 * > **IMPORTANT:** After calling twgl.setBuffersAndAttribute with a BufferInfo that uses a Vertex Array Object
 *   that Vertex Array Object will be bound. That means **ANY MANIPULATION OF ELEMENT_ARRAY_BUFFER or ATTRIBUTES**
 *   will affect the Vertex Array Object state.
 *
 * > Call `gl.bindVertexArray(null)` to get back manipulating the global attributes and ELEMENT_ARRAY_BUFFER.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.ProgramInfo|module:twgl.ProgramInfo[]} programInfo a programInfo or array of programInfos
 * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...
 *
 *    You need to make sure every attribute that will be used is bound. So for example assume shader 1
 *    uses attributes A, B, C and shader 2 uses attributes A, B, D. If you only pass in the programInfo
 *    for shader 1 then only attributes A, B, and C will have their attributes set because TWGL doesn't
 *    now attribute D's location.
 *
 *    So, you can pass in both shader 1 and shader 2's programInfo
 *
 * @return {module:twgl.VertexArrayInfo} The created VertexArrayInfo
 *
 * @memberOf module:twgl/vertexArrays
 */

function createVertexArrayInfo(gl, programInfos, bufferInfo) {
  var vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  if (!programInfos.length) {
    programInfos = [programInfos];
  }

  programInfos.forEach(function (programInfo) {
    programs.setBuffersAndAttributes(gl, programInfo, bufferInfo);
  });
  gl.bindVertexArray(null);
  return {
    numElements: bufferInfo.numElements,
    elementType: bufferInfo.elementType,
    vertexArrayObject: vao
  };
}
/**
 * Creates a vertex array object and then sets the attributes on it
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters
 * @param {Object.<string, module:twgl.AttribInfo>} attribs AttribInfos mapped by attribute name.
 * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
 * @memberOf module:twgl/vertexArrays
 */


function createVAOAndSetAttributes(gl, setters, attribs, indices) {
  var vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  programs.setAttributes(setters, attribs);

  if (indices) {
    gl.bindBuffer(ELEMENT_ARRAY_BUFFER, indices);
  } // We unbind this because otherwise any change to ELEMENT_ARRAY_BUFFER
  // like when creating buffers for other stuff will mess up this VAO's binding


  gl.bindVertexArray(null);
  return vao;
}
/**
 * Creates a vertex array object and then sets the attributes
 * on it
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {Object.<string, function>| module:twgl.ProgramInfo} programInfo as returned from createProgramInfo or Attribute setters as returned from createAttributeSetters
 * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...
 * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
 * @memberOf module:twgl/vertexArrays
 */


function createVAOFromBufferInfo(gl, programInfo, bufferInfo) {
  return createVAOAndSetAttributes(gl, programInfo.attribSetters || programInfo, bufferInfo.attribs, bufferInfo.indices);
}

/***/ })

/******/ });
});

},{}],5:[function(require,module,exports){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var loadMap = require("./loadMap");
var twgl = require("twgl.js");
var mat3 = require("gl-matrix/mat3");
var createDrawing = require("./renderer");
var canvas = document.createElement("canvas");

document.body.appendChild(canvas);

var gl = canvas.getContext("webgl");
var shapes = require("./shapes")(gl);

var scene = createDrawing(gl);

// GET MAP DATA
var progress = {
  message: "",
  completed: 0
};
var nodes = void 0;
var edges = void 0;
loadMap("toronto", progress).then(function (res) {
  nodes = res.nodes;
  edges = res.edges;
  main();
});

function render(time) {
  twgl.resizeCanvasToDisplaySize(gl.canvas);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  scene.draw();
}

function main() {
  var color = [1.0, 1.0, 1.0, 1.0];

  scene.addObject(nodes, edges, color, gl.LINES);

  attachHandlers();

  requestAnimationFrame(render);
}

function attachHandlers() {

  // handle window resize
  function handleResize(e) {
    scene.draw();
  }

  window.addEventListener('resize', handleResize);

  var camera = scene.camera;
  var viewProjectionMat = scene.viewProjectionMat;
  var updateViewProjection = scene.updateViewProjection;
  var startInvViewProjMat = mat3.create();
  var startCamera = void 0;
  var startPos = void 0;
  var startClipPos = void 0;
  var startMousePos = void 0;

  var moved = false;

  function moveCamera(e) {
    var pos = transformPoint(startInvViewProjMat, getClipSpaceMousePosition(e));

    camera.x = startCamera.x + startPos[0] - pos[0];
    camera.y = startCamera.y + startPos[1] - pos[1];
    scene.draw();
  }

  function handleMouseMove(e) {
    moved = true;
    moveCamera(e);
  }

  function handleMouseUp(e) {
    scene.draw();
    window.removeEventListener('mousemove', handleMouseMove);
    window.removeEventListener('mouseup', handleMouseUp);

    // check if mouse click (not drag)
    if (!moved) {
      console.log("mouse tap!");
      handleClick(e);
    }
    moved = false;
  }

  function handleClick(e) {
    var pos = transformPoint(startInvViewProjMat, getClipSpaceMousePosition(e));

    var marker = shapes.marker;
    var transforms = {
      x: pos[0],
      y: pos[1],
      scale: 5,
      zoom: false
    };

    scene.addObject(marker.verts, marker.indices, [0.85, 0, 0, 1], marker.drawType, transforms);
    scene.draw();
  }

  canvas.addEventListener('mousedown', function (e) {
    e.preventDefault();
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);

    mat3.invert(startInvViewProjMat, viewProjectionMat);

    startCamera = Object.assign({}, camera);
    startClipPos = getClipSpaceMousePosition(e);
    startPos = transformPoint(startInvViewProjMat, startClipPos);
    startMousePos = [e.clientX, e.clientY];
    scene.draw();
  });

  canvas.addEventListener('wheel', function (e) {
    e.preventDefault();

    var _getClipSpaceMousePos = getClipSpaceMousePosition(e),
        _getClipSpaceMousePos2 = _slicedToArray(_getClipSpaceMousePos, 2),
        clipX = _getClipSpaceMousePos2[0],
        clipY = _getClipSpaceMousePos2[1];
    // position before zooming


    var temp = mat3.create();
    mat3.invert(temp, viewProjectionMat);

    var _transformPoint = transformPoint(temp, [clipX, clipY]),
        _transformPoint2 = _slicedToArray(_transformPoint, 2),
        preZoomX = _transformPoint2[0],
        preZoomY = _transformPoint2[1];

    // multiply the wheel movement by the current zoom level
    // so we zoom less when zoomed in and more when zoomed out


    var newZoom = camera.zoom * Math.pow(2, e.deltaY * -0.01);
    camera.zoom = Math.max(0.02, Math.min(100, newZoom));

    updateViewProjection();

    // position after zooming
    mat3.invert(temp, viewProjectionMat);

    var _transformPoint3 = transformPoint(temp, [clipX, clipY]),
        _transformPoint4 = _slicedToArray(_transformPoint3, 2),
        postZoomX = _transformPoint4[0],
        postZoomY = _transformPoint4[1];

    // camera needs to be moved the difference of before and after


    camera.x += preZoomX - postZoomX;
    camera.y += preZoomY - postZoomY;

    scene.draw();
  });

  function transformPoint(m, v) {
    var v0 = v[0];
    var v1 = v[1];
    var d = v0 * m[0 * 3 + 2] + v1 * m[1 * 3 + 2] + m[2 * 3 + 2];
    return [(v0 * m[0 * 3 + 0] + v1 * m[1 * 3 + 0] + m[2 * 3 + 0]) / d, (v0 * m[0 * 3 + 1] + v1 * m[1 * 3 + 1] + m[2 * 3 + 1]) / d];
  }
}

function getClipSpaceMousePosition(e) {
  // get canvas relative css position
  var rect = canvas.getBoundingClientRect();
  var cssX = e.clientX - rect.left;
  var cssY = e.clientY - rect.top;

  // get normalized 0 to 1 position across and down canvas
  var normalizedX = cssX / canvas.clientWidth;
  var normalizedY = cssY / canvas.clientHeight;

  // convert to clip space
  var clipX = normalizedX * 2 - 1;
  var clipY = normalizedY * -2 + 1;

  return [clipX, clipY];
}

},{"./loadMap":6,"./renderer":7,"./shapes":9,"gl-matrix/mat3":2,"twgl.js":4}],6:[function(require,module,exports){
"use strict";

var request = require("./request");
var endpoint = "./data/";

module.exports = function (name, progress) {
  var nodes = void 0;
  var edges = void 0;

  return loadNodes().then(function (res) {
    setNodeCoordinates(res);
    return loadEdges();
  }).then(function (res) {
    setEdgeLinks(res);
    return {
      nodes: nodes, edges: edges
    };
  });

  function loadNodes() {
    return request(endpoint + (name + ".co.bin"), {
      responseType: "arraybuffer",
      progress: reportProgress("Loading map nodes")
    });
  }

  function loadEdges() {
    return request(endpoint + (name + ".gr.bin"), {
      responseType: "arraybuffer",
      progress: reportProgress("Loading map edges")
    });
  }

  function setNodeCoordinates(buffer) {
    nodes = new Int32Array(buffer);
    // TODO: add to graph structure
  }

  function setEdgeLinks(buffer) {
    edges = new Int32Array(buffer);
    edges.forEach(function (v, i) {
      edges[i] -= 1;
    });
  }

  function reportProgress(msg) {
    return function (e) {
      progress.message = msg;
      progress.completed = Math.round(e.percent * 100);
      console.log(progress.message + " " + progress.completed);
    };
  }
};

},{"./request":8}],7:[function(require,module,exports){
"use strict";

var glsl = require("glslify");
var twgl = require("twgl.js");
var mat3 = require("gl-matrix/mat3");

var vertexShader = glsl(["precision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 position;\n\nuniform mat3 u_matrix;\n\nvoid main() {\n  gl_Position = vec4((u_matrix * vec3(position, 1)).xy, 0, 1);\n}"]);
var fragmentShader = glsl(["precision mediump float;\n#define GLSLIFY 1\n\nuniform vec4 u_color;\n\nvoid main(){\n\n  gl_FragColor = u_color;\n\n}"]);

module.exports = function (gl) {
  var programInfo = twgl.createProgramInfo(gl, [vertexShader, fragmentShader]);
  var objects = [];
  var resolution = [gl.canvas.width, gl.canvas.height];
  var viewProjectionMat = mat3.create();
  var camera = {
    //x: -33948,
    //y: -17689,
    //zoom: 0.0271311
    x: 0,
    y: 0,
    zoom: 1
  };

  twgl.addExtensionsToContext(gl);

  function updateViewProjection() {
    mat3.projection(viewProjectionMat, gl.canvas.width, gl.canvas.height);

    // make camera matrix
    var zoomScale = 1 / camera.zoom;
    var cameraMat = mat3.create();
    mat3.translate(cameraMat, cameraMat, [camera.x, camera.y]);
    mat3.scale(cameraMat, cameraMat, [zoomScale, zoomScale]);

    var viewMat = mat3.create();
    mat3.invert(viewMat, cameraMat);
    mat3.multiply(viewProjectionMat, viewProjectionMat, viewMat);
  }

  function computeMatrixUniform(transforms) {
    var mat = mat3.create();
    mat3.identity(mat);
    mat3.translate(mat, mat, [transforms.x, transforms.y]);
    mat3.scale(mat, mat, [transforms.scale, transforms.scale]);

    if (!transforms.zoom) {
      mat3.scale(mat, mat, [1 / camera.zoom, 1 / camera.zoom]);
      console.log(mat);
    }

    mat3.multiply(mat, viewProjectionMat, mat);
    return mat;
  }

  function addObject(verts, inds, color, type) {
    var transforms = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : { x: 0, y: 0, scale: 1, zoom: true };

    var bufferData = {
      position: { numComponents: 2, data: new Float32Array(verts) },
      indices: { numComponents: 2, data: new Uint32Array(inds) }
    };
    var bufferInfo = twgl.createBufferInfoFromArrays(gl, bufferData);
    var obj = {
      bufferInfo: bufferInfo,
      color: color,
      drawType: type,
      transforms: transforms
    };

    objects.push(obj);
  }

  // Init/Re-init BufferInfo and set
  function updateData() {
    bufferInfo = twgl.createBufferInfoFromArrays(gl, bufferData);
    twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
  }

  return {
    updateData: updateData,
    updateViewProjection: updateViewProjection,
    addObject: addObject,
    camera: camera,
    viewProjectionMat: viewProjectionMat,

    draw: function draw() {
      if (!objects.length) {
        console.error("no objects to draw!");
        return;
      }
      resolution[0] = gl.canvas.width;
      resolution[1] = gl.canvas.height;

      twgl.resizeCanvasToDisplaySize(gl.canvas);

      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      gl.clearColor(0.0, 0.06, 0.21, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      updateViewProjection();

      objects.forEach(function (obj) {
        var uniforms = {
          u_color: obj.color,
          u_matrix: computeMatrixUniform(obj.transforms)
        };
        gl.useProgram(programInfo.program);
        twgl.setBuffersAndAttributes(gl, programInfo, obj.bufferInfo);
        twgl.setUniforms(programInfo, uniforms);
        twgl.drawBufferInfo(gl, obj.bufferInfo, obj.drawType);
      });
    }
  };
};

},{"gl-matrix/mat3":2,"glslify":3,"twgl.js":4}],8:[function(require,module,exports){
"use strict";

module.exports = request;

function request(url, options) {
  if (!options) options = {};

  return new Promise(download);

  function download(resolve, reject) {
    var req = new XMLHttpRequest();

    if (typeof options.progress === 'function') {
      req.addEventListener("progress", updateProgress, false);
    }

    req.addEventListener("load", transferComplete, false);
    req.addEventListener("error", transferFailed, false);
    req.addEventListener("abort", transferCanceled, false);

    req.open('GET', url);
    if (options.responseType) {
      req.responseType = options.responseType;
    }
    req.send(null);

    function updateProgress(e) {
      if (e.lengthComputable) {
        options.progress({
          loaded: e.loaded,
          total: e.total,
          percent: e.loaded / e.total
        });
      }
    }

    function transferComplete() {
      if (req.status !== 200) {
        reject("Unexpected status code " + req.status + " when calling " + url);
        return;
      }
      var response = req.response;

      if (options.responseType === 'json' && typeof response === 'string') {
        // IE
        response = JSON.parse(response);
      }

      resolve(response);
    }

    function transferFailed() {
      reject("Failed to download " + url);
    }

    function transferCanceled() {
      reject("Cancelled download of " + url);
    }
  }
}

},{}],9:[function(require,module,exports){
"use strict";

module.exports = function (gl) {
  return {
    marker: {
      verts: [0, -10, -2.6, -9.0, -2.6, -10, -2.0, -11.5, -0.7, -12.4, 0.7, -12.4, 2.0, -11.5, 2.6, -10, 2.6, -9.0, 0, 0],
      indices: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1],
      drawType: gl.TRIANGLE_FAN
    }
  };
};

},{}]},{},[5])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy9jb21tb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy9tYXQzLmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy90d2dsLmpzL2Rpc3QvNC54L3R3Z2wtZnVsbC5qcyIsInNyYy9pbmRleC5qcyIsInNyYy9sb2FkTWFwLmpzIiwic3JjL3JlbmRlcmVyLmpzIiwic3JjL3JlcXVlc3QuanMiLCJzcmMvc2hhcGVzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3AxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wyVUE7Ozs7QUFFQSxJQUFNLFVBQVUsUUFBUSxXQUFSLENBQWhCO0FBQ0EsSUFBTSxPQUFPLFFBQVEsU0FBUixDQUFiO0FBQ0EsSUFBTSxPQUFPLFFBQVEsZ0JBQVIsQ0FBYjtBQUNBLElBQU0sZ0JBQWdCLFFBQVEsWUFBUixDQUF0QjtBQUNBLElBQU0sU0FBUyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZjs7QUFFQSxTQUFTLElBQVQsQ0FBYyxXQUFkLENBQTBCLE1BQTFCOztBQUVBLElBQU0sS0FBSyxPQUFPLFVBQVAsQ0FBa0IsT0FBbEIsQ0FBWDtBQUNBLElBQU0sU0FBUyxRQUFRLFVBQVIsRUFBb0IsRUFBcEIsQ0FBZjs7QUFFQSxJQUFNLFFBQVEsY0FBYyxFQUFkLENBQWQ7O0FBRUE7QUFDQSxJQUFJLFdBQVc7QUFDYixXQUFTLEVBREk7QUFFYixhQUFXO0FBRkUsQ0FBZjtBQUlBLElBQUksY0FBSjtBQUNBLElBQUksY0FBSjtBQUNBLFFBQVEsU0FBUixFQUFtQixRQUFuQixFQUNHLElBREgsQ0FDUSxVQUFDLEdBQUQsRUFBUztBQUNiLFVBQVEsSUFBSSxLQUFaO0FBQ0EsVUFBUSxJQUFJLEtBQVo7QUFDQTtBQUNELENBTEg7O0FBT0EsU0FBUyxNQUFULENBQWdCLElBQWhCLEVBQXNCO0FBQ3BCLE9BQUsseUJBQUwsQ0FBK0IsR0FBRyxNQUFsQztBQUNBLEtBQUcsUUFBSCxDQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCLEdBQUcsTUFBSCxDQUFVLEtBQTVCLEVBQW1DLEdBQUcsTUFBSCxDQUFVLE1BQTdDO0FBQ0EsUUFBTSxJQUFOO0FBQ0Q7O0FBRUQsU0FBUyxJQUFULEdBQWU7QUFDYixNQUFJLFFBQVEsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsR0FBaEIsQ0FBWjs7QUFFQSxRQUFNLFNBQU4sQ0FBZ0IsS0FBaEIsRUFBdUIsS0FBdkIsRUFBOEIsS0FBOUIsRUFBcUMsR0FBRyxLQUF4Qzs7QUFFQTs7QUFFQSx3QkFBc0IsTUFBdEI7QUFDRDs7QUFFRCxTQUFTLGNBQVQsR0FBMEI7O0FBRXhCO0FBQ0EsV0FBUyxZQUFULENBQXNCLENBQXRCLEVBQXlCO0FBQ3ZCLFVBQU0sSUFBTjtBQUNEOztBQUVELFNBQU8sZ0JBQVAsQ0FBd0IsUUFBeEIsRUFBa0MsWUFBbEM7O0FBRUEsTUFBSSxTQUFTLE1BQU0sTUFBbkI7QUFDQSxNQUFJLG9CQUFvQixNQUFNLGlCQUE5QjtBQUNBLE1BQUksdUJBQXVCLE1BQU0sb0JBQWpDO0FBQ0EsTUFBSSxzQkFBc0IsS0FBSyxNQUFMLEVBQTFCO0FBQ0EsTUFBSSxvQkFBSjtBQUNBLE1BQUksaUJBQUo7QUFDQSxNQUFJLHFCQUFKO0FBQ0EsTUFBSSxzQkFBSjs7QUFFQSxNQUFJLFFBQVEsS0FBWjs7QUFFQSxXQUFTLFVBQVQsQ0FBb0IsQ0FBcEIsRUFBdUI7QUFDckIsUUFBTSxNQUFNLGVBQ1IsbUJBRFEsRUFFUiwwQkFBMEIsQ0FBMUIsQ0FGUSxDQUFaOztBQUlBLFdBQU8sQ0FBUCxHQUFXLFlBQVksQ0FBWixHQUFnQixTQUFTLENBQVQsQ0FBaEIsR0FBOEIsSUFBSSxDQUFKLENBQXpDO0FBQ0EsV0FBTyxDQUFQLEdBQVcsWUFBWSxDQUFaLEdBQWdCLFNBQVMsQ0FBVCxDQUFoQixHQUE4QixJQUFJLENBQUosQ0FBekM7QUFDQSxVQUFNLElBQU47QUFDRDs7QUFFRCxXQUFTLGVBQVQsQ0FBeUIsQ0FBekIsRUFBNEI7QUFDMUIsWUFBUSxJQUFSO0FBQ0EsZUFBVyxDQUFYO0FBQ0Q7O0FBRUQsV0FBUyxhQUFULENBQXVCLENBQXZCLEVBQTBCO0FBQ3hCLFVBQU0sSUFBTjtBQUNBLFdBQU8sbUJBQVAsQ0FBMkIsV0FBM0IsRUFBd0MsZUFBeEM7QUFDQSxXQUFPLG1CQUFQLENBQTJCLFNBQTNCLEVBQXNDLGFBQXRDOztBQUVBO0FBQ0EsUUFBSSxDQUFDLEtBQUwsRUFBWTtBQUNWLGNBQVEsR0FBUixDQUFZLFlBQVo7QUFDQSxrQkFBWSxDQUFaO0FBQ0Q7QUFDRCxZQUFRLEtBQVI7QUFDRDs7QUFFRCxXQUFTLFdBQVQsQ0FBcUIsQ0FBckIsRUFBd0I7QUFDdEIsUUFBTSxNQUFNLGVBQ1IsbUJBRFEsRUFFUiwwQkFBMEIsQ0FBMUIsQ0FGUSxDQUFaOztBQUlBLFFBQUksU0FBUyxPQUFPLE1BQXBCO0FBQ0EsUUFBSSxhQUFhO0FBQ2YsU0FBRyxJQUFJLENBQUosQ0FEWTtBQUVmLFNBQUcsSUFBSSxDQUFKLENBRlk7QUFHZixhQUFPLENBSFE7QUFJZixZQUFNO0FBSlMsS0FBakI7O0FBT0EsVUFBTSxTQUFOLENBQWdCLE9BQU8sS0FBdkIsRUFBOEIsT0FBTyxPQUFyQyxFQUE4QyxDQUFDLElBQUQsRUFBTSxDQUFOLEVBQVEsQ0FBUixFQUFVLENBQVYsQ0FBOUMsRUFBNEQsT0FBTyxRQUFuRSxFQUE2RSxVQUE3RTtBQUNBLFVBQU0sSUFBTjtBQUNEOztBQUVELFNBQU8sZ0JBQVAsQ0FBd0IsV0FBeEIsRUFBcUMsVUFBQyxDQUFELEVBQU87QUFDMUMsTUFBRSxjQUFGO0FBQ0EsV0FBTyxnQkFBUCxDQUF3QixXQUF4QixFQUFxQyxlQUFyQztBQUNBLFdBQU8sZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUMsYUFBbkM7O0FBRUEsU0FBSyxNQUFMLENBQVksbUJBQVosRUFBaUMsaUJBQWpDOztBQUVBLGtCQUFjLE9BQU8sTUFBUCxDQUFjLEVBQWQsRUFBa0IsTUFBbEIsQ0FBZDtBQUNBLG1CQUFlLDBCQUEwQixDQUExQixDQUFmO0FBQ0EsZUFBVyxlQUNQLG1CQURPLEVBRVAsWUFGTyxDQUFYO0FBR0Esb0JBQWdCLENBQUMsRUFBRSxPQUFILEVBQVksRUFBRSxPQUFkLENBQWhCO0FBQ0EsVUFBTSxJQUFOO0FBQ0QsR0FkRDs7QUFnQkEsU0FBTyxnQkFBUCxDQUF3QixPQUF4QixFQUFpQyxVQUFDLENBQUQsRUFBTztBQUN0QyxNQUFFLGNBQUY7O0FBRHNDLGdDQUVmLDBCQUEwQixDQUExQixDQUZlO0FBQUE7QUFBQSxRQUUvQixLQUYrQjtBQUFBLFFBRXhCLEtBRndCO0FBR3RDOzs7QUFDQSxRQUFJLE9BQU8sS0FBSyxNQUFMLEVBQVg7QUFDQSxTQUFLLE1BQUwsQ0FBWSxJQUFaLEVBQWtCLGlCQUFsQjs7QUFMc0MsMEJBTVQsZUFDekIsSUFEeUIsRUFFekIsQ0FBQyxLQUFELEVBQVEsS0FBUixDQUZ5QixDQU5TO0FBQUE7QUFBQSxRQU0vQixRQU4rQjtBQUFBLFFBTXJCLFFBTnFCOztBQVV0QztBQUNBOzs7QUFDQSxRQUFNLFVBQVUsT0FBTyxJQUFQLEdBQWMsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLEVBQUUsTUFBRixHQUFXLENBQUMsSUFBeEIsQ0FBOUI7QUFDQSxXQUFPLElBQVAsR0FBYyxLQUFLLEdBQUwsQ0FBUyxJQUFULEVBQWUsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLE9BQWQsQ0FBZixDQUFkOztBQUVBOztBQUVBO0FBQ0EsU0FBSyxNQUFMLENBQVksSUFBWixFQUFrQixpQkFBbEI7O0FBbEJzQywyQkFtQlAsZUFDM0IsSUFEMkIsRUFFM0IsQ0FBQyxLQUFELEVBQVEsS0FBUixDQUYyQixDQW5CTztBQUFBO0FBQUEsUUFtQi9CLFNBbkIrQjtBQUFBLFFBbUJwQixTQW5Cb0I7O0FBdUJ0Qzs7O0FBQ0EsV0FBTyxDQUFQLElBQVksV0FBVyxTQUF2QjtBQUNBLFdBQU8sQ0FBUCxJQUFZLFdBQVcsU0FBdkI7O0FBRUEsVUFBTSxJQUFOO0FBQ0QsR0E1QkQ7O0FBOEJBLFdBQVMsY0FBVCxDQUF3QixDQUF4QixFQUEyQixDQUEzQixFQUE4QjtBQUM1QixRQUFJLEtBQUssRUFBRSxDQUFGLENBQVQ7QUFDQSxRQUFJLEtBQUssRUFBRSxDQUFGLENBQVQ7QUFDQSxRQUFJLElBQUksS0FBSyxFQUFFLElBQUksQ0FBSixHQUFRLENBQVYsQ0FBTCxHQUFvQixLQUFLLEVBQUUsSUFBSSxDQUFKLEdBQVEsQ0FBVixDQUF6QixHQUF3QyxFQUFFLElBQUksQ0FBSixHQUFRLENBQVYsQ0FBaEQ7QUFDQSxXQUFPLENBQ0wsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFKLEdBQVEsQ0FBVixDQUFMLEdBQW9CLEtBQUssRUFBRSxJQUFJLENBQUosR0FBUSxDQUFWLENBQXpCLEdBQXdDLEVBQUUsSUFBSSxDQUFKLEdBQVEsQ0FBVixDQUF6QyxJQUF5RCxDQURwRCxFQUVMLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBSixHQUFRLENBQVYsQ0FBTCxHQUFvQixLQUFLLEVBQUUsSUFBSSxDQUFKLEdBQVEsQ0FBVixDQUF6QixHQUF3QyxFQUFFLElBQUksQ0FBSixHQUFRLENBQVYsQ0FBekMsSUFBeUQsQ0FGcEQsQ0FBUDtBQUlEO0FBQ0Y7O0FBRUQsU0FBUyx5QkFBVCxDQUFtQyxDQUFuQyxFQUFzQztBQUNwQztBQUNBLE1BQU0sT0FBTyxPQUFPLHFCQUFQLEVBQWI7QUFDQSxNQUFNLE9BQU8sRUFBRSxPQUFGLEdBQVksS0FBSyxJQUE5QjtBQUNBLE1BQU0sT0FBTyxFQUFFLE9BQUYsR0FBWSxLQUFLLEdBQTlCOztBQUVBO0FBQ0EsTUFBTSxjQUFjLE9BQU8sT0FBTyxXQUFsQztBQUNBLE1BQU0sY0FBYyxPQUFPLE9BQU8sWUFBbEM7O0FBRUE7QUFDQSxNQUFNLFFBQVEsY0FBZSxDQUFmLEdBQW1CLENBQWpDO0FBQ0EsTUFBTSxRQUFRLGNBQWMsQ0FBQyxDQUFmLEdBQW1CLENBQWpDOztBQUVBLFNBQU8sQ0FBQyxLQUFELEVBQVEsS0FBUixDQUFQO0FBQ0Q7Ozs7O0FDdExELElBQU0sVUFBVSxRQUFRLFdBQVIsQ0FBaEI7QUFDQSxJQUFNLFdBQVcsU0FBakI7O0FBRUEsT0FBTyxPQUFQLEdBQWlCLFVBQVMsSUFBVCxFQUFlLFFBQWYsRUFBeUI7QUFDeEMsTUFBSSxjQUFKO0FBQ0EsTUFBSSxjQUFKOztBQUVBLFNBQU8sWUFDRSxJQURGLENBQ08sVUFBQyxHQUFELEVBQVM7QUFDYix1QkFBbUIsR0FBbkI7QUFDQSxXQUFPLFdBQVA7QUFDRCxHQUpGLEVBS0UsSUFMRixDQUtPLFVBQUMsR0FBRCxFQUFTO0FBQ2IsaUJBQWEsR0FBYjtBQUNBLFdBQU87QUFDTCxrQkFESyxFQUNFO0FBREYsS0FBUDtBQUdELEdBVkYsQ0FBUDs7QUFZQSxXQUFTLFNBQVQsR0FBcUI7QUFDbkIsV0FBTyxRQUFRLFlBQWMsSUFBZCxhQUFSLEVBQXFDO0FBQzFDLG9CQUFjLGFBRDRCO0FBRTFDLGdCQUFVLGVBQWUsbUJBQWY7QUFGZ0MsS0FBckMsQ0FBUDtBQUlEOztBQUVELFdBQVMsU0FBVCxHQUFxQjtBQUNuQixXQUFPLFFBQVEsWUFBYyxJQUFkLGFBQVIsRUFBcUM7QUFDMUMsb0JBQWMsYUFENEI7QUFFMUMsZ0JBQVUsZUFBZSxtQkFBZjtBQUZnQyxLQUFyQyxDQUFQO0FBSUQ7O0FBRUQsV0FBUyxrQkFBVCxDQUE0QixNQUE1QixFQUFvQztBQUNsQyxZQUFRLElBQUksVUFBSixDQUFlLE1BQWYsQ0FBUjtBQUNBO0FBQ0Q7O0FBRUQsV0FBUyxZQUFULENBQXNCLE1BQXRCLEVBQThCO0FBQzVCLFlBQVEsSUFBSSxVQUFKLENBQWUsTUFBZixDQUFSO0FBQ0EsVUFBTSxPQUFOLENBQWMsVUFBQyxDQUFELEVBQUcsQ0FBSCxFQUFTO0FBQ3JCLFlBQU0sQ0FBTixLQUFZLENBQVo7QUFDRCxLQUZEO0FBR0Q7O0FBRUQsV0FBUyxjQUFULENBQXdCLEdBQXhCLEVBQTZCO0FBQzNCLFdBQU8sVUFBUyxDQUFULEVBQVk7QUFDakIsZUFBUyxPQUFULEdBQW1CLEdBQW5CO0FBQ0EsZUFBUyxTQUFULEdBQXFCLEtBQUssS0FBTCxDQUFXLEVBQUUsT0FBRixHQUFZLEdBQXZCLENBQXJCO0FBQ0EsY0FBUSxHQUFSLENBQVksU0FBUyxPQUFULEdBQW1CLEdBQW5CLEdBQXlCLFNBQVMsU0FBOUM7QUFDRCxLQUpEO0FBS0Q7QUFDRixDQWpERDs7O0FDSEE7O0FBRUEsSUFBTSxPQUFPLFFBQVEsU0FBUixDQUFiO0FBQ0EsSUFBTSxPQUFPLFFBQVEsU0FBUixDQUFiO0FBQ0EsSUFBTSxPQUFPLFFBQVEsZ0JBQVIsQ0FBYjs7QUFFQSxJQUFNLGVBQWUsS0FBSyxDQUFDLHVMQUFELENBQUwsQ0FBckI7QUFDQSxJQUFNLGlCQUFpQixLQUFLLENBQUMsd0hBQUQsQ0FBTCxDQUF2Qjs7QUFFQSxPQUFPLE9BQVAsR0FBaUIsVUFBUyxFQUFULEVBQWE7QUFDNUIsTUFBTSxjQUFjLEtBQUssaUJBQUwsQ0FBdUIsRUFBdkIsRUFBMkIsQ0FBQyxZQUFELEVBQWUsY0FBZixDQUEzQixDQUFwQjtBQUNBLE1BQU0sVUFBVSxFQUFoQjtBQUNBLE1BQU0sYUFBYSxDQUFDLEdBQUcsTUFBSCxDQUFVLEtBQVgsRUFBa0IsR0FBRyxNQUFILENBQVUsTUFBNUIsQ0FBbkI7QUFDQSxNQUFNLG9CQUFvQixLQUFLLE1BQUwsRUFBMUI7QUFDQSxNQUFNLFNBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxPQUFHLENBSlU7QUFLYixPQUFHLENBTFU7QUFNYixVQUFNO0FBTk8sR0FBZjs7QUFTQSxPQUFLLHNCQUFMLENBQTRCLEVBQTVCOztBQUVBLFdBQVMsb0JBQVQsR0FBZ0M7QUFDOUIsU0FBSyxVQUFMLENBQWdCLGlCQUFoQixFQUFtQyxHQUFHLE1BQUgsQ0FBVSxLQUE3QyxFQUFvRCxHQUFHLE1BQUgsQ0FBVSxNQUE5RDs7QUFFQTtBQUNBLFFBQU0sWUFBWSxJQUFJLE9BQU8sSUFBN0I7QUFDQSxRQUFJLFlBQVksS0FBSyxNQUFMLEVBQWhCO0FBQ0EsU0FBSyxTQUFMLENBQWUsU0FBZixFQUEwQixTQUExQixFQUFxQyxDQUFDLE9BQU8sQ0FBUixFQUFXLE9BQU8sQ0FBbEIsQ0FBckM7QUFDQSxTQUFLLEtBQUwsQ0FBVyxTQUFYLEVBQXNCLFNBQXRCLEVBQWlDLENBQUMsU0FBRCxFQUFZLFNBQVosQ0FBakM7O0FBRUEsUUFBSSxVQUFVLEtBQUssTUFBTCxFQUFkO0FBQ0EsU0FBSyxNQUFMLENBQVksT0FBWixFQUFxQixTQUFyQjtBQUNBLFNBQUssUUFBTCxDQUFjLGlCQUFkLEVBQWlDLGlCQUFqQyxFQUFvRCxPQUFwRDtBQUNEOztBQUVELFdBQVMsb0JBQVQsQ0FBOEIsVUFBOUIsRUFBMEM7QUFDeEMsUUFBSSxNQUFNLEtBQUssTUFBTCxFQUFWO0FBQ0EsU0FBSyxRQUFMLENBQWMsR0FBZDtBQUNBLFNBQUssU0FBTCxDQUFlLEdBQWYsRUFBb0IsR0FBcEIsRUFBeUIsQ0FBQyxXQUFXLENBQVosRUFBZSxXQUFXLENBQTFCLENBQXpCO0FBQ0EsU0FBSyxLQUFMLENBQVcsR0FBWCxFQUFnQixHQUFoQixFQUFxQixDQUFDLFdBQVcsS0FBWixFQUFtQixXQUFXLEtBQTlCLENBQXJCOztBQUVBLFFBQUksQ0FBQyxXQUFXLElBQWhCLEVBQXNCO0FBQ3BCLFdBQUssS0FBTCxDQUFXLEdBQVgsRUFBZ0IsR0FBaEIsRUFBcUIsQ0FBQyxJQUFFLE9BQU8sSUFBVixFQUFnQixJQUFFLE9BQU8sSUFBekIsQ0FBckI7QUFDQSxjQUFRLEdBQVIsQ0FBWSxHQUFaO0FBQ0Q7O0FBRUQsU0FBSyxRQUFMLENBQWMsR0FBZCxFQUFtQixpQkFBbkIsRUFBc0MsR0FBdEM7QUFDQSxXQUFPLEdBQVA7QUFDRDs7QUFFRCxXQUFTLFNBQVQsQ0FBbUIsS0FBbkIsRUFBMEIsSUFBMUIsRUFBZ0MsS0FBaEMsRUFBdUMsSUFBdkMsRUFBZ0c7QUFBQSxRQUFuRCxVQUFtRCx1RUFBdEMsRUFBRSxHQUFHLENBQUwsRUFBUSxHQUFHLENBQVgsRUFBYyxPQUFPLENBQXJCLEVBQXdCLE1BQU0sSUFBOUIsRUFBc0M7O0FBQzlGLFFBQU0sYUFBYTtBQUNqQixnQkFBVSxFQUFFLGVBQWUsQ0FBakIsRUFBb0IsTUFBTSxJQUFJLFlBQUosQ0FBaUIsS0FBakIsQ0FBMUIsRUFETztBQUVqQixlQUFVLEVBQUUsZUFBZSxDQUFqQixFQUFvQixNQUFNLElBQUksV0FBSixDQUFnQixJQUFoQixDQUExQjtBQUZPLEtBQW5CO0FBSUEsUUFBTSxhQUFhLEtBQUssMEJBQUwsQ0FBZ0MsRUFBaEMsRUFBb0MsVUFBcEMsQ0FBbkI7QUFDQSxRQUFNLE1BQU07QUFDVixrQkFBWSxVQURGO0FBRVYsYUFBTyxLQUZHO0FBR1YsZ0JBQVUsSUFIQTtBQUlWLGtCQUFZO0FBSkYsS0FBWjs7QUFPQSxZQUFRLElBQVIsQ0FBYSxHQUFiO0FBQ0Q7O0FBRUQ7QUFDQSxXQUFTLFVBQVQsR0FBc0I7QUFDcEIsaUJBQWEsS0FBSywwQkFBTCxDQUFnQyxFQUFoQyxFQUFvQyxVQUFwQyxDQUFiO0FBQ0EsU0FBSyx1QkFBTCxDQUE2QixFQUE3QixFQUFpQyxXQUFqQyxFQUE4QyxVQUE5QztBQUNEOztBQUVELFNBQU87QUFDTCwwQkFESztBQUVMLDhDQUZLO0FBR0wsd0JBSEs7QUFJTCxrQkFKSztBQUtMLHdDQUxLOztBQU9MLFFBUEssa0JBT0U7QUFDTCxVQUFJLENBQUMsUUFBUSxNQUFiLEVBQXFCO0FBQ25CLGdCQUFRLEtBQVIsQ0FBYyxxQkFBZDtBQUNBO0FBQ0Q7QUFDRCxpQkFBVyxDQUFYLElBQWdCLEdBQUcsTUFBSCxDQUFVLEtBQTFCO0FBQ0EsaUJBQVcsQ0FBWCxJQUFnQixHQUFHLE1BQUgsQ0FBVSxNQUExQjs7QUFFQSxXQUFLLHlCQUFMLENBQStCLEdBQUcsTUFBbEM7O0FBRUEsU0FBRyxRQUFILENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsR0FBRyxNQUFILENBQVUsS0FBNUIsRUFBbUMsR0FBRyxNQUFILENBQVUsTUFBN0M7QUFDQSxTQUFHLFVBQUgsQ0FBYyxHQUFkLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLEVBQStCLEdBQS9CO0FBQ0EsU0FBRyxLQUFILENBQVMsR0FBRyxnQkFBWjs7QUFFQTs7QUFFQSxjQUFRLE9BQVIsQ0FBZ0IsZUFBTztBQUNyQixZQUFNLFdBQVc7QUFDZixtQkFBUyxJQUFJLEtBREU7QUFFZixvQkFBVSxxQkFBcUIsSUFBSSxVQUF6QjtBQUZLLFNBQWpCO0FBSUEsV0FBRyxVQUFILENBQWMsWUFBWSxPQUExQjtBQUNBLGFBQUssdUJBQUwsQ0FBNkIsRUFBN0IsRUFBaUMsV0FBakMsRUFBOEMsSUFBSSxVQUFsRDtBQUNBLGFBQUssV0FBTCxDQUFpQixXQUFqQixFQUE4QixRQUE5QjtBQUNBLGFBQUssY0FBTCxDQUFvQixFQUFwQixFQUF3QixJQUFJLFVBQTVCLEVBQXdDLElBQUksUUFBNUM7QUFDRCxPQVREO0FBV0Q7QUFsQ0ksR0FBUDtBQW9DRCxDQXZHRDs7Ozs7QUNUQSxPQUFPLE9BQVAsR0FBaUIsT0FBakI7O0FBRUEsU0FBUyxPQUFULENBQWlCLEdBQWpCLEVBQXNCLE9BQXRCLEVBQStCO0FBQzdCLE1BQUksQ0FBQyxPQUFMLEVBQWMsVUFBVSxFQUFWOztBQUVkLFNBQU8sSUFBSSxPQUFKLENBQVksUUFBWixDQUFQOztBQUVBLFdBQVMsUUFBVCxDQUFrQixPQUFsQixFQUEyQixNQUEzQixFQUFtQztBQUNqQyxRQUFJLE1BQU0sSUFBSSxjQUFKLEVBQVY7O0FBRUEsUUFBSSxPQUFPLFFBQVEsUUFBZixLQUE0QixVQUFoQyxFQUE0QztBQUMxQyxVQUFJLGdCQUFKLENBQXFCLFVBQXJCLEVBQWlDLGNBQWpDLEVBQWlELEtBQWpEO0FBQ0Q7O0FBRUQsUUFBSSxnQkFBSixDQUFxQixNQUFyQixFQUE2QixnQkFBN0IsRUFBK0MsS0FBL0M7QUFDQSxRQUFJLGdCQUFKLENBQXFCLE9BQXJCLEVBQThCLGNBQTlCLEVBQThDLEtBQTlDO0FBQ0EsUUFBSSxnQkFBSixDQUFxQixPQUFyQixFQUE4QixnQkFBOUIsRUFBZ0QsS0FBaEQ7O0FBRUEsUUFBSSxJQUFKLENBQVMsS0FBVCxFQUFnQixHQUFoQjtBQUNBLFFBQUksUUFBUSxZQUFaLEVBQTBCO0FBQ3hCLFVBQUksWUFBSixHQUFtQixRQUFRLFlBQTNCO0FBQ0Q7QUFDRCxRQUFJLElBQUosQ0FBUyxJQUFUOztBQUVBLGFBQVMsY0FBVCxDQUF3QixDQUF4QixFQUEyQjtBQUN6QixVQUFJLEVBQUUsZ0JBQU4sRUFBd0I7QUFDdEIsZ0JBQVEsUUFBUixDQUFpQjtBQUNmLGtCQUFRLEVBQUUsTUFESztBQUVmLGlCQUFPLEVBQUUsS0FGTTtBQUdmLG1CQUFTLEVBQUUsTUFBRixHQUFXLEVBQUU7QUFIUCxTQUFqQjtBQUtEO0FBQ0Y7O0FBRUQsYUFBUyxnQkFBVCxHQUE0QjtBQUMxQixVQUFJLElBQUksTUFBSixLQUFlLEdBQW5CLEVBQXdCO0FBQ3RCLDJDQUFpQyxJQUFJLE1BQXJDLHNCQUE0RCxHQUE1RDtBQUNBO0FBQ0Q7QUFDRCxVQUFJLFdBQVcsSUFBSSxRQUFuQjs7QUFFQSxVQUFJLFFBQVEsWUFBUixLQUF5QixNQUF6QixJQUFtQyxPQUFPLFFBQVAsS0FBb0IsUUFBM0QsRUFBcUU7QUFDbkU7QUFDQSxtQkFBVyxLQUFLLEtBQUwsQ0FBVyxRQUFYLENBQVg7QUFDRDs7QUFFRCxjQUFRLFFBQVI7QUFDRDs7QUFFRCxhQUFTLGNBQVQsR0FBMEI7QUFDeEIscUNBQTZCLEdBQTdCO0FBQ0Q7O0FBRUQsYUFBUyxnQkFBVCxHQUE0QjtBQUMxQix3Q0FBZ0MsR0FBaEM7QUFDRDtBQUNGO0FBQ0Y7Ozs7O0FDekRELE9BQU8sT0FBUCxHQUFpQixVQUFVLEVBQVYsRUFBYztBQUM3QixTQUFPO0FBQ0wsWUFBUTtBQUNOLGFBQU8sQ0FBQyxDQUFELEVBQUksQ0FBQyxFQUFMLEVBQ0MsQ0FBQyxHQURGLEVBQ08sQ0FBQyxHQURSLEVBRUMsQ0FBQyxHQUZGLEVBRU8sQ0FBQyxFQUZSLEVBR0MsQ0FBQyxHQUhGLEVBR08sQ0FBQyxJQUhSLEVBSUMsQ0FBQyxHQUpGLEVBSU8sQ0FBQyxJQUpSLEVBS0MsR0FMRCxFQUtNLENBQUMsSUFMUCxFQU1DLEdBTkQsRUFNTSxDQUFDLElBTlAsRUFPQyxHQVBELEVBT00sQ0FBQyxFQVBQLEVBUUMsR0FSRCxFQVFNLENBQUMsR0FSUCxFQVNDLENBVEQsRUFTSSxDQVRKLENBREQ7QUFXTixlQUFTLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsRUFBK0IsQ0FBL0IsQ0FYSDtBQVlOLGdCQUFVLEdBQUc7QUFaUDtBQURILEdBQVA7QUFnQkQsQ0FqQkQiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2V0TWF0cml4QXJyYXlUeXBlID0gc2V0TWF0cml4QXJyYXlUeXBlO1xuZXhwb3J0cy50b1JhZGlhbiA9IHRvUmFkaWFuO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5leHBvcnRzLlJBTkRPTSA9IGV4cG9ydHMuQVJSQVlfVFlQRSA9IGV4cG9ydHMuRVBTSUxPTiA9IHZvaWQgMDtcblxuLyoqXHJcbiAqIENvbW1vbiB1dGlsaXRpZXNcclxuICogQG1vZHVsZSBnbE1hdHJpeFxyXG4gKi9cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG52YXIgRVBTSUxPTiA9IDAuMDAwMDAxO1xuZXhwb3J0cy5FUFNJTE9OID0gRVBTSUxPTjtcbnZhciBBUlJBWV9UWVBFID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmV4cG9ydHMuQVJSQVlfVFlQRSA9IEFSUkFZX1RZUEU7XG52YXIgUkFORE9NID0gTWF0aC5yYW5kb207XG4vKipcclxuICogU2V0cyB0aGUgdHlwZSBvZiBhcnJheSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZlY3RvcnMgYW5kIG1hdHJpY2VzXHJcbiAqXHJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5Q29uc3RydWN0b3IgfCBBcnJheUNvbnN0cnVjdG9yfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XHJcbiAqL1xuXG5leHBvcnRzLlJBTkRPTSA9IFJBTkRPTTtcblxuZnVuY3Rpb24gc2V0TWF0cml4QXJyYXlUeXBlKHR5cGUpIHtcbiAgZXhwb3J0cy5BUlJBWV9UWVBFID0gQVJSQVlfVFlQRSA9IHR5cGU7XG59XG5cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuLyoqXHJcbiAqIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBBbmdsZSBpbiBEZWdyZWVzXHJcbiAqL1xuXG5mdW5jdGlvbiB0b1JhZGlhbihhKSB7XG4gIHJldHVybiBhICogZGVncmVlO1xufVxuLyoqXHJcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHZhbHVlLCB3aXRoaW4gYW4gYWJzb2x1dGVcclxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xyXG4gKiB0aGFuIG9yIGVxdWFsIHRvIDEuMCwgYW5kIGEgcmVsYXRpdmUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIGxhcmdlciB2YWx1ZXMpXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCBudW1iZXIgdG8gdGVzdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xufVxuXG5pZiAoIU1hdGguaHlwb3QpIE1hdGguaHlwb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gMCxcbiAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB5ICs9IGFyZ3VtZW50c1tpXSAqIGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoeSk7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuZnJvbU1hdDQgPSBmcm9tTWF0NDtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZTtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuZXhwb3J0cy5hZGpvaW50ID0gYWRqb2ludDtcbmV4cG9ydHMuZGV0ZXJtaW5hbnQgPSBkZXRlcm1pbmFudDtcbmV4cG9ydHMubXVsdGlwbHkgPSBtdWx0aXBseTtcbmV4cG9ydHMudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuZXhwb3J0cy5yb3RhdGUgPSByb3RhdGU7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLmZyb21UcmFuc2xhdGlvbiA9IGZyb21UcmFuc2xhdGlvbjtcbmV4cG9ydHMuZnJvbVJvdGF0aW9uID0gZnJvbVJvdGF0aW9uO1xuZXhwb3J0cy5mcm9tU2NhbGluZyA9IGZyb21TY2FsaW5nO1xuZXhwb3J0cy5mcm9tTWF0MmQgPSBmcm9tTWF0MmQ7XG5leHBvcnRzLmZyb21RdWF0ID0gZnJvbVF1YXQ7XG5leHBvcnRzLm5vcm1hbEZyb21NYXQ0ID0gbm9ybWFsRnJvbU1hdDQ7XG5leHBvcnRzLnByb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLmZyb2IgPSBmcm9iO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG5leHBvcnRzLm11bHRpcGx5U2NhbGFyID0gbXVsdGlwbHlTY2FsYXI7XG5leHBvcnRzLm11bHRpcGx5U2NhbGFyQW5kQWRkID0gbXVsdGlwbHlTY2FsYXJBbmRBZGQ7XG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbmV4cG9ydHMuc3ViID0gZXhwb3J0cy5tdWwgPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKlxyXG4gKiAzeDMgTWF0cml4XHJcbiAqIEBtb2R1bGUgbWF0M1xyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgICB0aGUgc291cmNlIDR4NCBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tTWF0NChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVs0XTtcbiAgb3V0WzRdID0gYVs1XTtcbiAgb3V0WzVdID0gYVs2XTtcbiAgb3V0WzZdID0gYVs4XTtcbiAgb3V0WzddID0gYVs5XTtcbiAgb3V0WzhdID0gYVsxMF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIG1hdHJpeCB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MyB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0MyB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHJldHVybnMge21hdDN9IEEgbmV3IG1hdDNcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0xMDtcbiAgb3V0WzRdID0gbTExO1xuICBvdXRbNV0gPSBtMTI7XG4gIG91dFs2XSA9IG0yMDtcbiAgb3V0WzddID0gbTIxO1xuICBvdXRbOF0gPSBtMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgbWF0MyB0byB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTEyID0gYVs1XTtcbiAgICBvdXRbMV0gPSBhWzNdO1xuICAgIG91dFsyXSA9IGFbNl07XG4gICAgb3V0WzNdID0gYTAxO1xuICAgIG91dFs1XSA9IGFbN107XG4gICAgb3V0WzZdID0gYTAyO1xuICAgIG91dFs3XSA9IGExMjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbM107XG4gICAgb3V0WzJdID0gYVs2XTtcbiAgICBvdXRbM10gPSBhWzFdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs3XTtcbiAgICBvdXRbNl0gPSBhWzJdO1xuICAgIG91dFs3XSA9IGFbNV07XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogSW52ZXJ0cyBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIHZhciBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjE7XG4gIHZhciBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwO1xuICB2YXIgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gIG91dFsxXSA9ICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldDtcbiAgb3V0WzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XG4gIG91dFszXSA9IGIxMSAqIGRldDtcbiAgb3V0WzRdID0gKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQ7XG4gIG91dFs1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcbiAgb3V0WzZdID0gYjIxICogZGV0O1xuICBvdXRbN10gPSAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIG91dFswXSA9IGExMSAqIGEyMiAtIGExMiAqIGEyMTtcbiAgb3V0WzFdID0gYTAyICogYTIxIC0gYTAxICogYTIyO1xuICBvdXRbMl0gPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIG91dFszXSA9IGExMiAqIGEyMCAtIGExMCAqIGEyMjtcbiAgb3V0WzRdID0gYTAwICogYTIyIC0gYTAyICogYTIwO1xuICBvdXRbNV0gPSBhMDIgKiBhMTAgLSBhMDAgKiBhMTI7XG4gIG91dFs2XSA9IGExMCAqIGEyMSAtIGExMSAqIGEyMDtcbiAgb3V0WzddID0gYTAxICogYTIwIC0gYTAwICogYTIxO1xuICBvdXRbOF0gPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cblxuZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICByZXR1cm4gYTAwICogKGEyMiAqIGExMSAtIGExMiAqIGEyMSkgKyBhMDEgKiAoLWEyMiAqIGExMCArIGExMiAqIGEyMCkgKyBhMDIgKiAoYTIxICogYTEwIC0gYTExICogYTIwKTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQzJ3NcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIHZhciBiMDAgPSBiWzBdLFxuICAgICAgYjAxID0gYlsxXSxcbiAgICAgIGIwMiA9IGJbMl07XG4gIHZhciBiMTAgPSBiWzNdLFxuICAgICAgYjExID0gYls0XSxcbiAgICAgIGIxMiA9IGJbNV07XG4gIHZhciBiMjAgPSBiWzZdLFxuICAgICAgYjIxID0gYls3XSxcbiAgICAgIGIyMiA9IGJbOF07XG4gIG91dFswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcbiAgb3V0WzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xuICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG4gIG91dFszXSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMDtcbiAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICBvdXRbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XG4gIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgb3V0WzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xuICBvdXRbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV0sXG4gICAgICBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF0sXG4gICAgICB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdO1xuICBvdXRbMF0gPSBhMDA7XG4gIG91dFsxXSA9IGEwMTtcbiAgb3V0WzJdID0gYTAyO1xuICBvdXRbM10gPSBhMTA7XG4gIG91dFs0XSA9IGExMTtcbiAgb3V0WzVdID0gYTEyO1xuICBvdXRbNl0gPSB4ICogYTAwICsgeSAqIGExMCArIGEyMDtcbiAgb3V0WzddID0geCAqIGEwMSArIHkgKiBhMTEgKyBhMjE7XG4gIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdLFxuICAgICAgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdLFxuICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gIG91dFsxXSA9IGMgKiBhMDEgKyBzICogYTExO1xuICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcbiAgb3V0WzNdID0gYyAqIGExMCAtIHMgKiBhMDA7XG4gIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcbiAgb3V0WzZdID0gYTIwO1xuICBvdXRbN10gPSBhMjE7XG4gIG91dFs4XSA9IGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgdGhlIG1hdDMgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV07XG4gIG91dFswXSA9IHggKiBhWzBdO1xuICBvdXRbMV0gPSB4ICogYVsxXTtcbiAgb3V0WzJdID0geCAqIGFbMl07XG4gIG91dFszXSA9IHkgKiBhWzNdO1xuICBvdXRbNF0gPSB5ICogYVs0XTtcbiAgb3V0WzVdID0geSAqIGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDMudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSB2WzBdO1xuICBvdXRbN10gPSB2WzFdO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDMucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IC1zO1xuICBvdXRbNF0gPSBjO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDMuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB2WzFdO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBtYXQyZCBpbnRvIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjb3B5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICoqL1xuXG5cbmZ1bmN0aW9uIGZyb21NYXQyZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gYVsyXTtcbiAgb3V0WzRdID0gYVszXTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gYVs0XTtcbiAgb3V0WzddID0gYVs1XTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cclxuICpcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUXVhdChvdXQsIHEpIHtcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB5eCA9IHkgKiB4MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgenggPSB6ICogeDI7XG4gIHZhciB6eSA9IHogKiB5MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgb3V0WzNdID0geXggLSB3ejtcbiAgb3V0WzZdID0genggKyB3eTtcbiAgb3V0WzFdID0geXggKyB3ejtcbiAgb3V0WzRdID0gMSAtIHh4IC0geno7XG4gIG91dFs3XSA9IHp5IC0gd3g7XG4gIG91dFsyXSA9IHp4IC0gd3k7XG4gIG91dFs1XSA9IHp5ICsgd3g7XG4gIG91dFs4XSA9IDEgLSB4eCAtIHl5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBNYXQ0IHRvIGRlcml2ZSB0aGUgbm9ybWFsIG1hdHJpeCBmcm9tXHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsRnJvbU1hdDQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgb3V0WzRdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICBvdXRbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgb3V0WzddID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIDJEIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB5b3VyIGdsIGNvbnRleHRcclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgZ2wgY29udGV4dFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHByb2plY3Rpb24ob3V0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIG91dFswXSA9IDIgLyB3aWR0aDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gLTIgLyBoZWlnaHQ7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IC0xO1xuICBvdXRbN10gPSAxO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cblxuZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0MyhcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIiwgXCIgKyBhWzRdICsgXCIsIFwiICsgYVs1XSArIFwiLCBcIiArIGFbNl0gKyBcIiwgXCIgKyBhWzddICsgXCIsIFwiICsgYVs4XSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCBhWzZdLCBhWzddLCBhWzhdKTtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQzJ3NcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgb3V0WzddID0gYVs3XSAtIGJbN107XG4gIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgb3V0WzZdID0gYVs2XSAqIGI7XG4gIG91dFs3XSA9IGFbN10gKiBiO1xuICBvdXRbOF0gPSBhWzhdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQzJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XSAqIHNjYWxlO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XSAqIHNjYWxlO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XSAqIHNjYWxlO1xuICBvdXRbN10gPSBhWzddICsgYls3XSAqIHNjYWxlO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF07XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdLFxuICAgICAgYTYgPSBhWzZdLFxuICAgICAgYTcgPSBhWzddLFxuICAgICAgYTggPSBhWzhdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdLFxuICAgICAgYjYgPSBiWzZdLFxuICAgICAgYjcgPSBiWzddLFxuICAgICAgYjggPSBiWzhdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiYgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJiBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcbnZhciBzdWIgPSBzdWJ0cmFjdDtcbmV4cG9ydHMuc3ViID0gc3ViOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyaW5ncykge1xyXG4gIGlmICh0eXBlb2Ygc3RyaW5ncyA9PT0gJ3N0cmluZycpIHN0cmluZ3MgPSBbc3RyaW5nc11cclxuICB2YXIgZXhwcnMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKVxyXG4gIHZhciBwYXJ0cyA9IFtdXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aC0xOyBpKyspIHtcclxuICAgIHBhcnRzLnB1c2goc3RyaW5nc1tpXSwgZXhwcnNbaV0gfHwgJycpXHJcbiAgfVxyXG4gIHBhcnRzLnB1c2goc3RyaW5nc1tpXSlcclxuICByZXR1cm4gcGFydHMuam9pbignJylcclxufVxyXG4iLCIvKiFcbiAqIEBsaWNlbnNlIHR3Z2wuanMgNC4xOS4xIENvcHlyaWdodCAoYykgMjAxNSwgR3JlZ2cgVGF2YXJlcyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogQXZhaWxhYmxlIHZpYSB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBzZWU6IGh0dHA6Ly9naXRodWIuY29tL2dyZWdnbWFuL3R3Z2wuanMgZm9yIGRldGFpbHNcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widHdnbFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJ0d2dsXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy90d2dsLWZ1bGwuanNcIik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIFwiLi9zcmMvYXR0cmlidXRlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2F0dHJpYnV0ZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNyZWF0ZUF0dHJpYnNGcm9tQXJyYXlzID0gY3JlYXRlQXR0cmlic0Zyb21BcnJheXM7XG5leHBvcnRzLmNyZWF0ZUJ1ZmZlcnNGcm9tQXJyYXlzID0gY3JlYXRlQnVmZmVyc0Zyb21BcnJheXM7XG5leHBvcnRzLmNyZWF0ZUJ1ZmZlckZyb21BcnJheSA9IGNyZWF0ZUJ1ZmZlckZyb21BcnJheTtcbmV4cG9ydHMuY3JlYXRlQnVmZmVyRnJvbVR5cGVkQXJyYXkgPSBjcmVhdGVCdWZmZXJGcm9tVHlwZWRBcnJheTtcbmV4cG9ydHMuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMgPSBjcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cztcbmV4cG9ydHMuc2V0QXR0cmliSW5mb0J1ZmZlckZyb21BcnJheSA9IHNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXk7XG5leHBvcnRzLnNldEF0dHJpYnV0ZVByZWZpeCA9IHNldEF0dHJpYnV0ZVByZWZpeDtcbmV4cG9ydHMuc2V0QXR0cmlidXRlRGVmYXVsdHNfID0gc2V0RGVmYXVsdHM7XG5leHBvcnRzLmdldE51bUNvbXBvbmVudHNfID0gZ2V0TnVtQ29tcG9uZW50cztcbmV4cG9ydHMuZ2V0QXJyYXlfID0gZ2V0QXJyYXk7XG5cbnZhciB0eXBlZEFycmF5cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHlwZWRhcnJheXMuanMgKi8gXCIuL3NyYy90eXBlZGFycmF5cy5qc1wiKSk7XG5cbnZhciBoZWxwZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hlbHBlci5qcyAqLyBcIi4vc3JjL2hlbHBlci5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbnZhciBTVEFUSUNfRFJBVyA9IDB4ODhlNDtcbnZhciBBUlJBWV9CVUZGRVIgPSAweDg4OTI7XG52YXIgRUxFTUVOVF9BUlJBWV9CVUZGRVIgPSAweDg4OTM7XG52YXIgQlVGRkVSX1NJWkUgPSAweDg3NjQ7XG52YXIgQllURSA9IDB4MTQwMDtcbnZhciBVTlNJR05FRF9CWVRFID0gMHgxNDAxO1xudmFyIFNIT1JUID0gMHgxNDAyO1xudmFyIFVOU0lHTkVEX1NIT1JUID0gMHgxNDAzO1xudmFyIElOVCA9IDB4MTQwNDtcbnZhciBVTlNJR05FRF9JTlQgPSAweDE0MDU7XG52YXIgRkxPQVQgPSAweDE0MDY7XG4vKipcbiAqIExvdyBsZXZlbCBhdHRyaWJ1dGUgYW5kIGJ1ZmZlciByZWxhdGVkIGZ1bmN0aW9uc1xuICpcbiAqIFlvdSBzaG91bGQgZ2VuZXJhbGx5IG5vdCBuZWVkIHRvIHVzZSB0aGVzZSBmdW5jdGlvbnMuIFRoZXkgYXJlIHByb3ZpZGVkXG4gKiBmb3IgdGhvc2UgY2FzZXMgd2hlcmUgeW91J3JlIGRvaW5nIHNvbWV0aGluZyBvdXQgb2YgdGhlIG9yZGluYXJ5XG4gKiBhbmQgeW91IG5lZWQgbG93ZXIgbGV2ZWwgYWNjZXNzLlxuICpcbiAqIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHRoZXkgYXJlIGF2YWlsYWJsZSBhdCBib3RoIGB0d2dsLmF0dHJpYnV0ZXNgIGFuZCBgdHdnbGBcbiAqIGl0c2VsZlxuICpcbiAqIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2x9IGZvciBjb3JlIGZ1bmN0aW9uc1xuICpcbiAqIEBtb2R1bGUgdHdnbC9hdHRyaWJ1dGVzXG4gKi9cbi8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBzZWUgYSBnbG9iYWwgZ2xcblxudmFyIGdsID0gdW5kZWZpbmVkO1xuLyogZXNsaW50LWRpc2FibGUtbGluZSAqL1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGF0dHJpYlByZWZpeDogXCJcIlxufTtcbi8qKlxuICogU2V0cyB0aGUgZGVmYXVsdCBhdHRyaWIgcHJlZml4XG4gKlxuICogV2hlbiB3cml0aW5nIHNoYWRlcnMgSSBwcmVmZXIgdG8gbmFtZSBhdHRyaWJ1dGVzIHdpdGggYGFfYCwgdW5pZm9ybXMgd2l0aCBgdV9gIGFuZCB2YXJ5aW5ncyB3aXRoIGB2X2BcbiAqIGFzIGl0IG1ha2VzIGl0IGNsZWFyIHdoZXJlIHRoZXkgY2FtZSBmcm9tLiBCdXQsIHdoZW4gYnVpbGRpbmcgZ2VvbWV0cnkgSSBwcmVmZXIgdXNpbmcgdW4tcHJlZml4ZWQgbmFtZXMuXG4gKlxuICogSW4gb3RoZXIgd29yZHMgSSdsbCBjcmVhdGUgYXJyYXlzIG9mIGdlb21ldHJ5IGxpa2UgdGhpc1xuICpcbiAqICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgcG9zaXRpb246IC4uLlxuICogICAgICAgbm9ybWFsOiAuLi5cbiAqICAgICAgIHRleGNvb3JkOiAuLi5cbiAqICAgICB9O1xuICpcbiAqIEJ1dCBuZWVkIHRob3NlIG1hcHBlZCB0byBhdHRyaWJ1dGVzIGFuZCBteSBhdHRyaWJ1dGVzIHN0YXJ0IHdpdGggYGFfYC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLnNldERlZmF1bHRzfVxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBwcmVmaXggZm9yIGF0dHJpYnNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9hdHRyaWJ1dGVzXG4gKi9cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlUHJlZml4KHByZWZpeCkge1xuICBkZWZhdWx0cy5hdHRyaWJQcmVmaXggPSBwcmVmaXg7XG59XG5cbmZ1bmN0aW9uIHNldERlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gIGhlbHBlci5jb3B5RXhpc3RpbmdQcm9wZXJ0aWVzKG5ld0RlZmF1bHRzLCBkZWZhdWx0cyk7XG59XG5cbmZ1bmN0aW9uIHNldEJ1ZmZlckZyb21UeXBlZEFycmF5KGdsLCB0eXBlLCBidWZmZXIsIGFycmF5LCBkcmF3VHlwZSkge1xuICBnbC5iaW5kQnVmZmVyKHR5cGUsIGJ1ZmZlcik7XG4gIGdsLmJ1ZmZlckRhdGEodHlwZSwgYXJyYXksIGRyYXdUeXBlIHx8IFNUQVRJQ19EUkFXKTtcbn1cbi8qKlxuICogR2l2ZW4gdHlwZWQgYXJyYXkgY3JlYXRlcyBhIFdlYkdMQnVmZmVyIGFuZCBjb3BpZXMgdGhlIHR5cGVkIGFycmF5XG4gKiBpbnRvIGl0LlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxTaGFyZWRBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd8V2ViR0xCdWZmZXJ9IHR5cGVkQXJyYXkgdGhlIHR5cGVkIGFycmF5LiBOb3RlOiBJZiBhIFdlYkdMQnVmZmVyIGlzIHBhc3NlZCBpbiBpdCB3aWxsIGp1c3QgYmUgcmV0dXJuZWQuIE5vIGFjdGlvbiB3aWxsIGJlIHRha2VuXG4gKiBAcGFyYW0ge251bWJlcn0gW3R5cGVdIHRoZSBHTCBiaW5kIHR5cGUgZm9yIHRoZSBidWZmZXIuIERlZmF1bHQgPSBgZ2wuQVJSQVlfQlVGRkVSYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZHJhd1R5cGVdIHRoZSBHTCBkcmF3IHR5cGUgZm9yIHRoZSBidWZmZXIuIERlZmF1bHQgPSAnZ2wuU1RBVElDX0RSQVdgLlxuICogQHJldHVybiB7V2ViR0xCdWZmZXJ9IHRoZSBjcmVhdGVkIFdlYkdMQnVmZmVyXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvYXR0cmlidXRlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIHR5cGVkQXJyYXksIHR5cGUsIGRyYXdUeXBlKSB7XG4gIGlmIChoZWxwZXIuaXNCdWZmZXIoZ2wsIHR5cGVkQXJyYXkpKSB7XG4gICAgcmV0dXJuIHR5cGVkQXJyYXk7XG4gIH1cblxuICB0eXBlID0gdHlwZSB8fCBBUlJBWV9CVUZGRVI7XG4gIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgc2V0QnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIHR5cGUsIGJ1ZmZlciwgdHlwZWRBcnJheSwgZHJhd1R5cGUpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBpc0luZGljZXMobmFtZSkge1xuICByZXR1cm4gbmFtZSA9PT0gXCJpbmRpY2VzXCI7XG59IC8vIFRoaXMgaXMgcmVhbGx5IGp1c3QgYSBndWVzcy4gVGhvdWdoIEkgY2FuJ3QgcmVhbGx5IGltYWdpbmUgdXNpbmdcbi8vIGFueXRoaW5nIGVsc2U/IE1heWJlIGZvciBzb21lIGNvbXByZXNzaW9uP1xuXG5cbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25Gb3JUeXBlZEFycmF5KHR5cGVkQXJyYXkpIHtcbiAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIFRoaXMgaXMgcmVhbGx5IGp1c3QgYSBndWVzcy4gVGhvdWdoIEkgY2FuJ3QgcmVhbGx5IGltYWdpbmUgdXNpbmdcbi8vIGFueXRoaW5nIGVsc2U/IE1heWJlIGZvciBzb21lIGNvbXByZXNzaW9uP1xuXG5cbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25Gb3JUeXBlZEFycmF5VHlwZSh0eXBlZEFycmF5VHlwZSkge1xuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IEludDhBcnJheSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5VHlwZSA9PT0gVWludDhBcnJheSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXkoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5Lmxlbmd0aCA/IGFycmF5IDogYXJyYXkuZGF0YTtcbn1cblxudmFyIHRleGNvb3JkUkUgPSAvY29vcmR8dGV4dHVyZS9pO1xudmFyIGNvbG9yUkUgPSAvY29sb3J8Y29sb3VyL2k7XG5cbmZ1bmN0aW9uIGd1ZXNzTnVtQ29tcG9uZW50c0Zyb21OYW1lKG5hbWUsIGxlbmd0aCkge1xuICB2YXIgbnVtQ29tcG9uZW50cztcblxuICBpZiAodGV4Y29vcmRSRS50ZXN0KG5hbWUpKSB7XG4gICAgbnVtQ29tcG9uZW50cyA9IDI7XG4gIH0gZWxzZSBpZiAoY29sb3JSRS50ZXN0KG5hbWUpKSB7XG4gICAgbnVtQ29tcG9uZW50cyA9IDQ7XG4gIH0gZWxzZSB7XG4gICAgbnVtQ29tcG9uZW50cyA9IDM7IC8vIHBvc2l0aW9uLCBub3JtYWxzLCBpbmRpY2VzIC4uLlxuICB9XG5cbiAgaWYgKGxlbmd0aCAlIG51bUNvbXBvbmVudHMgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBndWVzcyBudW1Db21wb25lbnRzIGZvciBhdHRyaWJ1dGUgJ1wiLmNvbmNhdChuYW1lLCBcIicuIFRyaWVkIFwiKS5jb25jYXQobnVtQ29tcG9uZW50cywgXCIgYnV0IFwiKS5jb25jYXQobGVuZ3RoLCBcIiB2YWx1ZXMgaXMgbm90IGV2ZW5seSBkaXZpc2libGUgYnkgXCIpLmNvbmNhdChudW1Db21wb25lbnRzLCBcIi4gWW91IHNob3VsZCBzcGVjaWZ5IGl0LlwiKSk7XG4gIH1cblxuICByZXR1cm4gbnVtQ29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gZ2V0TnVtQ29tcG9uZW50cyhhcnJheSwgYXJyYXlOYW1lKSB7XG4gIHJldHVybiBhcnJheS5udW1Db21wb25lbnRzIHx8IGFycmF5LnNpemUgfHwgZ3Vlc3NOdW1Db21wb25lbnRzRnJvbU5hbWUoYXJyYXlOYW1lLCBnZXRBcnJheShhcnJheSkubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gbWFrZVR5cGVkQXJyYXkoYXJyYXksIG5hbWUpIHtcbiAgaWYgKHR5cGVkQXJyYXlzLmlzQXJyYXlCdWZmZXIoYXJyYXkpKSB7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgaWYgKHR5cGVkQXJyYXlzLmlzQXJyYXlCdWZmZXIoYXJyYXkuZGF0YSkpIHtcbiAgICByZXR1cm4gYXJyYXkuZGF0YTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgIGFycmF5ID0ge1xuICAgICAgZGF0YTogYXJyYXlcbiAgICB9O1xuICB9XG5cbiAgdmFyIFR5cGUgPSBhcnJheS50eXBlO1xuXG4gIGlmICghVHlwZSkge1xuICAgIGlmIChpc0luZGljZXMobmFtZSkpIHtcbiAgICAgIFR5cGUgPSBVaW50MTZBcnJheTtcbiAgICB9IGVsc2Uge1xuICAgICAgVHlwZSA9IEZsb2F0MzJBcnJheTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFR5cGUoYXJyYXkuZGF0YSk7XG59XG4vKipcbiAqIFRoZSBpbmZvIGZvciBhbiBhdHRyaWJ1dGUuIFRoaXMgaXMgZWZmZWN0aXZlbHkganVzdCB0aGUgYXJndW1lbnRzIHRvIGBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyYCBwbHVzIHRoZSBXZWJHTEJ1ZmZlclxuICogZm9yIHRoZSBhdHRyaWJ1dGUuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQXR0cmliSW5mb1xuICogQHByb3BlcnR5IHtudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd9IFt2YWx1ZV0gYSBjb25zdGFudCB2YWx1ZSBmb3IgdGhlIGF0dHJpYnV0ZS4gTm90ZTogaWYgdGhpcyBpcyBzZXQgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlXG4gKiAgICBkaXNhYmxlZCBhbmQgc2V0IHRvIHRoaXMgY29uc3RhbnQgdmFsdWUgYW5kIGFsbCBvdGhlciB2YWx1ZXMgd2lsbCBiZSBpZ25vcmVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtudW1Db21wb25lbnRzXSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgZm9yIHRoaXMgYXR0cmlidXRlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplXSBzeW5vbnltIGZvciBgbnVtQ29tcG9uZW50c2AuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3R5cGVdIHRoZSB0eXBlIG9mIHRoZSBhdHRyaWJ1dGUgKGVnLiBgZ2wuRkxPQVRgLCBgZ2wuVU5TSUdORURfQllURWAsIGV0Yy4uLikgRGVmYXVsdCA9IGBnbC5GTE9BVGBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW25vcm1hbGl6ZV0gd2hldGhlciBvciBub3QgdG8gbm9ybWFsaXplIHRoZSBkYXRhLiBEZWZhdWx0ID0gZmFsc2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb2Zmc2V0XSBvZmZzZXQgaW50byBidWZmZXIgaW4gYnl0ZXMuIERlZmF1bHQgPSAwXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N0cmlkZV0gdGhlIHN0cmlkZSBpbiBieXRlcyBwZXIgZWxlbWVudC4gRGVmYXVsdCA9IDBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGl2aXNvcl0gdGhlIGRpdmlzb3IgaW4gaW5zdGFuY2VzLiBEZWZhdWx0ID0gdW5kZWZpbmVkLiBOb3RlOiB1bmRlZmluZWQgPSBkb24ndCBjYWxsIGdsLnZlcnRleEF0dHJpYkRpdmlzb3JcbiAqICAgIHdoZXJlIGFzIGFueXRoaW5nIGVsc2UgPSBkbyBjYWxsIGl0IHdpdGggdGhpcyB2YWx1ZVxuICogQHByb3BlcnR5IHtXZWJHTEJ1ZmZlcn0gYnVmZmVyIHRoZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgZGF0YSBmb3IgdGhpcyBhdHRyaWJ1dGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHJhd1R5cGVdIHRoZSBkcmF3IHR5cGUgcGFzc2VkIHRvIGdsLmJ1ZmZlckRhdGEuIERlZmF1bHQgPSBnbC5TVEFUSUNfRFJBV1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBVc2UgdGhpcyB0eXBlIG9mIGFycmF5IHNwZWMgd2hlbiBUV0dMIGNhbid0IGd1ZXNzIHRoZSB0eXBlIG9yIG51bWJlciBvZiBjb21wb25lbnRzIG9mIGFuIGFycmF5XG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGdWxsQXJyYXlTcGVjXG4gKiBAcHJvcGVydHkge251bWJlcltdfEFycmF5QnVmZmVyVmlld30gW3ZhbHVlXSBhIGNvbnN0YW50IHZhbHVlIGZvciB0aGUgYXR0cmlidXRlLiBOb3RlOiBpZiB0aGlzIGlzIHNldCB0aGUgYXR0cmlidXRlIHdpbGwgYmVcbiAqICAgIGRpc2FibGVkIGFuZCBzZXQgdG8gdGhpcyBjb25zdGFudCB2YWx1ZSBhbmQgYWxsIG90aGVyIHZhbHVlcyB3aWxsIGJlIGlnbm9yZWQuXG4gKiBAcHJvcGVydHkgeyhudW1iZXJ8bnVtYmVyW118QXJyYXlCdWZmZXJWaWV3KX0gZGF0YSBUaGUgZGF0YSBvZiB0aGUgYXJyYXkuIEEgbnVtYmVyIGFsb25lIGJlY29tZXMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiB0eXBlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtudW1Db21wb25lbnRzXSBudW1iZXIgb2YgY29tcG9uZW50cyBmb3IgYHZlcnRleEF0dHJpYlBvaW50ZXJgLiBEZWZhdWx0IGlzIGJhc2VkIG9uIHRoZSBuYW1lIG9mIHRoZSBhcnJheS5cbiAqICAgIElmIGBjb29yZGAgaXMgaW4gdGhlIG5hbWUgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDJgLlxuICogICAgSWYgYGNvbG9yYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gNGAuXG4gKiAgICBvdGhlcndpc2UgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDNgXG4gKiBAcHJvcGVydHkge2NvbnN0cnVjdG9yfSBbdHlwZV0gdHlwZS4gVGhpcyBpcyBvbmx5IHVzZWQgaWYgYGRhdGFgIGlzIGEgSmF2YVNjcmlwdCBhcnJheS4gSXQgaXMgdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZWRhcnJheS4gKGVnLiBgVWludDhBcnJheWApLlxuICogRm9yIGV4YW1wbGUgaWYgeW91IHdhbnQgY29sb3JzIGluIGEgYFVpbnQ4QXJyYXlgIHlvdSBtaWdodCBoYXZlIGEgYEZ1bGxBcnJheVNwZWNgIGxpa2UgYHsgdHlwZTogVWludDhBcnJheSwgZGF0YTogWzI1NSwwLDI1NSwyNTUsIC4uLl0sIH1gLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplXSBzeW5vbnltIGZvciBgbnVtQ29tcG9uZW50c2AuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtub3JtYWxpemVdIG5vcm1hbGl6ZSBmb3IgYHZlcnRleEF0dHJpYlBvaW50ZXJgLiBEZWZhdWx0IGlzIHRydWUgaWYgdHlwZSBpcyBgSW50OEFycmF5YCBvciBgVWludDhBcnJheWAgb3RoZXJ3aXNlIGZhbHNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzdHJpZGVdIHN0cmlkZSBmb3IgYHZlcnRleEF0dHJpYlBvaW50ZXJgLiBEZWZhdWx0ID0gMFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvZmZzZXRdIG9mZnNldCBmb3IgYHZlcnRleEF0dHJpYlBvaW50ZXJgLiBEZWZhdWx0ID0gMFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkaXZpc29yXSBkaXZpc29yIGZvciBgdmVydGV4QXR0cmliRGl2aXNvcmAuIERlZmF1bHQgPSB1bmRlZmluZWQuIE5vdGU6IHVuZGVmaW5lZCA9IGRvbid0IGNhbGwgZ2wudmVydGV4QXR0cmliRGl2aXNvclxuICogICAgd2hlcmUgYXMgYW55dGhpbmcgZWxzZSA9IGRvIGNhbGwgaXQgd2l0aCB0aGlzIHZhbHVlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2F0dHJpYl0gbmFtZSBvZiBhdHRyaWJ1dGUgdGhpcyBhcnJheSBtYXBzIHRvLiBEZWZhdWx0cyB0byBzYW1lIG5hbWUgYXMgYXJyYXkgcHJlZml4ZWQgYnkgdGhlIGRlZmF1bHQgYXR0cmliUHJlZml4LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBzeW5vbnltIGZvciBgYXR0cmliYC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXR0cmliTmFtZV0gc3lub255bSBmb3IgYGF0dHJpYmAuXG4gKiBAcHJvcGVydHkge1dlYkdMQnVmZmVyfSBbYnVmZmVyXSBCdWZmZXIgdG8gdXNlIGZvciB0aGlzIGF0dHJpYnV0ZS4gVGhpcyBsZXRzIHlvdSB1c2UgeW91ciBvd24gYnVmZmVyXG4gKiAgICBidXQgeW91IHdpbGwgbmVlZCB0byBzdXBwbHkgYG51bUNvbXBvbmVudHNgIGFuZCBgdHlwZWAuIFlvdSBjYW4gZWZmZWN0aXZlbHkgcGFzcyBhbiBgQXR0cmliSW5mb2BcbiAqICAgIHRvIHByb3ZpZGUgdGhpcy4gRXhhbXBsZTpcbiAqXG4gKiAgICAgICAgIGNvbnN0IGJ1ZmZlckluZm8xID0gdHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwge1xuICogICAgICAgICAgIHBvc2l0aW9uOiBbMSwgMiwgMywgLi4uIF0sXG4gKiAgICAgICAgIH0pO1xuICogICAgICAgICBjb25zdCBidWZmZXJJbmZvMiA9IHR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMoZ2wsIHtcbiAqICAgICAgICAgICBwb3NpdGlvbjogYnVmZmVySW5mbzEuYXR0cmlicy5wb3NpdGlvbiwgIC8vIHVzZSB0aGUgc2FtZSBidWZmZXIgZnJvbSBidWZmZXJJbmZvMVxuICogICAgICAgICB9KTtcbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEFuIGluZGl2aWR1YWwgYXJyYXkgaW4ge0BsaW5rIG1vZHVsZTp0d2dsLkFycmF5c31cbiAqXG4gKiBXaGVuIHBhc3NlZCB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXN9IGlmIGFuIEFycmF5U3BlYyBpcyBgbnVtYmVyW11gIG9yIGBBcnJheUJ1ZmZlclZpZXdgXG4gKiB0aGUgdHlwZXMgd2lsbCBiZSBndWVzc2VkIGJhc2VkIG9uIHRoZSBuYW1lLiBgaW5kaWNlc2Agd2lsbCBiZSBgVWludDE2QXJyYXlgLCBldmVyeXRoaW5nIGVsc2Ugd2lsbFxuICogYmUgYEZsb2F0MzJBcnJheWAuIElmIGFuIEFycmF5U3BlYyBpcyBhIG51bWJlciBpdCdzIHRoZSBudW1iZXIgb2YgZmxvYXRzIGZvciBhbiBlbXB0eSAoemVyb2VkKSBidWZmZXIuXG4gKlxuICogQHR5cGVkZWYgeyhudW1iZXJ8bnVtYmVyW118QXJyYXlCdWZmZXJWaWV3fG1vZHVsZTp0d2dsLkZ1bGxBcnJheVNwZWMpfSBBcnJheVNwZWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogVGhpcyBpcyBhIEphdmFTY3JpcHQgb2JqZWN0IG9mIGFycmF5cyBieSBuYW1lLiBUaGUgbmFtZXMgc2hvdWxkIG1hdGNoIHlvdXIgc2hhZGVyJ3MgYXR0cmlidXRlcy4gSWYgeW91clxuICogYXR0cmlidXRlcyBoYXZlIGEgY29tbW9uIHByZWZpeCB5b3UgY2FuIHNwZWNpZnkgaXQgYnkgY2FsbGluZyB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QXR0cmlidXRlUHJlZml4fS5cbiAqXG4gKiAgICAgQmFyZSBKYXZhU2NyaXB0IEFycmF5c1xuICpcbiAqICAgICAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICAgICAgcG9zaXRpb246IFstMSwgMSwgMF0sXG4gKiAgICAgICAgICAgIG5vcm1hbDogWzAsIDEsIDBdLFxuICogICAgICAgICAgICAuLi5cbiAqICAgICAgICAgfVxuICpcbiAqICAgICBCYXJlIFR5cGVkQXJyYXlzXG4gKlxuICogICAgICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgICAgICBwb3NpdGlvbjogbmV3IEZsb2F0MzJBcnJheShbLTEsIDEsIDBdKSxcbiAqICAgICAgICAgICAgY29sb3I6IG5ldyBVaW50OEFycmF5KFsyNTUsIDEyOCwgNjQsIDI1NV0pLFxuICogICAgICAgICAgICAuLi5cbiAqICAgICAgICAgfVxuICpcbiAqICogICBXaWxsIGd1ZXNzIGF0IGBudW1Db21wb25lbnRzYCBpZiBub3Qgc3BlY2lmaWVkIGJhc2VkIG9uIG5hbWUuXG4gKlxuICogICAgIElmIGBjb29yZGAgaXMgaW4gdGhlIG5hbWUgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDJgXG4gKlxuICogICAgIElmIGBjb2xvcmAgaXMgaW4gdGhlIG5hbWUgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDRgXG4gKlxuICogICAgIG90aGVyd2lzZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gM2BcbiAqXG4gKiBPYmplY3RzIHdpdGggdmFyaW91cyBmaWVsZHMuIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2wuRnVsbEFycmF5U3BlY30uXG4gKlxuICogICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICBwb3NpdGlvbjogeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdLCB9LFxuICogICAgICAgdGV4Y29vcmQ6IHsgbnVtQ29tcG9uZW50czogMiwgZGF0YTogWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdLCAgICAgICAgICAgICAgICAgfSxcbiAqICAgICAgIG5vcm1hbDogICB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSwgICAgIH0sXG4gKiAgICAgICBpbmRpY2VzOiAgeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMSwgMiwgMSwgMiwgM10sICAgICAgICAgICAgICAgICAgICAgICB9LFxuICogICAgIH07XG4gKlxuICogQHR5cGVkZWYge09iamVjdC48c3RyaW5nLCBtb2R1bGU6dHdnbC5BcnJheVNwZWM+fSBBcnJheXNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvZiBhdHRyaWJ1dGUgZGF0YSBhbmQgV2ViR0xCdWZmZXJzIGZyb20gc2V0IG9mIGFycmF5c1xuICpcbiAqIEdpdmVuXG4gKlxuICogICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgIHBvc2l0aW9uOiB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAwLCAwLCAxMCwgMCwgMCwgMCwgMTAsIDAsIDEwLCAxMCwgMF0sIH0sXG4gKiAgICAgICAgdGV4Y29vcmQ6IHsgbnVtQ29tcG9uZW50czogMiwgZGF0YTogWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdLCAgICAgICAgICAgICAgICAgfSxcbiAqICAgICAgICBub3JtYWw6ICAgeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMV0sICAgICB9LFxuICogICAgICAgIGNvbG9yOiAgICB7IG51bUNvbXBvbmVudHM6IDQsIGRhdGE6IFsyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMCwgMCwgMjU1LCAwLCAwLCAyNTUsIDI1NV0sIHR5cGU6IFVpbnQ4QXJyYXksIH0sXG4gKiAgICAgICAgaW5kaWNlczogIHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDEsIDIsIDEsIDIsIDNdLCAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAqICAgICAgfTtcbiAqXG4gKiByZXR1cm5zIHNvbWV0aGluZyBsaWtlXG4gKlxuICogICAgICB2YXIgYXR0cmlicyA9IHtcbiAqICAgICAgICBwb3NpdGlvbjogeyBudW1Db21wb25lbnRzOiAzLCB0eXBlOiBnbC5GTE9BVCwgICAgICAgICBub3JtYWxpemU6IGZhbHNlLCBidWZmZXI6IFdlYkdMQnVmZmVyLCB9LFxuICogICAgICAgIHRleGNvb3JkOiB7IG51bUNvbXBvbmVudHM6IDIsIHR5cGU6IGdsLkZMT0FULCAgICAgICAgIG5vcm1hbGl6ZTogZmFsc2UsIGJ1ZmZlcjogV2ViR0xCdWZmZXIsIH0sXG4gKiAgICAgICAgbm9ybWFsOiAgIHsgbnVtQ29tcG9uZW50czogMywgdHlwZTogZ2wuRkxPQVQsICAgICAgICAgbm9ybWFsaXplOiBmYWxzZSwgYnVmZmVyOiBXZWJHTEJ1ZmZlciwgfSxcbiAqICAgICAgICBjb2xvcjogICAgeyBudW1Db21wb25lbnRzOiA0LCB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLCBub3JtYWxpemU6IHRydWUsICBidWZmZXI6IFdlYkdMQnVmZmVyLCB9LFxuICogICAgICB9O1xuICpcbiAqIG5vdGVzOlxuICpcbiAqICogICBBcnJheXMgY2FuIHRha2UgdmFyaW91cyBmb3Jtc1xuICpcbiAqICAgICBCYXJlIEphdmFTY3JpcHQgQXJyYXlzXG4gKlxuICogICAgICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgICAgICBwb3NpdGlvbjogWy0xLCAxLCAwXSxcbiAqICAgICAgICAgICAgbm9ybWFsOiBbMCwgMSwgMF0sXG4gKiAgICAgICAgICAgIC4uLlxuICogICAgICAgICB9XG4gKlxuICogICAgIEJhcmUgVHlwZWRBcnJheXNcbiAqXG4gKiAgICAgICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgRmxvYXQzMkFycmF5KFstMSwgMSwgMF0pLFxuICogICAgICAgICAgICBjb2xvcjogbmV3IFVpbnQ4QXJyYXkoWzI1NSwgMTI4LCA2NCwgMjU1XSksXG4gKiAgICAgICAgICAgIC4uLlxuICogICAgICAgICB9XG4gKlxuICogKiAgIFdpbGwgZ3Vlc3MgYXQgYG51bUNvbXBvbmVudHNgIGlmIG5vdCBzcGVjaWZpZWQgYmFzZWQgb24gbmFtZS5cbiAqXG4gKiAgICAgSWYgYGNvb3JkYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gMmBcbiAqXG4gKiAgICAgSWYgYGNvbG9yYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gNGBcbiAqXG4gKiAgICAgb3RoZXJ3aXNlIGFzc3VtZXMgYG51bUNvbXBvbmVudHMgPSAzYFxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgd2ViZ2wgcmVuZGVyaW5nIGNvbnRleHQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkFycmF5c30gYXJyYXlzIFRoZSBhcnJheXNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gW3NyY0J1ZmZlckluZm9dIGEgQnVmZmVySW5mbyB0byBjb3B5IGZyb21cbiAqICAgVGhpcyBsZXRzIHlvdSBzaGFyZSBidWZmZXJzLiBBbnkgYXJyYXlzIHlvdSBzdXBwbHkgd2lsbCBvdmVycmlkZVxuICogICB0aGUgYnVmZmVycyBmcm9tIHNyY0J1ZmZlckluZm8uXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnR3Z2wuQXR0cmliSW5mbz59IHRoZSBhdHRyaWJzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvYXR0cmlidXRlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQXR0cmlic0Zyb21BcnJheXMoZ2wsIGFycmF5cykge1xuICB2YXIgYXR0cmlicyA9IHt9O1xuICBPYmplY3Qua2V5cyhhcnJheXMpLmZvckVhY2goZnVuY3Rpb24gKGFycmF5TmFtZSkge1xuICAgIGlmICghaXNJbmRpY2VzKGFycmF5TmFtZSkpIHtcbiAgICAgIHZhciBhcnJheSA9IGFycmF5c1thcnJheU5hbWVdO1xuICAgICAgdmFyIGF0dHJpYk5hbWUgPSBhcnJheS5hdHRyaWIgfHwgYXJyYXkubmFtZSB8fCBhcnJheS5hdHRyaWJOYW1lIHx8IGRlZmF1bHRzLmF0dHJpYlByZWZpeCArIGFycmF5TmFtZTtcblxuICAgICAgaWYgKGFycmF5LnZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheS52YWx1ZSkgJiYgIXR5cGVkQXJyYXlzLmlzQXJyYXlCdWZmZXIoYXJyYXkudmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheS52YWx1ZSBpcyBub3QgYXJyYXkgb3IgdHlwZWRhcnJheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlic1thdHRyaWJOYW1lXSA9IHtcbiAgICAgICAgICB2YWx1ZTogYXJyYXkudmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgIHZhciB0eXBlO1xuICAgICAgICB2YXIgbm9ybWFsaXphdGlvbjtcbiAgICAgICAgdmFyIG51bUNvbXBvbmVudHM7XG5cbiAgICAgICAgaWYgKGFycmF5LmJ1ZmZlciAmJiBhcnJheS5idWZmZXIgaW5zdGFuY2VvZiBXZWJHTEJ1ZmZlcikge1xuICAgICAgICAgIGJ1ZmZlciA9IGFycmF5LmJ1ZmZlcjtcbiAgICAgICAgICBudW1Db21wb25lbnRzID0gYXJyYXkubnVtQ29tcG9uZW50cyB8fCBhcnJheS5zaXplO1xuICAgICAgICAgIHR5cGUgPSBhcnJheS50eXBlO1xuICAgICAgICAgIG5vcm1hbGl6YXRpb24gPSBhcnJheS5ub3JtYWxpemU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFycmF5ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBhcnJheS5kYXRhID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdmFyIG51bVZhbHVlcyA9IGFycmF5LmRhdGEgfHwgYXJyYXk7XG4gICAgICAgICAgdmFyIGFycmF5VHlwZSA9IGFycmF5LnR5cGUgfHwgRmxvYXQzMkFycmF5O1xuICAgICAgICAgIHZhciBudW1CeXRlcyA9IG51bVZhbHVlcyAqIGFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgICB0eXBlID0gdHlwZWRBcnJheXMuZ2V0R0xUeXBlRm9yVHlwZWRBcnJheVR5cGUoYXJyYXlUeXBlKTtcbiAgICAgICAgICBub3JtYWxpemF0aW9uID0gYXJyYXkubm9ybWFsaXplICE9PSB1bmRlZmluZWQgPyBhcnJheS5ub3JtYWxpemUgOiBnZXROb3JtYWxpemF0aW9uRm9yVHlwZWRBcnJheVR5cGUoYXJyYXlUeXBlKTtcbiAgICAgICAgICBudW1Db21wb25lbnRzID0gYXJyYXkubnVtQ29tcG9uZW50cyB8fCBhcnJheS5zaXplIHx8IGd1ZXNzTnVtQ29tcG9uZW50c0Zyb21OYW1lKGFycmF5TmFtZSwgbnVtVmFsdWVzKTtcbiAgICAgICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICBnbC5iaW5kQnVmZmVyKEFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgICAgICBnbC5idWZmZXJEYXRhKEFSUkFZX0JVRkZFUiwgbnVtQnl0ZXMsIGFycmF5LmRyYXdUeXBlIHx8IFNUQVRJQ19EUkFXKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZWRBcnJheSA9IG1ha2VUeXBlZEFycmF5KGFycmF5LCBhcnJheU5hbWUpO1xuICAgICAgICAgIGJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlckZyb21UeXBlZEFycmF5KGdsLCB0eXBlZEFycmF5LCB1bmRlZmluZWQsIGFycmF5LmRyYXdUeXBlKTtcbiAgICAgICAgICB0eXBlID0gdHlwZWRBcnJheXMuZ2V0R0xUeXBlRm9yVHlwZWRBcnJheSh0eXBlZEFycmF5KTtcbiAgICAgICAgICBub3JtYWxpemF0aW9uID0gYXJyYXkubm9ybWFsaXplICE9PSB1bmRlZmluZWQgPyBhcnJheS5ub3JtYWxpemUgOiBnZXROb3JtYWxpemF0aW9uRm9yVHlwZWRBcnJheSh0eXBlZEFycmF5KTtcbiAgICAgICAgICBudW1Db21wb25lbnRzID0gZ2V0TnVtQ29tcG9uZW50cyhhcnJheSwgYXJyYXlOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnNbYXR0cmliTmFtZV0gPSB7XG4gICAgICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICAgICAgbnVtQ29tcG9uZW50czogbnVtQ29tcG9uZW50cyxcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIG5vcm1hbGl6ZTogbm9ybWFsaXphdGlvbixcbiAgICAgICAgICBzdHJpZGU6IGFycmF5LnN0cmlkZSB8fCAwLFxuICAgICAgICAgIG9mZnNldDogYXJyYXkub2Zmc2V0IHx8IDAsXG4gICAgICAgICAgZGl2aXNvcjogYXJyYXkuZGl2aXNvciA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogYXJyYXkuZGl2aXNvcixcbiAgICAgICAgICBkcmF3VHlwZTogYXJyYXkuZHJhd1R5cGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBnbC5iaW5kQnVmZmVyKEFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gIHJldHVybiBhdHRyaWJzO1xufVxuLyoqXG4gKiBTZXRzIHRoZSBjb250ZW50cyBvZiBhIGJ1ZmZlciBhdHRhY2hlZCB0byBhbiBhdHRyaWJJbmZvXG4gKlxuICogVGhpcyBpcyBoZWxwZXIgZnVuY3Rpb24gdG8gZHluYW1pY2FsbHkgdXBkYXRlIGEgYnVmZmVyLlxuICpcbiAqIExldCdzIHNheSB5b3UgbWFrZSBhIGJ1ZmZlckluZm9cbiAqXG4gKiAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICBwb3NpdGlvbjogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdKSxcbiAqICAgICAgICB0ZXhjb29yZDogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0pLFxuICogICAgICAgIG5vcm1hbDogICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSksXG4gKiAgICAgICAgaW5kaWNlczogIG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMSwgMiwgM10pLFxuICogICAgIH07XG4gKiAgICAgdmFyIGJ1ZmZlckluZm8gPSB0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzKGdsLCBhcnJheXMpO1xuICpcbiAqICBBbmQgeW91IHdhbnQgdG8gZHluYW1pY2FsbHkgdXBkYXRlIHRoZSBwb3NpdGlvbnMuIFlvdSBjb3VsZCBkbyB0aGlzXG4gKlxuICogICAgIC8vIGFzc3VtaW5nIGFycmF5cy5wb3NpdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWQgd2l0aCBuZXcgZGF0YS5cbiAqICAgICB0d2dsLnNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXkoZ2wsIGJ1ZmZlckluZm8uYXR0cmlicy5wb3NpdGlvbiwgYXJyYXlzLnBvc2l0aW9uKTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAqIEBwYXJhbSB7QXR0cmliSW5mb30gYXR0cmliSW5mbyBUaGUgYXR0cmliSW5mbyB3aG8ncyBidWZmZXIgY29udGVudHMgdG8gc2V0LiBOT1RFOiBJZiB5b3UgaGF2ZSBhbiBhdHRyaWJ1dGUgcHJlZml4XG4gKiAgIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgd2lsbCBpbmNsdWRlIHRoZSBwcmVmaXguXG4gKiBAcGFyYW0ge0FycmF5U3BlY30gYXJyYXkgTm90ZTogaXQgaXMgYXJndWFibHkgaW5lZmZpY2llbnQgdG8gcGFzcyBpbiBhbnl0aGluZyBidXQgYSB0eXBlZCBhcnJheSBiZWNhdXNlIGFueXRoaW5nXG4gKiAgICBlbHNlIHdpbGwgaGF2ZSB0byBiZSBjb252ZXJ0ZWQgdG8gYSB0eXBlZCBhcnJheSBiZWZvcmUgaXQgY2FuIGJlIHVzZWQgYnkgV2ViR0wuIER1cmluZyBpbml0IHRpbWUgdGhhdFxuICogICAgaW5lZmZpY2llbmN5IGlzIHVzdWFsbHkgbm90IGltcG9ydGFudCBidXQgaWYgeW91J3JlIHVwZGF0aW5nIGRhdGEgZHluYW1pY2FsbHkgYmVzdCB0byBiZSBlZmZpY2llbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29mZnNldF0gYW4gb3B0aW9uYWwgb2Zmc2V0IGludG8gdGhlIGJ1ZmZlci4gVGhpcyBpcyBvbmx5IGFuIG9mZnNldCBpbnRvIHRoZSBXZWJHTCBidWZmZXJcbiAqICAgIG5vdCB0aGUgYXJyYXkuIFRvIHBhc3MgaW4gYW4gb2Zmc2V0IGludG8gdGhlIGFycmF5IGl0c2VsZiB1c2UgYSB0eXBlZCBhcnJheSBhbmQgY3JlYXRlIGFuIGBBcnJheUJ1ZmZlclZpZXdgXG4gKiAgICBmb3IgdGhlIHBvcnRpb24gb2YgdGhlIGFycmF5IHlvdSB3YW50IHRvIHVzZS5cbiAqXG4gKiAgICAgICAgdmFyIHNvbWVBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMTAwMCk7IC8vIGFuIGFycmF5IHdpdGggMTAwMCBmbG9hdHNcbiAqICAgICAgICB2YXIgc29tZVN1YkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShzb21lQXJyYXkuYnVmZmVyLCBvZmZzZXRJbkJ5dGVzLCBzaXplSW5Vbml0cyk7IC8vIGEgdmlldyBpbnRvIHNvbWVBcnJheVxuICpcbiAqICAgIE5vdyB5b3UgY2FuIHBhc3MgYHNvbWVTdWJBcnJheWAgaW50byBzZXRBdHRyaWJJbmZvQnVmZmVyRnJvbUFycmF5YFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXkoZ2wsIGF0dHJpYkluZm8sIGFycmF5LCBvZmZzZXQpIHtcbiAgYXJyYXkgPSBtYWtlVHlwZWRBcnJheShhcnJheSk7XG5cbiAgaWYgKG9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2wuYmluZEJ1ZmZlcihBUlJBWV9CVUZGRVIsIGF0dHJpYkluZm8uYnVmZmVyKTtcbiAgICBnbC5idWZmZXJTdWJEYXRhKEFSUkFZX0JVRkZFUiwgb2Zmc2V0LCBhcnJheSk7XG4gIH0gZWxzZSB7XG4gICAgc2V0QnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIEFSUkFZX0JVRkZFUiwgYXR0cmliSW5mby5idWZmZXIsIGFycmF5LCBhdHRyaWJJbmZvLmRyYXdUeXBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCeXRlc1BlclZhbHVlRm9yR0xUeXBlKGdsLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSBCWVRFKSByZXR1cm4gMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlID09PSBVTlNJR05FRF9CWVRFKSByZXR1cm4gMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlID09PSBTSE9SVCkgcmV0dXJuIDI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZSA9PT0gVU5TSUdORURfU0hPUlQpIHJldHVybiAyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKHR5cGUgPT09IElOVCkgcmV0dXJuIDQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZSA9PT0gVU5TSUdORURfSU5UKSByZXR1cm4gNDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlID09PSBGTE9BVCkgcmV0dXJuIDQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICByZXR1cm4gMDtcbn0gLy8gVHJpZXMgdG8gZ2V0IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSBhIHNldCBvZiBhcnJheXMuXG5cblxudmFyIHBvc2l0aW9uS2V5cyA9IFsncG9zaXRpb24nLCAncG9zaXRpb25zJywgJ2FfcG9zaXRpb24nXTtcblxuZnVuY3Rpb24gZ2V0TnVtRWxlbWVudHNGcm9tTm9uSW5kZXhlZEFycmF5cyhhcnJheXMpIHtcbiAgdmFyIGtleTtcbiAgdmFyIGlpO1xuXG4gIGZvciAoaWkgPSAwOyBpaSA8IHBvc2l0aW9uS2V5cy5sZW5ndGg7ICsraWkpIHtcbiAgICBrZXkgPSBwb3NpdGlvbktleXNbaWldO1xuXG4gICAgaWYgKGtleSBpbiBhcnJheXMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpaSA9PT0gcG9zaXRpb25LZXlzLmxlbmd0aCkge1xuICAgIGtleSA9IE9iamVjdC5rZXlzKGFycmF5cylbMF07XG4gIH1cblxuICB2YXIgYXJyYXkgPSBhcnJheXNba2V5XTtcbiAgdmFyIGxlbmd0aCA9IGdldEFycmF5KGFycmF5KS5sZW5ndGg7XG4gIHZhciBudW1Db21wb25lbnRzID0gZ2V0TnVtQ29tcG9uZW50cyhhcnJheSwga2V5KTtcbiAgdmFyIG51bUVsZW1lbnRzID0gbGVuZ3RoIC8gbnVtQ29tcG9uZW50cztcblxuICBpZiAobGVuZ3RoICUgbnVtQ29tcG9uZW50cyA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJudW1Db21wb25lbnRzIFwiLmNvbmNhdChudW1Db21wb25lbnRzLCBcIiBub3QgY29ycmVjdCBmb3IgbGVuZ3RoIFwiKS5jb25jYXQobGVuZ3RoKSk7XG4gIH1cblxuICByZXR1cm4gbnVtRWxlbWVudHM7XG59XG5cbmZ1bmN0aW9uIGdldE51bUVsZW1lbnRzRnJvbUF0dHJpYnV0ZXMoZ2wsIGF0dHJpYnMpIHtcbiAgdmFyIGtleTtcbiAgdmFyIGlpO1xuXG4gIGZvciAoaWkgPSAwOyBpaSA8IHBvc2l0aW9uS2V5cy5sZW5ndGg7ICsraWkpIHtcbiAgICBrZXkgPSBwb3NpdGlvbktleXNbaWldO1xuXG4gICAgaWYgKGtleSBpbiBhdHRyaWJzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBrZXkgPSBkZWZhdWx0cy5hdHRyaWJQcmVmaXggKyBrZXk7XG5cbiAgICBpZiAoa2V5IGluIGF0dHJpYnMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpaSA9PT0gcG9zaXRpb25LZXlzLmxlbmd0aCkge1xuICAgIGtleSA9IE9iamVjdC5rZXlzKGF0dHJpYnMpWzBdO1xuICB9XG5cbiAgdmFyIGF0dHJpYiA9IGF0dHJpYnNba2V5XTtcbiAgZ2wuYmluZEJ1ZmZlcihBUlJBWV9CVUZGRVIsIGF0dHJpYi5idWZmZXIpO1xuICB2YXIgbnVtQnl0ZXMgPSBnbC5nZXRCdWZmZXJQYXJhbWV0ZXIoQVJSQVlfQlVGRkVSLCBCVUZGRVJfU0laRSk7XG4gIGdsLmJpbmRCdWZmZXIoQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgdmFyIGJ5dGVzUGVyVmFsdWUgPSBnZXRCeXRlc1BlclZhbHVlRm9yR0xUeXBlKGdsLCBhdHRyaWIudHlwZSk7XG4gIHZhciB0b3RhbEVsZW1lbnRzID0gbnVtQnl0ZXMgLyBieXRlc1BlclZhbHVlO1xuICB2YXIgbnVtQ29tcG9uZW50cyA9IGF0dHJpYi5udW1Db21wb25lbnRzIHx8IGF0dHJpYi5zaXplOyAvLyBUT0RPOiBjaGVjayBzdHJpZGVcblxuICB2YXIgbnVtRWxlbWVudHMgPSB0b3RhbEVsZW1lbnRzIC8gbnVtQ29tcG9uZW50cztcblxuICBpZiAobnVtRWxlbWVudHMgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibnVtQ29tcG9uZW50cyBcIi5jb25jYXQobnVtQ29tcG9uZW50cywgXCIgbm90IGNvcnJlY3QgZm9yIGxlbmd0aCBcIikuY29uY2F0KGxlbmd0aCkpO1xuICB9XG5cbiAgcmV0dXJuIG51bUVsZW1lbnRzO1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCdWZmZXJJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gbnVtRWxlbWVudHMgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBwYXNzIHRvIGBnbC5kcmF3QXJyYXlzYCBvciBgZ2wuZHJhd0VsZW1lbnRzYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZWxlbWVudFR5cGVdIFRoZSB0eXBlIG9mIGluZGljZXMgYFVOU0lHTkVEX0JZVEVgLCBgVU5TSUdORURfU0hPUlRgIGV0Yy4uXG4gKiBAcHJvcGVydHkge1dlYkdMQnVmZmVyfSBbaW5kaWNlc10gVGhlIGluZGljZXMgYEVMRU1FTlRfQVJSQVlfQlVGRkVSYCBpZiBhbnkgaW5kaWNlcyBleGlzdC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkF0dHJpYkluZm8+fSBbYXR0cmlic10gVGhlIGF0dHJpYnMgYXBwcm9wcmlhdGUgdG8gY2FsbCBgc2V0QXR0cmlidXRlc2BcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIEJ1ZmZlckluZm8gZnJvbSBhbiBvYmplY3Qgb2YgYXJyYXlzLlxuICpcbiAqIFRoaXMgY2FuIGJlIHBhc3NlZCB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXN9IGFuZCB0b1xuICoge0BsaW5rIG1vZHVsZTp0d2dsOmRyYXdCdWZmZXJJbmZvfS5cbiAqXG4gKiBHaXZlbiBhbiBvYmplY3QgbGlrZVxuICpcbiAqICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgcG9zaXRpb246IHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDAsIDAsIDEwLCAwLCAwLCAwLCAxMCwgMCwgMTAsIDEwLCAwXSwgfSxcbiAqICAgICAgIHRleGNvb3JkOiB7IG51bUNvbXBvbmVudHM6IDIsIGRhdGE6IFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSwgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgICBub3JtYWw6ICAgeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMV0sICAgICB9LFxuICogICAgICAgaW5kaWNlczogIHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDEsIDIsIDEsIDIsIDNdLCAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAqICAgICB9O1xuICpcbiAqICBDcmVhdGVzIGFuIEJ1ZmZlckluZm8gbGlrZSB0aGlzXG4gKlxuICogICAgIGJ1ZmZlckluZm8gPSB7XG4gKiAgICAgICBudW1FbGVtZW50czogNCwgICAgICAgIC8vIG9yIHdoYXRldmVyIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaXNcbiAqICAgICAgIGluZGljZXM6IFdlYkdMQnVmZmVyLCAgLy8gdGhpcyBwcm9wZXJ0eSB3aWxsIG5vdCBleGlzdCBpZiB0aGVyZSBhcmUgbm8gaW5kaWNlc1xuICogICAgICAgYXR0cmliczoge1xuICogICAgICAgICBwb3NpdGlvbjogeyBidWZmZXI6IFdlYkdMQnVmZmVyLCBudW1Db21wb25lbnRzOiAzLCB9LFxuICogICAgICAgICBub3JtYWw6ICAgeyBidWZmZXI6IFdlYkdMQnVmZmVyLCBudW1Db21wb25lbnRzOiAzLCB9LFxuICogICAgICAgICB0ZXhjb29yZDogeyBidWZmZXI6IFdlYkdMQnVmZmVyLCBudW1Db21wb25lbnRzOiAyLCB9LFxuICogICAgICAgfSxcbiAqICAgICB9O1xuICpcbiAqICBUaGUgcHJvcGVydGllcyBvZiBhcnJheXMgY2FuIGJlIEphdmFTY3JpcHQgYXJyYXlzIGluIHdoaWNoIGNhc2UgdGhlIG51bWJlciBvZiBjb21wb25lbnRzXG4gKiAgd2lsbCBiZSBndWVzc2VkLlxuICpcbiAqICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgIHBvc2l0aW9uOiBbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdLFxuICogICAgICAgIHRleGNvb3JkOiBbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0sXG4gKiAgICAgICAgbm9ybWFsOiAgIFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSxcbiAqICAgICAgICBpbmRpY2VzOiAgWzAsIDEsIDIsIDEsIDIsIDNdLFxuICogICAgIH07XG4gKlxuICogIFRoZXkgY2FuIGFsc28gYmUgVHlwZWRBcnJheXNcbiAqXG4gKiAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICBwb3NpdGlvbjogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdKSxcbiAqICAgICAgICB0ZXhjb29yZDogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0pLFxuICogICAgICAgIG5vcm1hbDogICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSksXG4gKiAgICAgICAgaW5kaWNlczogIG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMSwgMiwgM10pLFxuICogICAgIH07XG4gKlxuICogIE9yIEF1Z21lbnRlZFR5cGVkQXJyYXlzXG4gKlxuICogICAgIHZhciBwb3NpdGlvbnMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIDQpO1xuICogICAgIHZhciB0ZXhjb29yZHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsIDQpO1xuICogICAgIHZhciBub3JtYWxzICAgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIDQpO1xuICogICAgIHZhciBpbmRpY2VzICAgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIDIsIFVpbnQxNkFycmF5KTtcbiAqXG4gKiAgICAgcG9zaXRpb25zLnB1c2goWzAsIDAsIDAsIDEwLCAwLCAwLCAwLCAxMCwgMCwgMTAsIDEwLCAwXSk7XG4gKiAgICAgdGV4Y29vcmRzLnB1c2goWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdKTtcbiAqICAgICBub3JtYWxzLnB1c2goWzAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdKTtcbiAqICAgICBpbmRpY2VzLnB1c2goWzAsIDEsIDIsIDEsIDIsIDNdKTtcbiAqXG4gKiAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICogICAgICAgIHRleGNvb3JkOiB0ZXhjb29yZHMsXG4gKiAgICAgICAgbm9ybWFsOiAgIG5vcm1hbHMsXG4gKiAgICAgICAgaW5kaWNlczogIGluZGljZXMsXG4gKiAgICAgfTtcbiAqXG4gKiBGb3IgdGhlIGxhc3QgZXhhbXBsZSBpdCBpcyBlcXVpdmFsZW50IHRvXG4gKlxuICogICAgIHZhciBidWZmZXJJbmZvID0ge1xuICogICAgICAgYXR0cmliczoge1xuICogICAgICAgICBwb3NpdGlvbjogeyBudW1Db21wb25lbnRzOiAzLCBidWZmZXI6IGdsLmNyZWF0ZUJ1ZmZlcigpLCB9LFxuICogICAgICAgICB0ZXhjb29yZDogeyBudW1Db21wb25lbnRzOiAyLCBidWZmZXI6IGdsLmNyZWF0ZUJ1ZmZlcigpLCB9LFxuICogICAgICAgICBub3JtYWw6IHsgbnVtQ29tcG9uZW50czogMywgYnVmZmVyOiBnbC5jcmVhdGVCdWZmZXIoKSwgfSxcbiAqICAgICAgIH0sXG4gKiAgICAgICBpbmRpY2VzOiBnbC5jcmVhdGVCdWZmZXIoKSxcbiAqICAgICAgIG51bUVsZW1lbnRzOiA2LFxuICogICAgIH07XG4gKlxuICogICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJJbmZvLmF0dHJpYnMucG9zaXRpb24uYnVmZmVyKTtcbiAqICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYXJyYXlzLnBvc2l0aW9uLCBnbC5TVEFUSUNfRFJBVyk7XG4gKiAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlckluZm8uYXR0cmlicy50ZXhjb29yZC5idWZmZXIpO1xuICogICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhcnJheXMudGV4Y29vcmQsIGdsLlNUQVRJQ19EUkFXKTtcbiAqICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVySW5mby5hdHRyaWJzLm5vcm1hbC5idWZmZXIpO1xuICogICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhcnJheXMubm9ybWFsLCBnbC5TVEFUSUNfRFJBVyk7XG4gKiAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnVmZmVySW5mby5pbmRpY2VzKTtcbiAqICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBhcnJheXMuaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5BcnJheXN9IGFycmF5cyBZb3VyIGRhdGFcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gW3NyY0J1ZmZlckluZm9dIEFuIGV4aXN0aW5nXG4gKiAgICAgICAgYnVmZmVyIGluZm8gdG8gc3RhcnQgZnJvbS4gV2ViR0xCdWZmZXJzIGV0YyBzcGVjaWZpZWRcbiAqICAgICAgICBpbiB0aGUgc3JjQnVmZmVySW5mbyB3aWxsIGJlIHVzZWQgaW4gYSBuZXcgQnVmZmVySW5mb1xuICogICAgICAgIHdpdGggYW55IGFycmF5cyBzcGVjaWZpZWQgb3ZlcnJpZGluZyB0aGUgb25lcyBpblxuICogICAgICAgIHNyY0J1ZmZlckluZm8uXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBBIEJ1ZmZlckluZm9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9hdHRyaWJ1dGVzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwgYXJyYXlzLCBzcmNCdWZmZXJJbmZvKSB7XG4gIHZhciBuZXdBdHRyaWJzID0gY3JlYXRlQXR0cmlic0Zyb21BcnJheXMoZ2wsIGFycmF5cyk7XG4gIHZhciBidWZmZXJJbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgc3JjQnVmZmVySW5mbyA/IHNyY0J1ZmZlckluZm8gOiB7fSk7XG4gIGJ1ZmZlckluZm8uYXR0cmlicyA9IE9iamVjdC5hc3NpZ24oe30sIHNyY0J1ZmZlckluZm8gPyBzcmNCdWZmZXJJbmZvLmF0dHJpYnMgOiB7fSwgbmV3QXR0cmlicyk7XG4gIHZhciBpbmRpY2VzID0gYXJyYXlzLmluZGljZXM7XG5cbiAgaWYgKGluZGljZXMpIHtcbiAgICB2YXIgbmV3SW5kaWNlcyA9IG1ha2VUeXBlZEFycmF5KGluZGljZXMsIFwiaW5kaWNlc1wiKTtcbiAgICBidWZmZXJJbmZvLmluZGljZXMgPSBjcmVhdGVCdWZmZXJGcm9tVHlwZWRBcnJheShnbCwgbmV3SW5kaWNlcywgRUxFTUVOVF9BUlJBWV9CVUZGRVIpO1xuICAgIGJ1ZmZlckluZm8ubnVtRWxlbWVudHMgPSBuZXdJbmRpY2VzLmxlbmd0aDtcbiAgICBidWZmZXJJbmZvLmVsZW1lbnRUeXBlID0gdHlwZWRBcnJheXMuZ2V0R0xUeXBlRm9yVHlwZWRBcnJheShuZXdJbmRpY2VzKTtcbiAgfSBlbHNlIGlmICghYnVmZmVySW5mby5udW1FbGVtZW50cykge1xuICAgIGJ1ZmZlckluZm8ubnVtRWxlbWVudHMgPSBnZXROdW1FbGVtZW50c0Zyb21BdHRyaWJ1dGVzKGdsLCBidWZmZXJJbmZvLmF0dHJpYnMpO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlckluZm87XG59XG4vKipcbiAqIENyZWF0ZXMgYSBidWZmZXIgZnJvbSBhbiBhcnJheSwgdHlwZWQgYXJyYXksIG9yIGFycmF5IHNwZWNcbiAqXG4gKiBHaXZlbiBzb21ldGhpbmcgbGlrZSB0aGlzXG4gKlxuICogICAgIFsxLCAyLCAzXSxcbiAqXG4gKiBvclxuICpcbiAqICAgICBuZXcgVWludDE2QXJyYXkoWzEsMiwzXSk7XG4gKlxuICogb3JcbiAqXG4gKiAgICAge1xuICogICAgICAgIGRhdGE6IFsxLCAyLCAzXSxcbiAqICAgICAgICB0eXBlOiBVaW50OEFycmF5LFxuICogICAgIH1cbiAqXG4gKiByZXR1cm5zIGEgV2ViR0xCdWZmZXIgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkFycmF5U3BlY30gYXJyYXkgYW4gYXJyYXksIHR5cGVkIGFycmF5LCBvciBhcnJheSBzcGVjLlxuICogQHBhcmFtIHtzdHJpbmd9IGFycmF5TmFtZSBuYW1lIG9mIGFycmF5LiBVc2VkIHRvIGd1ZXNzIHRoZSB0eXBlIGlmIHR5cGUgY2FuIG5vdCBiZSBkZXJpdmVkIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge1dlYkdMQnVmZmVyfSBhIFdlYkdMQnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRhdGEgaW4gYXJyYXkuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvYXR0cmlidXRlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyRnJvbUFycmF5KGdsLCBhcnJheSwgYXJyYXlOYW1lKSB7XG4gIHZhciB0eXBlID0gYXJyYXlOYW1lID09PSBcImluZGljZXNcIiA/IEVMRU1FTlRfQVJSQVlfQlVGRkVSIDogQVJSQVlfQlVGRkVSO1xuICB2YXIgdHlwZWRBcnJheSA9IG1ha2VUeXBlZEFycmF5KGFycmF5LCBhcnJheU5hbWUpO1xuICByZXR1cm4gY3JlYXRlQnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIHR5cGVkQXJyYXksIHR5cGUpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGJ1ZmZlcnMgZnJvbSBhcnJheXMgb3IgdHlwZWQgYXJyYXlzXG4gKlxuICogR2l2ZW4gc29tZXRoaW5nIGxpa2UgdGhpc1xuICpcbiAqICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgIHBvc2l0aW9uczogWzEsIDIsIDNdLFxuICogICAgICAgIG5vcm1hbHM6IFswLCAwLCAxXSxcbiAqICAgICB9XG4gKlxuICogcmV0dXJucyBzb21ldGhpbmcgbGlrZVxuICpcbiAqICAgICBidWZmZXJzID0ge1xuICogICAgICAgcG9zaXRpb25zOiBXZWJHTEJ1ZmZlcixcbiAqICAgICAgIG5vcm1hbHM6IFdlYkdMQnVmZmVyLFxuICogICAgIH1cbiAqXG4gKiBJZiB0aGUgYnVmZmVyIGlzIG5hbWVkICdpbmRpY2VzJyBpdCB3aWxsIGJlIG1hZGUgYW4gRUxFTUVOVF9BUlJBWV9CVUZGRVIuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5BcnJheXN9IGFycmF5c1xuICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgV2ViR0xCdWZmZXI+fSByZXR1cm5zIGFuIG9iamVjdCB3aXRoIG9uZSBXZWJHTEJ1ZmZlciBwZXIgYXJyYXlcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9hdHRyaWJ1dGVzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXJzRnJvbUFycmF5cyhnbCwgYXJyYXlzKSB7XG4gIHZhciBidWZmZXJzID0ge307XG4gIE9iamVjdC5rZXlzKGFycmF5cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgYnVmZmVyc1trZXldID0gY3JlYXRlQnVmZmVyRnJvbUFycmF5KGdsLCBhcnJheXNba2V5XSwga2V5KTtcbiAgfSk7IC8vIFVnaCFcblxuICBpZiAoYXJyYXlzLmluZGljZXMpIHtcbiAgICBidWZmZXJzLm51bUVsZW1lbnRzID0gYXJyYXlzLmluZGljZXMubGVuZ3RoO1xuICAgIGJ1ZmZlcnMuZWxlbWVudFR5cGUgPSB0eXBlZEFycmF5cy5nZXRHTFR5cGVGb3JUeXBlZEFycmF5KG1ha2VUeXBlZEFycmF5KGFycmF5cy5pbmRpY2VzKSwgJ2luZGljZXMnKTtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXJzLm51bUVsZW1lbnRzID0gZ2V0TnVtRWxlbWVudHNGcm9tTm9uSW5kZXhlZEFycmF5cyhhcnJheXMpO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcnM7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RyYXcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kcmF3LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kcmF3QnVmZmVySW5mbyA9IGRyYXdCdWZmZXJJbmZvO1xuZXhwb3J0cy5kcmF3T2JqZWN0TGlzdCA9IGRyYXdPYmplY3RMaXN0O1xuXG52YXIgcHJvZ3JhbXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Byb2dyYW1zLmpzICovIFwiLi9zcmMvcHJvZ3JhbXMuanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG52YXIgVFJJQU5HTEVTID0gMHgwMDA0O1xudmFyIFVOU0lHTkVEX1NIT1JUID0gMHgxNDAzO1xuLyoqXG4gKiBEcmF3aW5nIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgdGhleSBhcmUgYXZhaWxhYmxlIGF0IGJvdGggYHR3Z2wuZHJhd2AgYW5kIGB0d2dsYFxuICogaXRzZWxmXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6dHdnbH0gZm9yIGNvcmUgZnVuY3Rpb25zXG4gKlxuICogQG1vZHVsZSB0d2dsL2RyYXdcbiAqL1xuXG4vKipcbiAqIENhbGxzIGBnbC5kcmF3RWxlbWVudHNgIG9yIGBnbC5kcmF3QXJyYXlzYCwgd2hpY2hldmVyIGlzIGFwcHJvcHJpYXRlXG4gKlxuICogbm9ybWFsbHkgeW91J2QgY2FsbCBgZ2wuZHJhd0VsZW1lbnRzYCBvciBgZ2wuZHJhd0FycmF5c2AgeW91cnNlbGZcbiAqIGJ1dCBjYWxsaW5nIHRoaXMgbWVhbnMgaWYgeW91IHN3aXRjaCBmcm9tIGluZGV4ZWQgZGF0YSB0byBub24taW5kZXhlZFxuICogZGF0YSB5b3UgZG9uJ3QgaGF2ZSB0byByZW1lbWJlciB0byB1cGRhdGUgeW91ciBkcmF3IGNhbGwuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5CdWZmZXJJbmZvfG1vZHVsZTp0d2dsLlZlcnRleEFycmF5SW5mbyl9IGJ1ZmZlckluZm8gQSBCdWZmZXJJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzfSBvclxuICogICBhIFZlcnRleEFycmF5SW5mbyBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVWZXJ0ZXhBcnJheUluZm99XG4gKiBAcGFyYW0ge251bWJlcn0gW3R5cGVdIGVnIChnbC5UUklBTkdMRVMsIGdsLkxJTkVTLCBnbC5QT0lOVFMsIGdsLlRSSUFOR0xFX1NUUklQLCAuLi4pLiBEZWZhdWx0cyB0byBgZ2wuVFJJQU5HTEVTYFxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF0gQW4gb3B0aW9uYWwgY291bnQuIERlZmF1bHRzIHRvIGJ1ZmZlckluZm8ubnVtRWxlbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0XSBBbiBvcHRpb25hbCBvZmZzZXQuIERlZmF1bHRzIHRvIDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2luc3RhbmNlQ291bnRdIEFuIG9wdGlvbmFsIGluc3RhbmNlQ291bnQuIGlmIHNldCB0aGVuIGBkcmF3QXJyYXlzSW5zdGFuY2VkYCBvciBgZHJhd0VsZW1lbnRzSW5zdGFuY2VkYCB3aWxsIGJlIGNhbGxlZFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2RyYXdcbiAqL1xuXG5mdW5jdGlvbiBkcmF3QnVmZmVySW5mbyhnbCwgYnVmZmVySW5mbywgdHlwZSwgY291bnQsIG9mZnNldCwgaW5zdGFuY2VDb3VudCkge1xuICB0eXBlID0gdHlwZSA9PT0gdW5kZWZpbmVkID8gVFJJQU5HTEVTIDogdHlwZTtcbiAgdmFyIGluZGljZXMgPSBidWZmZXJJbmZvLmluZGljZXM7XG4gIHZhciBlbGVtZW50VHlwZSA9IGJ1ZmZlckluZm8uZWxlbWVudFR5cGU7XG4gIHZhciBudW1FbGVtZW50cyA9IGNvdW50ID09PSB1bmRlZmluZWQgPyBidWZmZXJJbmZvLm51bUVsZW1lbnRzIDogY291bnQ7XG4gIG9mZnNldCA9IG9mZnNldCA9PT0gdW5kZWZpbmVkID8gMCA6IG9mZnNldDtcblxuICBpZiAoZWxlbWVudFR5cGUgfHwgaW5kaWNlcykge1xuICAgIGlmIChpbnN0YW5jZUNvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZCh0eXBlLCBudW1FbGVtZW50cywgZWxlbWVudFR5cGUgPT09IHVuZGVmaW5lZCA/IFVOU0lHTkVEX1NIT1JUIDogYnVmZmVySW5mby5lbGVtZW50VHlwZSwgb2Zmc2V0LCBpbnN0YW5jZUNvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuZHJhd0VsZW1lbnRzKHR5cGUsIG51bUVsZW1lbnRzLCBlbGVtZW50VHlwZSA9PT0gdW5kZWZpbmVkID8gVU5TSUdORURfU0hPUlQgOiBidWZmZXJJbmZvLmVsZW1lbnRUeXBlLCBvZmZzZXQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaW5zdGFuY2VDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkKHR5cGUsIG9mZnNldCwgbnVtRWxlbWVudHMsIGluc3RhbmNlQ291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC5kcmF3QXJyYXlzKHR5cGUsIG9mZnNldCwgbnVtRWxlbWVudHMpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBBIERyYXdPYmplY3QgaXMgdXNlZnVsIGZvciBwdXR0aW5nIG9iamVjdHMgaW4gdG8gYW4gYXJyYXkgYW5kIHBhc3NpbmcgdGhlbSB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuZHJhd09iamVjdExpc3R9LlxuICpcbiAqIFlvdSBuZWVkIGVpdGhlciBhIGBCdWZmZXJJbmZvYCBvciBhIGBWZXJ0ZXhBcnJheUluZm9gLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERyYXdPYmplY3RcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FjdGl2ZV0gd2hldGhlciBvciBub3QgdG8gZHJhdy4gRGVmYXVsdCA9IGB0cnVlYCAobXVzdCBiZSBgZmFsc2VgIHRvIGJlIG5vdCB0cnVlKS4gSW4gb3RoZXIgd29yZHMgYHVuZGVmaW5lZGAgPSBgdHJ1ZWBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHlwZV0gdHlwZSB0byBkcmF3IGVnLiBgZ2wuVFJJQU5HTEVTYCwgYGdsLkxJTkVTYCwgZXRjLi4uXG4gKiBAcHJvcGVydHkge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfSBwcm9ncmFtSW5mbyBBIFByb2dyYW1JbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVByb2dyYW1JbmZvfVxuICogQHByb3BlcnR5IHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBbYnVmZmVySW5mb10gQSBCdWZmZXJJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzfVxuICogQHByb3BlcnR5IHttb2R1bGU6dHdnbC5WZXJ0ZXhBcnJheUluZm99IFt2ZXJ0ZXhBcnJheUluZm9dIEEgVmVydGV4QXJyYXlJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVZlcnRleEFycmF5SW5mb31cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgPz59IHVuaWZvcm1zIFRoZSB2YWx1ZXMgZm9yIHRoZSB1bmlmb3Jtcy5cbiAqICAgWW91IGNhbiBwYXNzIG11bHRpcGxlIG9iamVjdHMgYnkgcHV0dGluZyB0aGVtIGluIGFuIGFycmF5LiBGb3IgZXhhbXBsZVxuICpcbiAqICAgICB2YXIgc2hhcmVkVW5pZm9ybXMgPSB7XG4gKiAgICAgICB1X2ZvZ05lYXI6IDEwLFxuICogICAgICAgdV9wcm9qZWN0aW9uOiAuLi5cbiAqICAgICAgIC4uLlxuICogICAgIH07XG4gKlxuICogICAgIHZhciBsb2NhbFVuaWZvcm1zID0ge1xuICogICAgICAgdV93b3JsZDogLi4uXG4gKiAgICAgICB1X2RpZmZ1c2VDb2xvcjogLi4uXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgdmFyIGRyYXdPYmogPSB7XG4gKiAgICAgICAuLi5cbiAqICAgICAgIHVuaWZvcm1zOiBbc2hhcmVkVW5pZm9ybXMsIGxvY2FsVW5pZm9ybXNdLFxuICogICAgIH07XG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvZmZzZXRdIHRoZSBvZmZzZXQgdG8gcGFzcyB0byBgZ2wuZHJhd0FycmF5c2Agb3IgYGdsLmRyYXdFbGVtZW50c2AuIERlZmF1bHRzIHRvIDAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NvdW50XSB0aGUgY291bnQgdG8gcGFzcyB0byBgZ2wuZHJhd0FycmF5c2Agb3IgYGdsLmRyYXdFbGVtZW50c2AuIERlZmF1bHRzIHRvIGJ1ZmZlckluZm8ubnVtRWxlbWVudHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2luc3RhbmNlQ291bnRdIHRoZSBudW1iZXIgb2YgaW5zdGFuY2VzLiBEZWZhdWx0cyB0byB1bmRlZmluZWQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIERyYXdzIGEgbGlzdCBvZiBvYmplY3RzXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7RHJhd09iamVjdFtdfSBvYmplY3RzVG9EcmF3IGFuIGFycmF5IG9mIG9iamVjdHMgdG8gZHJhdy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9kcmF3XG4gKi9cblxuXG5mdW5jdGlvbiBkcmF3T2JqZWN0TGlzdChnbCwgb2JqZWN0c1RvRHJhdykge1xuICB2YXIgbGFzdFVzZWRQcm9ncmFtSW5mbyA9IG51bGw7XG4gIHZhciBsYXN0VXNlZEJ1ZmZlckluZm8gPSBudWxsO1xuICBvYmplY3RzVG9EcmF3LmZvckVhY2goZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuYWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9ncmFtSW5mbyA9IG9iamVjdC5wcm9ncmFtSW5mbztcbiAgICB2YXIgYnVmZmVySW5mbyA9IG9iamVjdC52ZXJ0ZXhBcnJheUluZm8gfHwgb2JqZWN0LmJ1ZmZlckluZm87XG4gICAgdmFyIGJpbmRCdWZmZXJzID0gZmFsc2U7XG4gICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZSA9PT0gdW5kZWZpbmVkID8gVFJJQU5HTEVTIDogb2JqZWN0LnR5cGU7XG5cbiAgICBpZiAocHJvZ3JhbUluZm8gIT09IGxhc3RVc2VkUHJvZ3JhbUluZm8pIHtcbiAgICAgIGxhc3RVc2VkUHJvZ3JhbUluZm8gPSBwcm9ncmFtSW5mbztcbiAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbUluZm8ucHJvZ3JhbSk7IC8vIFdlIGhhdmUgdG8gcmViaW5kIGJ1ZmZlcnMgd2hlbiBjaGFuZ2luZyBwcm9ncmFtcyBiZWNhdXNlIHdlXG4gICAgICAvLyBvbmx5IGJpbmQgYnVmZmVycyB0aGUgcHJvZ3JhbSB1c2VzLiBTbyBpZiAyIHByb2dyYW1zIHVzZSB0aGUgc2FtZVxuICAgICAgLy8gYnVmZmVySW5mbyBidXQgdGhlIDFzdCBvbmUgdXNlcyBvbmx5IHBvc2l0aW9ucyB0aGUgd2hlbiB0aGVcbiAgICAgIC8vIHdlIHN3aXRjaCB0byB0aGUgMm5kIG9uZSBzb21lIG9mIHRoZSBhdHRyaWJ1dGVzIHdpbGwgbm90IGJlIG9uLlxuXG4gICAgICBiaW5kQnVmZmVycyA9IHRydWU7XG4gICAgfSAvLyBTZXR1cCBhbGwgdGhlIG5lZWRlZCBhdHRyaWJ1dGVzLlxuXG5cbiAgICBpZiAoYmluZEJ1ZmZlcnMgfHwgYnVmZmVySW5mbyAhPT0gbGFzdFVzZWRCdWZmZXJJbmZvKSB7XG4gICAgICBpZiAobGFzdFVzZWRCdWZmZXJJbmZvICYmIGxhc3RVc2VkQnVmZmVySW5mby52ZXJ0ZXhBcnJheU9iamVjdCAmJiAhYnVmZmVySW5mby52ZXJ0ZXhBcnJheU9iamVjdCkge1xuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGxhc3RVc2VkQnVmZmVySW5mbyA9IGJ1ZmZlckluZm87XG4gICAgICBwcm9ncmFtcy5zZXRCdWZmZXJzQW5kQXR0cmlidXRlcyhnbCwgcHJvZ3JhbUluZm8sIGJ1ZmZlckluZm8pO1xuICAgIH0gLy8gU2V0IHRoZSB1bmlmb3Jtcy5cblxuXG4gICAgcHJvZ3JhbXMuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIG9iamVjdC51bmlmb3Jtcyk7IC8vIERyYXdcblxuICAgIGRyYXdCdWZmZXJJbmZvKGdsLCBidWZmZXJJbmZvLCB0eXBlLCBvYmplY3QuY291bnQsIG9iamVjdC5vZmZzZXQsIG9iamVjdC5pbnN0YW5jZUNvdW50KTtcbiAgfSk7XG5cbiAgaWYgKGxhc3RVc2VkQnVmZmVySW5mbyAmJiBsYXN0VXNlZEJ1ZmZlckluZm8udmVydGV4QXJyYXlPYmplY3QpIHtcbiAgICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZnJhbWVidWZmZXJzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9mcmFtZWJ1ZmZlcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuYmluZEZyYW1lYnVmZmVySW5mbyA9IGJpbmRGcmFtZWJ1ZmZlckluZm87XG5leHBvcnRzLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyA9IGNyZWF0ZUZyYW1lYnVmZmVySW5mbztcbmV4cG9ydHMucmVzaXplRnJhbWVidWZmZXJJbmZvID0gcmVzaXplRnJhbWVidWZmZXJJbmZvO1xuXG52YXIgdGV4dHVyZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RleHR1cmVzLmpzICovIFwiLi9zcmMvdGV4dHVyZXMuanNcIikpO1xuXG52YXIgaGVscGVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9oZWxwZXIuanMgKi8gXCIuL3NyYy9oZWxwZXIuanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogRnJhbWVidWZmZXIgcmVsYXRlZCBmdW5jdGlvbnNcbiAqXG4gKiBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB0aGV5IGFyZSBhdmFpbGFibGUgYXQgYm90aCBgdHdnbC5mcmFtZWJ1ZmZlcmAgYW5kIGB0d2dsYFxuICogaXRzZWxmXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6dHdnbH0gZm9yIGNvcmUgZnVuY3Rpb25zXG4gKlxuICogQG1vZHVsZSB0d2dsL2ZyYW1lYnVmZmVyc1xuICovXG4vLyBtYWtlIHN1cmUgd2UgZG9uJ3Qgc2VlIGEgZ2xvYmFsIGdsXG52YXIgZ2wgPSB1bmRlZmluZWQ7XG4vKiBlc2xpbnQtZGlzYWJsZS1saW5lICovXG5cbnZhciBGUkFNRUJVRkZFUiA9IDB4OGQ0MDtcbnZhciBSRU5ERVJCVUZGRVIgPSAweDhkNDE7XG52YXIgVEVYVFVSRV8yRCA9IDB4MGRlMTtcbnZhciBVTlNJR05FRF9CWVRFID0gMHgxNDAxO1xuLyogUGl4ZWxGb3JtYXQgKi9cblxudmFyIERFUFRIX0NPTVBPTkVOVCA9IDB4MTkwMjtcbnZhciBSR0JBID0gMHgxOTA4O1xudmFyIERFUFRIX0NPTVBPTkVOVDI0ID0gMHg4MWE2O1xudmFyIERFUFRIX0NPTVBPTkVOVDMyRiA9IDB4OGNhYztcbnZhciBERVBUSDI0X1NURU5DSUw4ID0gMHg4OGYwO1xudmFyIERFUFRIMzJGX1NURU5DSUw4ID0gMHg4Y2FkO1xuLyogRnJhbWVidWZmZXIgT2JqZWN0LiAqL1xuXG52YXIgUkdCQTQgPSAweDgwNTY7XG52YXIgUkdCNV9BMSA9IDB4ODA1NztcbnZhciBSR0I1NjUgPSAweDhENjI7XG52YXIgREVQVEhfQ09NUE9ORU5UMTYgPSAweDgxQTU7XG52YXIgU1RFTkNJTF9JTkRFWCA9IDB4MTkwMTtcbnZhciBTVEVOQ0lMX0lOREVYOCA9IDB4OEQ0ODtcbnZhciBERVBUSF9TVEVOQ0lMID0gMHg4NEY5O1xudmFyIENPTE9SX0FUVEFDSE1FTlQwID0gMHg4Q0UwO1xudmFyIERFUFRIX0FUVEFDSE1FTlQgPSAweDhEMDA7XG52YXIgU1RFTkNJTF9BVFRBQ0hNRU5UID0gMHg4RDIwO1xudmFyIERFUFRIX1NURU5DSUxfQVRUQUNITUVOVCA9IDB4ODIxQTtcbi8qIFRleHR1cmVXcmFwTW9kZSAqL1xuXG52YXIgQ0xBTVBfVE9fRURHRSA9IDB4ODEyRjtcbi8qIFRleHR1cmVNYWdGaWx0ZXIgKi9cblxudmFyIExJTkVBUiA9IDB4MjYwMTtcbi8qKlxuICogVGhlIG9wdGlvbnMgZm9yIGEgZnJhbWVidWZmZXIgYXR0YWNobWVudC5cbiAqXG4gKiBOb3RlOiBGb3IgYSBgZm9ybWF0YCB0aGF0IGlzIGEgdGV4dHVyZSBpbmNsdWRlIGFsbCB0aGUgdGV4dHVyZVxuICogb3B0aW9ucyBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gZm9yIGV4YW1wbGVcbiAqIGBtaW5gLCBgbWFnYCwgYGNsYW1wYCwgZXRjLi4uIE5vdGUgdGhhdCB1bmxpa2Uge0BsaW5rIG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfVxuICogYGF1dG9gIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIGF0dGFjaG1lbnQgdGV4dHVyZXMgYnV0IGBtaW5gIGFuZCBgbWFnYCBkZWZhdWx0XG4gKiB0byBgZ2wuTElORUFSYCBhbmQgYHdyYXBgIGRlZmF1bHRzIHRvIGBDTEFNUF9UT19FREdFYFxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEF0dGFjaG1lbnRPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2F0dGFjaG1lbnRQb2ludF0gVGhlIGF0dGFjaG1lbnQgcG9pbnQuIERlZmF1bHRzXG4gKiAgIHRvIGBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIG5keGAgdW5sZXNzIHR5cGUgaXMgYSBkZXB0aCBvciBzdGVuY2lsIHR5cGVcbiAqICAgdGhlbiBpdCdzIGdsLkRFUFRIX0FUVEFDSE1FTlQgb3IgYGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVGAgZGVwZW5kaW5nXG4gKiAgIG9uIHRoZSBmb3JtYXQgb3IgYXR0YWNobWVudCB0eXBlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmb3JtYXRdIFRoZSBmb3JtYXQuIElmIG9uZSBvZiBgZ2wuUkdCQTRgLFxuICogICBgZ2wuUkdCNTY1YCwgYGdsLlJHQjVfQTFgLCBgZ2wuREVQVEhfQ09NUE9ORU5UMTZgLFxuICogICBgZ2wuU1RFTkNJTF9JTkRFWDhgIG9yIGBnbC5ERVBUSF9TVEVOQ0lMYCB0aGVuIHdpbGwgY3JlYXRlIGFcbiAqICAgcmVuZGVyYnVmZmVyLiBPdGhlcndpc2Ugd2lsbCBjcmVhdGUgYSB0ZXh0dXJlLiBEZWZhdWx0ID0gYGdsLlJHQkFgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3R5cGVdIFRoZSB0eXBlLiBVc2VkIGZvciB0ZXh0dXJlLiBEZWZhdWx0ID0gYGdsLlVOU0lHTkVEX0JZVEVgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YXJnZXRdIFRoZSB0ZXh0dXJlIHRhcmdldCBmb3IgYGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEYC5cbiAqICAgRGVmYXVsdHMgdG8gYGdsLlRFWFRVUkVfMkRgLiBTZXQgdG8gYXBwcm9wcmlhdGUgZmFjZSBmb3IgY3ViZSBtYXBzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsZXZlbF0gbGV2ZWwgZm9yIGBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRGAuIERlZmF1bHRzIHRvIDAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xheWVyXSBsYXllciBmb3IgYGdsLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyYC4gRGVmYXVsdHMgdG8gdW5kZWZpbmVkLlxuICogICBJZiBzZXQgdGhlbiBgZ2wuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXJgIGlzIGNhbGxlZCwgaWYgbm90IHRoZW4gYGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEYFxuICogQHByb3BlcnR5IHtXZWJHTE9iamVjdH0gW2F0dGFjaG1lbnRdIEFuIGV4aXN0aW5nIHJlbmRlcmJ1ZmZlciBvciB0ZXh0dXJlLlxuICogICAgSWYgcHJvdmlkZWQgd2lsbCBhdHRhY2ggdGhpcyBPYmplY3QuIFRoaXMgYWxsb3dzIHlvdSB0byBzaGFyZVxuICogICAgYXR0YWNobWVudHMgYWNyb3NzIGZyYW1lYnVmZmVycy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICogQG1peGVzIG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zXG4gKi9cblxudmFyIGRlZmF1bHRBdHRhY2htZW50cyA9IFt7XG4gIGZvcm1hdDogUkdCQSxcbiAgdHlwZTogVU5TSUdORURfQllURSxcbiAgbWluOiBMSU5FQVIsXG4gIHdyYXA6IENMQU1QX1RPX0VER0Vcbn0sIHtcbiAgZm9ybWF0OiBERVBUSF9TVEVOQ0lMXG59XTtcbnZhciBhdHRhY2htZW50c0J5Rm9ybWF0ID0ge307XG5hdHRhY2htZW50c0J5Rm9ybWF0W0RFUFRIX1NURU5DSUxdID0gREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UO1xuYXR0YWNobWVudHNCeUZvcm1hdFtTVEVOQ0lMX0lOREVYXSA9IFNURU5DSUxfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbU1RFTkNJTF9JTkRFWDhdID0gU1RFTkNJTF9BVFRBQ0hNRU5UO1xuYXR0YWNobWVudHNCeUZvcm1hdFtERVBUSF9DT01QT05FTlRdID0gREVQVEhfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbREVQVEhfQ09NUE9ORU5UMTZdID0gREVQVEhfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbREVQVEhfQ09NUE9ORU5UMjRdID0gREVQVEhfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbREVQVEhfQ09NUE9ORU5UMzJGXSA9IERFUFRIX0FUVEFDSE1FTlQ7XG5hdHRhY2htZW50c0J5Rm9ybWF0W0RFUFRIMjRfU1RFTkNJTDhdID0gREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UO1xuYXR0YWNobWVudHNCeUZvcm1hdFtERVBUSDMyRl9TVEVOQ0lMOF0gPSBERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQ7XG5cbmZ1bmN0aW9uIGdldEF0dGFjaG1lbnRQb2ludEZvckZvcm1hdChmb3JtYXQsIGludGVybmFsRm9ybWF0KSB7XG4gIHJldHVybiBhdHRhY2htZW50c0J5Rm9ybWF0W2Zvcm1hdF0gfHwgYXR0YWNobWVudHNCeUZvcm1hdFtpbnRlcm5hbEZvcm1hdF07XG59XG5cbnZhciByZW5kZXJidWZmZXJGb3JtYXRzID0ge307XG5yZW5kZXJidWZmZXJGb3JtYXRzW1JHQkE0XSA9IHRydWU7XG5yZW5kZXJidWZmZXJGb3JtYXRzW1JHQjVfQTFdID0gdHJ1ZTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbUkdCNTY1XSA9IHRydWU7XG5yZW5kZXJidWZmZXJGb3JtYXRzW0RFUFRIX1NURU5DSUxdID0gdHJ1ZTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbREVQVEhfQ09NUE9ORU5UMTZdID0gdHJ1ZTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbU1RFTkNJTF9JTkRFWF0gPSB0cnVlO1xucmVuZGVyYnVmZmVyRm9ybWF0c1tTVEVOQ0lMX0lOREVYOF0gPSB0cnVlO1xuXG5mdW5jdGlvbiBpc1JlbmRlcmJ1ZmZlckZvcm1hdChmb3JtYXQpIHtcbiAgcmV0dXJuIHJlbmRlcmJ1ZmZlckZvcm1hdHNbZm9ybWF0XTtcbn1cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRnJhbWVidWZmZXJJbmZvXG4gKiBAcHJvcGVydHkge1dlYkdMRnJhbWVidWZmZXJ9IGZyYW1lYnVmZmVyIFRoZSBXZWJHTEZyYW1lYnVmZmVyIGZvciB0aGlzIGZyYW1lYnVmZmVySW5mb1xuICogQHByb3BlcnR5IHtXZWJHTE9iamVjdFtdfSBhdHRhY2htZW50cyBUaGUgY3JlYXRlZCBhdHRhY2htZW50cyBpbiB0aGUgc2FtZSBvcmRlciBhcyBwYXNzZWQgaW4gdG8ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mb30uXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBmcmFtZWJ1ZmZlciBhbmQgaXRzIGF0dGFjaG1lbnRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IFRoZSB3aWR0aCBvZiB0aGUgZnJhbWVidWZmZXIgYW5kIGl0cyBhdHRhY2htZW50c1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnJhbWVidWZmZXIgYW5kIGF0dGFjaG1lbnRzLlxuICpcbiAqIFRoaXMgcmV0dXJucyBhIHtAbGluayBtb2R1bGU6dHdnbC5GcmFtZWJ1ZmZlckluZm99IGJlY2F1c2UgaXQgbmVlZHMgdG8gcmV0dXJuIHRoZSBhdHRhY2htZW50cyBhcyB3ZWxsIGFzIHRoZSBmcmFtZWJ1ZmZlci5cbiAqXG4gKiBUaGUgc2ltcGxlc3QgdXNhZ2VcbiAqXG4gKiAgICAgLy8gY3JlYXRlIGFuIFJHQkEvVU5TSUdORURfQllURSB0ZXh0dXJlIGFuZCBERVBUSF9TVEVOQ0lMIHJlbmRlcmJ1ZmZlclxuICogICAgIGNvbnN0IGZiaSA9IHR3Z2wuY3JlYXRlRnJhbWVidWZmZXJJbmZvKGdsKTtcbiAqXG4gKiBNb3JlIGNvbXBsZXggdXNhZ2VcbiAqXG4gKiAgICAgLy8gY3JlYXRlIGFuIFJHQjU2NSByZW5kZXJidWZmZXIgYW5kIGEgU1RFTkNJTF9JTkRFWDggcmVuZGVyYnVmZmVyXG4gKiAgICAgY29uc3QgYXR0YWNobWVudHMgPSBbXG4gKiAgICAgICB7IGZvcm1hdDogUkdCNTY1LCBtYWc6IE5FQVJFU1QgfSxcbiAqICAgICAgIHsgZm9ybWF0OiBTVEVOQ0lMX0lOREVYOCB9LFxuICogICAgIF1cbiAqICAgICBjb25zdCBmYmkgPSB0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCwgYXR0YWNobWVudHMpO1xuICpcbiAqIFBhc3NpbmcgaW4gYSBzcGVjaWZpYyBzaXplXG4gKlxuICogICAgIGNvbnN0IHdpZHRoID0gMjU2O1xuICogICAgIGNvbnN0IGhlaWdodCA9IDI1NjtcbiAqICAgICBjb25zdCBmYmkgPSB0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCwgYXR0YWNobWVudHMsIHdpZHRoLCBoZWlnaHQpO1xuICpcbiAqICoqTm90ZSEhKiogSXQgaXMgdXAgdG8geW91IHRvIGNoZWNrIGlmIHRoZSBmcmFtZWJ1ZmZlciBpcyByZW5kZXJhYmxlIGJ5IGNhbGxpbmcgYGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXNgLlxuICogW1dlYkdMMSBvbmx5IGd1YXJhbnRlZXMgMyBjb21iaW5hdGlvbnMgb2YgYXR0YWNobWVudHMgd29ya10oaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvc3BlY3MvbGF0ZXN0LzEuMC8jNi42KS5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5BdHRhY2htZW50T3B0aW9uc1tdfSBbYXR0YWNobWVudHNdIHdoaWNoIGF0dGFjaG1lbnRzIHRvIGNyZWF0ZS4gSWYgbm90IHByb3ZpZGVkIHRoZSBkZWZhdWx0IGlzIGEgZnJhbWVidWZmZXIgd2l0aCBhblxuICogICAgYFJHQkFgLCBgVU5TSUdORURfQllURWAgdGV4dHVyZSBgQ09MT1JfQVRUQUNITUVOVDBgIGFuZCBhIGBERVBUSF9TVEVOQ0lMYCByZW5kZXJidWZmZXIgYERFUFRIX1NURU5DSUxfQVRUQUNITUVOVGAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSB0aGUgd2lkdGggZm9yIHRoZSBhdHRhY2htZW50cy4gRGVmYXVsdCA9IHNpemUgb2YgZHJhd2luZ0J1ZmZlclxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIHRoZSBoZWlnaHQgZm9yIHRoZSBhdHRhY2htZW50cy4gRGVmYXVsdCA9IHNpemUgb2YgZHJhd2luZ0J1ZmZlclxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuRnJhbWVidWZmZXJJbmZvfSB0aGUgZnJhbWVidWZmZXIgYW5kIGF0dGFjaG1lbnRzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2ZyYW1lYnVmZmVyc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRnJhbWVidWZmZXJJbmZvKGdsLCBhdHRhY2htZW50cywgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgdGFyZ2V0ID0gRlJBTUVCVUZGRVI7XG4gIHZhciBmYiA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gIGdsLmJpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIGZiKTtcbiAgd2lkdGggPSB3aWR0aCB8fCBnbC5kcmF3aW5nQnVmZmVyV2lkdGg7XG4gIGhlaWdodCA9IGhlaWdodCB8fCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xuICBhdHRhY2htZW50cyA9IGF0dGFjaG1lbnRzIHx8IGRlZmF1bHRBdHRhY2htZW50cztcbiAgdmFyIGNvbG9yQXR0YWNobWVudENvdW50ID0gMDtcbiAgdmFyIGZyYW1lYnVmZmVySW5mbyA9IHtcbiAgICBmcmFtZWJ1ZmZlcjogZmIsXG4gICAgYXR0YWNobWVudHM6IFtdLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuICBhdHRhY2htZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRhY2htZW50T3B0aW9ucykge1xuICAgIHZhciBhdHRhY2htZW50ID0gYXR0YWNobWVudE9wdGlvbnMuYXR0YWNobWVudDtcbiAgICB2YXIgZm9ybWF0ID0gYXR0YWNobWVudE9wdGlvbnMuZm9ybWF0O1xuICAgIHZhciBhdHRhY2htZW50UG9pbnQgPSBhdHRhY2htZW50T3B0aW9ucy5hdHRhY2htZW50UG9pbnQgfHwgZ2V0QXR0YWNobWVudFBvaW50Rm9yRm9ybWF0KGZvcm1hdCwgYXR0YWNobWVudE9wdGlvbnMuaW50ZXJuYWxGb3JtYXQpO1xuXG4gICAgaWYgKCFhdHRhY2htZW50UG9pbnQpIHtcbiAgICAgIGF0dGFjaG1lbnRQb2ludCA9IENPTE9SX0FUVEFDSE1FTlQwICsgY29sb3JBdHRhY2htZW50Q291bnQrKztcbiAgICB9XG5cbiAgICBpZiAoIWF0dGFjaG1lbnQpIHtcbiAgICAgIGlmIChpc1JlbmRlcmJ1ZmZlckZvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIGF0dGFjaG1lbnQgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihSRU5ERVJCVUZGRVIsIGF0dGFjaG1lbnQpO1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKFJFTkRFUkJVRkZFUiwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0dXJlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGF0dGFjaG1lbnRPcHRpb25zKTtcbiAgICAgICAgdGV4dHVyZU9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGV4dHVyZU9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIGlmICh0ZXh0dXJlT3B0aW9ucy5hdXRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0ZXh0dXJlT3B0aW9ucy5hdXRvID0gZmFsc2U7XG4gICAgICAgICAgdGV4dHVyZU9wdGlvbnMubWluID0gdGV4dHVyZU9wdGlvbnMubWluIHx8IHRleHR1cmVPcHRpb25zLm1pbk1hZyB8fCBMSU5FQVI7XG4gICAgICAgICAgdGV4dHVyZU9wdGlvbnMubWFnID0gdGV4dHVyZU9wdGlvbnMubWFnIHx8IHRleHR1cmVPcHRpb25zLm1pbk1hZyB8fCBMSU5FQVI7XG4gICAgICAgICAgdGV4dHVyZU9wdGlvbnMud3JhcFMgPSB0ZXh0dXJlT3B0aW9ucy53cmFwUyB8fCB0ZXh0dXJlT3B0aW9ucy53cmFwIHx8IENMQU1QX1RPX0VER0U7XG4gICAgICAgICAgdGV4dHVyZU9wdGlvbnMud3JhcFQgPSB0ZXh0dXJlT3B0aW9ucy53cmFwVCB8fCB0ZXh0dXJlT3B0aW9ucy53cmFwIHx8IENMQU1QX1RPX0VER0U7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRhY2htZW50ID0gdGV4dHVyZXMuY3JlYXRlVGV4dHVyZShnbCwgdGV4dHVyZU9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoZWxwZXIuaXNSZW5kZXJidWZmZXIoZ2wsIGF0dGFjaG1lbnQpKSB7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0YXJnZXQsIGF0dGFjaG1lbnRQb2ludCwgUkVOREVSQlVGRkVSLCBhdHRhY2htZW50KTtcbiAgICB9IGVsc2UgaWYgKGhlbHBlci5pc1RleHR1cmUoZ2wsIGF0dGFjaG1lbnQpKSB7XG4gICAgICBpZiAoYXR0YWNobWVudE9wdGlvbnMubGF5ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmVMYXllcih0YXJnZXQsIGF0dGFjaG1lbnRQb2ludCwgYXR0YWNobWVudCwgYXR0YWNobWVudE9wdGlvbnMubGV2ZWwgfHwgMCwgYXR0YWNobWVudE9wdGlvbnMubGF5ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGFyZ2V0LCBhdHRhY2htZW50UG9pbnQsIGF0dGFjaG1lbnRPcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJELCBhdHRhY2htZW50LCBhdHRhY2htZW50T3B0aW9ucy5sZXZlbCB8fCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGF0dGFjaG1lbnQgdHlwZScpO1xuICAgIH1cblxuICAgIGZyYW1lYnVmZmVySW5mby5hdHRhY2htZW50cy5wdXNoKGF0dGFjaG1lbnQpO1xuICB9KTtcbiAgcmV0dXJuIGZyYW1lYnVmZmVySW5mbztcbn1cbi8qKlxuICogUmVzaXplcyB0aGUgYXR0YWNobWVudHMgb2YgYSBmcmFtZWJ1ZmZlci5cbiAqXG4gKiBZb3UgbmVlZCB0byBwYXNzIGluIHRoZSBzYW1lIGBhdHRhY2htZW50c2AgYXMgeW91IHBhc3NlZCBpbiB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlRnJhbWVidWZmZXJJbmZvfVxuICogYmVjYXVzZSBUV0dMIGhhcyBubyBpZGVhIHRoZSBmb3JtYXQvdHlwZSBvZiBlYWNoIGF0dGFjaG1lbnQuXG4gKlxuICogVGhlIHNpbXBsZXN0IHVzYWdlXG4gKlxuICogICAgIC8vIGNyZWF0ZSBhbiBSR0JBL1VOU0lHTkVEX0JZVEUgdGV4dHVyZSBhbmQgREVQVEhfU1RFTkNJTCByZW5kZXJidWZmZXJcbiAqICAgICBjb25zdCBmYmkgPSB0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCk7XG4gKlxuICogICAgIC4uLlxuICpcbiAqICAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gKiAgICAgICBpZiAodHdnbC5yZXNpemVDYW52YXNUb0Rpc3BsYXlTaXplKGdsLmNhbnZhcykpIHtcbiAqICAgICAgICAgLy8gcmVzaXplIHRoZSBhdHRhY2htZW50c1xuICogICAgICAgICB0d2dsLnJlc2l6ZUZyYW1lYnVmZmVySW5mbyhnbCwgZmJpKTtcbiAqICAgICAgIH1cbiAqXG4gKiBNb3JlIGNvbXBsZXggdXNhZ2VcbiAqXG4gKiAgICAgLy8gY3JlYXRlIGFuIFJHQjU2NSByZW5kZXJidWZmZXIgYW5kIGEgU1RFTkNJTF9JTkRFWDggcmVuZGVyYnVmZmVyXG4gKiAgICAgY29uc3QgYXR0YWNobWVudHMgPSBbXG4gKiAgICAgICB7IGZvcm1hdDogUkdCNTY1LCBtYWc6IE5FQVJFU1QgfSxcbiAqICAgICAgIHsgZm9ybWF0OiBTVEVOQ0lMX0lOREVYOCB9LFxuICogICAgIF1cbiAqICAgICBjb25zdCBmYmkgPSB0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCwgYXR0YWNobWVudHMpO1xuICpcbiAqICAgICAuLi5cbiAqXG4gKiAgICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICogICAgICAgaWYgKHR3Z2wucmVzaXplQ2FudmFzVG9EaXNwbGF5U2l6ZShnbC5jYW52YXMpKSB7XG4gKiAgICAgICAgIC8vIHJlc2l6ZSB0aGUgYXR0YWNobWVudHMgdG8gbWF0Y2hcbiAqICAgICAgICAgdHdnbC5yZXNpemVGcmFtZWJ1ZmZlckluZm8oZ2wsIGZiaSwgYXR0YWNobWVudHMpO1xuICogICAgICAgfVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkZyYW1lYnVmZmVySW5mb30gZnJhbWVidWZmZXJJbmZvIGEgZnJhbWVidWZmZXJJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mb30uXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkF0dGFjaG1lbnRPcHRpb25zW119IFthdHRhY2htZW50c10gdGhlIHNhbWUgYXR0YWNobWVudHMgb3B0aW9ucyBhcyBwYXNzZWQgdG8ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mb30uXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSB0aGUgd2lkdGggZm9yIHRoZSBhdHRhY2htZW50cy4gRGVmYXVsdCA9IHNpemUgb2YgZHJhd2luZ0J1ZmZlclxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIHRoZSBoZWlnaHQgZm9yIHRoZSBhdHRhY2htZW50cy4gRGVmYXVsdCA9IHNpemUgb2YgZHJhd2luZ0J1ZmZlclxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2ZyYW1lYnVmZmVyc1xuICovXG5cblxuZnVuY3Rpb24gcmVzaXplRnJhbWVidWZmZXJJbmZvKGdsLCBmcmFtZWJ1ZmZlckluZm8sIGF0dGFjaG1lbnRzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHdpZHRoID0gd2lkdGggfHwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoO1xuICBoZWlnaHQgPSBoZWlnaHQgfHwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodDtcbiAgZnJhbWVidWZmZXJJbmZvLndpZHRoID0gd2lkdGg7XG4gIGZyYW1lYnVmZmVySW5mby5oZWlnaHQgPSBoZWlnaHQ7XG4gIGF0dGFjaG1lbnRzID0gYXR0YWNobWVudHMgfHwgZGVmYXVsdEF0dGFjaG1lbnRzO1xuICBhdHRhY2htZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRhY2htZW50T3B0aW9ucywgbmR4KSB7XG4gICAgdmFyIGF0dGFjaG1lbnQgPSBmcmFtZWJ1ZmZlckluZm8uYXR0YWNobWVudHNbbmR4XTtcbiAgICB2YXIgZm9ybWF0ID0gYXR0YWNobWVudE9wdGlvbnMuZm9ybWF0O1xuXG4gICAgaWYgKGhlbHBlci5pc1JlbmRlcmJ1ZmZlcihnbCwgYXR0YWNobWVudCkpIHtcbiAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoUkVOREVSQlVGRkVSLCBhdHRhY2htZW50KTtcbiAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoUkVOREVSQlVGRkVSLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoaGVscGVyLmlzVGV4dHVyZShnbCwgYXR0YWNobWVudCkpIHtcbiAgICAgIHRleHR1cmVzLnJlc2l6ZVRleHR1cmUoZ2wsIGF0dGFjaG1lbnQsIGF0dGFjaG1lbnRPcHRpb25zLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGF0dGFjaG1lbnQgdHlwZScpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEJpbmRzIGEgZnJhbWVidWZmZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHByZXR0eSBtdWNoIHNvbGVseSBleGlzdHMgYmVjYXVzZSBJIHNwZW50IGhvdXJzXG4gKiB0cnlpbmcgdG8gZmlndXJlIG91dCB3aHkgc29tZXRoaW5nIEkgd3JvdGUgd2Fzbid0IHdvcmtpbmcgb25seVxuICogdG8gcmVhbGl6ZSBJIGZvcmdldCB0byBzZXQgdGhlIHZpZXdwb3J0IGRpbWVuc2lvbnMuXG4gKiBNeSBob3BlIGlzIHRoaXMgZnVuY3Rpb24gd2lsbCBmaXggdGhhdC5cbiAqXG4gKiBJdCBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSBhc1xuICpcbiAqICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHNvbWVGcmFtZWJ1ZmZlckluZm8uZnJhbWVidWZmZXIpO1xuICogICAgIGdsLnZpZXdwb3J0KDAsIDAsIHNvbWVGcmFtZWJ1ZmZlckluZm8ud2lkdGgsIHNvbWVGcmFtZWJ1ZmZlckluZm8uaGVpZ2h0KTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5GcmFtZWJ1ZmZlckluZm98bnVsbH0gW2ZyYW1lYnVmZmVySW5mb10gYSBmcmFtZWJ1ZmZlckluZm8gYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlRnJhbWVidWZmZXJJbmZvfS5cbiAqICAgSWYgZmFsc3kgd2lsbCBiaW5kIHRoZSBjYW52YXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW3RhcmdldF0gVGhlIHRhcmdldC4gSWYgbm90IHBhc3NlZCBgZ2wuRlJBTUVCVUZGRVJgIHdpbGwgYmUgdXNlZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9mcmFtZWJ1ZmZlcnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGJpbmRGcmFtZWJ1ZmZlckluZm8oZ2wsIGZyYW1lYnVmZmVySW5mbywgdGFyZ2V0KSB7XG4gIHRhcmdldCA9IHRhcmdldCB8fCBGUkFNRUJVRkZFUjtcblxuICBpZiAoZnJhbWVidWZmZXJJbmZvKSB7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgZnJhbWVidWZmZXJJbmZvLmZyYW1lYnVmZmVyKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBmcmFtZWJ1ZmZlckluZm8ud2lkdGgsIGZyYW1lYnVmZmVySW5mby5oZWlnaHQpO1xuICB9IGVsc2Uge1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIG51bGwpO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvaGVscGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9oZWxwZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvcHlFeGlzdGluZ1Byb3BlcnRpZXMgPSBjb3B5RXhpc3RpbmdQcm9wZXJ0aWVzO1xuZXhwb3J0cy5jb3B5TmFtZWRQcm9wZXJ0aWVzID0gY29weU5hbWVkUHJvcGVydGllcztcbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmV4cG9ydHMud2FybiA9IHdhcm47XG5leHBvcnRzLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5leHBvcnRzLmlzUmVuZGVyYnVmZmVyID0gaXNSZW5kZXJidWZmZXI7XG5leHBvcnRzLmlzU2hhZGVyID0gaXNTaGFkZXI7XG5leHBvcnRzLmlzVGV4dHVyZSA9IGlzVGV4dHVyZTtcbmV4cG9ydHMuaXNTYW1wbGVyID0gaXNTYW1wbGVyO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby1jb25zb2xlOiBcIm9mZlwiICovXG5cbi8qKlxuICogQ29weSBuYW1lZCBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gbmFtZXMgbmFtZXMgb2YgcHJvcGVydGllcyB0byBjb3B5XG4gKiBAcGFyYW0ge29iamVjdH0gc3JjIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtvYmplY3R9IGRzdCBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb3B5TmFtZWRQcm9wZXJ0aWVzKG5hbWVzLCBzcmMsIGRzdCkge1xuICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gc3JjW25hbWVdO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRzdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIGRlc3Qgb25seSBpZiBhIG1hdGNoaW5nIGtleSBpcyBpbiBkZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgPz59IHNyYyB0aGUgc291cmNlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCA/Pn0gZHN0IHRoZSBkZXN0XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gY29weUV4aXN0aW5nUHJvcGVydGllcyhzcmMsIGRzdCkge1xuICBPYmplY3Qua2V5cyhkc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChkc3QuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLyogZXNsaW50IG5vLXByb3RvdHlwZS1idWlsdGluczogMCAqL1xuICAgICAgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlcnJvcigpIHtcbiAgdmFyIF9jb25zb2xlO1xuXG4gIChfY29uc29sZSA9IGNvbnNvbGUpLmVycm9yLmFwcGx5KF9jb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiB3YXJuKCkge1xuICB2YXIgX2NvbnNvbGUyO1xuXG4gIChfY29uc29sZTIgPSBjb25zb2xlKS53YXJuLmFwcGx5KF9jb25zb2xlMiwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIoZ2wsIHQpIHtcbiAgcmV0dXJuIHR5cGVvZiBXZWJHTEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdCBpbnN0YW5jZW9mIFdlYkdMQnVmZmVyO1xufVxuXG5mdW5jdGlvbiBpc1JlbmRlcmJ1ZmZlcihnbCwgdCkge1xuICByZXR1cm4gdHlwZW9mIFdlYkdMUmVuZGVyYnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0IGluc3RhbmNlb2YgV2ViR0xSZW5kZXJidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGlzU2hhZGVyKGdsLCB0KSB7XG4gIHJldHVybiB0eXBlb2YgV2ViR0xTaGFkZXIgIT09ICd1bmRlZmluZWQnICYmIHQgaW5zdGFuY2VvZiBXZWJHTFNoYWRlcjtcbn1cblxuZnVuY3Rpb24gaXNUZXh0dXJlKGdsLCB0KSB7XG4gIHJldHVybiB0eXBlb2YgV2ViR0xUZXh0dXJlICE9PSAndW5kZWZpbmVkJyAmJiB0IGluc3RhbmNlb2YgV2ViR0xUZXh0dXJlO1xufVxuXG5mdW5jdGlvbiBpc1NhbXBsZXIoZ2wsIHQpIHtcbiAgcmV0dXJuIHR5cGVvZiBXZWJHTFNhbXBsZXIgIT09ICd1bmRlZmluZWQnICYmIHQgaW5zdGFuY2VvZiBXZWJHTFNhbXBsZXI7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL200LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL200LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuYXhpc1JvdGF0ZSA9IGF4aXNSb3RhdGU7XG5leHBvcnRzLmF4aXNSb3RhdGlvbiA9IGF4aXNSb3RhdGlvbjtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmZydXN0dW0gPSBmcnVzdHVtO1xuZXhwb3J0cy5nZXRBeGlzID0gZ2V0QXhpcztcbmV4cG9ydHMuZ2V0VHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbjtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuaW52ZXJzZSA9IGludmVyc2U7XG5leHBvcnRzLmxvb2tBdCA9IGxvb2tBdDtcbmV4cG9ydHMubXVsdGlwbHkgPSBtdWx0aXBseTtcbmV4cG9ydHMubmVnYXRlID0gbmVnYXRlO1xuZXhwb3J0cy5vcnRobyA9IG9ydGhvO1xuZXhwb3J0cy5wZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlO1xuZXhwb3J0cy5yb3RhdGVYID0gcm90YXRlWDtcbmV4cG9ydHMucm90YXRlWSA9IHJvdGF0ZVk7XG5leHBvcnRzLnJvdGF0ZVogPSByb3RhdGVaO1xuZXhwb3J0cy5yb3RhdGlvblggPSByb3RhdGlvblg7XG5leHBvcnRzLnJvdGF0aW9uWSA9IHJvdGF0aW9uWTtcbmV4cG9ydHMucm90YXRpb25aID0gcm90YXRpb25aO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5zY2FsaW5nID0gc2NhbGluZztcbmV4cG9ydHMuc2V0QXhpcyA9IHNldEF4aXM7XG5leHBvcnRzLnNldERlZmF1bHRUeXBlID0gc2V0RGVmYXVsdFR5cGU7XG5leHBvcnRzLnNldFRyYW5zbGF0aW9uID0gc2V0VHJhbnNsYXRpb247XG5leHBvcnRzLnRyYW5zZm9ybURpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbjtcbmV4cG9ydHMudHJhbnNmb3JtTm9ybWFsID0gdHJhbnNmb3JtTm9ybWFsO1xuZXhwb3J0cy50cmFuc2Zvcm1Qb2ludCA9IHRyYW5zZm9ybVBvaW50O1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb247XG5leHBvcnRzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZTtcblxudmFyIHYzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92My5qcyAqLyBcIi4vc3JjL3YzLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIDR4NCBNYXRyaXggbWF0aCBtYXRoIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbG1vc3QgYWxsIGZ1bmN0aW9ucyB0YWtlIGFuIG9wdGlvbmFsIGBkc3RgIGFyZ3VtZW50LiBJZiBpdCBpcyBub3QgcGFzc2VkIGluIHRoZVxuICogZnVuY3Rpb25zIHdpbGwgY3JlYXRlIGEgbmV3IG1hdHJpeC4gSW4gb3RoZXIgd29yZHMgeW91IGNhbiBkbyB0aGlzXG4gKlxuICogICAgIGNvbnN0IG1hdCA9IG00LnRyYW5zbGF0aW9uKFsxLCAyLCAzXSk7ICAvLyBDcmVhdGVzIGEgbmV3IHRyYW5zbGF0aW9uIG1hdHJpeFxuICpcbiAqIG9yXG4gKlxuICogICAgIGNvbnN0IG1hdCA9IG00LmNyZWF0ZSgpO1xuICogICAgIG00LnRyYW5zbGF0aW9uKFsxLCAyLCAzXSwgbWF0KTsgIC8vIFB1dHMgdHJhbnNsYXRpb24gbWF0cml4IGluIG1hdC5cbiAqXG4gKiBUaGUgZmlyc3Qgc3R5bGUgaXMgb2Z0ZW4gZWFzaWVyIGJ1dCBkZXBlbmRpbmcgb24gd2hlcmUgaXQncyB1c2VkIGl0IGdlbmVyYXRlcyBnYXJiYWdlIHdoZXJlXG4gKiBhcyB0aGVyZSBpcyBhbG1vc3QgbmV2ZXIgYWxsb2NhdGlvbiB3aXRoIHRoZSBzZWNvbmQgc3R5bGUuXG4gKlxuICogSXQgaXMgYWx3YXlzIHNhdmUgdG8gcGFzcyBhbnkgbWF0cml4IGFzIHRoZSBkZXN0aW5hdGlvbi4gU28gZm9yIGV4YW1wbGVcbiAqXG4gKiAgICAgY29uc3QgbWF0ID0gbTQuaWRlbnRpdHkoKTtcbiAqICAgICBjb25zdCB0cmFucyA9IG00LnRyYW5zbGF0aW9uKFsxLCAyLCAzXSk7XG4gKiAgICAgbTQubXVsdGlwbHkobWF0LCB0cmFucywgbWF0KTsgIC8vIE11bHRpcGxpZXMgbWF0ICogdHJhbnMgYW5kIHB1dHMgcmVzdWx0IGluIG1hdC5cbiAqXG4gKiBAbW9kdWxlIHR3Z2wvbTRcbiAqL1xudmFyIE1hdFR5cGUgPSBGbG9hdDMyQXJyYXk7XG4vKipcbiAqIEEgSmF2YVNjcmlwdCBhcnJheSB3aXRoIDE2IHZhbHVlcyBvciBhIEZsb2F0MzJBcnJheSB3aXRoIDE2IHZhbHVlcy5cbiAqIFdoZW4gY3JlYXRlZCBieSB0aGUgbGlicmFyeSB3aWxsIGNyZWF0ZSB0aGUgZGVmYXVsdCB0eXBlIHdoaWNoIGlzIGBGbG9hdDMyQXJyYXlgXG4gKiBidXQgY2FuIGJlIHNldCBieSBjYWxsaW5nIHtAbGluayBtb2R1bGU6dHdnbC9tNC5zZXREZWZhdWx0VHlwZX0uXG4gKiBAdHlwZWRlZiB7KG51bWJlcltdfEZsb2F0MzJBcnJheSl9IE1hdDRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cbi8qKlxuICogU2V0cyB0aGUgdHlwZSB0aGlzIGxpYnJhcnkgY3JlYXRlcyBmb3IgYSBNYXQ0XG4gKiBAcGFyYW0ge2NvbnN0cnVjdG9yfSBjdG9yIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHR5cGUuIEVpdGhlciBgRmxvYXQzMkFycmF5YCBvciBgQXJyYXlgXG4gKiBAcmV0dXJuIHtjb25zdHJ1Y3Rvcn0gcHJldmlvdXMgY29uc3RydWN0b3IgZm9yIE1hdDRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cbmZ1bmN0aW9uIHNldERlZmF1bHRUeXBlKGN0b3IpIHtcbiAgdmFyIG9sZFR5cGUgPSBNYXRUeXBlO1xuICBNYXRUeXBlID0gY3RvcjtcbiAgcmV0dXJuIG9sZFR5cGU7XG59XG4vKipcbiAqIE5lZ2F0ZXMgYSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gLW0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIG5lZ2F0ZShtLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgZHN0WzBdID0gLW1bMF07XG4gIGRzdFsxXSA9IC1tWzFdO1xuICBkc3RbMl0gPSAtbVsyXTtcbiAgZHN0WzNdID0gLW1bM107XG4gIGRzdFs0XSA9IC1tWzRdO1xuICBkc3RbNV0gPSAtbVs1XTtcbiAgZHN0WzZdID0gLW1bNl07XG4gIGRzdFs3XSA9IC1tWzddO1xuICBkc3RbOF0gPSAtbVs4XTtcbiAgZHN0WzldID0gLW1bOV07XG4gIGRzdFsxMF0gPSAtbVsxMF07XG4gIGRzdFsxMV0gPSAtbVsxMV07XG4gIGRzdFsxMl0gPSAtbVsxMl07XG4gIGRzdFsxM10gPSAtbVsxM107XG4gIGRzdFsxNF0gPSAtbVsxNF07XG4gIGRzdFsxNV0gPSAtbVsxNV07XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENvcGllcyBhIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBUaGUgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gQSBjb3B5IG9mIG0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkobSwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIGRzdFswXSA9IG1bMF07XG4gIGRzdFsxXSA9IG1bMV07XG4gIGRzdFsyXSA9IG1bMl07XG4gIGRzdFszXSA9IG1bM107XG4gIGRzdFs0XSA9IG1bNF07XG4gIGRzdFs1XSA9IG1bNV07XG4gIGRzdFs2XSA9IG1bNl07XG4gIGRzdFs3XSA9IG1bN107XG4gIGRzdFs4XSA9IG1bOF07XG4gIGRzdFs5XSA9IG1bOV07XG4gIGRzdFsxMF0gPSBtWzEwXTtcbiAgZHN0WzExXSA9IG1bMTFdO1xuICBkc3RbMTJdID0gbVsxMl07XG4gIGRzdFsxM10gPSBtWzEzXTtcbiAgZHN0WzE0XSA9IG1bMTRdO1xuICBkc3RbMTVdID0gbVsxNV07XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gbi1ieS1uIGlkZW50aXR5IG1hdHJpeC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IEFuIG4tYnktbiBpZGVudGl0eSBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICBkc3RbMF0gPSAxO1xuICBkc3RbMV0gPSAwO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAwO1xuICBkc3RbNV0gPSAxO1xuICBkc3RbNl0gPSAwO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSAwO1xuICBkc3RbOV0gPSAwO1xuICBkc3RbMTBdID0gMTtcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSAwO1xuICBkc3RbMTNdID0gMDtcbiAgZHN0WzE0XSA9IDA7XG4gIGRzdFsxNV0gPSAxO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBUYWtlcyB0aGUgdHJhbnNwb3NlIG9mIGEgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSB0cmFuc3Bvc2Ugb2YgbS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNwb3NlKG0sIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGlmIChkc3QgPT09IG0pIHtcbiAgICB2YXIgdDtcbiAgICB0ID0gbVsxXTtcbiAgICBtWzFdID0gbVs0XTtcbiAgICBtWzRdID0gdDtcbiAgICB0ID0gbVsyXTtcbiAgICBtWzJdID0gbVs4XTtcbiAgICBtWzhdID0gdDtcbiAgICB0ID0gbVszXTtcbiAgICBtWzNdID0gbVsxMl07XG4gICAgbVsxMl0gPSB0O1xuICAgIHQgPSBtWzZdO1xuICAgIG1bNl0gPSBtWzldO1xuICAgIG1bOV0gPSB0O1xuICAgIHQgPSBtWzddO1xuICAgIG1bN10gPSBtWzEzXTtcbiAgICBtWzEzXSA9IHQ7XG4gICAgdCA9IG1bMTFdO1xuICAgIG1bMTFdID0gbVsxNF07XG4gICAgbVsxNF0gPSB0O1xuICAgIHJldHVybiBkc3Q7XG4gIH1cblxuICB2YXIgbTAwID0gbVswICogNCArIDBdO1xuICB2YXIgbTAxID0gbVswICogNCArIDFdO1xuICB2YXIgbTAyID0gbVswICogNCArIDJdO1xuICB2YXIgbTAzID0gbVswICogNCArIDNdO1xuICB2YXIgbTEwID0gbVsxICogNCArIDBdO1xuICB2YXIgbTExID0gbVsxICogNCArIDFdO1xuICB2YXIgbTEyID0gbVsxICogNCArIDJdO1xuICB2YXIgbTEzID0gbVsxICogNCArIDNdO1xuICB2YXIgbTIwID0gbVsyICogNCArIDBdO1xuICB2YXIgbTIxID0gbVsyICogNCArIDFdO1xuICB2YXIgbTIyID0gbVsyICogNCArIDJdO1xuICB2YXIgbTIzID0gbVsyICogNCArIDNdO1xuICB2YXIgbTMwID0gbVszICogNCArIDBdO1xuICB2YXIgbTMxID0gbVszICogNCArIDFdO1xuICB2YXIgbTMyID0gbVszICogNCArIDJdO1xuICB2YXIgbTMzID0gbVszICogNCArIDNdO1xuICBkc3RbMF0gPSBtMDA7XG4gIGRzdFsxXSA9IG0xMDtcbiAgZHN0WzJdID0gbTIwO1xuICBkc3RbM10gPSBtMzA7XG4gIGRzdFs0XSA9IG0wMTtcbiAgZHN0WzVdID0gbTExO1xuICBkc3RbNl0gPSBtMjE7XG4gIGRzdFs3XSA9IG0zMTtcbiAgZHN0WzhdID0gbTAyO1xuICBkc3RbOV0gPSBtMTI7XG4gIGRzdFsxMF0gPSBtMjI7XG4gIGRzdFsxMV0gPSBtMzI7XG4gIGRzdFsxMl0gPSBtMDM7XG4gIGRzdFsxM10gPSBtMTM7XG4gIGRzdFsxNF0gPSBtMjM7XG4gIGRzdFsxNV0gPSBtMzM7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBpbnZlcnNlIG9mIGEgNC1ieS00IG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgaW52ZXJzZSBvZiBtLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnNlKG0sIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICB2YXIgbTAwID0gbVswICogNCArIDBdO1xuICB2YXIgbTAxID0gbVswICogNCArIDFdO1xuICB2YXIgbTAyID0gbVswICogNCArIDJdO1xuICB2YXIgbTAzID0gbVswICogNCArIDNdO1xuICB2YXIgbTEwID0gbVsxICogNCArIDBdO1xuICB2YXIgbTExID0gbVsxICogNCArIDFdO1xuICB2YXIgbTEyID0gbVsxICogNCArIDJdO1xuICB2YXIgbTEzID0gbVsxICogNCArIDNdO1xuICB2YXIgbTIwID0gbVsyICogNCArIDBdO1xuICB2YXIgbTIxID0gbVsyICogNCArIDFdO1xuICB2YXIgbTIyID0gbVsyICogNCArIDJdO1xuICB2YXIgbTIzID0gbVsyICogNCArIDNdO1xuICB2YXIgbTMwID0gbVszICogNCArIDBdO1xuICB2YXIgbTMxID0gbVszICogNCArIDFdO1xuICB2YXIgbTMyID0gbVszICogNCArIDJdO1xuICB2YXIgbTMzID0gbVszICogNCArIDNdO1xuICB2YXIgdG1wXzAgPSBtMjIgKiBtMzM7XG4gIHZhciB0bXBfMSA9IG0zMiAqIG0yMztcbiAgdmFyIHRtcF8yID0gbTEyICogbTMzO1xuICB2YXIgdG1wXzMgPSBtMzIgKiBtMTM7XG4gIHZhciB0bXBfNCA9IG0xMiAqIG0yMztcbiAgdmFyIHRtcF81ID0gbTIyICogbTEzO1xuICB2YXIgdG1wXzYgPSBtMDIgKiBtMzM7XG4gIHZhciB0bXBfNyA9IG0zMiAqIG0wMztcbiAgdmFyIHRtcF84ID0gbTAyICogbTIzO1xuICB2YXIgdG1wXzkgPSBtMjIgKiBtMDM7XG4gIHZhciB0bXBfMTAgPSBtMDIgKiBtMTM7XG4gIHZhciB0bXBfMTEgPSBtMTIgKiBtMDM7XG4gIHZhciB0bXBfMTIgPSBtMjAgKiBtMzE7XG4gIHZhciB0bXBfMTMgPSBtMzAgKiBtMjE7XG4gIHZhciB0bXBfMTQgPSBtMTAgKiBtMzE7XG4gIHZhciB0bXBfMTUgPSBtMzAgKiBtMTE7XG4gIHZhciB0bXBfMTYgPSBtMTAgKiBtMjE7XG4gIHZhciB0bXBfMTcgPSBtMjAgKiBtMTE7XG4gIHZhciB0bXBfMTggPSBtMDAgKiBtMzE7XG4gIHZhciB0bXBfMTkgPSBtMzAgKiBtMDE7XG4gIHZhciB0bXBfMjAgPSBtMDAgKiBtMjE7XG4gIHZhciB0bXBfMjEgPSBtMjAgKiBtMDE7XG4gIHZhciB0bXBfMjIgPSBtMDAgKiBtMTE7XG4gIHZhciB0bXBfMjMgPSBtMTAgKiBtMDE7XG4gIHZhciB0MCA9IHRtcF8wICogbTExICsgdG1wXzMgKiBtMjEgKyB0bXBfNCAqIG0zMSAtICh0bXBfMSAqIG0xMSArIHRtcF8yICogbTIxICsgdG1wXzUgKiBtMzEpO1xuICB2YXIgdDEgPSB0bXBfMSAqIG0wMSArIHRtcF82ICogbTIxICsgdG1wXzkgKiBtMzEgLSAodG1wXzAgKiBtMDEgKyB0bXBfNyAqIG0yMSArIHRtcF84ICogbTMxKTtcbiAgdmFyIHQyID0gdG1wXzIgKiBtMDEgKyB0bXBfNyAqIG0xMSArIHRtcF8xMCAqIG0zMSAtICh0bXBfMyAqIG0wMSArIHRtcF82ICogbTExICsgdG1wXzExICogbTMxKTtcbiAgdmFyIHQzID0gdG1wXzUgKiBtMDEgKyB0bXBfOCAqIG0xMSArIHRtcF8xMSAqIG0yMSAtICh0bXBfNCAqIG0wMSArIHRtcF85ICogbTExICsgdG1wXzEwICogbTIxKTtcbiAgdmFyIGQgPSAxLjAgLyAobTAwICogdDAgKyBtMTAgKiB0MSArIG0yMCAqIHQyICsgbTMwICogdDMpO1xuICBkc3RbMF0gPSBkICogdDA7XG4gIGRzdFsxXSA9IGQgKiB0MTtcbiAgZHN0WzJdID0gZCAqIHQyO1xuICBkc3RbM10gPSBkICogdDM7XG4gIGRzdFs0XSA9IGQgKiAodG1wXzEgKiBtMTAgKyB0bXBfMiAqIG0yMCArIHRtcF81ICogbTMwIC0gKHRtcF8wICogbTEwICsgdG1wXzMgKiBtMjAgKyB0bXBfNCAqIG0zMCkpO1xuICBkc3RbNV0gPSBkICogKHRtcF8wICogbTAwICsgdG1wXzcgKiBtMjAgKyB0bXBfOCAqIG0zMCAtICh0bXBfMSAqIG0wMCArIHRtcF82ICogbTIwICsgdG1wXzkgKiBtMzApKTtcbiAgZHN0WzZdID0gZCAqICh0bXBfMyAqIG0wMCArIHRtcF82ICogbTEwICsgdG1wXzExICogbTMwIC0gKHRtcF8yICogbTAwICsgdG1wXzcgKiBtMTAgKyB0bXBfMTAgKiBtMzApKTtcbiAgZHN0WzddID0gZCAqICh0bXBfNCAqIG0wMCArIHRtcF85ICogbTEwICsgdG1wXzEwICogbTIwIC0gKHRtcF81ICogbTAwICsgdG1wXzggKiBtMTAgKyB0bXBfMTEgKiBtMjApKTtcbiAgZHN0WzhdID0gZCAqICh0bXBfMTIgKiBtMTMgKyB0bXBfMTUgKiBtMjMgKyB0bXBfMTYgKiBtMzMgLSAodG1wXzEzICogbTEzICsgdG1wXzE0ICogbTIzICsgdG1wXzE3ICogbTMzKSk7XG4gIGRzdFs5XSA9IGQgKiAodG1wXzEzICogbTAzICsgdG1wXzE4ICogbTIzICsgdG1wXzIxICogbTMzIC0gKHRtcF8xMiAqIG0wMyArIHRtcF8xOSAqIG0yMyArIHRtcF8yMCAqIG0zMykpO1xuICBkc3RbMTBdID0gZCAqICh0bXBfMTQgKiBtMDMgKyB0bXBfMTkgKiBtMTMgKyB0bXBfMjIgKiBtMzMgLSAodG1wXzE1ICogbTAzICsgdG1wXzE4ICogbTEzICsgdG1wXzIzICogbTMzKSk7XG4gIGRzdFsxMV0gPSBkICogKHRtcF8xNyAqIG0wMyArIHRtcF8yMCAqIG0xMyArIHRtcF8yMyAqIG0yMyAtICh0bXBfMTYgKiBtMDMgKyB0bXBfMjEgKiBtMTMgKyB0bXBfMjIgKiBtMjMpKTtcbiAgZHN0WzEyXSA9IGQgKiAodG1wXzE0ICogbTIyICsgdG1wXzE3ICogbTMyICsgdG1wXzEzICogbTEyIC0gKHRtcF8xNiAqIG0zMiArIHRtcF8xMiAqIG0xMiArIHRtcF8xNSAqIG0yMikpO1xuICBkc3RbMTNdID0gZCAqICh0bXBfMjAgKiBtMzIgKyB0bXBfMTIgKiBtMDIgKyB0bXBfMTkgKiBtMjIgLSAodG1wXzE4ICogbTIyICsgdG1wXzIxICogbTMyICsgdG1wXzEzICogbTAyKSk7XG4gIGRzdFsxNF0gPSBkICogKHRtcF8xOCAqIG0xMiArIHRtcF8yMyAqIG0zMiArIHRtcF8xNSAqIG0wMiAtICh0bXBfMjIgKiBtMzIgKyB0bXBfMTQgKiBtMDIgKyB0bXBfMTkgKiBtMTIpKTtcbiAgZHN0WzE1XSA9IGQgKiAodG1wXzIyICogbTIyICsgdG1wXzE2ICogbTAyICsgdG1wXzIxICogbTEyIC0gKHRtcF8yMCAqIG0xMiArIHRtcF8yMyAqIG0yMiArIHRtcF8xNyAqIG0wMikpO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byA0LWJ5LTQgbWF0cmljZXMgd2l0aCBhIG9uIHRoZSBsZWZ0IGFuZCBiIG9uIHRoZSByaWdodFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBhIFRoZSBtYXRyaXggb24gdGhlIGxlZnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IGIgVGhlIG1hdHJpeCBvbiB0aGUgcmlnaHQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBtYXRyaXggcHJvZHVjdCBvZiBhIGFuZCBiLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseShhLCBiLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzQgKyAwXTtcbiAgdmFyIGExMSA9IGFbNCArIDFdO1xuICB2YXIgYTEyID0gYVs0ICsgMl07XG4gIHZhciBhMTMgPSBhWzQgKyAzXTtcbiAgdmFyIGEyMCA9IGFbOCArIDBdO1xuICB2YXIgYTIxID0gYVs4ICsgMV07XG4gIHZhciBhMjIgPSBhWzggKyAyXTtcbiAgdmFyIGEyMyA9IGFbOCArIDNdO1xuICB2YXIgYTMwID0gYVsxMiArIDBdO1xuICB2YXIgYTMxID0gYVsxMiArIDFdO1xuICB2YXIgYTMyID0gYVsxMiArIDJdO1xuICB2YXIgYTMzID0gYVsxMiArIDNdO1xuICB2YXIgYjAwID0gYlswXTtcbiAgdmFyIGIwMSA9IGJbMV07XG4gIHZhciBiMDIgPSBiWzJdO1xuICB2YXIgYjAzID0gYlszXTtcbiAgdmFyIGIxMCA9IGJbNCArIDBdO1xuICB2YXIgYjExID0gYls0ICsgMV07XG4gIHZhciBiMTIgPSBiWzQgKyAyXTtcbiAgdmFyIGIxMyA9IGJbNCArIDNdO1xuICB2YXIgYjIwID0gYls4ICsgMF07XG4gIHZhciBiMjEgPSBiWzggKyAxXTtcbiAgdmFyIGIyMiA9IGJbOCArIDJdO1xuICB2YXIgYjIzID0gYls4ICsgM107XG4gIHZhciBiMzAgPSBiWzEyICsgMF07XG4gIHZhciBiMzEgPSBiWzEyICsgMV07XG4gIHZhciBiMzIgPSBiWzEyICsgMl07XG4gIHZhciBiMzMgPSBiWzEyICsgM107XG4gIGRzdFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMiArIGEzMCAqIGIwMztcbiAgZHN0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyICsgYTMxICogYjAzO1xuICBkc3RbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDIgKyBhMzIgKiBiMDM7XG4gIGRzdFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMiArIGEzMyAqIGIwMztcbiAgZHN0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyICsgYTMwICogYjEzO1xuICBkc3RbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTIgKyBhMzEgKiBiMTM7XG4gIGRzdFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMiArIGEzMiAqIGIxMztcbiAgZHN0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyICsgYTMzICogYjEzO1xuICBkc3RbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjIgKyBhMzAgKiBiMjM7XG4gIGRzdFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMiArIGEzMSAqIGIyMztcbiAgZHN0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMiArIGEzMiAqIGIyMztcbiAgZHN0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMiArIGEzMyAqIGIyMztcbiAgZHN0WzEyXSA9IGEwMCAqIGIzMCArIGExMCAqIGIzMSArIGEyMCAqIGIzMiArIGEzMCAqIGIzMztcbiAgZHN0WzEzXSA9IGEwMSAqIGIzMCArIGExMSAqIGIzMSArIGEyMSAqIGIzMiArIGEzMSAqIGIzMztcbiAgZHN0WzE0XSA9IGEwMiAqIGIzMCArIGExMiAqIGIzMSArIGEyMiAqIGIzMiArIGEzMiAqIGIzMztcbiAgZHN0WzE1XSA9IGEwMyAqIGIzMCArIGExMyAqIGIzMSArIGEyMyAqIGIzMiArIGEzMyAqIGIzMztcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogU2V0cyB0aGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIGEgNC1ieS00IG1hdHJpeCB0byB0aGUgZ2l2ZW5cbiAqIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gYSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IFRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBtYXRyaXggd2l0aCB0cmFuc2xhdGlvbiBzZXQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRyYW5zbGF0aW9uKGEsIHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgaWRlbnRpdHkoKTtcblxuICBpZiAoYSAhPT0gZHN0KSB7XG4gICAgZHN0WzBdID0gYVswXTtcbiAgICBkc3RbMV0gPSBhWzFdO1xuICAgIGRzdFsyXSA9IGFbMl07XG4gICAgZHN0WzNdID0gYVszXTtcbiAgICBkc3RbNF0gPSBhWzRdO1xuICAgIGRzdFs1XSA9IGFbNV07XG4gICAgZHN0WzZdID0gYVs2XTtcbiAgICBkc3RbN10gPSBhWzddO1xuICAgIGRzdFs4XSA9IGFbOF07XG4gICAgZHN0WzldID0gYVs5XTtcbiAgICBkc3RbMTBdID0gYVsxMF07XG4gICAgZHN0WzExXSA9IGFbMTFdO1xuICB9XG5cbiAgZHN0WzEyXSA9IHZbMF07XG4gIGRzdFsxM10gPSB2WzFdO1xuICBkc3RbMTRdID0gdlsyXTtcbiAgZHN0WzE1XSA9IDE7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiBhIDQtYnktNCBtYXRyaXggYXMgYSB2ZWN0b3Igd2l0aCAzXG4gKiBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnQgb2YgbS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24obSwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCB2My5jcmVhdGUoKTtcbiAgZHN0WzBdID0gbVsxMl07XG4gIGRzdFsxXSA9IG1bMTNdO1xuICBkc3RbMl0gPSBtWzE0XTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBheGlzIG9mIGEgNHg0IG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDMgZW50cmllc1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge251bWJlcn0gYXhpcyBUaGUgYXhpcyAwID0geCwgMSA9IHksIDIgPSB6O1xuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIGF4aXMgY29tcG9uZW50IG9mIG0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEF4aXMobSwgYXhpcywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCB2My5jcmVhdGUoKTtcbiAgdmFyIG9mZiA9IGF4aXMgKiA0O1xuICBkc3RbMF0gPSBtW29mZiArIDBdO1xuICBkc3RbMV0gPSBtW29mZiArIDFdO1xuICBkc3RbMl0gPSBtW29mZiArIDJdO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBTZXRzIGFuIGF4aXMgb2YgYSA0eDQgbWF0cml4IGFzIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiB0aGUgYXhpcyB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBheGlzIFRoZSBheGlzICAwID0geCwgMSA9IHksIDIgPSB6O1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBUaGUgbWF0cml4IHRvIHNldC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBtYXRyaXggd2l0aCBheGlzIHNldC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gc2V0QXhpcyhhLCB2LCBheGlzLCBkc3QpIHtcbiAgaWYgKGRzdCAhPT0gYSkge1xuICAgIGRzdCA9IGNvcHkoYSwgZHN0KTtcbiAgfVxuXG4gIHZhciBvZmYgPSBheGlzICogNDtcbiAgZHN0W29mZiArIDBdID0gdlswXTtcbiAgZHN0W29mZiArIDFdID0gdlsxXTtcbiAgZHN0W29mZiArIDJdID0gdlsyXTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgYSA0LWJ5LTQgcGVyc3BlY3RpdmUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGdpdmVuIHRoZSBhbmd1bGFyIGhlaWdodFxuICogb2YgdGhlIGZydXN0dW0sIHRoZSBhc3BlY3QgcmF0aW8sIGFuZCB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gIFRoZVxuICogYXJndW1lbnRzIGRlZmluZSBhIGZydXN0dW0gZXh0ZW5kaW5nIGluIHRoZSBuZWdhdGl2ZSB6IGRpcmVjdGlvbi4gIFRoZSBnaXZlblxuICogYW5nbGUgaXMgdGhlIHZlcnRpY2FsIGFuZ2xlIG9mIHRoZSBmcnVzdHVtLCBhbmQgdGhlIGhvcml6b250YWwgYW5nbGUgaXNcbiAqIGRldGVybWluZWQgdG8gcHJvZHVjZSB0aGUgZ2l2ZW4gYXNwZWN0IHJhdGlvLiAgVGhlIGFyZ3VtZW50cyBuZWFyIGFuZCBmYXIgYXJlXG4gKiB0aGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiAgTm90ZSB0aGF0IG5lYXIgYW5kIGZhclxuICogYXJlIG5vdCB6IGNvb3JkaW5hdGVzLCBidXQgcmF0aGVyIHRoZXkgYXJlIGRpc3RhbmNlcyBhbG9uZyB0aGUgbmVnYXRpdmVcbiAqIHotYXhpcy4gIFRoZSBtYXRyaXggZ2VuZXJhdGVkIHNlbmRzIHRoZSB2aWV3aW5nIGZydXN0dW0gdG8gdGhlIHVuaXQgYm94LlxuICogV2UgYXNzdW1lIGEgdW5pdCBib3ggZXh0ZW5kaW5nIGZyb20gLTEgdG8gMSBpbiB0aGUgeCBhbmQgeSBkaW1lbnNpb25zIGFuZFxuICogZnJvbSAwIHRvIDEgaW4gdGhlIHogZGltZW5zaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkT2ZWaWV3WUluUmFkaWFucyBUaGUgY2FtZXJhIGFuZ2xlIGZyb20gdG9wIHRvIGJvdHRvbSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IFRoZSBhc3BlY3QgcmF0aW8gd2lkdGggLyBoZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0gek5lYXIgVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gKiAgICAgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gekZhciBUaGUgZGVwdGggKG5lZ2F0aXZlIHogY29vcmRpbmF0ZSlcbiAqICAgICBvZiB0aGUgZmFyIGNsaXBwaW5nIHBsYW5lLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgcGVyc3BlY3RpdmUgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBwZXJzcGVjdGl2ZShmaWVsZE9mVmlld1lJblJhZGlhbnMsIGFzcGVjdCwgek5lYXIsIHpGYXIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICB2YXIgZiA9IE1hdGgudGFuKE1hdGguUEkgKiAwLjUgLSAwLjUgKiBmaWVsZE9mVmlld1lJblJhZGlhbnMpO1xuICB2YXIgcmFuZ2VJbnYgPSAxLjAgLyAoek5lYXIgLSB6RmFyKTtcbiAgZHN0WzBdID0gZiAvIGFzcGVjdDtcbiAgZHN0WzFdID0gMDtcbiAgZHN0WzJdID0gMDtcbiAgZHN0WzNdID0gMDtcbiAgZHN0WzRdID0gMDtcbiAgZHN0WzVdID0gZjtcbiAgZHN0WzZdID0gMDtcbiAgZHN0WzddID0gMDtcbiAgZHN0WzhdID0gMDtcbiAgZHN0WzldID0gMDtcbiAgZHN0WzEwXSA9ICh6TmVhciArIHpGYXIpICogcmFuZ2VJbnY7XG4gIGRzdFsxMV0gPSAtMTtcbiAgZHN0WzEyXSA9IDA7XG4gIGRzdFsxM10gPSAwO1xuICBkc3RbMTRdID0gek5lYXIgKiB6RmFyICogcmFuZ2VJbnYgKiAyO1xuICBkc3RbMTVdID0gMDtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgYSA0LWJ5LTQgb3J0aG9nb25hbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZ2l2ZW4gdGhlIGxlZnQsIHJpZ2h0LFxuICogYm90dG9tLCBhbmQgdG9wIGRpbWVuc2lvbnMgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgYXMgd2VsbCBhcyB0aGVcbiAqIG5lYXIgYW5kIGZhciBjbGlwcGluZyBwbGFuZSBkaXN0YW5jZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IHNpZGUgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgdmlld3BvcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgc2lkZSBvZiB0aGUgbmVhciBjbGlwcGluZyBwbGFuZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIHZpZXdwb3J0LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3Agb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgdmlld3BvcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBUaGUgZGVwdGggKG5lZ2F0aXZlIHogY29vcmRpbmF0ZSlcbiAqICAgICBvZiB0aGUgbmVhciBjbGlwcGluZyBwbGFuZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gKiAgICAgb2YgdGhlIGZhciBjbGlwcGluZyBwbGFuZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gT3V0cHV0IG1hdHJpeC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBwZXJzcGVjdGl2ZSBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIG9ydGhvKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgZHN0WzBdID0gMiAvIChyaWdodCAtIGxlZnQpO1xuICBkc3RbMV0gPSAwO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAwO1xuICBkc3RbNV0gPSAyIC8gKHRvcCAtIGJvdHRvbSk7XG4gIGRzdFs2XSA9IDA7XG4gIGRzdFs3XSA9IDA7XG4gIGRzdFs4XSA9IDA7XG4gIGRzdFs5XSA9IDA7XG4gIGRzdFsxMF0gPSAyIC8gKG5lYXIgLSBmYXIpO1xuICBkc3RbMTFdID0gMDtcbiAgZHN0WzEyXSA9IChyaWdodCArIGxlZnQpIC8gKGxlZnQgLSByaWdodCk7XG4gIGRzdFsxM10gPSAodG9wICsgYm90dG9tKSAvIChib3R0b20gLSB0b3ApO1xuICBkc3RbMTRdID0gKGZhciArIG5lYXIpIC8gKG5lYXIgLSBmYXIpO1xuICBkc3RbMTVdID0gMTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgYSA0LWJ5LTQgcGVyc3BlY3RpdmUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGdpdmVuIHRoZSBsZWZ0LCByaWdodCxcbiAqIHRvcCwgYm90dG9tLCBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiBUaGUgYXJndW1lbnRzIGRlZmluZSBhIGZydXN0dW1cbiAqIGV4dGVuZGluZyBpbiB0aGUgbmVnYXRpdmUgeiBkaXJlY3Rpb24uIFRoZSBhcmd1bWVudHMgbmVhciBhbmQgZmFyIGFyZSB0aGVcbiAqIGRpc3RhbmNlcyB0byB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gTm90ZSB0aGF0IG5lYXIgYW5kIGZhciBhcmUgbm90XG4gKiB6IGNvb3JkaW5hdGVzLCBidXQgcmF0aGVyIHRoZXkgYXJlIGRpc3RhbmNlcyBhbG9uZyB0aGUgbmVnYXRpdmUgei1heGlzLiBUaGVcbiAqIG1hdHJpeCBnZW5lcmF0ZWQgc2VuZHMgdGhlIHZpZXdpbmcgZnJ1c3R1bSB0byB0aGUgdW5pdCBib3guIFdlIGFzc3VtZSBhIHVuaXRcbiAqIGJveCBleHRlbmRpbmcgZnJvbSAtMSB0byAxIGluIHRoZSB4IGFuZCB5IGRpbWVuc2lvbnMgYW5kIGZyb20gMCB0byAxIGluIHRoZSB6XG4gKiBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHBsYW5lIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgcGxhbmUgb2YgdGhlIGJveC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIHBsYW5lIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IHBsYW5lIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBUaGUgbmVnYXRpdmUgeiBjb29yZGluYXRlIG9mIHRoZSBuZWFyIHBsYW5lIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIFRoZSBuZWdhdGl2ZSB6IGNvb3JkaW5hdGUgb2YgdGhlIGZhciBwbGFuZSBvZiB0aGUgYm94LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBPdXRwdXQgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBmcnVzdHVtKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIGR4ID0gcmlnaHQgLSBsZWZ0O1xuICB2YXIgZHkgPSB0b3AgLSBib3R0b207XG4gIHZhciBkeiA9IG5lYXIgLSBmYXI7XG4gIGRzdFswXSA9IDIgKiBuZWFyIC8gZHg7XG4gIGRzdFsxXSA9IDA7XG4gIGRzdFsyXSA9IDA7XG4gIGRzdFszXSA9IDA7XG4gIGRzdFs0XSA9IDA7XG4gIGRzdFs1XSA9IDIgKiBuZWFyIC8gZHk7XG4gIGRzdFs2XSA9IDA7XG4gIGRzdFs3XSA9IDA7XG4gIGRzdFs4XSA9IChsZWZ0ICsgcmlnaHQpIC8gZHg7XG4gIGRzdFs5XSA9ICh0b3AgKyBib3R0b20pIC8gZHk7XG4gIGRzdFsxMF0gPSBmYXIgLyBkejtcbiAgZHN0WzExXSA9IC0xO1xuICBkc3RbMTJdID0gMDtcbiAgZHN0WzEzXSA9IDA7XG4gIGRzdFsxNF0gPSBuZWFyICogZmFyIC8gZHo7XG4gIGRzdFsxNV0gPSAwO1xuICByZXR1cm4gZHN0O1xufVxuXG52YXIgeEF4aXM7XG52YXIgeUF4aXM7XG52YXIgekF4aXM7XG4vKipcbiAqIENvbXB1dGVzIGEgNC1ieS00IGxvb2stYXQgdHJhbnNmb3JtYXRpb24uXG4gKlxuICogVGhpcyBpcyBhIG1hdHJpeCB3aGljaCBwb3NpdGlvbnMgdGhlIGNhbWVyYSBpdHNlbGYuIElmIHlvdSB3YW50XG4gKiBhIHZpZXcgbWF0cml4IChhIG1hdHJpeCB3aGljaCBtb3ZlcyB0aGluZ3MgaW4gZnJvbnQgb2YgdGhlIGNhbWVyYSlcbiAqIHRha2UgdGhlIGludmVyc2Ugb2YgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGV5ZSBUaGUgcG9zaXRpb24gb2YgdGhlIGV5ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdGFyZ2V0IFRoZSBwb3NpdGlvbiBtZWFudCB0byBiZSB2aWV3ZWQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHVwIEEgdmVjdG9yIHBvaW50aW5nIHVwLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgbG9vay1hdCBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5mdW5jdGlvbiBsb29rQXQoZXllLCB0YXJnZXQsIHVwLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgeEF4aXMgPSB4QXhpcyB8fCB2My5jcmVhdGUoKTtcbiAgeUF4aXMgPSB5QXhpcyB8fCB2My5jcmVhdGUoKTtcbiAgekF4aXMgPSB6QXhpcyB8fCB2My5jcmVhdGUoKTtcbiAgdjMubm9ybWFsaXplKHYzLnN1YnRyYWN0KGV5ZSwgdGFyZ2V0LCB6QXhpcyksIHpBeGlzKTtcbiAgdjMubm9ybWFsaXplKHYzLmNyb3NzKHVwLCB6QXhpcywgeEF4aXMpLCB4QXhpcyk7XG4gIHYzLm5vcm1hbGl6ZSh2My5jcm9zcyh6QXhpcywgeEF4aXMsIHlBeGlzKSwgeUF4aXMpO1xuICBkc3RbMF0gPSB4QXhpc1swXTtcbiAgZHN0WzFdID0geEF4aXNbMV07XG4gIGRzdFsyXSA9IHhBeGlzWzJdO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSB5QXhpc1swXTtcbiAgZHN0WzVdID0geUF4aXNbMV07XG4gIGRzdFs2XSA9IHlBeGlzWzJdO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSB6QXhpc1swXTtcbiAgZHN0WzldID0gekF4aXNbMV07XG4gIGRzdFsxMF0gPSB6QXhpc1syXTtcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSBleWVbMF07XG4gIGRzdFsxM10gPSBleWVbMV07XG4gIGRzdFsxNF0gPSBleWVbMl07XG4gIGRzdFsxNV0gPSAxO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCB0cmFuc2xhdGVzIGJ5IHRoZSBnaXZlbiB2ZWN0b3Igdi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgdmVjdG9yIGJ5XG4gKiAgICAgd2hpY2ggdG8gdHJhbnNsYXRlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgdHJhbnNsYXRpb24gbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2xhdGlvbih2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgZHN0WzBdID0gMTtcbiAgZHN0WzFdID0gMDtcbiAgZHN0WzJdID0gMDtcbiAgZHN0WzNdID0gMDtcbiAgZHN0WzRdID0gMDtcbiAgZHN0WzVdID0gMTtcbiAgZHN0WzZdID0gMDtcbiAgZHN0WzddID0gMDtcbiAgZHN0WzhdID0gMDtcbiAgZHN0WzldID0gMDtcbiAgZHN0WzEwXSA9IDE7XG4gIGRzdFsxMV0gPSAwO1xuICBkc3RbMTJdID0gdlswXTtcbiAgZHN0WzEzXSA9IHZbMV07XG4gIGRzdFsxNF0gPSB2WzJdO1xuICBkc3RbMTVdID0gMTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogVHJhbnNsYXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBieSB0aGUgZ2l2ZW4gdmVjdG9yIHYuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgdmVjdG9yIGJ5XG4gKiAgICAgd2hpY2ggdG8gdHJhbnNsYXRlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgdHJhbnNsYXRlZCBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShtLCB2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIHYwID0gdlswXTtcbiAgdmFyIHYxID0gdlsxXTtcbiAgdmFyIHYyID0gdlsyXTtcbiAgdmFyIG0wMCA9IG1bMF07XG4gIHZhciBtMDEgPSBtWzFdO1xuICB2YXIgbTAyID0gbVsyXTtcbiAgdmFyIG0wMyA9IG1bM107XG4gIHZhciBtMTAgPSBtWzEgKiA0ICsgMF07XG4gIHZhciBtMTEgPSBtWzEgKiA0ICsgMV07XG4gIHZhciBtMTIgPSBtWzEgKiA0ICsgMl07XG4gIHZhciBtMTMgPSBtWzEgKiA0ICsgM107XG4gIHZhciBtMjAgPSBtWzIgKiA0ICsgMF07XG4gIHZhciBtMjEgPSBtWzIgKiA0ICsgMV07XG4gIHZhciBtMjIgPSBtWzIgKiA0ICsgMl07XG4gIHZhciBtMjMgPSBtWzIgKiA0ICsgM107XG4gIHZhciBtMzAgPSBtWzMgKiA0ICsgMF07XG4gIHZhciBtMzEgPSBtWzMgKiA0ICsgMV07XG4gIHZhciBtMzIgPSBtWzMgKiA0ICsgMl07XG4gIHZhciBtMzMgPSBtWzMgKiA0ICsgM107XG5cbiAgaWYgKG0gIT09IGRzdCkge1xuICAgIGRzdFswXSA9IG0wMDtcbiAgICBkc3RbMV0gPSBtMDE7XG4gICAgZHN0WzJdID0gbTAyO1xuICAgIGRzdFszXSA9IG0wMztcbiAgICBkc3RbNF0gPSBtMTA7XG4gICAgZHN0WzVdID0gbTExO1xuICAgIGRzdFs2XSA9IG0xMjtcbiAgICBkc3RbN10gPSBtMTM7XG4gICAgZHN0WzhdID0gbTIwO1xuICAgIGRzdFs5XSA9IG0yMTtcbiAgICBkc3RbMTBdID0gbTIyO1xuICAgIGRzdFsxMV0gPSBtMjM7XG4gIH1cblxuICBkc3RbMTJdID0gbTAwICogdjAgKyBtMTAgKiB2MSArIG0yMCAqIHYyICsgbTMwO1xuICBkc3RbMTNdID0gbTAxICogdjAgKyBtMTEgKiB2MSArIG0yMSAqIHYyICsgbTMxO1xuICBkc3RbMTRdID0gbTAyICogdjAgKyBtMTIgKiB2MSArIG0yMiAqIHYyICsgbTMyO1xuICBkc3RbMTVdID0gbTAzICogdjAgKyBtMTMgKiB2MSArIG0yMyAqIHYyICsgbTMzO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgeC1heGlzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHJvdGF0aW9uIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRpb25YKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIHZhciBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICBkc3RbMF0gPSAxO1xuICBkc3RbMV0gPSAwO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAwO1xuICBkc3RbNV0gPSBjO1xuICBkc3RbNl0gPSBzO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSAwO1xuICBkc3RbOV0gPSAtcztcbiAgZHN0WzEwXSA9IGM7XG4gIGRzdFsxMV0gPSAwO1xuICBkc3RbMTJdID0gMDtcbiAgZHN0WzEzXSA9IDA7XG4gIGRzdFsxNF0gPSAwO1xuICBkc3RbMTVdID0gMTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogUm90YXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBhcm91bmQgdGhlIHgtYXhpcyBieSB0aGUgZ2l2ZW5cbiAqIGFuZ2xlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSByb3RhdGVkIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWChtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIHZhciBtMTAgPSBtWzRdO1xuICB2YXIgbTExID0gbVs1XTtcbiAgdmFyIG0xMiA9IG1bNl07XG4gIHZhciBtMTMgPSBtWzddO1xuICB2YXIgbTIwID0gbVs4XTtcbiAgdmFyIG0yMSA9IG1bOV07XG4gIHZhciBtMjIgPSBtWzEwXTtcbiAgdmFyIG0yMyA9IG1bMTFdO1xuICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gIGRzdFs0XSA9IGMgKiBtMTAgKyBzICogbTIwO1xuICBkc3RbNV0gPSBjICogbTExICsgcyAqIG0yMTtcbiAgZHN0WzZdID0gYyAqIG0xMiArIHMgKiBtMjI7XG4gIGRzdFs3XSA9IGMgKiBtMTMgKyBzICogbTIzO1xuICBkc3RbOF0gPSBjICogbTIwIC0gcyAqIG0xMDtcbiAgZHN0WzldID0gYyAqIG0yMSAtIHMgKiBtMTE7XG4gIGRzdFsxMF0gPSBjICogbTIyIC0gcyAqIG0xMjtcbiAgZHN0WzExXSA9IGMgKiBtMjMgLSBzICogbTEzO1xuXG4gIGlmIChtICE9PSBkc3QpIHtcbiAgICBkc3RbMF0gPSBtWzBdO1xuICAgIGRzdFsxXSA9IG1bMV07XG4gICAgZHN0WzJdID0gbVsyXTtcbiAgICBkc3RbM10gPSBtWzNdO1xuICAgIGRzdFsxMl0gPSBtWzEyXTtcbiAgICBkc3RbMTNdID0gbVsxM107XG4gICAgZHN0WzE0XSA9IG1bMTRdO1xuICAgIGRzdFsxNV0gPSBtWzE1XTtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYXJvdW5kIHRoZSB5LWF4aXMgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgcm90YXRpb24gbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGlvblkoYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gIGRzdFswXSA9IGM7XG4gIGRzdFsxXSA9IDA7XG4gIGRzdFsyXSA9IC1zO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAwO1xuICBkc3RbNV0gPSAxO1xuICBkc3RbNl0gPSAwO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSBzO1xuICBkc3RbOV0gPSAwO1xuICBkc3RbMTBdID0gYztcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSAwO1xuICBkc3RbMTNdID0gMDtcbiAgZHN0WzE0XSA9IDA7XG4gIGRzdFsxNV0gPSAxO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBSb3RhdGVzIHRoZSBnaXZlbiA0LWJ5LTQgbWF0cml4IGFyb3VuZCB0aGUgeS1heGlzIGJ5IHRoZSBnaXZlblxuICogYW5nbGUuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHJvdGF0ZWQgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVZKG0sIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIG0wMCA9IG1bMCAqIDQgKyAwXTtcbiAgdmFyIG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgdmFyIG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgdmFyIG0wMyA9IG1bMCAqIDQgKyAzXTtcbiAgdmFyIG0yMCA9IG1bMiAqIDQgKyAwXTtcbiAgdmFyIG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgdmFyIG0yMiA9IG1bMiAqIDQgKyAyXTtcbiAgdmFyIG0yMyA9IG1bMiAqIDQgKyAzXTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIHZhciBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICBkc3RbMF0gPSBjICogbTAwIC0gcyAqIG0yMDtcbiAgZHN0WzFdID0gYyAqIG0wMSAtIHMgKiBtMjE7XG4gIGRzdFsyXSA9IGMgKiBtMDIgLSBzICogbTIyO1xuICBkc3RbM10gPSBjICogbTAzIC0gcyAqIG0yMztcbiAgZHN0WzhdID0gYyAqIG0yMCArIHMgKiBtMDA7XG4gIGRzdFs5XSA9IGMgKiBtMjEgKyBzICogbTAxO1xuICBkc3RbMTBdID0gYyAqIG0yMiArIHMgKiBtMDI7XG4gIGRzdFsxMV0gPSBjICogbTIzICsgcyAqIG0wMztcblxuICBpZiAobSAhPT0gZHN0KSB7XG4gICAgZHN0WzRdID0gbVs0XTtcbiAgICBkc3RbNV0gPSBtWzVdO1xuICAgIGRzdFs2XSA9IG1bNl07XG4gICAgZHN0WzddID0gbVs3XTtcbiAgICBkc3RbMTJdID0gbVsxMl07XG4gICAgZHN0WzEzXSA9IG1bMTNdO1xuICAgIGRzdFsxNF0gPSBtWzE0XTtcbiAgICBkc3RbMTVdID0gbVsxNV07XG4gIH1cblxuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgei1heGlzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHJvdGF0aW9uIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRpb25aKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIHZhciBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICBkc3RbMF0gPSBjO1xuICBkc3RbMV0gPSBzO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAtcztcbiAgZHN0WzVdID0gYztcbiAgZHN0WzZdID0gMDtcbiAgZHN0WzddID0gMDtcbiAgZHN0WzhdID0gMDtcbiAgZHN0WzldID0gMDtcbiAgZHN0WzEwXSA9IDE7XG4gIGRzdFsxMV0gPSAwO1xuICBkc3RbMTJdID0gMDtcbiAgZHN0WzEzXSA9IDA7XG4gIGRzdFsxNF0gPSAwO1xuICBkc3RbMTVdID0gMTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogUm90YXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBhcm91bmQgdGhlIHotYXhpcyBieSB0aGUgZ2l2ZW5cbiAqIGFuZ2xlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSByb3RhdGVkIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWihtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIHZhciBtMDAgPSBtWzAgKiA0ICsgMF07XG4gIHZhciBtMDEgPSBtWzAgKiA0ICsgMV07XG4gIHZhciBtMDIgPSBtWzAgKiA0ICsgMl07XG4gIHZhciBtMDMgPSBtWzAgKiA0ICsgM107XG4gIHZhciBtMTAgPSBtWzEgKiA0ICsgMF07XG4gIHZhciBtMTEgPSBtWzEgKiA0ICsgMV07XG4gIHZhciBtMTIgPSBtWzEgKiA0ICsgMl07XG4gIHZhciBtMTMgPSBtWzEgKiA0ICsgM107XG4gIHZhciBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgZHN0WzBdID0gYyAqIG0wMCArIHMgKiBtMTA7XG4gIGRzdFsxXSA9IGMgKiBtMDEgKyBzICogbTExO1xuICBkc3RbMl0gPSBjICogbTAyICsgcyAqIG0xMjtcbiAgZHN0WzNdID0gYyAqIG0wMyArIHMgKiBtMTM7XG4gIGRzdFs0XSA9IGMgKiBtMTAgLSBzICogbTAwO1xuICBkc3RbNV0gPSBjICogbTExIC0gcyAqIG0wMTtcbiAgZHN0WzZdID0gYyAqIG0xMiAtIHMgKiBtMDI7XG4gIGRzdFs3XSA9IGMgKiBtMTMgLSBzICogbTAzO1xuXG4gIGlmIChtICE9PSBkc3QpIHtcbiAgICBkc3RbOF0gPSBtWzhdO1xuICAgIGRzdFs5XSA9IG1bOV07XG4gICAgZHN0WzEwXSA9IG1bMTBdO1xuICAgIGRzdFsxMV0gPSBtWzExXTtcbiAgICBkc3RbMTJdID0gbVsxMl07XG4gICAgZHN0WzEzXSA9IG1bMTNdO1xuICAgIGRzdFsxNF0gPSBtWzE0XTtcbiAgICBkc3RbMTVdID0gbVsxNV07XG4gIH1cblxuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpcyBieSB0aGUgZ2l2ZW5cbiAqIGFuZ2xlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBheGlzIFRoZSBheGlzXG4gKiAgICAgYWJvdXQgd2hpY2ggdG8gcm90YXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBBIG1hdHJpeCB3aGljaCByb3RhdGVzIGFuZ2xlIHJhZGlhbnNcbiAqICAgICBhcm91bmQgdGhlIGF4aXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIGF4aXNSb3RhdGlvbihheGlzLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIHZhciB4ID0gYXhpc1swXTtcbiAgdmFyIHkgPSBheGlzWzFdO1xuICB2YXIgeiA9IGF4aXNbMl07XG4gIHZhciBuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIHggLz0gbjtcbiAgeSAvPSBuO1xuICB6IC89IG47XG4gIHZhciB4eCA9IHggKiB4O1xuICB2YXIgeXkgPSB5ICogeTtcbiAgdmFyIHp6ID0geiAqIHo7XG4gIHZhciBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgdmFyIG9uZU1pbnVzQ29zaW5lID0gMSAtIGM7XG4gIGRzdFswXSA9IHh4ICsgKDEgLSB4eCkgKiBjO1xuICBkc3RbMV0gPSB4ICogeSAqIG9uZU1pbnVzQ29zaW5lICsgeiAqIHM7XG4gIGRzdFsyXSA9IHggKiB6ICogb25lTWludXNDb3NpbmUgLSB5ICogcztcbiAgZHN0WzNdID0gMDtcbiAgZHN0WzRdID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSAtIHogKiBzO1xuICBkc3RbNV0gPSB5eSArICgxIC0geXkpICogYztcbiAgZHN0WzZdID0geSAqIHogKiBvbmVNaW51c0Nvc2luZSArIHggKiBzO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lICsgeSAqIHM7XG4gIGRzdFs5XSA9IHkgKiB6ICogb25lTWludXNDb3NpbmUgLSB4ICogcztcbiAgZHN0WzEwXSA9IHp6ICsgKDEgLSB6eikgKiBjO1xuICBkc3RbMTFdID0gMDtcbiAgZHN0WzEyXSA9IDA7XG4gIGRzdFsxM10gPSAwO1xuICBkc3RbMTRdID0gMDtcbiAgZHN0WzE1XSA9IDE7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFJvdGF0ZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggYXJvdW5kIHRoZSBnaXZlbiBheGlzIGJ5IHRoZVxuICogZ2l2ZW4gYW5nbGUuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYXhpcyBUaGUgYXhpc1xuICogICAgIGFib3V0IHdoaWNoIHRvIHJvdGF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHJvdGF0ZWQgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBheGlzUm90YXRlKG0sIGF4aXMsIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIHggPSBheGlzWzBdO1xuICB2YXIgeSA9IGF4aXNbMV07XG4gIHZhciB6ID0gYXhpc1syXTtcbiAgdmFyIG4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgeCAvPSBuO1xuICB5IC89IG47XG4gIHogLz0gbjtcbiAgdmFyIHh4ID0geCAqIHg7XG4gIHZhciB5eSA9IHkgKiB5O1xuICB2YXIgenogPSB6ICogejtcbiAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIHZhciBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICB2YXIgb25lTWludXNDb3NpbmUgPSAxIC0gYztcbiAgdmFyIHIwMCA9IHh4ICsgKDEgLSB4eCkgKiBjO1xuICB2YXIgcjAxID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSArIHogKiBzO1xuICB2YXIgcjAyID0geCAqIHogKiBvbmVNaW51c0Nvc2luZSAtIHkgKiBzO1xuICB2YXIgcjEwID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSAtIHogKiBzO1xuICB2YXIgcjExID0geXkgKyAoMSAtIHl5KSAqIGM7XG4gIHZhciByMTIgPSB5ICogeiAqIG9uZU1pbnVzQ29zaW5lICsgeCAqIHM7XG4gIHZhciByMjAgPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lICsgeSAqIHM7XG4gIHZhciByMjEgPSB5ICogeiAqIG9uZU1pbnVzQ29zaW5lIC0geCAqIHM7XG4gIHZhciByMjIgPSB6eiArICgxIC0genopICogYztcbiAgdmFyIG0wMCA9IG1bMF07XG4gIHZhciBtMDEgPSBtWzFdO1xuICB2YXIgbTAyID0gbVsyXTtcbiAgdmFyIG0wMyA9IG1bM107XG4gIHZhciBtMTAgPSBtWzRdO1xuICB2YXIgbTExID0gbVs1XTtcbiAgdmFyIG0xMiA9IG1bNl07XG4gIHZhciBtMTMgPSBtWzddO1xuICB2YXIgbTIwID0gbVs4XTtcbiAgdmFyIG0yMSA9IG1bOV07XG4gIHZhciBtMjIgPSBtWzEwXTtcbiAgdmFyIG0yMyA9IG1bMTFdO1xuICBkc3RbMF0gPSByMDAgKiBtMDAgKyByMDEgKiBtMTAgKyByMDIgKiBtMjA7XG4gIGRzdFsxXSA9IHIwMCAqIG0wMSArIHIwMSAqIG0xMSArIHIwMiAqIG0yMTtcbiAgZHN0WzJdID0gcjAwICogbTAyICsgcjAxICogbTEyICsgcjAyICogbTIyO1xuICBkc3RbM10gPSByMDAgKiBtMDMgKyByMDEgKiBtMTMgKyByMDIgKiBtMjM7XG4gIGRzdFs0XSA9IHIxMCAqIG0wMCArIHIxMSAqIG0xMCArIHIxMiAqIG0yMDtcbiAgZHN0WzVdID0gcjEwICogbTAxICsgcjExICogbTExICsgcjEyICogbTIxO1xuICBkc3RbNl0gPSByMTAgKiBtMDIgKyByMTEgKiBtMTIgKyByMTIgKiBtMjI7XG4gIGRzdFs3XSA9IHIxMCAqIG0wMyArIHIxMSAqIG0xMyArIHIxMiAqIG0yMztcbiAgZHN0WzhdID0gcjIwICogbTAwICsgcjIxICogbTEwICsgcjIyICogbTIwO1xuICBkc3RbOV0gPSByMjAgKiBtMDEgKyByMjEgKiBtMTEgKyByMjIgKiBtMjE7XG4gIGRzdFsxMF0gPSByMjAgKiBtMDIgKyByMjEgKiBtMTIgKyByMjIgKiBtMjI7XG4gIGRzdFsxMV0gPSByMjAgKiBtMDMgKyByMjEgKiBtMTMgKyByMjIgKiBtMjM7XG5cbiAgaWYgKG0gIT09IGRzdCkge1xuICAgIGRzdFsxMl0gPSBtWzEyXTtcbiAgICBkc3RbMTNdID0gbVsxM107XG4gICAgZHN0WzE0XSA9IG1bMTRdO1xuICAgIGRzdFsxNV0gPSBtWzE1XTtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHNjYWxlcyBpbiBlYWNoIGRpbWVuc2lvbiBieSBhbiBhbW91bnQgZ2l2ZW4gYnlcbiAqIHRoZSBjb3JyZXNwb25kaW5nIGVudHJ5IGluIHRoZSBnaXZlbiB2ZWN0b3I7IGFzc3VtZXMgdGhlIHZlY3RvciBoYXMgdGhyZWVcbiAqIGVudHJpZXMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgQSB2ZWN0b3Igb2ZcbiAqICAgICB0aHJlZSBlbnRyaWVzIHNwZWNpZnlpbmcgdGhlIGZhY3RvciBieSB3aGljaCB0byBzY2FsZSBpbiBlYWNoIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHNjYWxpbmcgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsaW5nKHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICBkc3RbMF0gPSB2WzBdO1xuICBkc3RbMV0gPSAwO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAwO1xuICBkc3RbNV0gPSB2WzFdO1xuICBkc3RbNl0gPSAwO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSAwO1xuICBkc3RbOV0gPSAwO1xuICBkc3RbMTBdID0gdlsyXTtcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSAwO1xuICBkc3RbMTNdID0gMDtcbiAgZHN0WzE0XSA9IDA7XG4gIGRzdFsxNV0gPSAxO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBTY2FsZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggaW4gZWFjaCBkaW1lbnNpb24gYnkgYW4gYW1vdW50XG4gKiBnaXZlbiBieSB0aGUgY29ycmVzcG9uZGluZyBlbnRyeSBpbiB0aGUgZ2l2ZW4gdmVjdG9yOyBhc3N1bWVzIHRoZSB2ZWN0b3IgaGFzXG4gKiB0aHJlZSBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXggdG8gYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgQSB2ZWN0b3Igb2YgdGhyZWUgZW50cmllcyBzcGVjaWZ5aW5nIHRoZVxuICogICAgIGZhY3RvciBieSB3aGljaCB0byBzY2FsZSBpbiBlYWNoIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHNjYWxlZCBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG0sIHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICB2YXIgdjAgPSB2WzBdO1xuICB2YXIgdjEgPSB2WzFdO1xuICB2YXIgdjIgPSB2WzJdO1xuICBkc3RbMF0gPSB2MCAqIG1bMCAqIDQgKyAwXTtcbiAgZHN0WzFdID0gdjAgKiBtWzAgKiA0ICsgMV07XG4gIGRzdFsyXSA9IHYwICogbVswICogNCArIDJdO1xuICBkc3RbM10gPSB2MCAqIG1bMCAqIDQgKyAzXTtcbiAgZHN0WzRdID0gdjEgKiBtWzEgKiA0ICsgMF07XG4gIGRzdFs1XSA9IHYxICogbVsxICogNCArIDFdO1xuICBkc3RbNl0gPSB2MSAqIG1bMSAqIDQgKyAyXTtcbiAgZHN0WzddID0gdjEgKiBtWzEgKiA0ICsgM107XG4gIGRzdFs4XSA9IHYyICogbVsyICogNCArIDBdO1xuICBkc3RbOV0gPSB2MiAqIG1bMiAqIDQgKyAxXTtcbiAgZHN0WzEwXSA9IHYyICogbVsyICogNCArIDJdO1xuICBkc3RbMTFdID0gdjIgKiBtWzIgKiA0ICsgM107XG5cbiAgaWYgKG0gIT09IGRzdCkge1xuICAgIGRzdFsxMl0gPSBtWzEyXTtcbiAgICBkc3RbMTNdID0gbVsxM107XG4gICAgZHN0WzE0XSA9IG1bMTRdO1xuICAgIGRzdFsxNV0gPSBtWzE1XTtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFRha2VzIGEgNC1ieS00IG1hdHJpeCBhbmQgYSB2ZWN0b3Igd2l0aCAzIGVudHJpZXMsXG4gKiBpbnRlcnByZXRzIHRoZSB2ZWN0b3IgYXMgYSBwb2ludCwgdHJhbnNmb3JtcyB0aGF0IHBvaW50IGJ5IHRoZSBtYXRyaXgsIGFuZFxuICogcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIHBvaW50LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSBvcHRpb25hbCB2ZWMzIHRvIHN0b3JlIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSB0cmFuc2Zvcm1lZCBwb2ludC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnQobSwgdiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCB2My5jcmVhdGUoKTtcbiAgdmFyIHYwID0gdlswXTtcbiAgdmFyIHYxID0gdlsxXTtcbiAgdmFyIHYyID0gdlsyXTtcbiAgdmFyIGQgPSB2MCAqIG1bMCAqIDQgKyAzXSArIHYxICogbVsxICogNCArIDNdICsgdjIgKiBtWzIgKiA0ICsgM10gKyBtWzMgKiA0ICsgM107XG4gIGRzdFswXSA9ICh2MCAqIG1bMCAqIDQgKyAwXSArIHYxICogbVsxICogNCArIDBdICsgdjIgKiBtWzIgKiA0ICsgMF0gKyBtWzMgKiA0ICsgMF0pIC8gZDtcbiAgZHN0WzFdID0gKHYwICogbVswICogNCArIDFdICsgdjEgKiBtWzEgKiA0ICsgMV0gKyB2MiAqIG1bMiAqIDQgKyAxXSArIG1bMyAqIDQgKyAxXSkgLyBkO1xuICBkc3RbMl0gPSAodjAgKiBtWzAgKiA0ICsgMl0gKyB2MSAqIG1bMSAqIDQgKyAyXSArIHYyICogbVsyICogNCArIDJdICsgbVszICogNCArIDJdKSAvIGQ7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFRha2VzIGEgNC1ieS00IG1hdHJpeCBhbmQgYSB2ZWN0b3Igd2l0aCAzIGVudHJpZXMsIGludGVycHJldHMgdGhlIHZlY3RvciBhcyBhXG4gKiBkaXJlY3Rpb24sIHRyYW5zZm9ybXMgdGhhdCBkaXJlY3Rpb24gYnkgdGhlIG1hdHJpeCwgYW5kIHJldHVybnMgdGhlIHJlc3VsdDtcbiAqIGFzc3VtZXMgdGhlIHRyYW5zZm9ybWF0aW9uIG9mIDMtZGltZW5zaW9uYWwgc3BhY2UgcmVwcmVzZW50ZWQgYnkgdGhlIG1hdHJpeFxuICogaXMgcGFyYWxsZWwtcHJlc2VydmluZywgaS5lLiBhbnkgY29tYmluYXRpb24gb2Ygcm90YXRpb24sIHNjYWxpbmcgYW5kXG4gKiB0cmFuc2xhdGlvbiwgYnV0IG5vdCBhIHBlcnNwZWN0aXZlIGRpc3RvcnRpb24uIFJldHVybnMgYSB2ZWN0b3Igd2l0aCAzXG4gKiBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIGRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gb3B0aW9uYWwgVmVjMyB0byBzdG9yZSByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBUaGUgdHJhbnNmb3JtZWQgZGlyZWN0aW9uLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1EaXJlY3Rpb24obSwgdiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCB2My5jcmVhdGUoKTtcbiAgdmFyIHYwID0gdlswXTtcbiAgdmFyIHYxID0gdlsxXTtcbiAgdmFyIHYyID0gdlsyXTtcbiAgZHN0WzBdID0gdjAgKiBtWzAgKiA0ICsgMF0gKyB2MSAqIG1bMSAqIDQgKyAwXSArIHYyICogbVsyICogNCArIDBdO1xuICBkc3RbMV0gPSB2MCAqIG1bMCAqIDQgKyAxXSArIHYxICogbVsxICogNCArIDFdICsgdjIgKiBtWzIgKiA0ICsgMV07XG4gIGRzdFsyXSA9IHYwICogbVswICogNCArIDJdICsgdjEgKiBtWzEgKiA0ICsgMl0gKyB2MiAqIG1bMiAqIDQgKyAyXTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogVGFrZXMgYSA0LWJ5LTQgbWF0cml4IG0gYW5kIGEgdmVjdG9yIHYgd2l0aCAzIGVudHJpZXMsIGludGVycHJldHMgdGhlIHZlY3RvclxuICogYXMgYSBub3JtYWwgdG8gYSBzdXJmYWNlLCBhbmQgY29tcHV0ZXMgYSB2ZWN0b3Igd2hpY2ggaXMgbm9ybWFsIHVwb25cbiAqIHRyYW5zZm9ybWluZyB0aGF0IHN1cmZhY2UgYnkgdGhlIG1hdHJpeC4gVGhlIGVmZmVjdCBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRoZVxuICogc2FtZSBhcyB0cmFuc2Zvcm1pbmcgdiAoYXMgYSBkaXJlY3Rpb24pIGJ5IHRoZSBpbnZlcnNlLXRyYW5zcG9zZSBvZiBtLiAgVGhpc1xuICogZnVuY3Rpb24gYXNzdW1lcyB0aGUgdHJhbnNmb3JtYXRpb24gb2YgMy1kaW1lbnNpb25hbCBzcGFjZSByZXByZXNlbnRlZCBieSB0aGVcbiAqIG1hdHJpeCBpcyBwYXJhbGxlbC1wcmVzZXJ2aW5nLCBpLmUuIGFueSBjb21iaW5hdGlvbiBvZiByb3RhdGlvbiwgc2NhbGluZyBhbmRcbiAqIHRyYW5zbGF0aW9uLCBidXQgbm90IGEgcGVyc3BlY3RpdmUgZGlzdG9ydGlvbi4gIFJldHVybnMgYSB2ZWN0b3Igd2l0aCAzXG4gKiBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIG5vcm1hbC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gVGhlIGRpcmVjdGlvbi4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSB0cmFuc2Zvcm1lZCBub3JtYWwuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vcm1hbChtLCB2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IHYzLmNyZWF0ZSgpO1xuICB2YXIgbWkgPSBpbnZlcnNlKG0pO1xuICB2YXIgdjAgPSB2WzBdO1xuICB2YXIgdjEgPSB2WzFdO1xuICB2YXIgdjIgPSB2WzJdO1xuICBkc3RbMF0gPSB2MCAqIG1pWzAgKiA0ICsgMF0gKyB2MSAqIG1pWzAgKiA0ICsgMV0gKyB2MiAqIG1pWzAgKiA0ICsgMl07XG4gIGRzdFsxXSA9IHYwICogbWlbMSAqIDQgKyAwXSArIHYxICogbWlbMSAqIDQgKyAxXSArIHYyICogbWlbMSAqIDQgKyAyXTtcbiAgZHN0WzJdID0gdjAgKiBtaVsyICogNCArIDBdICsgdjEgKiBtaVsyICogNCArIDFdICsgdjIgKiBtaVsyICogNCArIDJdO1xuICByZXR1cm4gZHN0O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9wcmltaXRpdmVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcHJpbWl0aXZlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlM0RGVmVydGljZXMgPSBjcmVhdGUzREZWZXJ0aWNlcztcbmV4cG9ydHMuY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXk7XG5leHBvcnRzLmNyZWF0ZUN1YmVWZXJ0aWNlcyA9IGNyZWF0ZUN1YmVWZXJ0aWNlcztcbmV4cG9ydHMuY3JlYXRlUGxhbmVWZXJ0aWNlcyA9IGNyZWF0ZVBsYW5lVmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZVNwaGVyZVZlcnRpY2VzID0gY3JlYXRlU3BoZXJlVmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZVRydW5jYXRlZENvbmVWZXJ0aWNlcyA9IGNyZWF0ZVRydW5jYXRlZENvbmVWZXJ0aWNlcztcbmV4cG9ydHMuY3JlYXRlWFlRdWFkVmVydGljZXMgPSBjcmVhdGVYWVF1YWRWZXJ0aWNlcztcbmV4cG9ydHMuY3JlYXRlQ3Jlc2NlbnRWZXJ0aWNlcyA9IGNyZWF0ZUNyZXNjZW50VmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZUN5bGluZGVyVmVydGljZXMgPSBjcmVhdGVDeWxpbmRlclZlcnRpY2VzO1xuZXhwb3J0cy5jcmVhdGVUb3J1c1ZlcnRpY2VzID0gY3JlYXRlVG9ydXNWZXJ0aWNlcztcbmV4cG9ydHMuY3JlYXRlRGlzY1ZlcnRpY2VzID0gY3JlYXRlRGlzY1ZlcnRpY2VzO1xuZXhwb3J0cy5kZWluZGV4VmVydGljZXMgPSBkZWluZGV4VmVydGljZXM7XG5leHBvcnRzLmZsYXR0ZW5Ob3JtYWxzID0gZmxhdHRlbk5vcm1hbHM7XG5leHBvcnRzLm1ha2VSYW5kb21WZXJ0ZXhDb2xvcnMgPSBtYWtlUmFuZG9tVmVydGV4Q29sb3JzO1xuZXhwb3J0cy5yZW9yaWVudERpcmVjdGlvbnMgPSByZW9yaWVudERpcmVjdGlvbnM7XG5leHBvcnRzLnJlb3JpZW50Tm9ybWFscyA9IHJlb3JpZW50Tm9ybWFscztcbmV4cG9ydHMucmVvcmllbnRQb3NpdGlvbnMgPSByZW9yaWVudFBvc2l0aW9ucztcbmV4cG9ydHMucmVvcmllbnRWZXJ0aWNlcyA9IHJlb3JpZW50VmVydGljZXM7XG5leHBvcnRzLmNvbmNhdFZlcnRpY2VzID0gY29uY2F0VmVydGljZXM7XG5leHBvcnRzLmR1cGxpY2F0ZVZlcnRpY2VzID0gZHVwbGljYXRlVmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZURpc2NCdWZmZXJzID0gZXhwb3J0cy5jcmVhdGVEaXNjQnVmZmVySW5mbyA9IGV4cG9ydHMuY3JlYXRlVG9ydXNCdWZmZXJzID0gZXhwb3J0cy5jcmVhdGVUb3J1c0J1ZmZlckluZm8gPSBleHBvcnRzLmNyZWF0ZUN5bGluZGVyQnVmZmVycyA9IGV4cG9ydHMuY3JlYXRlQ3lsaW5kZXJCdWZmZXJJbmZvID0gZXhwb3J0cy5jcmVhdGVDcmVzY2VudEJ1ZmZlcnMgPSBleHBvcnRzLmNyZWF0ZUNyZXNjZW50QnVmZmVySW5mbyA9IGV4cG9ydHMuY3JlYXRlQ3Jlc2VudFZlcnRpY2VzID0gZXhwb3J0cy5jcmVhdGVDcmVzZW50QnVmZmVycyA9IGV4cG9ydHMuY3JlYXRlQ3Jlc2VudEJ1ZmZlckluZm8gPSBleHBvcnRzLmNyZWF0ZVhZUXVhZEJ1ZmZlcnMgPSBleHBvcnRzLmNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8gPSBleHBvcnRzLmNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJzID0gZXhwb3J0cy5jcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVySW5mbyA9IGV4cG9ydHMuY3JlYXRlU3BoZXJlQnVmZmVycyA9IGV4cG9ydHMuY3JlYXRlU3BoZXJlQnVmZmVySW5mbyA9IGV4cG9ydHMuY3JlYXRlUGxhbmVCdWZmZXJzID0gZXhwb3J0cy5jcmVhdGVQbGFuZUJ1ZmZlckluZm8gPSBleHBvcnRzLmNyZWF0ZUN1YmVCdWZmZXJzID0gZXhwb3J0cy5jcmVhdGVDdWJlQnVmZmVySW5mbyA9IGV4cG9ydHMuY3JlYXRlM0RGQnVmZmVycyA9IGV4cG9ydHMuY3JlYXRlM0RGQnVmZmVySW5mbyA9IHZvaWQgMDtcblxudmFyIGF0dHJpYnV0ZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2F0dHJpYnV0ZXMuanMgKi8gXCIuL3NyYy9hdHRyaWJ1dGVzLmpzXCIpKTtcblxudmFyIGhlbHBlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGVscGVyLmpzICovIFwiLi9zcmMvaGVscGVyLmpzXCIpKTtcblxudmFyIHR5cGVkQXJyYXlzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90eXBlZGFycmF5cy5qcyAqLyBcIi4vc3JjL3R5cGVkYXJyYXlzLmpzXCIpKTtcblxudmFyIG00ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tNC5qcyAqLyBcIi4vc3JjL200LmpzXCIpKTtcblxudmFyIHYzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92My5qcyAqLyBcIi4vc3JjL3YzLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIFZhcmlvdXMgZnVuY3Rpb25zIHRvIG1ha2Ugc2ltcGxlIHByaW1pdGl2ZXNcbiAqXG4gKiBub3RlOiBNb3N0IHByaW1pdGl2ZSBmdW5jdGlvbnMgY29tZSBpbiAzIHN0eWxlc1xuICpcbiAqICogIGBjcmVhdGVTb21lU2hhcGVCdWZmZXJJbmZvYFxuICpcbiAqICAgIFRoZXNlIGZ1bmN0aW9ucyBhcmUgYWxtb3N0IGFsd2F5cyB0aGUgZnVuY3Rpb25zIHlvdSB3YW50IHRvIGNhbGwuIFRoZXlcbiAqICAgIGNyZWF0ZSB2ZXJ0aWNlcyB0aGVuIG1ha2UgV2ViR0xCdWZmZXJzIGFuZCBjcmVhdGUge0BsaW5rIG1vZHVsZTp0d2dsLkF0dHJpYkluZm99c1xuICogICAgcmV0dXJuaW5nIGEge0BsaW5rIG1vZHVsZTp0d2dsLkJ1ZmZlckluZm99IHlvdSBjYW4gcGFzcyB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXN9XG4gKiAgICBhbmQge0BsaW5rIG1vZHVsZTp0d2dsLmRyYXdCdWZmZXJJbmZvfSBldGMuLi5cbiAqXG4gKiAqICBgY3JlYXRlU29tZVNoYXBlQnVmZmVyc2BcbiAqXG4gKiAgICBUaGVzZSBjcmVhdGUgV2ViR0xCdWZmZXJzIGFuZCBwdXQgeW91ciBkYXRhIGluIHRoZW0gYnV0IG5vdGhpbmcgZWxzZS5cbiAqICAgIEl0J3MgYSBzaG9ydGN1dCB0byBkb2luZyBpdCB5b3Vyc2VsZiBpZiB5b3UgZG9uJ3Qgd2FudCB0byB1c2VcbiAqICAgIHRoZSBoaWdoZXIgbGV2ZWwgZnVuY3Rpb25zLlxuICpcbiAqICogIGBjcmVhdGVTb21lU2hhcGVWZXJ0aWNlc2BcbiAqXG4gKiAgICBUaGVzZSBqdXN0IGNyZWF0ZSB2ZXJ0aWNlcywgbm8gYnVmZmVycy4gVGhpcyBhbGxvd3MgeW91IHRvIG1hbmlwdWxhdGUgdGhlIHZlcnRpY2VzXG4gKiAgICBvciBhZGQgbW9yZSBkYXRhIGJlZm9yZSBnZW5lcmF0aW5nIGEge0BsaW5rIG1vZHVsZTp0d2dsLkJ1ZmZlckluZm99LiBPbmNlIHlvdSdyZSBmaW5pc2hlZFxuICogICAgbWFuaXB1bGF0aW5nIHRoZSB2ZXJ0aWNlcyBjYWxsIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5c30uXG4gKlxuICogICAgZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgY29uc3QgYXJyYXlzID0gdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVBsYW5lQXJyYXlzKDEpO1xuICogICAgICAgIHR3Z2wucHJpbWl0aXZlcy5yZW9yaWVudFZlcnRpY2VzKGFycmF5cywgbTQucm90YXRpb25YKE1hdGguUEkgKiAwLjUpKTtcbiAqICAgICAgICBjb25zdCBidWZmZXJJbmZvID0gdHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwgYXJyYXlzKTtcbiAqXG4gKiBAbW9kdWxlIHR3Z2wvcHJpbWl0aXZlc1xuICovXG52YXIgZ2V0QXJyYXkgPSBhdHRyaWJ1dGVzLmdldEFycmF5XzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG52YXIgZ2V0TnVtQ29tcG9uZW50cyA9IGF0dHJpYnV0ZXMuZ2V0TnVtQ29tcG9uZW50c187IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBAdHlwZWRlZiB7KEludDhBcnJheXxVaW50OEFycmF5fEludDE2QXJyYXl8VWludDE2QXJyYXl8SW50MzJBcnJheXxVaW50MzJBcnJheXxGbG9hdDMyQXJyYXkpfSBUeXBlZEFycmF5XG4gKi9cblxuLyoqXG4gKiBBZGQgYHB1c2hgIHRvIGEgdHlwZWQgYXJyYXkuIEl0IGp1c3Qga2VlcHMgYSAnY3Vyc29yJ1xuICogYW5kIGFsbG93cyB1c2UgdG8gYHB1c2hgIHZhbHVlcyBpbnRvIHRoZSBhcnJheSBzbyB3ZVxuICogZG9uJ3QgaGF2ZSB0byBtYW51YWxseSBjb21wdXRlIG9mZnNldHNcbiAqIEBwYXJhbSB7VHlwZWRBcnJheX0gdHlwZWRBcnJheSBUeXBlZEFycmF5IHRvIGF1Z21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1Db21wb25lbnRzIG51bWJlciBvZiBjb21wb25lbnRzLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhdWdtZW50VHlwZWRBcnJheSh0eXBlZEFycmF5LCBudW1Db21wb25lbnRzKSB7XG4gIHZhciBjdXJzb3IgPSAwO1xuXG4gIHR5cGVkQXJyYXkucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpaSkge1xuICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzW2lpXTtcblxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgfHwgdHlwZWRBcnJheXMuaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgZm9yICh2YXIgamogPSAwOyBqaiA8IHZhbHVlLmxlbmd0aDsgKytqaikge1xuICAgICAgICAgIHR5cGVkQXJyYXlbY3Vyc29yKytdID0gdmFsdWVbampdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlZEFycmF5W2N1cnNvcisrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0eXBlZEFycmF5LnJlc2V0ID0gZnVuY3Rpb24gKG9wdF9pbmRleCkge1xuICAgIGN1cnNvciA9IG9wdF9pbmRleCB8fCAwO1xuICB9O1xuXG4gIHR5cGVkQXJyYXkubnVtQ29tcG9uZW50cyA9IG51bUNvbXBvbmVudHM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlZEFycmF5LCAnbnVtRWxlbWVudHMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggLyB0aGlzLm51bUNvbXBvbmVudHMgfCAwO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0eXBlZEFycmF5O1xufVxuLyoqXG4gKiBjcmVhdGVzIGEgdHlwZWQgYXJyYXkgd2l0aCBhIGBwdXNoYCBmdW5jdGlvbiBhdHRhY2hlZFxuICogc28gdGhhdCB5b3UgY2FuIGVhc2lseSAqcHVzaCogdmFsdWVzLlxuICpcbiAqIGBwdXNoYCBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMuIElmIGFuIGFyZ3VtZW50IGlzIGFuIGFycmF5IGVhY2ggZWxlbWVudFxuICogb2YgdGhlIGFycmF5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHR5cGVkIGFycmF5LlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGFycmF5ID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCAyKTsgIC8vIGNyZWF0ZXMgYSBGbG9hdDMyQXJyYXkgd2l0aCA2IHZhbHVlc1xuICogICAgIGFycmF5LnB1c2goMSwgMiwgMyk7XG4gKiAgICAgYXJyYXkucHVzaChbNCwgNSwgNl0pO1xuICogICAgIC8vIGFycmF5IG5vdyBjb250YWlucyBbMSwgMiwgMywgNCwgNSwgNl1cbiAqXG4gKiBBbHNvIGhhcyBgbnVtQ29tcG9uZW50c2AgYW5kIGBudW1FbGVtZW50c2AgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtQ29tcG9uZW50cyBudW1iZXIgb2YgY29tcG9uZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG51bUVsZW1lbnRzIG51bWJlciBvZiBlbGVtZW50cy4gVGhlIHRvdGFsIHNpemUgb2YgdGhlIGFycmF5IHdpbGwgYmUgYG51bUNvbXBvbmVudHMgKiBudW1FbGVtZW50c2AuXG4gKiBAcGFyYW0ge2NvbnN0cnVjdG9yfSBvcHRfdHlwZSBBIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZS4gRGVmYXVsdCA9IGBGbG9hdDMyQXJyYXlgLlxuICogQHJldHVybiB7QXJyYXlCdWZmZXJWaWV3fSBBIHR5cGVkIGFycmF5LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkobnVtQ29tcG9uZW50cywgbnVtRWxlbWVudHMsIG9wdF90eXBlKSB7XG4gIHZhciBUeXBlID0gb3B0X3R5cGUgfHwgRmxvYXQzMkFycmF5O1xuICByZXR1cm4gYXVnbWVudFR5cGVkQXJyYXkobmV3IFR5cGUobnVtQ29tcG9uZW50cyAqIG51bUVsZW1lbnRzKSwgbnVtQ29tcG9uZW50cyk7XG59XG5cbmZ1bmN0aW9uIGFsbEJ1dEluZGljZXMobmFtZSkge1xuICByZXR1cm4gbmFtZSAhPT0gXCJpbmRpY2VzXCI7XG59XG4vKipcbiAqIEdpdmVuIGluZGV4ZWQgdmVydGljZXMgY3JlYXRlcyBhIG5ldyBzZXQgb2YgdmVydGljZXMgdW4taW5kZXhlZCBieSBleHBhbmRpbmcgdGhlIGluZGV4ZWQgdmVydGljZXMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gdmVydGljZXMgVGhlIGluZGV4ZWQgdmVydGljZXMgdG8gZGVpbmRleFxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgZGVpbmRleGVkIHZlcnRpY2VzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gZGVpbmRleFZlcnRpY2VzKHZlcnRpY2VzKSB7XG4gIHZhciBpbmRpY2VzID0gdmVydGljZXMuaW5kaWNlcztcbiAgdmFyIG5ld1ZlcnRpY2VzID0ge307XG4gIHZhciBudW1FbGVtZW50cyA9IGluZGljZXMubGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGV4cGFuZFRvVW5pbmRleGVkKGNoYW5uZWwpIHtcbiAgICB2YXIgc3JjQnVmZmVyID0gdmVydGljZXNbY2hhbm5lbF07XG4gICAgdmFyIG51bUNvbXBvbmVudHMgPSBzcmNCdWZmZXIubnVtQ29tcG9uZW50cztcbiAgICB2YXIgZHN0QnVmZmVyID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheShudW1Db21wb25lbnRzLCBudW1FbGVtZW50cywgc3JjQnVmZmVyLmNvbnN0cnVjdG9yKTtcblxuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1FbGVtZW50czsgKytpaSkge1xuICAgICAgdmFyIG5keCA9IGluZGljZXNbaWldO1xuICAgICAgdmFyIG9mZnNldCA9IG5keCAqIG51bUNvbXBvbmVudHM7XG5cbiAgICAgIGZvciAodmFyIGpqID0gMDsgamogPCBudW1Db21wb25lbnRzOyArK2pqKSB7XG4gICAgICAgIGRzdEJ1ZmZlci5wdXNoKHNyY0J1ZmZlcltvZmZzZXQgKyBqal0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5ld1ZlcnRpY2VzW2NoYW5uZWxdID0gZHN0QnVmZmVyO1xuICB9XG5cbiAgT2JqZWN0LmtleXModmVydGljZXMpLmZpbHRlcihhbGxCdXRJbmRpY2VzKS5mb3JFYWNoKGV4cGFuZFRvVW5pbmRleGVkKTtcbiAgcmV0dXJuIG5ld1ZlcnRpY2VzO1xufVxuLyoqXG4gKiBmbGF0dGVucyB0aGUgbm9ybWFscyBvZiBkZWluZGV4ZWQgdmVydGljZXMgaW4gcGxhY2UuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gdmVydGljZXMgVGhlIGRlaW5kZXhlZCB2ZXJ0aWNlcyB3aG8ncyBub3JtYWxzIHRvIGZsYXR0ZW5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGZsYXR0ZW5lZCB2ZXJ0aWNlcyAoc2FtZSBhcyB3YXMgcGFzc2VkIGluKVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGZsYXR0ZW5Ob3JtYWxzKHZlcnRpY2VzKSB7XG4gIGlmICh2ZXJ0aWNlcy5pbmRpY2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW4gbm90IGZsYXR0ZW4gbm9ybWFscyBvZiBpbmRleGVkIHZlcnRpY2VzLiBkZWluZGV4IHRoZW0gZmlyc3QnKTtcbiAgfVxuXG4gIHZhciBub3JtYWxzID0gdmVydGljZXMubm9ybWFsO1xuICB2YXIgbnVtTm9ybWFscyA9IG5vcm1hbHMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1Ob3JtYWxzOyBpaSArPSA5KSB7XG4gICAgLy8gcHVsbCBvdXQgdGhlIDMgbm9ybWFscyBmb3IgdGhpcyB0cmlhbmdsZVxuICAgIHZhciBuYXggPSBub3JtYWxzW2lpICsgMF07XG4gICAgdmFyIG5heSA9IG5vcm1hbHNbaWkgKyAxXTtcbiAgICB2YXIgbmF6ID0gbm9ybWFsc1tpaSArIDJdO1xuICAgIHZhciBuYnggPSBub3JtYWxzW2lpICsgM107XG4gICAgdmFyIG5ieSA9IG5vcm1hbHNbaWkgKyA0XTtcbiAgICB2YXIgbmJ6ID0gbm9ybWFsc1tpaSArIDVdO1xuICAgIHZhciBuY3ggPSBub3JtYWxzW2lpICsgNl07XG4gICAgdmFyIG5jeSA9IG5vcm1hbHNbaWkgKyA3XTtcbiAgICB2YXIgbmN6ID0gbm9ybWFsc1tpaSArIDhdOyAvLyBhZGQgdGhlbVxuXG4gICAgdmFyIG54ID0gbmF4ICsgbmJ4ICsgbmN4O1xuICAgIHZhciBueSA9IG5heSArIG5ieSArIG5jeTtcbiAgICB2YXIgbnogPSBuYXogKyBuYnogKyBuY3o7IC8vIG5vcm1hbGl6ZSB0aGVtXG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KG54ICogbnggKyBueSAqIG55ICsgbnogKiBueik7XG4gICAgbnggLz0gbGVuZ3RoO1xuICAgIG55IC89IGxlbmd0aDtcbiAgICBueiAvPSBsZW5ndGg7IC8vIGNvcHkgdGhlbSBiYWNrIGluXG5cbiAgICBub3JtYWxzW2lpICsgMF0gPSBueDtcbiAgICBub3JtYWxzW2lpICsgMV0gPSBueTtcbiAgICBub3JtYWxzW2lpICsgMl0gPSBuejtcbiAgICBub3JtYWxzW2lpICsgM10gPSBueDtcbiAgICBub3JtYWxzW2lpICsgNF0gPSBueTtcbiAgICBub3JtYWxzW2lpICsgNV0gPSBuejtcbiAgICBub3JtYWxzW2lpICsgNl0gPSBueDtcbiAgICBub3JtYWxzW2lpICsgN10gPSBueTtcbiAgICBub3JtYWxzW2lpICsgOF0gPSBuejtcbiAgfVxuXG4gIHJldHVybiB2ZXJ0aWNlcztcbn1cblxuZnVuY3Rpb24gYXBwbHlGdW5jVG9WM0FycmF5KGFycmF5LCBtYXRyaXgsIGZuKSB7XG4gIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gIHZhciB0bXAgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW47IGlpICs9IDMpIHtcbiAgICBmbihtYXRyaXgsIFthcnJheVtpaV0sIGFycmF5W2lpICsgMV0sIGFycmF5W2lpICsgMl1dLCB0bXApO1xuICAgIGFycmF5W2lpXSA9IHRtcFswXTtcbiAgICBhcnJheVtpaSArIDFdID0gdG1wWzFdO1xuICAgIGFycmF5W2lpICsgMl0gPSB0bXBbMl07XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9ybWFsKG1pLCB2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IHYzLmNyZWF0ZSgpO1xuICB2YXIgdjAgPSB2WzBdO1xuICB2YXIgdjEgPSB2WzFdO1xuICB2YXIgdjIgPSB2WzJdO1xuICBkc3RbMF0gPSB2MCAqIG1pWzAgKiA0ICsgMF0gKyB2MSAqIG1pWzAgKiA0ICsgMV0gKyB2MiAqIG1pWzAgKiA0ICsgMl07XG4gIGRzdFsxXSA9IHYwICogbWlbMSAqIDQgKyAwXSArIHYxICogbWlbMSAqIDQgKyAxXSArIHYyICogbWlbMSAqIDQgKyAyXTtcbiAgZHN0WzJdID0gdjAgKiBtaVsyICogNCArIDBdICsgdjEgKiBtaVsyICogNCArIDFdICsgdjIgKiBtaVsyICogNCArIDJdO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBSZW9yaWVudHMgZGlyZWN0aW9ucyBieSB0aGUgZ2l2ZW4gbWF0cml4Li5cbiAqIEBwYXJhbSB7KG51bWJlcltdfFR5cGVkQXJyYXkpfSBhcnJheSBUaGUgYXJyYXkuIEFzc3VtZXMgdmFsdWUgZmxvYXRzIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtYXRyaXggQSBtYXRyaXggdG8gbXVsdGlwbHkgYnkuXG4gKiBAcmV0dXJuIHsobnVtYmVyW118VHlwZWRBcnJheSl9IHRoZSBzYW1lIGFycmF5IHRoYXQgd2FzIHBhc3NlZCBpblxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlb3JpZW50RGlyZWN0aW9ucyhhcnJheSwgbWF0cml4KSB7XG4gIGFwcGx5RnVuY1RvVjNBcnJheShhcnJheSwgbWF0cml4LCBtNC50cmFuc2Zvcm1EaXJlY3Rpb24pO1xuICByZXR1cm4gYXJyYXk7XG59XG4vKipcbiAqIFJlb3JpZW50cyBub3JtYWxzIGJ5IHRoZSBpbnZlcnNlLXRyYW5zcG9zZSBvZiB0aGUgZ2l2ZW5cbiAqIG1hdHJpeC4uXG4gKiBAcGFyYW0geyhudW1iZXJbXXxUeXBlZEFycmF5KX0gYXJyYXkgVGhlIGFycmF5LiBBc3N1bWVzIHZhbHVlIGZsb2F0cyBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbWF0cml4IEEgbWF0cml4IHRvIG11bHRpcGx5IGJ5LlxuICogQHJldHVybiB7KG51bWJlcltdfFR5cGVkQXJyYXkpfSB0aGUgc2FtZSBhcnJheSB0aGF0IHdhcyBwYXNzZWQgaW5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuXG5mdW5jdGlvbiByZW9yaWVudE5vcm1hbHMoYXJyYXksIG1hdHJpeCkge1xuICBhcHBseUZ1bmNUb1YzQXJyYXkoYXJyYXksIG00LmludmVyc2UobWF0cml4KSwgdHJhbnNmb3JtTm9ybWFsKTtcbiAgcmV0dXJuIGFycmF5O1xufVxuLyoqXG4gKiBSZW9yaWVudHMgcG9zaXRpb25zIGJ5IHRoZSBnaXZlbiBtYXRyaXguIEluIG90aGVyIHdvcmRzLCBpdFxuICogbXVsdGlwbGllcyBlYWNoIHZlcnRleCBieSB0aGUgZ2l2ZW4gbWF0cml4LlxuICogQHBhcmFtIHsobnVtYmVyW118VHlwZWRBcnJheSl9IGFycmF5IFRoZSBhcnJheS4gQXNzdW1lcyB2YWx1ZSBmbG9hdHMgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG1hdHJpeCBBIG1hdHJpeCB0byBtdWx0aXBseSBieS5cbiAqIEByZXR1cm4geyhudW1iZXJbXXxUeXBlZEFycmF5KX0gdGhlIHNhbWUgYXJyYXkgdGhhdCB3YXMgcGFzc2VkIGluXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gcmVvcmllbnRQb3NpdGlvbnMoYXJyYXksIG1hdHJpeCkge1xuICBhcHBseUZ1bmNUb1YzQXJyYXkoYXJyYXksIG1hdHJpeCwgbTQudHJhbnNmb3JtUG9pbnQpO1xuICByZXR1cm4gYXJyYXk7XG59XG4vKipcbiAqIEB0eXBlZGVmIHsobnVtYmVyW118VHlwZWRBcnJheSl9IE5hdGl2ZUFycmF5T3JUeXBlZEFycmF5XG4gKi9cblxuLyoqXG4gKiBSZW9yaWVudHMgYXJyYXlzIGJ5IHRoZSBnaXZlbiBtYXRyaXguIEFzc3VtZXMgYXJyYXlzIGhhdmVcbiAqIG5hbWVzIHRoYXQgY29udGFpbnMgJ3BvcycgY291bGQgYmUgcmVvcmllbnRlZCBhcyBwb3NpdGlvbnMsXG4gKiAnYmlub3JtJyBvciAndGFuJyBhcyBkaXJlY3Rpb25zLCBhbmQgJ25vcm0nIGFzIG5vcm1hbHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgTmF0aXZlQXJyYXlPclR5cGVkQXJyYXk+fSBhcnJheXMgVGhlIHZlcnRpY2VzIHRvIHJlb3JpZW50XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG1hdHJpeCBtYXRyaXggdG8gcmVvcmllbnQgYnkuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgTmF0aXZlQXJyYXlPclR5cGVkQXJyYXk+fSBzYW1lIGFycmF5cyB0aGF0IHdlcmUgcGFzc2VkIGluLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlb3JpZW50VmVydGljZXMoYXJyYXlzLCBtYXRyaXgpIHtcbiAgT2JqZWN0LmtleXMoYXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGFycmF5ID0gYXJyYXlzW25hbWVdO1xuXG4gICAgaWYgKG5hbWUuaW5kZXhPZihcInBvc1wiKSA+PSAwKSB7XG4gICAgICByZW9yaWVudFBvc2l0aW9ucyhhcnJheSwgbWF0cml4KTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuaW5kZXhPZihcInRhblwiKSA+PSAwIHx8IG5hbWUuaW5kZXhPZihcImJpbm9ybVwiKSA+PSAwKSB7XG4gICAgICByZW9yaWVudERpcmVjdGlvbnMoYXJyYXksIG1hdHJpeCk7XG4gICAgfSBlbHNlIGlmIChuYW1lLmluZGV4T2YoXCJub3JtXCIpID49IDApIHtcbiAgICAgIHJlb3JpZW50Tm9ybWFscyhhcnJheSwgbWF0cml4KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXJyYXlzO1xufVxuLyoqXG4gKiBDcmVhdGVzIFhZIHF1YWQgQnVmZmVySW5mb1xuICpcbiAqIFRoZSBkZWZhdWx0IHdpdGggbm8gcGFyYW1ldGVycyB3aWxsIHJldHVybiBhIDJ4MiBxdWFkIHdpdGggdmFsdWVzIGZyb20gLTEgdG8gKzEuXG4gKiBJZiB5b3Ugd2FudCBhIHVuaXQgcXVhZCB3aXRoIHRoYXQgZ29lcyBmcm9tIDAgdG8gMSB5b3UnZCBjYWxsIGl0IHdpdGhcbiAqXG4gKiAgICAgdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8oZ2wsIDEsIDAuNSwgMC41KTtcbiAqXG4gKiBJZiB5b3Ugd2FudCBhIHVuaXQgcXVhZCBjZW50ZXJlZCBhYm92ZSAwLDAgeW91J2QgY2FsbCBpdCB3aXRoXG4gKlxuICogICAgIHR3Z2wucHJpbWl0aXZlcy5jcmVhdGVYWVF1YWRCdWZmZXJJbmZvKGdsLCAxLCAwLCAwLjUpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXSB0aGUgc2l6ZSBhY3Jvc3MgdGhlIHF1YWQuIERlZmF1bHRzIHRvIDIgd2hpY2ggbWVhbnMgdmVydGljZXMgd2lsbCBnbyBmcm9tIC0xIHRvICsxXG4gKiBAcGFyYW0ge251bWJlcn0gW3hPZmZzZXRdIHRoZSBhbW91bnQgdG8gb2Zmc2V0IHRoZSBxdWFkIGluIFhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeU9mZnNldF0gdGhlIGFtb3VudCB0byBvZmZzZXQgdGhlIHF1YWQgaW4gWVxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFdlYkdMQnVmZmVyPn0gdGhlIGNyZWF0ZWQgWFkgUXVhZCBCdWZmZXJJbmZvXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVhZUXVhZEJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgWFkgcXVhZCBCdWZmZXJzXG4gKlxuICogVGhlIGRlZmF1bHQgd2l0aCBubyBwYXJhbWV0ZXJzIHdpbGwgcmV0dXJuIGEgMngyIHF1YWQgd2l0aCB2YWx1ZXMgZnJvbSAtMSB0byArMS5cbiAqIElmIHlvdSB3YW50IGEgdW5pdCBxdWFkIHdpdGggdGhhdCBnb2VzIGZyb20gMCB0byAxIHlvdSdkIGNhbGwgaXQgd2l0aFxuICpcbiAqICAgICB0d2dsLnByaW1pdGl2ZXMuY3JlYXRlWFlRdWFkQnVmZmVySW5mbyhnbCwgMSwgMC41LCAwLjUpO1xuICpcbiAqIElmIHlvdSB3YW50IGEgdW5pdCBxdWFkIGNlbnRlcmVkIGFib3ZlIDAsMCB5b3UnZCBjYWxsIGl0IHdpdGhcbiAqXG4gKiAgICAgdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8oZ2wsIDEsIDAsIDAuNSk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemVdIHRoZSBzaXplIGFjcm9zcyB0aGUgcXVhZC4gRGVmYXVsdHMgdG8gMiB3aGljaCBtZWFucyB2ZXJ0aWNlcyB3aWxsIGdvIGZyb20gLTEgdG8gKzFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeE9mZnNldF0gdGhlIGFtb3VudCB0byBvZmZzZXQgdGhlIHF1YWQgaW4gWFxuICogQHBhcmFtIHtudW1iZXJ9IFt5T2Zmc2V0XSB0aGUgYW1vdW50IHRvIG9mZnNldCB0aGUgcXVhZCBpbiBZXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSB0aGUgY3JlYXRlZCBYWSBRdWFkIGJ1ZmZlcnNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlWFlRdWFkQnVmZmVySW5mb1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBYWSBxdWFkIHZlcnRpY2VzXG4gKlxuICogVGhlIGRlZmF1bHQgd2l0aCBubyBwYXJhbWV0ZXJzIHdpbGwgcmV0dXJuIGEgMngyIHF1YWQgd2l0aCB2YWx1ZXMgZnJvbSAtMSB0byArMS5cbiAqIElmIHlvdSB3YW50IGEgdW5pdCBxdWFkIHdpdGggdGhhdCBnb2VzIGZyb20gMCB0byAxIHlvdSdkIGNhbGwgaXQgd2l0aFxuICpcbiAqICAgICB0d2dsLnByaW1pdGl2ZXMuY3JlYXRlWFlRdWFkVmVydGljZXMoMSwgMC41LCAwLjUpO1xuICpcbiAqIElmIHlvdSB3YW50IGEgdW5pdCBxdWFkIGNlbnRlcmVkIGFib3ZlIDAsMCB5b3UnZCBjYWxsIGl0IHdpdGhcbiAqXG4gKiAgICAgdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVhZUXVhZFZlcnRpY2VzKDEsIDAsIDAuNSk7XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXSB0aGUgc2l6ZSBhY3Jvc3MgdGhlIHF1YWQuIERlZmF1bHRzIHRvIDIgd2hpY2ggbWVhbnMgdmVydGljZXMgd2lsbCBnbyBmcm9tIC0xIHRvICsxXG4gKiBAcGFyYW0ge251bWJlcn0gW3hPZmZzZXRdIHRoZSBhbW91bnQgdG8gb2Zmc2V0IHRoZSBxdWFkIGluIFhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeU9mZnNldF0gdGhlIGFtb3VudCB0byBvZmZzZXQgdGhlIHF1YWQgaW4gWVxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSB0aGUgY3JlYXRlZCBYWSBRdWFkIHZlcnRpY2VzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlWFlRdWFkVmVydGljZXMoc2l6ZSwgeE9mZnNldCwgeU9mZnNldCkge1xuICBzaXplID0gc2l6ZSB8fCAyO1xuICB4T2Zmc2V0ID0geE9mZnNldCB8fCAwO1xuICB5T2Zmc2V0ID0geU9mZnNldCB8fCAwO1xuICBzaXplICo9IDAuNTtcbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjoge1xuICAgICAgbnVtQ29tcG9uZW50czogMixcbiAgICAgIGRhdGE6IFt4T2Zmc2V0ICsgLTEgKiBzaXplLCB5T2Zmc2V0ICsgLTEgKiBzaXplLCB4T2Zmc2V0ICsgMSAqIHNpemUsIHlPZmZzZXQgKyAtMSAqIHNpemUsIHhPZmZzZXQgKyAtMSAqIHNpemUsIHlPZmZzZXQgKyAxICogc2l6ZSwgeE9mZnNldCArIDEgKiBzaXplLCB5T2Zmc2V0ICsgMSAqIHNpemVdXG4gICAgfSxcbiAgICBub3JtYWw6IFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSxcbiAgICB0ZXhjb29yZDogWzAsIDAsIDEsIDAsIDAsIDEsIDEsIDFdLFxuICAgIGluZGljZXM6IFswLCAxLCAyLCAyLCAxLCAzXVxuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIFhaIHBsYW5lIEJ1ZmZlckluZm8uXG4gKlxuICogVGhlIGNyZWF0ZWQgcGxhbmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSBXaWR0aCBvZiB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoXSBEZXB0aCBvZiB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3N1YmRpdmlzaW9uc1dpZHRoXSBOdW1iZXIgb2Ygc3RlcHMgYWNyb3NzIHRoZSBwbGFuZS4gRGVmYXVsdCA9IDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3ViZGl2aXNpb25zRGVwdGhdIE51bWJlciBvZiBzdGVwcyBkb3duIHRoZSBwbGFuZS4gRGVmYXVsdCA9IDFcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW21hdHJpeF0gQSBtYXRyaXggYnkgd2hpY2ggdG8gbXVsdGlwbHkgYWxsIHRoZSB2ZXJ0aWNlcy5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIHBsYW5lIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVBsYW5lQnVmZmVySW5mb1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBYWiBwbGFuZSBidWZmZXJzLlxuICpcbiAqIFRoZSBjcmVhdGVkIHBsYW5lIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCBhbmQgdGV4Y29vcmQgZGF0YVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gV2lkdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aF0gRGVwdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtzdWJkaXZpc2lvbnNXaWR0aF0gTnVtYmVyIG9mIHN0ZXBzIGFjcm9zcyB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3N1YmRpdmlzaW9uc0RlcHRoXSBOdW1iZXIgb2Ygc3RlcHMgZG93biB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFttYXRyaXhdIEEgbWF0cml4IGJ5IHdoaWNoIHRvIG11bHRpcGx5IGFsbCB0aGUgdmVydGljZXMuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBwbGFuZSBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVQbGFuZUJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgWFogcGxhbmUgdmVydGljZXMuXG4gKlxuICogVGhlIGNyZWF0ZWQgcGxhbmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gV2lkdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aF0gRGVwdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtzdWJkaXZpc2lvbnNXaWR0aF0gTnVtYmVyIG9mIHN0ZXBzIGFjcm9zcyB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3N1YmRpdmlzaW9uc0RlcHRoXSBOdW1iZXIgb2Ygc3RlcHMgZG93biB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFttYXRyaXhdIEEgbWF0cml4IGJ5IHdoaWNoIHRvIG11bHRpcGx5IGFsbCB0aGUgdmVydGljZXMuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHBsYW5lIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBsYW5lVmVydGljZXMod2lkdGgsIGRlcHRoLCBzdWJkaXZpc2lvbnNXaWR0aCwgc3ViZGl2aXNpb25zRGVwdGgsIG1hdHJpeCkge1xuICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gIGRlcHRoID0gZGVwdGggfHwgMTtcbiAgc3ViZGl2aXNpb25zV2lkdGggPSBzdWJkaXZpc2lvbnNXaWR0aCB8fCAxO1xuICBzdWJkaXZpc2lvbnNEZXB0aCA9IHN1YmRpdmlzaW9uc0RlcHRoIHx8IDE7XG4gIG1hdHJpeCA9IG1hdHJpeCB8fCBtNC5pZGVudGl0eSgpO1xuICB2YXIgbnVtVmVydGljZXMgPSAoc3ViZGl2aXNpb25zV2lkdGggKyAxKSAqIChzdWJkaXZpc2lvbnNEZXB0aCArIDEpO1xuICB2YXIgcG9zaXRpb25zID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciBub3JtYWxzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciB0ZXhjb29yZHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsIG51bVZlcnRpY2VzKTtcblxuICBmb3IgKHZhciB6ID0gMDsgeiA8PSBzdWJkaXZpc2lvbnNEZXB0aDsgeisrKSB7XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPD0gc3ViZGl2aXNpb25zV2lkdGg7IHgrKykge1xuICAgICAgdmFyIHUgPSB4IC8gc3ViZGl2aXNpb25zV2lkdGg7XG4gICAgICB2YXIgdiA9IHogLyBzdWJkaXZpc2lvbnNEZXB0aDtcbiAgICAgIHBvc2l0aW9ucy5wdXNoKHdpZHRoICogdSAtIHdpZHRoICogMC41LCAwLCBkZXB0aCAqIHYgLSBkZXB0aCAqIDAuNSk7XG4gICAgICBub3JtYWxzLnB1c2goMCwgMSwgMCk7XG4gICAgICB0ZXhjb29yZHMucHVzaCh1LCB2KTtcbiAgICB9XG4gIH1cblxuICB2YXIgbnVtVmVydHNBY3Jvc3MgPSBzdWJkaXZpc2lvbnNXaWR0aCArIDE7XG4gIHZhciBpbmRpY2VzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBzdWJkaXZpc2lvbnNXaWR0aCAqIHN1YmRpdmlzaW9uc0RlcHRoICogMiwgVWludDE2QXJyYXkpO1xuXG4gIGZvciAodmFyIF96ID0gMDsgX3ogPCBzdWJkaXZpc2lvbnNEZXB0aDsgX3orKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmb3IgKHZhciBfeCA9IDA7IF94IDwgc3ViZGl2aXNpb25zV2lkdGg7IF94KyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIE1ha2UgdHJpYW5nbGUgMSBvZiBxdWFkLlxuICAgICAgaW5kaWNlcy5wdXNoKChfeiArIDApICogbnVtVmVydHNBY3Jvc3MgKyBfeCwgKF96ICsgMSkgKiBudW1WZXJ0c0Fjcm9zcyArIF94LCAoX3ogKyAwKSAqIG51bVZlcnRzQWNyb3NzICsgX3ggKyAxKTsgLy8gTWFrZSB0cmlhbmdsZSAyIG9mIHF1YWQuXG5cbiAgICAgIGluZGljZXMucHVzaCgoX3ogKyAxKSAqIG51bVZlcnRzQWNyb3NzICsgX3gsIChfeiArIDEpICogbnVtVmVydHNBY3Jvc3MgKyBfeCArIDEsIChfeiArIDApICogbnVtVmVydHNBY3Jvc3MgKyBfeCArIDEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhcnJheXMgPSByZW9yaWVudFZlcnRpY2VzKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXNcbiAgfSwgbWF0cml4KTtcbiAgcmV0dXJuIGFycmF5cztcbn1cbi8qKlxuICogQ3JlYXRlcyBzcGhlcmUgQnVmZmVySW5mby5cbiAqXG4gKiBUaGUgY3JlYXRlZCBzcGhlcmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIHJhZGl1cyBvZiB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0F4aXMgbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0hlaWdodCBudW1iZXIgb2YgdmVydGljYWxseSBvbiB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gc3RhcnQgdGhlXG4gKiAgICAgdG9wIG9mIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnNdIFdoZXJlIHRvIGVuZCB0aGVcbiAqICAgICBib3R0b20gb2YgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IE1hdGguUEkuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9zdGFydExvbmdpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gc3RhcnRcbiAqICAgICB3cmFwcGluZyB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X2VuZExvbmdpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gZW5kXG4gKiAgICAgd3JhcHBpbmcgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDIgKiBNYXRoLlBJLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgc3BoZXJlIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVNwaGVyZUJ1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgc3BoZXJlIGJ1ZmZlcnMuXG4gKlxuICogVGhlIGNyZWF0ZWQgc3BoZXJlIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCBhbmQgdGV4Y29vcmQgZGF0YVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyByYWRpdXMgb2YgdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNBeGlzIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNIZWlnaHQgbnVtYmVyIG9mIHZlcnRpY2FsbHkgb24gdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X3N0YXJ0TGF0aXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIHN0YXJ0IHRoZVxuICogICAgIHRvcCBvZiB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X2VuZExhdGl0dWRlSW5SYWRpYW5zXSBXaGVyZSB0byBlbmQgdGhlXG4gKiAgICAgYm90dG9tIG9mIHRoZSBzcGhlcmUuIERlZmF1bHQgPSBNYXRoLlBJLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIHN0YXJ0XG4gKiAgICAgd3JhcHBpbmcgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9lbmRMb25naXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIGVuZFxuICogICAgIHdyYXBwaW5nIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAyICogTWF0aC5QSS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIHNwaGVyZSBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVTcGhlcmVCdWZmZXJzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIHNwaGVyZSB2ZXJ0aWNlcy5cbiAqXG4gKiBUaGUgY3JlYXRlZCBzcGhlcmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyByYWRpdXMgb2YgdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNBeGlzIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNIZWlnaHQgbnVtYmVyIG9mIHZlcnRpY2FsbHkgb24gdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X3N0YXJ0TGF0aXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIHN0YXJ0IHRoZVxuICogICAgIHRvcCBvZiB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X2VuZExhdGl0dWRlSW5SYWRpYW5zXSBXaGVyZSB0byBlbmQgdGhlXG4gKiAgICAgYm90dG9tIG9mIHRoZSBzcGhlcmUuIERlZmF1bHQgPSBNYXRoLlBJLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIHN0YXJ0XG4gKiAgICAgd3JhcHBpbmcgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9lbmRMb25naXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIGVuZFxuICogICAgIHdyYXBwaW5nIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAyICogTWF0aC5QSS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgc3BoZXJlIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNwaGVyZVZlcnRpY2VzKHJhZGl1cywgc3ViZGl2aXNpb25zQXhpcywgc3ViZGl2aXNpb25zSGVpZ2h0LCBvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFucywgb3B0X2VuZExhdGl0dWRlSW5SYWRpYW5zLCBvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnMsIG9wdF9lbmRMb25naXR1ZGVJblJhZGlhbnMpIHtcbiAgaWYgKHN1YmRpdmlzaW9uc0F4aXMgPD0gMCB8fCBzdWJkaXZpc2lvbnNIZWlnaHQgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3ViZGl2aXNpb25BeGlzIGFuZCBzdWJkaXZpc2lvbkhlaWdodCBtdXN0IGJlID4gMCcpO1xuICB9XG5cbiAgb3B0X3N0YXJ0TGF0aXR1ZGVJblJhZGlhbnMgPSBvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFucyB8fCAwO1xuICBvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnMgPSBvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnMgfHwgTWF0aC5QSTtcbiAgb3B0X3N0YXJ0TG9uZ2l0dWRlSW5SYWRpYW5zID0gb3B0X3N0YXJ0TG9uZ2l0dWRlSW5SYWRpYW5zIHx8IDA7XG4gIG9wdF9lbmRMb25naXR1ZGVJblJhZGlhbnMgPSBvcHRfZW5kTG9uZ2l0dWRlSW5SYWRpYW5zIHx8IE1hdGguUEkgKiAyO1xuICB2YXIgbGF0UmFuZ2UgPSBvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnMgLSBvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFucztcbiAgdmFyIGxvbmdSYW5nZSA9IG9wdF9lbmRMb25naXR1ZGVJblJhZGlhbnMgLSBvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnM7IC8vIFdlIGFyZSBnb2luZyB0byBnZW5lcmF0ZSBvdXIgc3BoZXJlIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGl0c1xuICAvLyBzcGhlcmljYWwgY29vcmRpbmF0ZXMgYW5kIGdlbmVyYXRpbmcgMiB0cmlhbmdsZXMgZm9yIGVhY2ggcXVhZCBvbiBhXG4gIC8vIHJpbmcgb2YgdGhlIHNwaGVyZS5cblxuICB2YXIgbnVtVmVydGljZXMgPSAoc3ViZGl2aXNpb25zQXhpcyArIDEpICogKHN1YmRpdmlzaW9uc0hlaWdodCArIDEpO1xuICB2YXIgcG9zaXRpb25zID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciBub3JtYWxzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciB0ZXhjb29yZHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsIG51bVZlcnRpY2VzKTsgLy8gR2VuZXJhdGUgdGhlIGluZGl2aWR1YWwgdmVydGljZXMgaW4gb3VyIHZlcnRleCBidWZmZXIuXG5cbiAgZm9yICh2YXIgeSA9IDA7IHkgPD0gc3ViZGl2aXNpb25zSGVpZ2h0OyB5KyspIHtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8PSBzdWJkaXZpc2lvbnNBeGlzOyB4KyspIHtcbiAgICAgIC8vIEdlbmVyYXRlIGEgdmVydGV4IGJhc2VkIG9uIGl0cyBzcGhlcmljYWwgY29vcmRpbmF0ZXNcbiAgICAgIHZhciB1ID0geCAvIHN1YmRpdmlzaW9uc0F4aXM7XG4gICAgICB2YXIgdiA9IHkgLyBzdWJkaXZpc2lvbnNIZWlnaHQ7XG4gICAgICB2YXIgdGhldGEgPSBsb25nUmFuZ2UgKiB1ICsgb3B0X3N0YXJ0TG9uZ2l0dWRlSW5SYWRpYW5zO1xuICAgICAgdmFyIHBoaSA9IGxhdFJhbmdlICogdiArIG9wdF9zdGFydExhdGl0dWRlSW5SYWRpYW5zO1xuICAgICAgdmFyIHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgdmFyIGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHNpblBoaSA9IE1hdGguc2luKHBoaSk7XG4gICAgICB2YXIgY29zUGhpID0gTWF0aC5jb3MocGhpKTtcbiAgICAgIHZhciB1eCA9IGNvc1RoZXRhICogc2luUGhpO1xuICAgICAgdmFyIHV5ID0gY29zUGhpO1xuICAgICAgdmFyIHV6ID0gc2luVGhldGEgKiBzaW5QaGk7XG4gICAgICBwb3NpdGlvbnMucHVzaChyYWRpdXMgKiB1eCwgcmFkaXVzICogdXksIHJhZGl1cyAqIHV6KTtcbiAgICAgIG5vcm1hbHMucHVzaCh1eCwgdXksIHV6KTtcbiAgICAgIHRleGNvb3Jkcy5wdXNoKDEgLSB1LCB2KTtcbiAgICB9XG4gIH1cblxuICB2YXIgbnVtVmVydHNBcm91bmQgPSBzdWJkaXZpc2lvbnNBeGlzICsgMTtcbiAgdmFyIGluZGljZXMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIHN1YmRpdmlzaW9uc0F4aXMgKiBzdWJkaXZpc2lvbnNIZWlnaHQgKiAyLCBVaW50MTZBcnJheSk7XG5cbiAgZm9yICh2YXIgX3gyID0gMDsgX3gyIDwgc3ViZGl2aXNpb25zQXhpczsgX3gyKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZm9yICh2YXIgX3kgPSAwOyBfeSA8IHN1YmRpdmlzaW9uc0hlaWdodDsgX3krKykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgLy8gTWFrZSB0cmlhbmdsZSAxIG9mIHF1YWQuXG4gICAgICBpbmRpY2VzLnB1c2goKF95ICsgMCkgKiBudW1WZXJ0c0Fyb3VuZCArIF94MiwgKF95ICsgMCkgKiBudW1WZXJ0c0Fyb3VuZCArIF94MiArIDEsIChfeSArIDEpICogbnVtVmVydHNBcm91bmQgKyBfeDIpOyAvLyBNYWtlIHRyaWFuZ2xlIDIgb2YgcXVhZC5cblxuICAgICAgaW5kaWNlcy5wdXNoKChfeSArIDEpICogbnVtVmVydHNBcm91bmQgKyBfeDIsIChfeSArIDApICogbnVtVmVydHNBcm91bmQgKyBfeDIgKyAxLCAoX3kgKyAxKSAqIG51bVZlcnRzQXJvdW5kICsgX3gyICsgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXNcbiAgfTtcbn1cbi8qKlxuICogQXJyYXkgb2YgdGhlIGluZGljZXMgb2YgY29ybmVycyBvZiBlYWNoIGZhY2Ugb2YgYSBjdWJlLlxuICogQHR5cGUge0FycmF5LjxudW1iZXJbXT59XG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIENVQkVfRkFDRV9JTkRJQ0VTID0gW1szLCA3LCA1LCAxXSwgLy8gcmlnaHRcbls2LCAyLCAwLCA0XSwgLy8gbGVmdFxuWzYsIDcsIDMsIDJdLCAvLyA/P1xuWzAsIDEsIDUsIDRdLCAvLyA/P1xuWzcsIDYsIDQsIDVdLCAvLyBmcm9udFxuWzIsIDMsIDEsIDBdIC8vIGJhY2tcbl07XG4vKipcbiAqIENyZWF0ZXMgYSBCdWZmZXJJbmZvIGZvciBhIGN1YmUuXG4gKlxuICogVGhlIGN1YmUgaXMgY3JlYXRlZCBhcm91bmQgdGhlIG9yaWdpbi4gKC1zaXplIC8gMiwgc2l6ZSAvIDIpLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXSB3aWR0aCwgaGVpZ2h0IGFuZCBkZXB0aCBvZiB0aGUgY3ViZS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUN1YmVCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBidWZmZXJzIGFuZCBpbmRpY2VzIGZvciBhIGN1YmUuXG4gKlxuICogVGhlIGN1YmUgaXMgY3JlYXRlZCBhcm91bmQgdGhlIG9yaWdpbi4gKC1zaXplIC8gMiwgc2l6ZSAvIDIpLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXSB3aWR0aCwgaGVpZ2h0IGFuZCBkZXB0aCBvZiB0aGUgY3ViZS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUN1YmVCdWZmZXJzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIHRoZSB2ZXJ0aWNlcyBhbmQgaW5kaWNlcyBmb3IgYSBjdWJlLlxuICpcbiAqIFRoZSBjdWJlIGlzIGNyZWF0ZWQgYXJvdW5kIHRoZSBvcmlnaW4uICgtc2l6ZSAvIDIsIHNpemUgLyAyKS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemVdIHdpZHRoLCBoZWlnaHQgYW5kIGRlcHRoIG9mIHRoZSBjdWJlLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQ3ViZVZlcnRpY2VzKHNpemUpIHtcbiAgc2l6ZSA9IHNpemUgfHwgMTtcbiAgdmFyIGsgPSBzaXplIC8gMjtcbiAgdmFyIGNvcm5lclZlcnRpY2VzID0gW1staywgLWssIC1rXSwgWytrLCAtaywgLWtdLCBbLWssICtrLCAta10sIFsraywgK2ssIC1rXSwgWy1rLCAtaywgK2tdLCBbK2ssIC1rLCAra10sIFstaywgK2ssICtrXSwgWytrLCAraywgK2tdXTtcbiAgdmFyIGZhY2VOb3JtYWxzID0gW1srMSwgKzAsICswXSwgWy0xLCArMCwgKzBdLCBbKzAsICsxLCArMF0sIFsrMCwgLTEsICswXSwgWyswLCArMCwgKzFdLCBbKzAsICswLCAtMV1dO1xuICB2YXIgdXZDb29yZHMgPSBbWzEsIDBdLCBbMCwgMF0sIFswLCAxXSwgWzEsIDFdXTtcbiAgdmFyIG51bVZlcnRpY2VzID0gNiAqIDQ7XG4gIHZhciBwb3NpdGlvbnMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIG5vcm1hbHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIHRleGNvb3JkcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiwgbnVtVmVydGljZXMpO1xuICB2YXIgaW5kaWNlcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgNiAqIDIsIFVpbnQxNkFycmF5KTtcblxuICBmb3IgKHZhciBmID0gMDsgZiA8IDY7ICsrZikge1xuICAgIHZhciBmYWNlSW5kaWNlcyA9IENVQkVfRkFDRV9JTkRJQ0VTW2ZdO1xuXG4gICAgZm9yICh2YXIgdiA9IDA7IHYgPCA0OyArK3YpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGNvcm5lclZlcnRpY2VzW2ZhY2VJbmRpY2VzW3ZdXTtcbiAgICAgIHZhciBub3JtYWwgPSBmYWNlTm9ybWFsc1tmXTtcbiAgICAgIHZhciB1diA9IHV2Q29vcmRzW3ZdOyAvLyBFYWNoIGZhY2UgbmVlZHMgYWxsIGZvdXIgdmVydGljZXMgYmVjYXVzZSB0aGUgbm9ybWFscyBhbmQgdGV4dHVyZVxuICAgICAgLy8gY29vcmRpbmF0ZXMgYXJlIG5vdCBhbGwgdGhlIHNhbWUuXG5cbiAgICAgIHBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcbiAgICAgIG5vcm1hbHMucHVzaChub3JtYWwpO1xuICAgICAgdGV4Y29vcmRzLnB1c2godXYpO1xuICAgIH0gLy8gVHdvIHRyaWFuZ2xlcyBtYWtlIGEgc3F1YXJlIGZhY2UuXG5cblxuICAgIHZhciBvZmZzZXQgPSA0ICogZjtcbiAgICBpbmRpY2VzLnB1c2gob2Zmc2V0ICsgMCwgb2Zmc2V0ICsgMSwgb2Zmc2V0ICsgMik7XG4gICAgaW5kaWNlcy5wdXNoKG9mZnNldCArIDAsIG9mZnNldCArIDIsIG9mZnNldCArIDMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXNcbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIEJ1ZmZlckluZm8gZm9yIGEgdHJ1bmNhdGVkIGNvbmUsIHdoaWNoIGlzIGxpa2UgYSBjeWxpbmRlclxuICogZXhjZXB0IHRoYXQgaXQgaGFzIGRpZmZlcmVudCB0b3AgYW5kIGJvdHRvbSByYWRpaS4gQSB0cnVuY2F0ZWQgY29uZVxuICogY2FuIGFsc28gYmUgdXNlZCB0byBjcmVhdGUgY3lsaW5kZXJzIGFuZCByZWd1bGFyIGNvbmVzLiBUaGVcbiAqIHRydW5jYXRlZCBjb25lIHdpbGwgYmUgY3JlYXRlZCBjZW50ZXJlZCBhYm91dCB0aGUgb3JpZ2luLCB3aXRoIHRoZVxuICogeSBheGlzIGFzIGl0cyB2ZXJ0aWNhbCBheGlzLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbVJhZGl1cyBCb3R0b20gcmFkaXVzIG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcFJhZGl1cyBUb3AgcmFkaXVzIG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGVcbiAqICAgICB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBkb3duIHRoZVxuICogICAgIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0X3RvcENhcF0gQ3JlYXRlIHRvcCBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0X2JvdHRvbUNhcF0gQ3JlYXRlIGJvdHRvbSBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgY29uZSBCdWZmZXJJbmZvLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVySW5mb1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBidWZmZXJzIGZvciBhIHRydW5jYXRlZCBjb25lLCB3aGljaCBpcyBsaWtlIGEgY3lsaW5kZXJcbiAqIGV4Y2VwdCB0aGF0IGl0IGhhcyBkaWZmZXJlbnQgdG9wIGFuZCBib3R0b20gcmFkaWkuIEEgdHJ1bmNhdGVkIGNvbmVcbiAqIGNhbiBhbHNvIGJlIHVzZWQgdG8gY3JlYXRlIGN5bGluZGVycyBhbmQgcmVndWxhciBjb25lcy4gVGhlXG4gKiB0cnVuY2F0ZWQgY29uZSB3aWxsIGJlIGNyZWF0ZWQgY2VudGVyZWQgYWJvdXQgdGhlIG9yaWdpbiwgd2l0aCB0aGVcbiAqIHkgYXhpcyBhcyBpdHMgdmVydGljYWwgYXhpcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b21SYWRpdXMgQm90dG9tIHJhZGl1cyBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3BSYWRpdXMgVG9wIHJhZGl1cyBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlXG4gKiAgICAgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgZG93biB0aGVcbiAqICAgICB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdF90b3BDYXBdIENyZWF0ZSB0b3AgY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdF9ib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGNvbmUgYnVmZmVycy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlVHJ1bmNhdGVkQ29uZUJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgdmVydGljZXMgZm9yIGEgdHJ1bmNhdGVkIGNvbmUsIHdoaWNoIGlzIGxpa2UgYSBjeWxpbmRlclxuICogZXhjZXB0IHRoYXQgaXQgaGFzIGRpZmZlcmVudCB0b3AgYW5kIGJvdHRvbSByYWRpaS4gQSB0cnVuY2F0ZWQgY29uZVxuICogY2FuIGFsc28gYmUgdXNlZCB0byBjcmVhdGUgY3lsaW5kZXJzIGFuZCByZWd1bGFyIGNvbmVzLiBUaGVcbiAqIHRydW5jYXRlZCBjb25lIHdpbGwgYmUgY3JlYXRlZCBjZW50ZXJlZCBhYm91dCB0aGUgb3JpZ2luLCB3aXRoIHRoZVxuICogeSBheGlzIGFzIGl0cyB2ZXJ0aWNhbCBheGlzLiAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbVJhZGl1cyBCb3R0b20gcmFkaXVzIG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcFJhZGl1cyBUb3AgcmFkaXVzIG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGVcbiAqICAgICB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBkb3duIHRoZVxuICogICAgIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0X3RvcENhcF0gQ3JlYXRlIHRvcCBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0X2JvdHRvbUNhcF0gQ3JlYXRlIGJvdHRvbSBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCBjb25lIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVRydW5jYXRlZENvbmVWZXJ0aWNlcyhib3R0b21SYWRpdXMsIHRvcFJhZGl1cywgaGVpZ2h0LCByYWRpYWxTdWJkaXZpc2lvbnMsIHZlcnRpY2FsU3ViZGl2aXNpb25zLCBvcHRfdG9wQ2FwLCBvcHRfYm90dG9tQ2FwKSB7XG4gIGlmIChyYWRpYWxTdWJkaXZpc2lvbnMgPCAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpYWxTdWJkaXZpc2lvbnMgbXVzdCBiZSAzIG9yIGdyZWF0ZXInKTtcbiAgfVxuXG4gIGlmICh2ZXJ0aWNhbFN1YmRpdmlzaW9ucyA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnRpY2FsU3ViZGl2aXNpb25zIG11c3QgYmUgMSBvciBncmVhdGVyJyk7XG4gIH1cblxuICB2YXIgdG9wQ2FwID0gb3B0X3RvcENhcCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdF90b3BDYXA7XG4gIHZhciBib3R0b21DYXAgPSBvcHRfYm90dG9tQ2FwID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0X2JvdHRvbUNhcDtcbiAgdmFyIGV4dHJhID0gKHRvcENhcCA/IDIgOiAwKSArIChib3R0b21DYXAgPyAyIDogMCk7XG4gIHZhciBudW1WZXJ0aWNlcyA9IChyYWRpYWxTdWJkaXZpc2lvbnMgKyAxKSAqICh2ZXJ0aWNhbFN1YmRpdmlzaW9ucyArIDEgKyBleHRyYSk7XG4gIHZhciBwb3NpdGlvbnMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIG5vcm1hbHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIHRleGNvb3JkcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiwgbnVtVmVydGljZXMpO1xuICB2YXIgaW5kaWNlcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgcmFkaWFsU3ViZGl2aXNpb25zICogKHZlcnRpY2FsU3ViZGl2aXNpb25zICsgZXh0cmEgLyAyKSAqIDIsIFVpbnQxNkFycmF5KTtcbiAgdmFyIHZlcnRzQXJvdW5kRWRnZSA9IHJhZGlhbFN1YmRpdmlzaW9ucyArIDE7IC8vIFRoZSBzbGFudCBvZiB0aGUgY29uZSBpcyBjb25zdGFudCBhY3Jvc3MgaXRzIHN1cmZhY2VcblxuICB2YXIgc2xhbnQgPSBNYXRoLmF0YW4yKGJvdHRvbVJhZGl1cyAtIHRvcFJhZGl1cywgaGVpZ2h0KTtcbiAgdmFyIGNvc1NsYW50ID0gTWF0aC5jb3Moc2xhbnQpO1xuICB2YXIgc2luU2xhbnQgPSBNYXRoLnNpbihzbGFudCk7XG4gIHZhciBzdGFydCA9IHRvcENhcCA/IC0yIDogMDtcbiAgdmFyIGVuZCA9IHZlcnRpY2FsU3ViZGl2aXNpb25zICsgKGJvdHRvbUNhcCA/IDIgOiAwKTtcblxuICBmb3IgKHZhciB5eSA9IHN0YXJ0OyB5eSA8PSBlbmQ7ICsreXkpIHtcbiAgICB2YXIgdiA9IHl5IC8gdmVydGljYWxTdWJkaXZpc2lvbnM7XG4gICAgdmFyIHkgPSBoZWlnaHQgKiB2O1xuICAgIHZhciByaW5nUmFkaXVzID0gdm9pZCAwO1xuXG4gICAgaWYgKHl5IDwgMCkge1xuICAgICAgeSA9IDA7XG4gICAgICB2ID0gMTtcbiAgICAgIHJpbmdSYWRpdXMgPSBib3R0b21SYWRpdXM7XG4gICAgfSBlbHNlIGlmICh5eSA+IHZlcnRpY2FsU3ViZGl2aXNpb25zKSB7XG4gICAgICB5ID0gaGVpZ2h0O1xuICAgICAgdiA9IDE7XG4gICAgICByaW5nUmFkaXVzID0gdG9wUmFkaXVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByaW5nUmFkaXVzID0gYm90dG9tUmFkaXVzICsgKHRvcFJhZGl1cyAtIGJvdHRvbVJhZGl1cykgKiAoeXkgLyB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKHl5ID09PSAtMiB8fCB5eSA9PT0gdmVydGljYWxTdWJkaXZpc2lvbnMgKyAyKSB7XG4gICAgICByaW5nUmFkaXVzID0gMDtcbiAgICAgIHYgPSAwO1xuICAgIH1cblxuICAgIHkgLT0gaGVpZ2h0IC8gMjtcblxuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB2ZXJ0c0Fyb3VuZEVkZ2U7ICsraWkpIHtcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihpaSAqIE1hdGguUEkgKiAyIC8gcmFkaWFsU3ViZGl2aXNpb25zKTtcbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhpaSAqIE1hdGguUEkgKiAyIC8gcmFkaWFsU3ViZGl2aXNpb25zKTtcbiAgICAgIHBvc2l0aW9ucy5wdXNoKHNpbiAqIHJpbmdSYWRpdXMsIHksIGNvcyAqIHJpbmdSYWRpdXMpO1xuXG4gICAgICBpZiAoeXkgPCAwKSB7XG4gICAgICAgIG5vcm1hbHMucHVzaCgwLCAtMSwgMCk7XG4gICAgICB9IGVsc2UgaWYgKHl5ID4gdmVydGljYWxTdWJkaXZpc2lvbnMpIHtcbiAgICAgICAgbm9ybWFscy5wdXNoKDAsIDEsIDApO1xuICAgICAgfSBlbHNlIGlmIChyaW5nUmFkaXVzID09PSAwLjApIHtcbiAgICAgICAgbm9ybWFscy5wdXNoKDAsIDAsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFscy5wdXNoKHNpbiAqIGNvc1NsYW50LCBzaW5TbGFudCwgY29zICogY29zU2xhbnQpO1xuICAgICAgfVxuXG4gICAgICB0ZXhjb29yZHMucHVzaChpaSAvIHJhZGlhbFN1YmRpdmlzaW9ucywgMSAtIHYpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF95eSA9IDA7IF95eSA8IHZlcnRpY2FsU3ViZGl2aXNpb25zICsgZXh0cmE7ICsrX3l5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChfeXkgPT09IDEgJiYgdG9wQ2FwIHx8IF95eSA9PT0gdmVydGljYWxTdWJkaXZpc2lvbnMgKyBleHRyYSAtIDIgJiYgYm90dG9tQ2FwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaWkgPSAwOyBfaWkgPCByYWRpYWxTdWJkaXZpc2lvbnM7ICsrX2lpKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpbmRpY2VzLnB1c2godmVydHNBcm91bmRFZGdlICogKF95eSArIDApICsgMCArIF9paSwgdmVydHNBcm91bmRFZGdlICogKF95eSArIDApICsgMSArIF9paSwgdmVydHNBcm91bmRFZGdlICogKF95eSArIDEpICsgMSArIF9paSk7XG4gICAgICBpbmRpY2VzLnB1c2godmVydHNBcm91bmRFZGdlICogKF95eSArIDApICsgMCArIF9paSwgdmVydHNBcm91bmRFZGdlICogKF95eSArIDEpICsgMSArIF9paSwgdmVydHNBcm91bmRFZGdlICogKF95eSArIDEpICsgMCArIF9paSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXNcbiAgfTtcbn1cbi8qKlxuICogRXhwYW5kcyBSTEUgZGF0YVxuICogQHBhcmFtIHtudW1iZXJbXX0gcmxlRGF0YSBkYXRhIGluIGZvcm1hdCBvZiBydW4tbGVuZ3RoLCB4LCB5LCB6LCBydW4tbGVuZ3RoLCB4LCB5LCB6XG4gKiBAcGFyYW0ge251bWJlcltdfSBbcGFkZGluZ10gdmFsdWUgdG8gYWRkIGVhY2ggZW50cnkgd2l0aC5cbiAqIEByZXR1cm4ge251bWJlcltdfSB0aGUgZXhwYW5kZWQgcmxlRGF0YVxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4cGFuZFJMRURhdGEocmxlRGF0YSwgcGFkZGluZykge1xuICBwYWRkaW5nID0gcGFkZGluZyB8fCBbXTtcbiAgdmFyIGRhdGEgPSBbXTtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgcmxlRGF0YS5sZW5ndGg7IGlpICs9IDQpIHtcbiAgICB2YXIgcnVuTGVuZ3RoID0gcmxlRGF0YVtpaV07XG4gICAgdmFyIGVsZW1lbnQgPSBybGVEYXRhLnNsaWNlKGlpICsgMSwgaWkgKyA0KTtcbiAgICBlbGVtZW50LnB1c2guYXBwbHkoZWxlbWVudCwgcGFkZGluZyk7XG5cbiAgICBmb3IgKHZhciBqaiA9IDA7IGpqIDwgcnVuTGVuZ3RoOyArK2pqKSB7XG4gICAgICBkYXRhLnB1c2guYXBwbHkoZGF0YSwgZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENyZWF0ZXMgM0QgJ0YnIEJ1ZmZlckluZm8uXG4gKiBBbiAnRicgaXMgdXNlZnVsIGJlY2F1c2UgeW91IGNhbiBlYXNpbHkgdGVsbCB3aGljaCB3YXkgaXQgaXMgb3JpZW50ZWQuXG4gKiBUaGUgY3JlYXRlZCAnRicgaGFzIHBvc2l0aW9uLCBub3JtYWwsIHRleGNvb3JkLCBhbmQgY29sb3IgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZTNERkJ1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgM0QgJ0YnIGJ1ZmZlcnMuXG4gKiBBbiAnRicgaXMgdXNlZnVsIGJlY2F1c2UgeW91IGNhbiBlYXNpbHkgdGVsbCB3aGljaCB3YXkgaXQgaXMgb3JpZW50ZWQuXG4gKiBUaGUgY3JlYXRlZCAnRicgaGFzIHBvc2l0aW9uLCBub3JtYWwsIHRleGNvb3JkLCBhbmQgY29sb3IgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZTNERkJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgM0QgJ0YnIHZlcnRpY2VzLlxuICogQW4gJ0YnIGlzIHVzZWZ1bCBiZWNhdXNlIHlvdSBjYW4gZWFzaWx5IHRlbGwgd2hpY2ggd2F5IGl0IGlzIG9yaWVudGVkLlxuICogVGhlIGNyZWF0ZWQgJ0YnIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCB0ZXhjb29yZCwgYW5kIGNvbG9yIGFycmF5cy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZTNERlZlcnRpY2VzKCkge1xuICB2YXIgcG9zaXRpb25zID0gWy8vIGxlZnQgY29sdW1uIGZyb250XG4gIDAsIDAsIDAsIDAsIDE1MCwgMCwgMzAsIDAsIDAsIDAsIDE1MCwgMCwgMzAsIDE1MCwgMCwgMzAsIDAsIDAsIC8vIHRvcCBydW5nIGZyb250XG4gIDMwLCAwLCAwLCAzMCwgMzAsIDAsIDEwMCwgMCwgMCwgMzAsIDMwLCAwLCAxMDAsIDMwLCAwLCAxMDAsIDAsIDAsIC8vIG1pZGRsZSBydW5nIGZyb250XG4gIDMwLCA2MCwgMCwgMzAsIDkwLCAwLCA2NywgNjAsIDAsIDMwLCA5MCwgMCwgNjcsIDkwLCAwLCA2NywgNjAsIDAsIC8vIGxlZnQgY29sdW1uIGJhY2tcbiAgMCwgMCwgMzAsIDMwLCAwLCAzMCwgMCwgMTUwLCAzMCwgMCwgMTUwLCAzMCwgMzAsIDAsIDMwLCAzMCwgMTUwLCAzMCwgLy8gdG9wIHJ1bmcgYmFja1xuICAzMCwgMCwgMzAsIDEwMCwgMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDEwMCwgMCwgMzAsIDEwMCwgMzAsIDMwLCAvLyBtaWRkbGUgcnVuZyBiYWNrXG4gIDMwLCA2MCwgMzAsIDY3LCA2MCwgMzAsIDMwLCA5MCwgMzAsIDMwLCA5MCwgMzAsIDY3LCA2MCwgMzAsIDY3LCA5MCwgMzAsIC8vIHRvcFxuICAwLCAwLCAwLCAxMDAsIDAsIDAsIDEwMCwgMCwgMzAsIDAsIDAsIDAsIDEwMCwgMCwgMzAsIDAsIDAsIDMwLCAvLyB0b3AgcnVuZyBmcm9udFxuICAxMDAsIDAsIDAsIDEwMCwgMzAsIDAsIDEwMCwgMzAsIDMwLCAxMDAsIDAsIDAsIDEwMCwgMzAsIDMwLCAxMDAsIDAsIDMwLCAvLyB1bmRlciB0b3AgcnVuZ1xuICAzMCwgMzAsIDAsIDMwLCAzMCwgMzAsIDEwMCwgMzAsIDMwLCAzMCwgMzAsIDAsIDEwMCwgMzAsIDMwLCAxMDAsIDMwLCAwLCAvLyBiZXR3ZWVuIHRvcCBydW5nIGFuZCBtaWRkbGVcbiAgMzAsIDMwLCAwLCAzMCwgNjAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDAsIDMwLCA2MCwgMCwgMzAsIDYwLCAzMCwgLy8gdG9wIG9mIG1pZGRsZSBydW5nXG4gIDMwLCA2MCwgMCwgNjcsIDYwLCAzMCwgMzAsIDYwLCAzMCwgMzAsIDYwLCAwLCA2NywgNjAsIDAsIDY3LCA2MCwgMzAsIC8vIGZyb250IG9mIG1pZGRsZSBydW5nXG4gIDY3LCA2MCwgMCwgNjcsIDkwLCAzMCwgNjcsIDYwLCAzMCwgNjcsIDYwLCAwLCA2NywgOTAsIDAsIDY3LCA5MCwgMzAsIC8vIGJvdHRvbSBvZiBtaWRkbGUgcnVuZy5cbiAgMzAsIDkwLCAwLCAzMCwgOTAsIDMwLCA2NywgOTAsIDMwLCAzMCwgOTAsIDAsIDY3LCA5MCwgMzAsIDY3LCA5MCwgMCwgLy8gZnJvbnQgb2YgYm90dG9tXG4gIDMwLCA5MCwgMCwgMzAsIDE1MCwgMzAsIDMwLCA5MCwgMzAsIDMwLCA5MCwgMCwgMzAsIDE1MCwgMCwgMzAsIDE1MCwgMzAsIC8vIGJvdHRvbVxuICAwLCAxNTAsIDAsIDAsIDE1MCwgMzAsIDMwLCAxNTAsIDMwLCAwLCAxNTAsIDAsIDMwLCAxNTAsIDMwLCAzMCwgMTUwLCAwLCAvLyBsZWZ0IHNpZGVcbiAgMCwgMCwgMCwgMCwgMCwgMzAsIDAsIDE1MCwgMzAsIDAsIDAsIDAsIDAsIDE1MCwgMzAsIDAsIDE1MCwgMF07XG4gIHZhciB0ZXhjb29yZHMgPSBbLy8gbGVmdCBjb2x1bW4gZnJvbnRcbiAgMC4yMiwgMC4xOSwgMC4yMiwgMC43OSwgMC4zNCwgMC4xOSwgMC4yMiwgMC43OSwgMC4zNCwgMC43OSwgMC4zNCwgMC4xOSwgLy8gdG9wIHJ1bmcgZnJvbnRcbiAgMC4zNCwgMC4xOSwgMC4zNCwgMC4zMSwgMC42MiwgMC4xOSwgMC4zNCwgMC4zMSwgMC42MiwgMC4zMSwgMC42MiwgMC4xOSwgLy8gbWlkZGxlIHJ1bmcgZnJvbnRcbiAgMC4zNCwgMC40MywgMC4zNCwgMC41NSwgMC40OSwgMC40MywgMC4zNCwgMC41NSwgMC40OSwgMC41NSwgMC40OSwgMC40MywgLy8gbGVmdCBjb2x1bW4gYmFja1xuICAwLCAwLCAxLCAwLCAwLCAxLCAwLCAxLCAxLCAwLCAxLCAxLCAvLyB0b3AgcnVuZyBiYWNrXG4gIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDEsIDEsIDAsIDEsIDEsIC8vIG1pZGRsZSBydW5nIGJhY2tcbiAgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMSwgMSwgMCwgMSwgMSwgLy8gdG9wXG4gIDAsIDAsIDEsIDAsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIC8vIHRvcCBydW5nIGZyb250XG4gIDAsIDAsIDEsIDAsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIC8vIHVuZGVyIHRvcCBydW5nXG4gIDAsIDAsIDAsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDEsIDAsIC8vIGJldHdlZW4gdG9wIHJ1bmcgYW5kIG1pZGRsZVxuICAwLCAwLCAxLCAxLCAwLCAxLCAwLCAwLCAxLCAwLCAxLCAxLCAvLyB0b3Agb2YgbWlkZGxlIHJ1bmdcbiAgMCwgMCwgMSwgMSwgMCwgMSwgMCwgMCwgMSwgMCwgMSwgMSwgLy8gZnJvbnQgb2YgbWlkZGxlIHJ1bmdcbiAgMCwgMCwgMSwgMSwgMCwgMSwgMCwgMCwgMSwgMCwgMSwgMSwgLy8gYm90dG9tIG9mIG1pZGRsZSBydW5nLlxuICAwLCAwLCAwLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAxLCAwLCAvLyBmcm9udCBvZiBib3R0b21cbiAgMCwgMCwgMSwgMSwgMCwgMSwgMCwgMCwgMSwgMCwgMSwgMSwgLy8gYm90dG9tXG4gIDAsIDAsIDAsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDEsIDAsIC8vIGxlZnQgc2lkZVxuICAwLCAwLCAwLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAxLCAwXTtcbiAgdmFyIG5vcm1hbHMgPSBleHBhbmRSTEVEYXRhKFsvLyBsZWZ0IGNvbHVtbiBmcm9udFxuICAvLyB0b3AgcnVuZyBmcm9udFxuICAvLyBtaWRkbGUgcnVuZyBmcm9udFxuICAxOCwgMCwgMCwgMSwgLy8gbGVmdCBjb2x1bW4gYmFja1xuICAvLyB0b3AgcnVuZyBiYWNrXG4gIC8vIG1pZGRsZSBydW5nIGJhY2tcbiAgMTgsIDAsIDAsIC0xLCAvLyB0b3BcbiAgNiwgMCwgMSwgMCwgLy8gdG9wIHJ1bmcgZnJvbnRcbiAgNiwgMSwgMCwgMCwgLy8gdW5kZXIgdG9wIHJ1bmdcbiAgNiwgMCwgLTEsIDAsIC8vIGJldHdlZW4gdG9wIHJ1bmcgYW5kIG1pZGRsZVxuICA2LCAxLCAwLCAwLCAvLyB0b3Agb2YgbWlkZGxlIHJ1bmdcbiAgNiwgMCwgMSwgMCwgLy8gZnJvbnQgb2YgbWlkZGxlIHJ1bmdcbiAgNiwgMSwgMCwgMCwgLy8gYm90dG9tIG9mIG1pZGRsZSBydW5nLlxuICA2LCAwLCAtMSwgMCwgLy8gZnJvbnQgb2YgYm90dG9tXG4gIDYsIDEsIDAsIDAsIC8vIGJvdHRvbVxuICA2LCAwLCAtMSwgMCwgLy8gbGVmdCBzaWRlXG4gIDYsIC0xLCAwLCAwXSk7XG4gIHZhciBjb2xvcnMgPSBleHBhbmRSTEVEYXRhKFsvLyBsZWZ0IGNvbHVtbiBmcm9udFxuICAvLyB0b3AgcnVuZyBmcm9udFxuICAvLyBtaWRkbGUgcnVuZyBmcm9udFxuICAxOCwgMjAwLCA3MCwgMTIwLCAvLyBsZWZ0IGNvbHVtbiBiYWNrXG4gIC8vIHRvcCBydW5nIGJhY2tcbiAgLy8gbWlkZGxlIHJ1bmcgYmFja1xuICAxOCwgODAsIDcwLCAyMDAsIC8vIHRvcFxuICA2LCA3MCwgMjAwLCAyMTAsIC8vIHRvcCBydW5nIGZyb250XG4gIDYsIDIwMCwgMjAwLCA3MCwgLy8gdW5kZXIgdG9wIHJ1bmdcbiAgNiwgMjEwLCAxMDAsIDcwLCAvLyBiZXR3ZWVuIHRvcCBydW5nIGFuZCBtaWRkbGVcbiAgNiwgMjEwLCAxNjAsIDcwLCAvLyB0b3Agb2YgbWlkZGxlIHJ1bmdcbiAgNiwgNzAsIDE4MCwgMjEwLCAvLyBmcm9udCBvZiBtaWRkbGUgcnVuZ1xuICA2LCAxMDAsIDcwLCAyMTAsIC8vIGJvdHRvbSBvZiBtaWRkbGUgcnVuZy5cbiAgNiwgNzYsIDIxMCwgMTAwLCAvLyBmcm9udCBvZiBib3R0b21cbiAgNiwgMTQwLCAyMTAsIDgwLCAvLyBib3R0b21cbiAgNiwgOTAsIDEzMCwgMTEwLCAvLyBsZWZ0IHNpZGVcbiAgNiwgMTYwLCAxNjAsIDIyMF0sIFsyNTVdKTtcbiAgdmFyIG51bVZlcnRzID0gcG9zaXRpb25zLmxlbmd0aCAvIDM7XG4gIHZhciBhcnJheXMgPSB7XG4gICAgcG9zaXRpb246IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydHMpLFxuICAgIHRleGNvb3JkOiBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsIG51bVZlcnRzKSxcbiAgICBub3JtYWw6IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydHMpLFxuICAgIGNvbG9yOiBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDQsIG51bVZlcnRzLCBVaW50OEFycmF5KSxcbiAgICBpbmRpY2VzOiBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRzIC8gMywgVWludDE2QXJyYXkpXG4gIH07XG4gIGFycmF5cy5wb3NpdGlvbi5wdXNoKHBvc2l0aW9ucyk7XG4gIGFycmF5cy50ZXhjb29yZC5wdXNoKHRleGNvb3Jkcyk7XG4gIGFycmF5cy5ub3JtYWwucHVzaChub3JtYWxzKTtcbiAgYXJyYXlzLmNvbG9yLnB1c2goY29sb3JzKTtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbnVtVmVydHM7ICsraWkpIHtcbiAgICBhcnJheXMuaW5kaWNlcy5wdXNoKGlpKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheXM7XG59XG4vKipcbiAqIENyZWF0ZXMgY3Jlc2NlbnQgQnVmZmVySW5mby5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFJhZGl1cyBUaGUgdmVydGljYWwgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRlclJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbm5lclJhZGl1cyBUaGUgaW5uZXIgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGlja25lc3MgVGhlIHRoaWNrbmVzcyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zRG93biBudW1iZXIgb2Ygc3RlcHMgYXJvdW5kIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRPZmZzZXRdIFdoZXJlIHRvIHN0YXJ0IGFyYy4gRGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmRPZmZzZXRdIFdoZXJlIHRvIGVuZCBhcmcuIERlZmF1bHQgMS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUNyZXNlbnRCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGNyZXNjZW50IGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxSYWRpdXMgVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0ZXJSYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5uZXJSYWRpdXMgVGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIFRoZSB0aGlja25lc3Mgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0Rvd24gbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0T2Zmc2V0XSBXaGVyZSB0byBzdGFydCBhcmMuIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kT2Zmc2V0XSBXaGVyZSB0byBlbmQgYXJnLiBEZWZhdWx0IDEuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVDcmVzZW50QnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBjcmVzY2VudCB2ZXJ0aWNlcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxSYWRpdXMgVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0ZXJSYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5uZXJSYWRpdXMgVGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIFRoZSB0aGlja25lc3Mgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0Rvd24gbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0T2Zmc2V0XSBXaGVyZSB0byBzdGFydCBhcmMuIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kT2Zmc2V0XSBXaGVyZSB0byBlbmQgYXJnLiBEZWZhdWx0IDEuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVDcmVzZW50QnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBjcmVzY2VudCBCdWZmZXJJbmZvLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsUmFkaXVzIFRoZSB2ZXJ0aWNhbCByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG91dGVyUmFkaXVzIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGlubmVyUmFkaXVzIFRoZSBpbm5lciByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRoaWNrbmVzcyBUaGUgdGhpY2tuZXNzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNEb3duIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydE9mZnNldF0gV2hlcmUgdG8gc3RhcnQgYXJjLiBEZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZE9mZnNldF0gV2hlcmUgdG8gZW5kIGFyZy4gRGVmYXVsdCAxLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlQ3Jlc2NlbnRCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGNyZXNjZW50IGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxSYWRpdXMgVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0ZXJSYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5uZXJSYWRpdXMgVGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIFRoZSB0aGlja25lc3Mgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0Rvd24gbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0T2Zmc2V0XSBXaGVyZSB0byBzdGFydCBhcmMuIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kT2Zmc2V0XSBXaGVyZSB0byBlbmQgYXJnLiBEZWZhdWx0IDEuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVDcmVzY2VudEJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgY3Jlc2NlbnQgdmVydGljZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsUmFkaXVzIFRoZSB2ZXJ0aWNhbCByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG91dGVyUmFkaXVzIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGlubmVyUmFkaXVzIFRoZSBpbm5lciByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRoaWNrbmVzcyBUaGUgdGhpY2tuZXNzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNEb3duIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydE9mZnNldF0gV2hlcmUgdG8gc3RhcnQgYXJjLiBEZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZE9mZnNldF0gV2hlcmUgdG8gZW5kIGFyZy4gRGVmYXVsdCAxLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVDcmVzY2VudFZlcnRpY2VzKHZlcnRpY2FsUmFkaXVzLCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMsIHRoaWNrbmVzcywgc3ViZGl2aXNpb25zRG93biwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICBpZiAoc3ViZGl2aXNpb25zRG93biA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdWJkaXZpc2lvbkRvd24gbXVzdCBiZSA+IDAnKTtcbiAgfVxuXG4gIHN0YXJ0T2Zmc2V0ID0gc3RhcnRPZmZzZXQgfHwgMDtcbiAgZW5kT2Zmc2V0ID0gZW5kT2Zmc2V0IHx8IDE7XG4gIHZhciBzdWJkaXZpc2lvbnNUaGljayA9IDI7XG4gIHZhciBvZmZzZXRSYW5nZSA9IGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xuICB2YXIgbnVtVmVydGljZXMgPSAoc3ViZGl2aXNpb25zRG93biArIDEpICogMiAqICgyICsgc3ViZGl2aXNpb25zVGhpY2spO1xuICB2YXIgcG9zaXRpb25zID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciBub3JtYWxzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciB0ZXhjb29yZHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsIG51bVZlcnRpY2VzKTtcblxuICBmdW5jdGlvbiBsZXJwKGEsIGIsIHMpIHtcbiAgICByZXR1cm4gYSArIChiIC0gYSkgKiBzO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJjKGFyY1JhZGl1cywgeCwgbm9ybWFsTXVsdCwgbm9ybWFsQWRkLCB1TXVsdCwgdUFkZCkge1xuICAgIGZvciAodmFyIHogPSAwOyB6IDw9IHN1YmRpdmlzaW9uc0Rvd247IHorKykge1xuICAgICAgdmFyIHVCYWNrID0geCAvIChzdWJkaXZpc2lvbnNUaGljayAtIDEpO1xuICAgICAgdmFyIHYgPSB6IC8gc3ViZGl2aXNpb25zRG93bjtcbiAgICAgIHZhciB4QmFjayA9ICh1QmFjayAtIDAuNSkgKiAyO1xuICAgICAgdmFyIGFuZ2xlID0gKHN0YXJ0T2Zmc2V0ICsgdiAqIG9mZnNldFJhbmdlKSAqIE1hdGguUEk7XG4gICAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgdmFyIHJhZGl1cyA9IGxlcnAodmVydGljYWxSYWRpdXMsIGFyY1JhZGl1cywgcyk7XG4gICAgICB2YXIgcHggPSB4QmFjayAqIHRoaWNrbmVzcztcbiAgICAgIHZhciBweSA9IGMgKiB2ZXJ0aWNhbFJhZGl1cztcbiAgICAgIHZhciBweiA9IHMgKiByYWRpdXM7XG4gICAgICBwb3NpdGlvbnMucHVzaChweCwgcHksIHB6KTtcbiAgICAgIHZhciBuID0gdjMuYWRkKHYzLm11bHRpcGx5KFswLCBzLCBjXSwgbm9ybWFsTXVsdCksIG5vcm1hbEFkZCk7XG4gICAgICBub3JtYWxzLnB1c2gobik7XG4gICAgICB0ZXhjb29yZHMucHVzaCh1QmFjayAqIHVNdWx0ICsgdUFkZCwgdik7XG4gICAgfVxuICB9IC8vIEdlbmVyYXRlIHRoZSBpbmRpdmlkdWFsIHZlcnRpY2VzIGluIG91ciB2ZXJ0ZXggYnVmZmVyLlxuXG5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCBzdWJkaXZpc2lvbnNUaGljazsgeCsrKSB7XG4gICAgdmFyIHVCYWNrID0gKHggLyAoc3ViZGl2aXNpb25zVGhpY2sgLSAxKSAtIDAuNSkgKiAyO1xuICAgIGNyZWF0ZUFyYyhvdXRlclJhZGl1cywgeCwgWzEsIDEsIDFdLCBbMCwgMCwgMF0sIDEsIDApO1xuICAgIGNyZWF0ZUFyYyhvdXRlclJhZGl1cywgeCwgWzAsIDAsIDBdLCBbdUJhY2ssIDAsIDBdLCAwLCAwKTtcbiAgICBjcmVhdGVBcmMoaW5uZXJSYWRpdXMsIHgsIFsxLCAxLCAxXSwgWzAsIDAsIDBdLCAxLCAwKTtcbiAgICBjcmVhdGVBcmMoaW5uZXJSYWRpdXMsIHgsIFswLCAwLCAwXSwgW3VCYWNrLCAwLCAwXSwgMCwgMSk7XG4gIH0gLy8gRG8gb3V0ZXIgc3VyZmFjZS5cblxuXG4gIHZhciBpbmRpY2VzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBzdWJkaXZpc2lvbnNEb3duICogMiAqICgyICsgc3ViZGl2aXNpb25zVGhpY2spLCBVaW50MTZBcnJheSk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3VyZmFjZShsZWZ0QXJjT2Zmc2V0LCByaWdodEFyY09mZnNldCkge1xuICAgIGZvciAodmFyIHogPSAwOyB6IDwgc3ViZGl2aXNpb25zRG93bjsgKyt6KSB7XG4gICAgICAvLyBNYWtlIHRyaWFuZ2xlIDEgb2YgcXVhZC5cbiAgICAgIGluZGljZXMucHVzaChsZWZ0QXJjT2Zmc2V0ICsgeiArIDAsIGxlZnRBcmNPZmZzZXQgKyB6ICsgMSwgcmlnaHRBcmNPZmZzZXQgKyB6ICsgMCk7IC8vIE1ha2UgdHJpYW5nbGUgMiBvZiBxdWFkLlxuXG4gICAgICBpbmRpY2VzLnB1c2gobGVmdEFyY09mZnNldCArIHogKyAxLCByaWdodEFyY09mZnNldCArIHogKyAxLCByaWdodEFyY09mZnNldCArIHogKyAwKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbnVtVmVydGljZXNEb3duID0gc3ViZGl2aXNpb25zRG93biArIDE7IC8vIGZyb250XG5cbiAgY3JlYXRlU3VyZmFjZShudW1WZXJ0aWNlc0Rvd24gKiAwLCBudW1WZXJ0aWNlc0Rvd24gKiA0KTsgLy8gcmlnaHRcblxuICBjcmVhdGVTdXJmYWNlKG51bVZlcnRpY2VzRG93biAqIDUsIG51bVZlcnRpY2VzRG93biAqIDcpOyAvLyBiYWNrXG5cbiAgY3JlYXRlU3VyZmFjZShudW1WZXJ0aWNlc0Rvd24gKiA2LCBudW1WZXJ0aWNlc0Rvd24gKiAyKTsgLy8gbGVmdFxuXG4gIGNyZWF0ZVN1cmZhY2UobnVtVmVydGljZXNEb3duICogMywgbnVtVmVydGljZXNEb3duICogMSk7XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9ucyxcbiAgICBub3JtYWw6IG5vcm1hbHMsXG4gICAgdGV4Y29vcmQ6IHRleGNvb3JkcyxcbiAgICBpbmRpY2VzOiBpbmRpY2VzXG4gIH07XG59XG4vKipcbiAqIENyZWF0ZXMgY3lsaW5kZXIgQnVmZmVySW5mby4gVGhlIGN5bGluZGVyIHdpbGwgYmUgY3JlYXRlZCBhcm91bmQgdGhlIG9yaWdpblxuICogYWxvbmcgdGhlIHktYXhpcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgY3lsaW5kZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGUgY3lsaW5kZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgZG93biB0aGUgY3lsaW5kZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0b3BDYXBdIENyZWF0ZSB0b3AgY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JvdHRvbUNhcF0gQ3JlYXRlIGJvdHRvbSBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlQ3lsaW5kZXJCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGN5bGluZGVyIGJ1ZmZlcnMuIFRoZSBjeWxpbmRlciB3aWxsIGJlIGNyZWF0ZWQgYXJvdW5kIHRoZSBvcmlnaW5cbiAqIGFsb25nIHRoZSB5LWF4aXMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBjeWxpbmRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGRvd24gdGhlIGN5bGluZGVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdG9wQ2FwXSBDcmVhdGUgdG9wIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUN5bGluZGVyQnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBjeWxpbmRlciB2ZXJ0aWNlcy4gVGhlIGN5bGluZGVyIHdpbGwgYmUgY3JlYXRlZCBhcm91bmQgdGhlIG9yaWdpblxuICogYWxvbmcgdGhlIHktYXhpcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBjeWxpbmRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGRvd24gdGhlIGN5bGluZGVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdG9wQ2FwXSBDcmVhdGUgdG9wIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQ3lsaW5kZXJWZXJ0aWNlcyhyYWRpdXMsIGhlaWdodCwgcmFkaWFsU3ViZGl2aXNpb25zLCB2ZXJ0aWNhbFN1YmRpdmlzaW9ucywgdG9wQ2FwLCBib3R0b21DYXApIHtcbiAgcmV0dXJuIGNyZWF0ZVRydW5jYXRlZENvbmVWZXJ0aWNlcyhyYWRpdXMsIHJhZGl1cywgaGVpZ2h0LCByYWRpYWxTdWJkaXZpc2lvbnMsIHZlcnRpY2FsU3ViZGl2aXNpb25zLCB0b3BDYXAsIGJvdHRvbUNhcCk7XG59XG4vKipcbiAqIENyZWF0ZXMgQnVmZmVySW5mbyBmb3IgYSB0b3J1c1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyByYWRpdXMgb2YgY2VudGVyIG9mIHRvcnVzIGNpcmNsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGlja25lc3MgcmFkaXVzIG9mIHRvcnVzIHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGUgdG9ydXMuXG4gKiBAcGFyYW0ge251bWJlcn0gYm9keVN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIGJvZHkgdG9ydXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFydEFuZ2xlXSBzdGFydCBhbmdsZSBpbiByYWRpYW5zLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuZEFuZ2xlXSBlbmQgYW5nbGUgaW4gcmFkaWFucy4gRGVmYXVsdCA9IE1hdGguUEkgKiAyLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlVG9ydXNCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGJ1ZmZlcnMgZm9yIGEgdG9ydXNcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgcmFkaXVzIG9mIGNlbnRlciBvZiB0b3J1cyBjaXJjbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIHJhZGl1cyBvZiB0b3J1cyByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIHRvcnVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvZHlTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZSBib2R5IHRvcnVzLlxuICogQHBhcmFtIHtib29sZWFufSBbc3RhcnRBbmdsZV0gc3RhcnQgYW5nbGUgaW4gcmFkaWFucy4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRBbmdsZV0gZW5kIGFuZ2xlIGluIHJhZGlhbnMuIERlZmF1bHQgPSBNYXRoLlBJICogMi5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVRvcnVzQnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyB2ZXJ0aWNlcyBmb3IgYSB0b3J1c1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgcmFkaXVzIG9mIGNlbnRlciBvZiB0b3J1cyBjaXJjbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIHJhZGl1cyBvZiB0b3J1cyByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIHRvcnVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvZHlTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZSBib2R5IHRvcnVzLlxuICogQHBhcmFtIHtib29sZWFufSBbc3RhcnRBbmdsZV0gc3RhcnQgYW5nbGUgaW4gcmFkaWFucy4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRBbmdsZV0gZW5kIGFuZ2xlIGluIHJhZGlhbnMuIERlZmF1bHQgPSBNYXRoLlBJICogMi5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlVG9ydXNWZXJ0aWNlcyhyYWRpdXMsIHRoaWNrbmVzcywgcmFkaWFsU3ViZGl2aXNpb25zLCBib2R5U3ViZGl2aXNpb25zLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkge1xuICBpZiAocmFkaWFsU3ViZGl2aXNpb25zIDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmFkaWFsU3ViZGl2aXNpb25zIG11c3QgYmUgMyBvciBncmVhdGVyJyk7XG4gIH1cblxuICBpZiAoYm9keVN1YmRpdmlzaW9ucyA8IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnRpY2FsU3ViZGl2aXNpb25zIG11c3QgYmUgMyBvciBncmVhdGVyJyk7XG4gIH1cblxuICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSB8fCAwO1xuICBlbmRBbmdsZSA9IGVuZEFuZ2xlIHx8IE1hdGguUEkgKiAyO1xuICB2YXIgcmFuZ2UgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gIHZhciByYWRpYWxQYXJ0cyA9IHJhZGlhbFN1YmRpdmlzaW9ucyArIDE7XG4gIHZhciBib2R5UGFydHMgPSBib2R5U3ViZGl2aXNpb25zICsgMTtcbiAgdmFyIG51bVZlcnRpY2VzID0gcmFkaWFsUGFydHMgKiBib2R5UGFydHM7XG4gIHZhciBwb3NpdGlvbnMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIG5vcm1hbHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIHRleGNvb3JkcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiwgbnVtVmVydGljZXMpO1xuICB2YXIgaW5kaWNlcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgcmFkaWFsU3ViZGl2aXNpb25zICogYm9keVN1YmRpdmlzaW9ucyAqIDIsIFVpbnQxNkFycmF5KTtcblxuICBmb3IgKHZhciBzbGljZSA9IDA7IHNsaWNlIDwgYm9keVBhcnRzOyArK3NsaWNlKSB7XG4gICAgdmFyIHYgPSBzbGljZSAvIGJvZHlTdWJkaXZpc2lvbnM7XG4gICAgdmFyIHNsaWNlQW5nbGUgPSB2ICogTWF0aC5QSSAqIDI7XG4gICAgdmFyIHNsaWNlU2luID0gTWF0aC5zaW4oc2xpY2VBbmdsZSk7XG4gICAgdmFyIHJpbmdSYWRpdXMgPSByYWRpdXMgKyBzbGljZVNpbiAqIHRoaWNrbmVzcztcbiAgICB2YXIgbnkgPSBNYXRoLmNvcyhzbGljZUFuZ2xlKTtcbiAgICB2YXIgeSA9IG55ICogdGhpY2tuZXNzO1xuXG4gICAgZm9yICh2YXIgcmluZyA9IDA7IHJpbmcgPCByYWRpYWxQYXJ0czsgKytyaW5nKSB7XG4gICAgICB2YXIgdSA9IHJpbmcgLyByYWRpYWxTdWJkaXZpc2lvbnM7XG4gICAgICB2YXIgcmluZ0FuZ2xlID0gc3RhcnRBbmdsZSArIHUgKiByYW5nZTtcbiAgICAgIHZhciB4U2luID0gTWF0aC5zaW4ocmluZ0FuZ2xlKTtcbiAgICAgIHZhciB6Q29zID0gTWF0aC5jb3MocmluZ0FuZ2xlKTtcbiAgICAgIHZhciB4ID0geFNpbiAqIHJpbmdSYWRpdXM7XG4gICAgICB2YXIgeiA9IHpDb3MgKiByaW5nUmFkaXVzO1xuICAgICAgdmFyIG54ID0geFNpbiAqIHNsaWNlU2luO1xuICAgICAgdmFyIG56ID0gekNvcyAqIHNsaWNlU2luO1xuICAgICAgcG9zaXRpb25zLnB1c2goeCwgeSwgeik7XG4gICAgICBub3JtYWxzLnB1c2gobngsIG55LCBueik7XG4gICAgICB0ZXhjb29yZHMucHVzaCh1LCAxIC0gdik7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3NsaWNlID0gMDsgX3NsaWNlIDwgYm9keVN1YmRpdmlzaW9uczsgKytfc2xpY2UpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZm9yICh2YXIgX3JpbmcgPSAwOyBfcmluZyA8IHJhZGlhbFN1YmRpdmlzaW9uczsgKytfcmluZykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgdmFyIG5leHRSaW5nSW5kZXggPSAxICsgX3Jpbmc7XG4gICAgICB2YXIgbmV4dFNsaWNlSW5kZXggPSAxICsgX3NsaWNlO1xuICAgICAgaW5kaWNlcy5wdXNoKHJhZGlhbFBhcnRzICogX3NsaWNlICsgX3JpbmcsIHJhZGlhbFBhcnRzICogbmV4dFNsaWNlSW5kZXggKyBfcmluZywgcmFkaWFsUGFydHMgKiBfc2xpY2UgKyBuZXh0UmluZ0luZGV4KTtcbiAgICAgIGluZGljZXMucHVzaChyYWRpYWxQYXJ0cyAqIG5leHRTbGljZUluZGV4ICsgX3JpbmcsIHJhZGlhbFBhcnRzICogbmV4dFNsaWNlSW5kZXggKyBuZXh0UmluZ0luZGV4LCByYWRpYWxQYXJ0cyAqIF9zbGljZSArIG5leHRSaW5nSW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9ucyxcbiAgICBub3JtYWw6IG5vcm1hbHMsXG4gICAgdGV4Y29vcmQ6IHRleGNvb3JkcyxcbiAgICBpbmRpY2VzOiBpbmRpY2VzXG4gIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBkaXNjIEJ1ZmZlckluZm8uIFRoZSBkaXNjIHdpbGwgYmUgaW4gdGhlIHh6IHBsYW5lLCBjZW50ZXJlZCBhdFxuICogdGhlIG9yaWdpbi4gV2hlbiBjcmVhdGluZywgYXQgbGVhc3QgMyBkaXZpc2lvbnMsIG9yIHBpZVxuICogcGllY2VzLCBuZWVkIHRvIGJlIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHRoZSB0cmlhbmdsZXMgbWFraW5nXG4gKiB1cCB0aGUgZGlzYyB3aWxsIGJlIGRlZ2VuZXJhdGUuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IHRoZVxuICogbnVtYmVyIG9mIHJhZGlhbCBwaWVjZXMgYHN0YWNrc2AuIEEgdmFsdWUgb2YgMSBmb3JcbiAqIHN0YWNrcyB3aWxsIGdpdmUgeW91IGEgc2ltcGxlIGRpc2Mgb2YgcGllIHBpZWNlcy4gIElmIHlvdVxuICogd2FudCB0byBjcmVhdGUgYW4gYW5udWx1cyB5b3UgY2FuIHNldCBgaW5uZXJSYWRpdXNgIHRvIGFcbiAqIHZhbHVlID4gMC4gRmluYWxseSwgYHN0YWNrUG93ZXJgIGFsbG93cyB5b3UgdG8gaGF2ZSB0aGUgd2lkdGhzXG4gKiBpbmNyZWFzZSBvciBkZWNyZWFzZSBhcyB5b3UgbW92ZSBhd2F5IGZyb20gdGhlIGNlbnRlci4gVGhpc1xuICogaXMgcGFydGljdWxhcmx5IHVzZWZ1bCB3aGVuIHVzaW5nIHRoZSBkaXNjIGFzIGEgZ3JvdW5kIHBsYW5lXG4gKiB3aXRoIGEgZml4ZWQgY2FtZXJhIHN1Y2ggdGhhdCB5b3UgZG9uJ3QgbmVlZCB0aGUgcmVzb2x1dGlvblxuICogb2Ygc21hbGwgdHJpYW5nbGVzIG5lYXIgdGhlIHBlcmltZXRlci4gRm9yIGV4YW1wbGUsIGEgdmFsdWVcbiAqIG9mIDIgd2lsbCBwcm9kdWNlIHN0YWNrcyB3aG9zZSBvdXRzaWRlIHJhZGl1cyBpbmNyZWFzZXMgd2l0aFxuICogdGhlIHNxdWFyZSBvZiB0aGUgc3RhY2sgaW5kZXguIEEgdmFsdWUgb2YgMSB3aWxsIGdpdmUgdW5pZm9ybVxuICogc3RhY2tzLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgdGhlIGdyb3VuZCBwbGFuZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpc2lvbnMgTnVtYmVyIG9mIHRyaWFuZ2xlcyBpbiB0aGUgZ3JvdW5kIHBsYW5lIChhdCBsZWFzdCAzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhY2tzXSBOdW1iZXIgb2YgcmFkaWFsIGRpdmlzaW9ucyAoZGVmYXVsdD0xKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5uZXJSYWRpdXNdIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhY2tQb3dlcl0gUG93ZXIgdG8gcmFpc2Ugc3RhY2sgc2l6ZSB0byBmb3IgZGVjcmVhc2luZyB3aWR0aC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZURpc2NCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGRpc2MgYnVmZmVycy4gVGhlIGRpc2Mgd2lsbCBiZSBpbiB0aGUgeHogcGxhbmUsIGNlbnRlcmVkIGF0XG4gKiB0aGUgb3JpZ2luLiBXaGVuIGNyZWF0aW5nLCBhdCBsZWFzdCAzIGRpdmlzaW9ucywgb3IgcGllXG4gKiBwaWVjZXMsIG5lZWQgdG8gYmUgc3BlY2lmaWVkLCBvdGhlcndpc2UgdGhlIHRyaWFuZ2xlcyBtYWtpbmdcbiAqIHVwIHRoZSBkaXNjIHdpbGwgYmUgZGVnZW5lcmF0ZS4gWW91IGNhbiBhbHNvIHNwZWNpZnkgdGhlXG4gKiBudW1iZXIgb2YgcmFkaWFsIHBpZWNlcyBgc3RhY2tzYC4gQSB2YWx1ZSBvZiAxIGZvclxuICogc3RhY2tzIHdpbGwgZ2l2ZSB5b3UgYSBzaW1wbGUgZGlzYyBvZiBwaWUgcGllY2VzLiAgSWYgeW91XG4gKiB3YW50IHRvIGNyZWF0ZSBhbiBhbm51bHVzIHlvdSBjYW4gc2V0IGBpbm5lclJhZGl1c2AgdG8gYVxuICogdmFsdWUgPiAwLiBGaW5hbGx5LCBgc3RhY2tQb3dlcmAgYWxsb3dzIHlvdSB0byBoYXZlIHRoZSB3aWR0aHNcbiAqIGluY3JlYXNlIG9yIGRlY3JlYXNlIGFzIHlvdSBtb3ZlIGF3YXkgZnJvbSB0aGUgY2VudGVyLiBUaGlzXG4gKiBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gdXNpbmcgdGhlIGRpc2MgYXMgYSBncm91bmQgcGxhbmVcbiAqIHdpdGggYSBmaXhlZCBjYW1lcmEgc3VjaCB0aGF0IHlvdSBkb24ndCBuZWVkIHRoZSByZXNvbHV0aW9uXG4gKiBvZiBzbWFsbCB0cmlhbmdsZXMgbmVhciB0aGUgcGVyaW1ldGVyLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZVxuICogb2YgMiB3aWxsIHByb2R1Y2Ugc3RhY2tzIHdob3NlIG91dHNpZGUgcmFkaXVzIGluY3JlYXNlcyB3aXRoXG4gKiB0aGUgc3F1YXJlIG9mIHRoZSBzdGFjayBpbmRleC4gQSB2YWx1ZSBvZiAxIHdpbGwgZ2l2ZSB1bmlmb3JtXG4gKiBzdGFja3MuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgZ3JvdW5kIHBsYW5lLlxuICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzaW9ucyBOdW1iZXIgb2YgdHJpYW5nbGVzIGluIHRoZSBncm91bmQgcGxhbmUgKGF0IGxlYXN0IDMpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja3NdIE51bWJlciBvZiByYWRpYWwgZGl2aXNpb25zIChkZWZhdWx0PTEpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtpbm5lclJhZGl1c10gRGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja1Bvd2VyXSBQb3dlciB0byByYWlzZSBzdGFjayBzaXplIHRvIGZvciBkZWNyZWFzaW5nIHdpZHRoLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFdlYkdMQnVmZmVyPn0gVGhlIGNyZWF0ZWQgYnVmZmVycy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlRGlzY0J1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgZGlzYyB2ZXJ0aWNlcy4gVGhlIGRpc2Mgd2lsbCBiZSBpbiB0aGUgeHogcGxhbmUsIGNlbnRlcmVkIGF0XG4gKiB0aGUgb3JpZ2luLiBXaGVuIGNyZWF0aW5nLCBhdCBsZWFzdCAzIGRpdmlzaW9ucywgb3IgcGllXG4gKiBwaWVjZXMsIG5lZWQgdG8gYmUgc3BlY2lmaWVkLCBvdGhlcndpc2UgdGhlIHRyaWFuZ2xlcyBtYWtpbmdcbiAqIHVwIHRoZSBkaXNjIHdpbGwgYmUgZGVnZW5lcmF0ZS4gWW91IGNhbiBhbHNvIHNwZWNpZnkgdGhlXG4gKiBudW1iZXIgb2YgcmFkaWFsIHBpZWNlcyBgc3RhY2tzYC4gQSB2YWx1ZSBvZiAxIGZvclxuICogc3RhY2tzIHdpbGwgZ2l2ZSB5b3UgYSBzaW1wbGUgZGlzYyBvZiBwaWUgcGllY2VzLiAgSWYgeW91XG4gKiB3YW50IHRvIGNyZWF0ZSBhbiBhbm51bHVzIHlvdSBjYW4gc2V0IGBpbm5lclJhZGl1c2AgdG8gYVxuICogdmFsdWUgPiAwLiBGaW5hbGx5LCBgc3RhY2tQb3dlcmAgYWxsb3dzIHlvdSB0byBoYXZlIHRoZSB3aWR0aHNcbiAqIGluY3JlYXNlIG9yIGRlY3JlYXNlIGFzIHlvdSBtb3ZlIGF3YXkgZnJvbSB0aGUgY2VudGVyLiBUaGlzXG4gKiBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gdXNpbmcgdGhlIGRpc2MgYXMgYSBncm91bmQgcGxhbmVcbiAqIHdpdGggYSBmaXhlZCBjYW1lcmEgc3VjaCB0aGF0IHlvdSBkb24ndCBuZWVkIHRoZSByZXNvbHV0aW9uXG4gKiBvZiBzbWFsbCB0cmlhbmdsZXMgbmVhciB0aGUgcGVyaW1ldGVyLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZVxuICogb2YgMiB3aWxsIHByb2R1Y2Ugc3RhY2tzIHdob3NlIG91dHNpZGUgcmFkaXVzIGluY3JlYXNlcyB3aXRoXG4gKiB0aGUgc3F1YXJlIG9mIHRoZSBzdGFjayBpbmRleC4gQSB2YWx1ZSBvZiAxIHdpbGwgZ2l2ZSB1bmlmb3JtXG4gKiBzdGFja3MuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgdGhlIGdyb3VuZCBwbGFuZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpc2lvbnMgTnVtYmVyIG9mIHRyaWFuZ2xlcyBpbiB0aGUgZ3JvdW5kIHBsYW5lIChhdCBsZWFzdCAzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhY2tzXSBOdW1iZXIgb2YgcmFkaWFsIGRpdmlzaW9ucyAoZGVmYXVsdD0xKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5uZXJSYWRpdXNdIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhY2tQb3dlcl0gUG93ZXIgdG8gcmFpc2Ugc3RhY2sgc2l6ZSB0byBmb3IgZGVjcmVhc2luZyB3aWR0aC5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRGlzY1ZlcnRpY2VzKHJhZGl1cywgZGl2aXNpb25zLCBzdGFja3MsIGlubmVyUmFkaXVzLCBzdGFja1Bvd2VyKSB7XG4gIGlmIChkaXZpc2lvbnMgPCAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaXZpc2lvbnMgbXVzdCBiZSBhdCBsZWFzdCAzJyk7XG4gIH1cblxuICBzdGFja3MgPSBzdGFja3MgPyBzdGFja3MgOiAxO1xuICBzdGFja1Bvd2VyID0gc3RhY2tQb3dlciA/IHN0YWNrUG93ZXIgOiAxO1xuICBpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzID8gaW5uZXJSYWRpdXMgOiAwOyAvLyBOb3RlOiBXZSBkb24ndCBzaGFyZSB0aGUgY2VudGVyIHZlcnRleCBiZWNhdXNlIHRoYXQgd291bGRcbiAgLy8gbWVzcyB1cCB0ZXh0dXJlIGNvb3JkaW5hdGVzLlxuXG4gIHZhciBudW1WZXJ0aWNlcyA9IChkaXZpc2lvbnMgKyAxKSAqIChzdGFja3MgKyAxKTtcbiAgdmFyIHBvc2l0aW9ucyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICB2YXIgbm9ybWFscyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICB2YXIgdGV4Y29vcmRzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyLCBudW1WZXJ0aWNlcyk7XG4gIHZhciBpbmRpY2VzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBzdGFja3MgKiBkaXZpc2lvbnMgKiAyLCBVaW50MTZBcnJheSk7XG4gIHZhciBmaXJzdEluZGV4ID0gMDtcbiAgdmFyIHJhZGl1c1NwYW4gPSByYWRpdXMgLSBpbm5lclJhZGl1cztcbiAgdmFyIHBvaW50c1BlclN0YWNrID0gZGl2aXNpb25zICsgMTsgLy8gQnVpbGQgdGhlIGRpc2sgb25lIHN0YWNrIGF0IGEgdGltZS5cblxuICBmb3IgKHZhciBzdGFjayA9IDA7IHN0YWNrIDw9IHN0YWNrczsgKytzdGFjaykge1xuICAgIHZhciBzdGFja1JhZGl1cyA9IGlubmVyUmFkaXVzICsgcmFkaXVzU3BhbiAqIE1hdGgucG93KHN0YWNrIC8gc3RhY2tzLCBzdGFja1Bvd2VyKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGRpdmlzaW9uczsgKytpKSB7XG4gICAgICB2YXIgdGhldGEgPSAyLjAgKiBNYXRoLlBJICogaSAvIGRpdmlzaW9ucztcbiAgICAgIHZhciB4ID0gc3RhY2tSYWRpdXMgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICB2YXIgeiA9IHN0YWNrUmFkaXVzICogTWF0aC5zaW4odGhldGEpO1xuICAgICAgcG9zaXRpb25zLnB1c2goeCwgMCwgeik7XG4gICAgICBub3JtYWxzLnB1c2goMCwgMSwgMCk7XG4gICAgICB0ZXhjb29yZHMucHVzaCgxIC0gaSAvIGRpdmlzaW9ucywgc3RhY2sgLyBzdGFja3MpO1xuXG4gICAgICBpZiAoc3RhY2sgPiAwICYmIGkgIT09IGRpdmlzaW9ucykge1xuICAgICAgICAvLyBhLCBiLCBjIGFuZCBkIGFyZSB0aGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXMgb2YgYSBxdWFkLiAgdW5sZXNzXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHN0YWNrIGlzIHRoZSBvbmUgY2xvc2VzdCB0byB0aGUgY2VudGVyLCBpbiB3aGljaCBjYXNlXG4gICAgICAgIC8vIHRoZSB2ZXJ0aWNlcyBhIGFuZCBiIGNvbm5lY3QgdG8gdGhlIGNlbnRlciB2ZXJ0ZXguXG4gICAgICAgIHZhciBhID0gZmlyc3RJbmRleCArIChpICsgMSk7XG4gICAgICAgIHZhciBiID0gZmlyc3RJbmRleCArIGk7XG4gICAgICAgIHZhciBjID0gZmlyc3RJbmRleCArIGkgLSBwb2ludHNQZXJTdGFjaztcbiAgICAgICAgdmFyIGQgPSBmaXJzdEluZGV4ICsgKGkgKyAxKSAtIHBvaW50c1BlclN0YWNrOyAvLyBNYWtlIGEgcXVhZCBvZiB0aGUgdmVydGljZXMgYSwgYiwgYywgZC5cblxuICAgICAgICBpbmRpY2VzLnB1c2goYSwgYiwgYyk7XG4gICAgICAgIGluZGljZXMucHVzaChhLCBjLCBkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaXJzdEluZGV4ICs9IGRpdmlzaW9ucyArIDE7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbnMsXG4gICAgbm9ybWFsOiBub3JtYWxzLFxuICAgIHRleGNvb3JkOiB0ZXhjb29yZHMsXG4gICAgaW5kaWNlczogaW5kaWNlc1xuICB9O1xufVxuLyoqXG4gKiBjcmVhdGVzIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiAwIGFuZCByYW5nZSAtIDEgaW5jbHVzaXZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHJhbmRvbSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIHJhbmdlIC0gMSBpbmNsdXNpdmUuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gcmFuZEludChyYW5nZSkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIHJhbmdlIHwgMDtcbn1cbi8qKlxuICogVXNlZCB0byBzdXBwbHkgcmFuZG9tIGNvbG9yc1xuICogQGNhbGxiYWNrIFJhbmRvbUNvbG9yRnVuY1xuICogQHBhcmFtIHtudW1iZXJ9IG5keCBpbmRleCBvZiB0cmlhbmdsZS9xdWFkIGlmIHVuaW5kZXhlZCBvciBpbmRleCBvZiB2ZXJ0ZXggaWYgaW5kZXhlZFxuICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWwgMCA9IHJlZCwgMSA9IGdyZWVuLCAyID0gYmx1ZSwgMyA9IGFscGhhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEgbnVtYmVyIGZyb20gMCB0byAyNTVcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSYW5kb21WZXJ0aWNlc09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmVydHNQZXJDb2xvcl0gRGVmYXVsdHMgdG8gMyBmb3Igbm9uLWluZGV4ZWQgdmVydGljZXNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnR3Z2wvcHJpbWl0aXZlcy5SYW5kb21Db2xvckZ1bmN9IFtyYW5kXSBBIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHJhbmRvbSBudW1iZXJzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhdWdtZW50ZWRUeXBlZEFycmF5IG9mIHJhbmRvbSB2ZXJ0ZXggY29sb3JzLlxuICogSWYgdGhlIHZlcnRpY2VzIGFyZSBpbmRleGVkIChoYXZlIGFuIGluZGljZXMgYXJyYXkpIHRoZW4gd2lsbFxuICoganVzdCBtYWtlIHJhbmRvbSBjb2xvcnMuIE90aGVyd2lzZSBhc3N1bWVzIHRoZXkgYXJlIHRyaWFuZ2xlc1xuICogYW5kIG1ha2VzIG9uZSByYW5kb20gY29sb3IgZm9yIGV2ZXJ5IDMgdmVydGljZXMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBBdWdtZW50ZWRUeXBlZEFycmF5Pn0gdmVydGljZXMgVmVydGljZXMgYXMgcmV0dXJuZWQgZnJvbSBvbmUgb2YgdGhlIGNyZWF0ZVhYWFZlcnRpY2VzIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvcHJpbWl0aXZlcy5SYW5kb21WZXJ0aWNlc09wdGlvbnN9IFtvcHRpb25zXSBvcHRpb25zLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIEF1Z21lbnRlZFR5cGVkQXJyYXk+fSBzYW1lIHZlcnRpY2VzIGFzIHBhc3NlZCBpbiB3aXRoIGBjb2xvcmAgYWRkZWQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gbWFrZVJhbmRvbVZlcnRleENvbG9ycyh2ZXJ0aWNlcywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG51bUVsZW1lbnRzID0gdmVydGljZXMucG9zaXRpb24ubnVtRWxlbWVudHM7XG4gIHZhciB2Q29sb3JzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSg0LCBudW1FbGVtZW50cywgVWludDhBcnJheSk7XG5cbiAgdmFyIHJhbmQgPSBvcHRpb25zLnJhbmQgfHwgZnVuY3Rpb24gKG5keCwgY2hhbm5lbCkge1xuICAgIHJldHVybiBjaGFubmVsIDwgMyA/IHJhbmRJbnQoMjU2KSA6IDI1NTtcbiAgfTtcblxuICB2ZXJ0aWNlcy5jb2xvciA9IHZDb2xvcnM7XG5cbiAgaWYgKHZlcnRpY2VzLmluZGljZXMpIHtcbiAgICAvLyBqdXN0IG1ha2UgcmFuZG9tIGNvbG9ycyBpZiBpbmRleFxuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1FbGVtZW50czsgKytpaSkge1xuICAgICAgdkNvbG9ycy5wdXNoKHJhbmQoaWksIDApLCByYW5kKGlpLCAxKSwgcmFuZChpaSwgMiksIHJhbmQoaWksIDMpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFrZSByYW5kb20gY29sb3JzIHBlciB0cmlhbmdsZVxuICAgIHZhciBudW1WZXJ0c1BlckNvbG9yID0gb3B0aW9ucy52ZXJ0c1BlckNvbG9yIHx8IDM7XG4gICAgdmFyIG51bVNldHMgPSBudW1FbGVtZW50cyAvIG51bVZlcnRzUGVyQ29sb3I7XG5cbiAgICBmb3IgKHZhciBfaWkyID0gMDsgX2lpMiA8IG51bVNldHM7ICsrX2lpMikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgdmFyIGNvbG9yID0gW3JhbmQoX2lpMiwgMCksIHJhbmQoX2lpMiwgMSksIHJhbmQoX2lpMiwgMiksIHJhbmQoX2lpMiwgMyldO1xuXG4gICAgICBmb3IgKHZhciBqaiA9IDA7IGpqIDwgbnVtVmVydHNQZXJDb2xvcjsgKytqaikge1xuICAgICAgICB2Q29sb3JzLnB1c2goY29sb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2ZXJ0aWNlcztcbn1cbi8qKlxuICogY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgZm4gdG8gY3JlYXRlIHZlcnRpY2VzIGFuZCB0aGVuXG4gKiBjcmVhdGVzIGEgYnVmZmVycyBmb3IgdGhlbVxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlckZ1bmMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChnbCkge1xuICAgIHZhciBhcnJheXMgPSBmbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICByZXR1cm4gYXR0cmlidXRlcy5jcmVhdGVCdWZmZXJzRnJvbUFycmF5cyhnbCwgYXJyYXlzKTtcbiAgfTtcbn1cbi8qKlxuICogY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgZm4gdG8gY3JlYXRlIHZlcnRpY2VzIGFuZCB0aGVuXG4gKiBjcmVhdGVzIGEgYnVmZmVySW5mbyBvYmplY3QgZm9yIHRoZW1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXJJbmZvRnVuYyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGdsKSB7XG4gICAgdmFyIGFycmF5cyA9IGZuLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHJldHVybiBhdHRyaWJ1dGVzLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzKGdsLCBhcnJheXMpO1xuICB9O1xufVxuXG52YXIgYXJyYXlTcGVjUHJvcGVydHlOYW1lcyA9IFtcIm51bUNvbXBvbmVudHNcIiwgXCJzaXplXCIsIFwidHlwZVwiLCBcIm5vcm1hbGl6ZVwiLCBcInN0cmlkZVwiLCBcIm9mZnNldFwiLCBcImF0dHJpYlwiLCBcIm5hbWVcIiwgXCJhdHRyaWJOYW1lXCJdO1xuLyoqXG4gKiBDb3B5IGVsZW1lbnRzIGZyb20gb25lIGFycmF5IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IHNyYyBzb3VyY2UgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl8VHlwZWRBcnJheX0gZHN0IGRlc3QgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkc3ROZHggaW5kZXggaW4gZGVzdCB0byBjb3B5IHNyY1xuICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRdIG9mZnNldCB0byBhZGQgdG8gY29waWVkIHZhbHVlc1xuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb3B5RWxlbWVudHMoc3JjLCBkc3QsIGRzdE5keCwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgbGVuZ3RoID0gc3JjLmxlbmd0aDtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuZ3RoOyArK2lpKSB7XG4gICAgZHN0W2RzdE5keCArIGlpXSA9IHNyY1tpaV0gKyBvZmZzZXQ7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgc2FtZSB0aW1lXG4gKlxuICogQHBhcmFtIHsobnVtYmVyW118QXJyYXlCdWZmZXJWaWV3fG1vZHVsZTp0d2dsLkZ1bGxBcnJheVNwZWMpfSBzcmNBcnJheSBhcnJheSB3aG8ncyB0eXBlIHRvIGNvcHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggc2l6ZSBvZiBuZXcgYXJyYXlcbiAqIEByZXR1cm4geyhudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd8bW9kdWxlOnR3Z2wuRnVsbEFycmF5U3BlYyl9IGFycmF5IHdpdGggc2FtZSB0eXBlIGFzIHNyY0FycmF5XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlNhbWVUeXBlKHNyY0FycmF5LCBsZW5ndGgpIHtcbiAgdmFyIGFycmF5U3JjID0gZ2V0QXJyYXkoc3JjQXJyYXkpO1xuICB2YXIgbmV3QXJyYXkgPSBuZXcgYXJyYXlTcmMuY29uc3RydWN0b3IobGVuZ3RoKTtcbiAgdmFyIG5ld0FycmF5U3BlYyA9IG5ld0FycmF5OyAvLyBJZiBpdCBhcHBlYXJzIHRvIGhhdmUgYmVlbiBhdWdtZW50ZWQgbWFrZSBuZXcgb25lIGF1Z21lbnRlZFxuXG4gIGlmIChhcnJheVNyYy5udW1Db21wb25lbnRzICYmIGFycmF5U3JjLm51bUVsZW1lbnRzKSB7XG4gICAgYXVnbWVudFR5cGVkQXJyYXkobmV3QXJyYXksIGFycmF5U3JjLm51bUNvbXBvbmVudHMpO1xuICB9IC8vIElmIGl0IHdhcyBhIGZ1bGwgc3BlYyBtYWtlIG5ldyBvbmUgYSBmdWxsIHNwZWNcblxuXG4gIGlmIChzcmNBcnJheS5kYXRhKSB7XG4gICAgbmV3QXJyYXlTcGVjID0ge1xuICAgICAgZGF0YTogbmV3QXJyYXlcbiAgICB9O1xuICAgIGhlbHBlci5jb3B5TmFtZWRQcm9wZXJ0aWVzKGFycmF5U3BlY1Byb3BlcnR5TmFtZXMsIHNyY0FycmF5LCBuZXdBcnJheVNwZWMpO1xuICB9XG5cbiAgcmV0dXJuIG5ld0FycmF5U3BlYztcbn1cbi8qKlxuICogQ29uY2F0ZW5hdGVzIHNldHMgb2YgdmVydGljZXNcbiAqXG4gKiBBc3N1bWVzIHRoZSB2ZXJ0aWNlcyBtYXRjaCBpbiBjb21wb3NpdGlvbi4gRm9yIGV4YW1wbGVcbiAqIGlmIG9uZSBzZXQgb2YgdmVydGljZXMgaGFzIHBvc2l0aW9ucywgbm9ybWFscywgYW5kIGluZGljZXNcbiAqIGFsbCBzZXRzIG9mIHZlcnRpY2VzIG11c3QgaGF2ZSBwb3NpdGlvbnMsIG5vcm1hbHMsIGFuZCBpbmRpY2VzXG4gKiBhbmQgb2YgdGhlIHNhbWUgdHlwZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgY29uc3QgY3ViZVZlcnRpY2VzID0gdHdnbC5wcmltaXRpdmVzLmNyZWF0ZUN1YmVWZXJ0aWNlcygyKTtcbiAqICAgICAgY29uc3Qgc3BoZXJlVmVydGljZXMgPSB0d2dsLnByaW1pdGl2ZXMuY3JlYXRlU3BoZXJlVmVydGljZXMoMSwgMTAsIDEwKTtcbiAqICAgICAgLy8gbW92ZSB0aGUgc3BoZXJlIDIgdW5pdHMgdXBcbiAqICAgICAgdHdnbC5wcmltaXRpdmVzLnJlb3JpZW50VmVydGljZXMoXG4gKiAgICAgICAgICBzcGhlcmVWZXJ0aWNlcywgdHdnbC5tNC50cmFuc2xhdGlvbihbMCwgMiwgMF0pKTtcbiAqICAgICAgLy8gbWVyZ2UgdGhlIHNwaGVyZSB3aXRoIHRoZSBjdWJlXG4gKiAgICAgIGNvbnN0IGN1YmVTcGhlcmVWZXJ0aWNlcyA9IHR3Z2wucHJpbWl0aXZlcy5jb25jYXRWZXJ0aWNlcyhcbiAqICAgICAgICAgIFtjdWJlVmVydGljZXMsIHNwaGVyZVZlcnRpY2VzXSk7XG4gKiAgICAgIC8vIHR1cm4gdGhlbSBpbnRvIFdlYkdMIGJ1ZmZlcnMgYW5kIGF0dHJpYiBkYXRhXG4gKiAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzKGdsLCBjdWJlU3BoZXJlVmVydGljZXMpO1xuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQXJyYXlzW119IGFycmF5cyBBcnJheSBvZiBhcnJheXMgb2YgdmVydGljZXNcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkFycmF5c30gVGhlIGNvbmNhdGVuYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuXG5mdW5jdGlvbiBjb25jYXRWZXJ0aWNlcyhhcnJheU9mQXJyYXlzKSB7XG4gIHZhciBuYW1lcyA9IHt9O1xuICB2YXIgYmFzZU5hbWU7IC8vIGdldCBuYW1lcyBvZiBhbGwgYXJyYXlzLlxuICAvLyBhbmQgbnVtRWxlbWVudHMgZm9yIGVhY2ggc2V0IG9mIHZlcnRpY2VzXG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaWkpIHtcbiAgICB2YXIgYXJyYXlzID0gYXJyYXlPZkFycmF5c1tpaV07XG4gICAgT2JqZWN0LmtleXMoYXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpZiAoIW5hbWVzW25hbWVdKSB7XG4gICAgICAgIG5hbWVzW25hbWVdID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICghYmFzZU5hbWUgJiYgbmFtZSAhPT0gJ2luZGljZXMnKSB7XG4gICAgICAgIGJhc2VOYW1lID0gbmFtZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFycmF5SW5mbyA9IGFycmF5c1tuYW1lXTtcbiAgICAgIHZhciBudW1Db21wb25lbnRzID0gZ2V0TnVtQ29tcG9uZW50cyhhcnJheUluZm8sIG5hbWUpO1xuICAgICAgdmFyIGFycmF5ID0gZ2V0QXJyYXkoYXJyYXlJbmZvKTtcbiAgICAgIHZhciBudW1FbGVtZW50cyA9IGFycmF5Lmxlbmd0aCAvIG51bUNvbXBvbmVudHM7XG4gICAgICBuYW1lc1tuYW1lXS5wdXNoKG51bUVsZW1lbnRzKTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgYXJyYXlPZkFycmF5cy5sZW5ndGg7ICsraWkpIHtcbiAgICBfbG9vcChpaSk7XG4gIH0gLy8gY29tcHV0ZSBsZW5ndGggb2YgY29tYmluZWQgYXJyYXlcbiAgLy8gYW5kIHJldHVybiBvbmUgZm9yIHJlZmVyZW5jZVxuXG5cbiAgZnVuY3Rpb24gZ2V0TGVuZ3RoT2ZDb21iaW5lZEFycmF5cyhuYW1lKSB7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgdmFyIGFycmF5U3BlYztcblxuICAgIGZvciAodmFyIF9paTMgPSAwOyBfaWkzIDwgYXJyYXlPZkFycmF5cy5sZW5ndGg7ICsrX2lpMykge1xuICAgICAgdmFyIGFycmF5cyA9IGFycmF5T2ZBcnJheXNbX2lpM107XG4gICAgICB2YXIgYXJyYXlJbmZvID0gYXJyYXlzW25hbWVdO1xuICAgICAgdmFyIGFycmF5ID0gZ2V0QXJyYXkoYXJyYXlJbmZvKTtcbiAgICAgIGxlbmd0aCArPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmICghYXJyYXlTcGVjIHx8IGFycmF5SW5mby5kYXRhKSB7XG4gICAgICAgIGFycmF5U3BlYyA9IGFycmF5SW5mbztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICBzcGVjOiBhcnJheVNwZWNcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29weUFycmF5c1RvTmV3QXJyYXkobmFtZSwgYmFzZSwgbmV3QXJyYXkpIHtcbiAgICB2YXIgYmFzZUluZGV4ID0gMDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGZvciAodmFyIF9paTQgPSAwOyBfaWk0IDwgYXJyYXlPZkFycmF5cy5sZW5ndGg7ICsrX2lpNCkge1xuICAgICAgdmFyIGFycmF5cyA9IGFycmF5T2ZBcnJheXNbX2lpNF07XG4gICAgICB2YXIgYXJyYXlJbmZvID0gYXJyYXlzW25hbWVdO1xuICAgICAgdmFyIGFycmF5ID0gZ2V0QXJyYXkoYXJyYXlJbmZvKTtcblxuICAgICAgaWYgKG5hbWUgPT09ICdpbmRpY2VzJykge1xuICAgICAgICBjb3B5RWxlbWVudHMoYXJyYXksIG5ld0FycmF5LCBvZmZzZXQsIGJhc2VJbmRleCk7XG4gICAgICAgIGJhc2VJbmRleCArPSBiYXNlW19paTRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weUVsZW1lbnRzKGFycmF5LCBuZXdBcnJheSwgb2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0ICs9IGFycmF5Lmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9IG5hbWVzW2Jhc2VOYW1lXTtcbiAgdmFyIG5ld0FycmF5cyA9IHt9O1xuICBPYmplY3Qua2V5cyhuYW1lcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpbmZvID0gZ2V0TGVuZ3RoT2ZDb21iaW5lZEFycmF5cyhuYW1lKTtcbiAgICB2YXIgbmV3QXJyYXlTcGVjID0gY3JlYXRlQXJyYXlPZlNhbWVUeXBlKGluZm8uc3BlYywgaW5mby5sZW5ndGgpO1xuICAgIGNvcHlBcnJheXNUb05ld0FycmF5KG5hbWUsIGJhc2UsIGdldEFycmF5KG5ld0FycmF5U3BlYykpO1xuICAgIG5ld0FycmF5c1tuYW1lXSA9IG5ld0FycmF5U3BlYztcbiAgfSk7XG4gIHJldHVybiBuZXdBcnJheXM7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBkdXBsaWNhdGUgc2V0IG9mIHZlcnRpY2VzXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNhbGxpbmcgcmVvcmllbnRWZXJ0aWNlcyB3aGVuIHlvdVxuICogYWxzbyB3YW50IHRvIGtlZXAgdGhlIG9yaWdpbmFsIGF2YWlsYWJsZVxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQXJyYXlzfSBhcnJheXMgb2YgdmVydGljZXNcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkFycmF5c30gVGhlIGR1cGxpY2F0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gZHVwbGljYXRlVmVydGljZXMoYXJyYXlzKSB7XG4gIHZhciBuZXdBcnJheXMgPSB7fTtcbiAgT2JqZWN0LmtleXMoYXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGFycmF5U3BlYyA9IGFycmF5c1tuYW1lXTtcbiAgICB2YXIgc3JjQXJyYXkgPSBnZXRBcnJheShhcnJheVNwZWMpO1xuICAgIHZhciBuZXdBcnJheVNwZWMgPSBjcmVhdGVBcnJheU9mU2FtZVR5cGUoYXJyYXlTcGVjLCBzcmNBcnJheS5sZW5ndGgpO1xuICAgIGNvcHlFbGVtZW50cyhzcmNBcnJheSwgZ2V0QXJyYXkobmV3QXJyYXlTcGVjKSwgMCk7XG4gICAgbmV3QXJyYXlzW25hbWVdID0gbmV3QXJyYXlTcGVjO1xuICB9KTtcbiAgcmV0dXJuIG5ld0FycmF5cztcbn1cblxudmFyIGNyZWF0ZTNERkJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGUzREZWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZTNERkJ1ZmZlckluZm8gPSBjcmVhdGUzREZCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZTNERkJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZTNERlZlcnRpY2VzKTtcbmV4cG9ydHMuY3JlYXRlM0RGQnVmZmVycyA9IGNyZWF0ZTNERkJ1ZmZlcnM7XG52YXIgY3JlYXRlQ3ViZUJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVDdWJlVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVDdWJlQnVmZmVySW5mbyA9IGNyZWF0ZUN1YmVCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZUN1YmVCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVDdWJlVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVDdWJlQnVmZmVycyA9IGNyZWF0ZUN1YmVCdWZmZXJzO1xudmFyIGNyZWF0ZVBsYW5lQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZVBsYW5lVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVQbGFuZUJ1ZmZlckluZm8gPSBjcmVhdGVQbGFuZUJ1ZmZlckluZm87XG52YXIgY3JlYXRlUGxhbmVCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVQbGFuZVZlcnRpY2VzKTtcbmV4cG9ydHMuY3JlYXRlUGxhbmVCdWZmZXJzID0gY3JlYXRlUGxhbmVCdWZmZXJzO1xudmFyIGNyZWF0ZVNwaGVyZUJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVTcGhlcmVWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZVNwaGVyZUJ1ZmZlckluZm8gPSBjcmVhdGVTcGhlcmVCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZVNwaGVyZUJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZVNwaGVyZVZlcnRpY2VzKTtcbmV4cG9ydHMuY3JlYXRlU3BoZXJlQnVmZmVycyA9IGNyZWF0ZVNwaGVyZUJ1ZmZlcnM7XG52YXIgY3JlYXRlVHJ1bmNhdGVkQ29uZUJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVUcnVuY2F0ZWRDb25lVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVySW5mbyA9IGNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVUcnVuY2F0ZWRDb25lVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVycyA9IGNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJzO1xudmFyIGNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVYWVF1YWRWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8gPSBjcmVhdGVYWVF1YWRCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZVhZUXVhZEJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZVhZUXVhZFZlcnRpY2VzKTtcbmV4cG9ydHMuY3JlYXRlWFlRdWFkQnVmZmVycyA9IGNyZWF0ZVhZUXVhZEJ1ZmZlcnM7XG52YXIgY3JlYXRlQ3Jlc2NlbnRCdWZmZXJJbmZvID0gY3JlYXRlQnVmZmVySW5mb0Z1bmMoY3JlYXRlQ3Jlc2NlbnRWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZUNyZXNjZW50QnVmZmVySW5mbyA9IGNyZWF0ZUNyZXNjZW50QnVmZmVySW5mbztcbnZhciBjcmVhdGVDcmVzY2VudEJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZUNyZXNjZW50VmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVDcmVzY2VudEJ1ZmZlcnMgPSBjcmVhdGVDcmVzY2VudEJ1ZmZlcnM7XG52YXIgY3JlYXRlQ3lsaW5kZXJCdWZmZXJJbmZvID0gY3JlYXRlQnVmZmVySW5mb0Z1bmMoY3JlYXRlQ3lsaW5kZXJWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZUN5bGluZGVyQnVmZmVySW5mbyA9IGNyZWF0ZUN5bGluZGVyQnVmZmVySW5mbztcbnZhciBjcmVhdGVDeWxpbmRlckJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZUN5bGluZGVyVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVDeWxpbmRlckJ1ZmZlcnMgPSBjcmVhdGVDeWxpbmRlckJ1ZmZlcnM7XG52YXIgY3JlYXRlVG9ydXNCdWZmZXJJbmZvID0gY3JlYXRlQnVmZmVySW5mb0Z1bmMoY3JlYXRlVG9ydXNWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZVRvcnVzQnVmZmVySW5mbyA9IGNyZWF0ZVRvcnVzQnVmZmVySW5mbztcbnZhciBjcmVhdGVUb3J1c0J1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZVRvcnVzVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVUb3J1c0J1ZmZlcnMgPSBjcmVhdGVUb3J1c0J1ZmZlcnM7XG52YXIgY3JlYXRlRGlzY0J1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVEaXNjVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVEaXNjQnVmZmVySW5mbyA9IGNyZWF0ZURpc2NCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZURpc2NCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVEaXNjVmVydGljZXMpOyAvLyB0aGVzZSB3ZXJlIG1pcy1zcGVsbGVkIHVudGlsIDQuMTJcblxuZXhwb3J0cy5jcmVhdGVEaXNjQnVmZmVycyA9IGNyZWF0ZURpc2NCdWZmZXJzO1xudmFyIGNyZWF0ZUNyZXNlbnRCdWZmZXJJbmZvID0gY3JlYXRlQ3Jlc2NlbnRCdWZmZXJJbmZvO1xuZXhwb3J0cy5jcmVhdGVDcmVzZW50QnVmZmVySW5mbyA9IGNyZWF0ZUNyZXNlbnRCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZUNyZXNlbnRCdWZmZXJzID0gY3JlYXRlQ3Jlc2NlbnRCdWZmZXJzO1xuZXhwb3J0cy5jcmVhdGVDcmVzZW50QnVmZmVycyA9IGNyZWF0ZUNyZXNlbnRCdWZmZXJzO1xudmFyIGNyZWF0ZUNyZXNlbnRWZXJ0aWNlcyA9IGNyZWF0ZUNyZXNjZW50VmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZUNyZXNlbnRWZXJ0aWNlcyA9IGNyZWF0ZUNyZXNlbnRWZXJ0aWNlcztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcHJvZ3JhbXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcHJvZ3JhbXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jcmVhdGVBdHRyaWJ1dGVTZXR0ZXJzID0gY3JlYXRlQXR0cmlidXRlU2V0dGVycztcbmV4cG9ydHMuY3JlYXRlUHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW07XG5leHBvcnRzLmNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyA9IGNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cztcbmV4cG9ydHMuY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2VzID0gY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2VzO1xuZXhwb3J0cy5jcmVhdGVQcm9ncmFtSW5mbyA9IGNyZWF0ZVByb2dyYW1JbmZvO1xuZXhwb3J0cy5jcmVhdGVQcm9ncmFtSW5mb0Zyb21Qcm9ncmFtID0gY3JlYXRlUHJvZ3JhbUluZm9Gcm9tUHJvZ3JhbTtcbmV4cG9ydHMuY3JlYXRlVW5pZm9ybVNldHRlcnMgPSBjcmVhdGVVbmlmb3JtU2V0dGVycztcbmV4cG9ydHMuY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtID0gY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtO1xuZXhwb3J0cy5jcmVhdGVVbmlmb3JtQmxvY2tJbmZvRnJvbVByb2dyYW0gPSBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvRnJvbVByb2dyYW07XG5leHBvcnRzLmNyZWF0ZVVuaWZvcm1CbG9ja0luZm8gPSBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvO1xuZXhwb3J0cy5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFjayA9IGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrO1xuZXhwb3J0cy5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFja0luZm8gPSBjcmVhdGVUcmFuc2Zvcm1GZWVkYmFja0luZm87XG5leHBvcnRzLmJpbmRUcmFuc2Zvcm1GZWVkYmFja0luZm8gPSBiaW5kVHJhbnNmb3JtRmVlZGJhY2tJbmZvO1xuZXhwb3J0cy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcbmV4cG9ydHMuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXMgPSBzZXRCdWZmZXJzQW5kQXR0cmlidXRlcztcbmV4cG9ydHMuc2V0VW5pZm9ybXMgPSBzZXRVbmlmb3JtcztcbmV4cG9ydHMuc2V0VW5pZm9ybUJsb2NrID0gc2V0VW5pZm9ybUJsb2NrO1xuZXhwb3J0cy5zZXRCbG9ja1VuaWZvcm1zID0gc2V0QmxvY2tVbmlmb3JtcztcbmV4cG9ydHMuYmluZFVuaWZvcm1CbG9jayA9IGJpbmRVbmlmb3JtQmxvY2s7XG5leHBvcnRzLnNldFVuaWZvcm1zQW5kQmluZFRleHR1cmVzID0gdm9pZCAwO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIikpO1xuXG52YXIgaGVscGVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9oZWxwZXIuanMgKi8gXCIuL3NyYy9oZWxwZXIuanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8qKlxuICogTG93IGxldmVsIHNoYWRlciBwcm9ncmFtIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKlxuICogWW91IHNob3VsZCBnZW5lcmFsbHkgbm90IG5lZWQgdG8gdXNlIHRoZXNlIGZ1bmN0aW9ucy4gVGhleSBhcmUgcHJvdmlkZWRcbiAqIGZvciB0aG9zZSBjYXNlcyB3aGVyZSB5b3UncmUgZG9pbmcgc29tZXRoaW5nIG91dCBvZiB0aGUgb3JkaW5hcnlcbiAqIGFuZCB5b3UgbmVlZCBsb3dlciBsZXZlbCBhY2Nlc3MuXG4gKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgdGhleSBhcmUgYXZhaWxhYmxlIGF0IGJvdGggYHR3Z2wucHJvZ3JhbXNgIGFuZCBgdHdnbGBcbiAqIGl0c2VsZlxuICpcbiAqIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2x9IGZvciBjb3JlIGZ1bmN0aW9uc1xuICpcbiAqIEBtb2R1bGUgdHdnbC9wcm9ncmFtc1xuICovXG52YXIgZXJyb3IgPSBoZWxwZXIuZXJyb3I7XG52YXIgd2FybiA9IGhlbHBlci53YXJuO1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50QnlJZChpZCkge1xuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IG51bGw7XG59XG5cbnZhciBURVhUVVJFMCA9IDB4ODRjMDtcbnZhciBEWU5BTUlDX0RSQVcgPSAweDg4ZTg7XG52YXIgQVJSQVlfQlVGRkVSID0gMHg4ODkyO1xudmFyIEVMRU1FTlRfQVJSQVlfQlVGRkVSID0gMHg4ODkzO1xudmFyIFVOSUZPUk1fQlVGRkVSID0gMHg4YTExO1xudmFyIFRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIgPSAweDhjOGU7XG52YXIgVFJBTlNGT1JNX0ZFRURCQUNLID0gMHg4ZTIyO1xudmFyIENPTVBJTEVfU1RBVFVTID0gMHg4YjgxO1xudmFyIExJTktfU1RBVFVTID0gMHg4YjgyO1xudmFyIEZSQUdNRU5UX1NIQURFUiA9IDB4OGIzMDtcbnZhciBWRVJURVhfU0hBREVSID0gMHg4YjMxO1xudmFyIFNFUEFSQVRFX0FUVFJJQlMgPSAweDhjOGQ7XG52YXIgQUNUSVZFX1VOSUZPUk1TID0gMHg4Yjg2O1xudmFyIEFDVElWRV9BVFRSSUJVVEVTID0gMHg4Yjg5O1xudmFyIFRSQU5TRk9STV9GRUVEQkFDS19WQVJZSU5HUyA9IDB4OGM4MztcbnZhciBBQ1RJVkVfVU5JRk9STV9CTE9DS1MgPSAweDhhMzY7XG52YXIgVU5JRk9STV9CTE9DS19SRUZFUkVOQ0VEX0JZX1ZFUlRFWF9TSEFERVIgPSAweDhhNDQ7XG52YXIgVU5JRk9STV9CTE9DS19SRUZFUkVOQ0VEX0JZX0ZSQUdNRU5UX1NIQURFUiA9IDB4OGE0NjtcbnZhciBVTklGT1JNX0JMT0NLX0RBVEFfU0laRSA9IDB4OGE0MDtcbnZhciBVTklGT1JNX0JMT0NLX0FDVElWRV9VTklGT1JNX0lORElDRVMgPSAweDhhNDM7XG52YXIgRkxPQVQgPSAweDE0MDY7XG52YXIgRkxPQVRfVkVDMiA9IDB4OEI1MDtcbnZhciBGTE9BVF9WRUMzID0gMHg4QjUxO1xudmFyIEZMT0FUX1ZFQzQgPSAweDhCNTI7XG52YXIgSU5UID0gMHgxNDA0O1xudmFyIElOVF9WRUMyID0gMHg4QjUzO1xudmFyIElOVF9WRUMzID0gMHg4QjU0O1xudmFyIElOVF9WRUM0ID0gMHg4QjU1O1xudmFyIEJPT0wgPSAweDhCNTY7XG52YXIgQk9PTF9WRUMyID0gMHg4QjU3O1xudmFyIEJPT0xfVkVDMyA9IDB4OEI1ODtcbnZhciBCT09MX1ZFQzQgPSAweDhCNTk7XG52YXIgRkxPQVRfTUFUMiA9IDB4OEI1QTtcbnZhciBGTE9BVF9NQVQzID0gMHg4QjVCO1xudmFyIEZMT0FUX01BVDQgPSAweDhCNUM7XG52YXIgU0FNUExFUl8yRCA9IDB4OEI1RTtcbnZhciBTQU1QTEVSX0NVQkUgPSAweDhCNjA7XG52YXIgU0FNUExFUl8zRCA9IDB4OEI1RjtcbnZhciBTQU1QTEVSXzJEX1NIQURPVyA9IDB4OEI2MjtcbnZhciBGTE9BVF9NQVQyeDMgPSAweDhCNjU7XG52YXIgRkxPQVRfTUFUMng0ID0gMHg4QjY2O1xudmFyIEZMT0FUX01BVDN4MiA9IDB4OEI2NztcbnZhciBGTE9BVF9NQVQzeDQgPSAweDhCNjg7XG52YXIgRkxPQVRfTUFUNHgyID0gMHg4QjY5O1xudmFyIEZMT0FUX01BVDR4MyA9IDB4OEI2QTtcbnZhciBTQU1QTEVSXzJEX0FSUkFZID0gMHg4REMxO1xudmFyIFNBTVBMRVJfMkRfQVJSQVlfU0hBRE9XID0gMHg4REM0O1xudmFyIFNBTVBMRVJfQ1VCRV9TSEFET1cgPSAweDhEQzU7XG52YXIgVU5TSUdORURfSU5UID0gMHgxNDA1O1xudmFyIFVOU0lHTkVEX0lOVF9WRUMyID0gMHg4REM2O1xudmFyIFVOU0lHTkVEX0lOVF9WRUMzID0gMHg4REM3O1xudmFyIFVOU0lHTkVEX0lOVF9WRUM0ID0gMHg4REM4O1xudmFyIElOVF9TQU1QTEVSXzJEID0gMHg4RENBO1xudmFyIElOVF9TQU1QTEVSXzNEID0gMHg4RENCO1xudmFyIElOVF9TQU1QTEVSX0NVQkUgPSAweDhEQ0M7XG52YXIgSU5UX1NBTVBMRVJfMkRfQVJSQVkgPSAweDhEQ0Y7XG52YXIgVU5TSUdORURfSU5UX1NBTVBMRVJfMkQgPSAweDhERDI7XG52YXIgVU5TSUdORURfSU5UX1NBTVBMRVJfM0QgPSAweDhERDM7XG52YXIgVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRSA9IDB4OERENDtcbnZhciBVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWSA9IDB4OERENztcbnZhciBURVhUVVJFXzJEID0gMHgwREUxO1xudmFyIFRFWFRVUkVfQ1VCRV9NQVAgPSAweDg1MTM7XG52YXIgVEVYVFVSRV8zRCA9IDB4ODA2RjtcbnZhciBURVhUVVJFXzJEX0FSUkFZID0gMHg4QzFBO1xudmFyIHR5cGVNYXAgPSB7fTtcbi8qKlxuICogUmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBiaW5kIHBvaW50IGZvciBhIGdpdmVuIHNhbXBsZXIgdHlwZVxuICovXG5cbmZ1bmN0aW9uIGdldEJpbmRQb2ludEZvclNhbXBsZXJUeXBlKGdsLCB0eXBlKSB7XG4gIHJldHVybiB0eXBlTWFwW3R5cGVdLmJpbmRQb2ludDtcbn0gLy8gVGhpcyBraW5kIG9mIHN1Y2tzISBJZiB5b3UgY291bGQgY29tcG9zZSBmdW5jdGlvbnMgYXMgaW4gYHZhciBmbiA9IGdsW25hbWVdO2Bcbi8vIHRoaXMgY29kZSBjb3VsZCBiZSBhIGxvdCBzbWFsbGVyIGJ1dCB0aGF0IGlzIHNhZGx5IHJlYWxseSBzbG93IChUX1QpXG5cblxuZnVuY3Rpb24gZmxvYXRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0QXJyYXlTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdFZlYzJTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0yZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdFZlYzNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdFZlYzRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm00ZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludEFycmF5U2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50VmVjMlNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludFZlYzNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0zaXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRWZWM0U2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtNGl2KGxvY2F0aW9uLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdWludFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTF1aShsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVpbnRBcnJheVNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTF1aXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1aW50VmVjMlNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTJ1aXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1aW50VmVjM1NldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTN1aXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1aW50VmVjNFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTR1aXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdE1hdDJTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYobG9jYXRpb24sIGZhbHNlLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvYXRNYXQzU2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0NFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdE1hdDIzU2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4MngzZnYobG9jYXRpb24sIGZhbHNlLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvYXRNYXQzMlNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDN4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0MjRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm1NYXRyaXgyeDRmdihsb2NhdGlvbiwgZmFsc2UsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdE1hdDQyU2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4NHgyZnYobG9jYXRpb24sIGZhbHNlLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvYXRNYXQzNFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDN4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0NDNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm1NYXRyaXg0eDNmdihsb2NhdGlvbiwgZmFsc2UsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzYW1wbGVyU2V0dGVyKGdsLCB0eXBlLCB1bml0LCBsb2NhdGlvbikge1xuICB2YXIgYmluZFBvaW50ID0gZ2V0QmluZFBvaW50Rm9yU2FtcGxlclR5cGUoZ2wsIHR5cGUpO1xuICByZXR1cm4gdXRpbHMuaXNXZWJHTDIoZ2wpID8gZnVuY3Rpb24gKHRleHR1cmVPclBhaXIpIHtcbiAgICB2YXIgdGV4dHVyZTtcbiAgICB2YXIgc2FtcGxlcjtcblxuICAgIGlmIChoZWxwZXIuaXNUZXh0dXJlKGdsLCB0ZXh0dXJlT3JQYWlyKSkge1xuICAgICAgdGV4dHVyZSA9IHRleHR1cmVPclBhaXI7XG4gICAgICBzYW1wbGVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dHVyZSA9IHRleHR1cmVPclBhaXIudGV4dHVyZTtcbiAgICAgIHNhbXBsZXIgPSB0ZXh0dXJlT3JQYWlyLnNhbXBsZXI7XG4gICAgfVxuXG4gICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB1bml0KTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKFRFWFRVUkUwICsgdW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoYmluZFBvaW50LCB0ZXh0dXJlKTtcbiAgICBnbC5iaW5kU2FtcGxlcih1bml0LCBzYW1wbGVyKTtcbiAgfSA6IGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB1bml0KTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKFRFWFRVUkUwICsgdW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoYmluZFBvaW50LCB0ZXh0dXJlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2FtcGxlckFycmF5U2V0dGVyKGdsLCB0eXBlLCB1bml0LCBsb2NhdGlvbiwgc2l6ZSkge1xuICB2YXIgYmluZFBvaW50ID0gZ2V0QmluZFBvaW50Rm9yU2FtcGxlclR5cGUoZ2wsIHR5cGUpO1xuICB2YXIgdW5pdHMgPSBuZXcgSW50MzJBcnJheShzaXplKTtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc2l6ZTsgKytpaSkge1xuICAgIHVuaXRzW2lpXSA9IHVuaXQgKyBpaTtcbiAgfVxuXG4gIHJldHVybiB1dGlscy5pc1dlYkdMMihnbCkgPyBmdW5jdGlvbiAodGV4dHVyZXMpIHtcbiAgICBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB1bml0cyk7XG4gICAgdGV4dHVyZXMuZm9yRWFjaChmdW5jdGlvbiAodGV4dHVyZU9yUGFpciwgaW5kZXgpIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoVEVYVFVSRTAgKyB1bml0c1tpbmRleF0pO1xuICAgICAgdmFyIHRleHR1cmU7XG4gICAgICB2YXIgc2FtcGxlcjtcblxuICAgICAgaWYgKGhlbHBlci5pc1RleHR1cmUoZ2wsIHRleHR1cmVPclBhaXIpKSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlT3JQYWlyO1xuICAgICAgICBzYW1wbGVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlT3JQYWlyLnRleHR1cmU7XG4gICAgICAgIHNhbXBsZXIgPSB0ZXh0dXJlT3JQYWlyLnNhbXBsZXI7XG4gICAgICB9XG5cbiAgICAgIGdsLmJpbmRTYW1wbGVyKHVuaXQsIHNhbXBsZXIpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoYmluZFBvaW50LCB0ZXh0dXJlKTtcbiAgICB9KTtcbiAgfSA6IGZ1bmN0aW9uICh0ZXh0dXJlcykge1xuICAgIGdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHVuaXRzKTtcbiAgICB0ZXh0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXh0dXJlLCBpbmRleCkge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShURVhUVVJFMCArIHVuaXRzW2luZGV4XSk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShiaW5kUG9pbnQsIHRleHR1cmUpO1xuICAgIH0pO1xuICB9O1xufVxuXG50eXBlTWFwW0ZMT0FUXSA9IHtcbiAgVHlwZTogRmxvYXQzMkFycmF5LFxuICBzaXplOiA0LFxuICBzZXR0ZXI6IGZsb2F0U2V0dGVyLFxuICBhcnJheVNldHRlcjogZmxvYXRBcnJheVNldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfVkVDMl0gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogOCxcbiAgc2V0dGVyOiBmbG9hdFZlYzJTZXR0ZXJcbn07XG50eXBlTWFwW0ZMT0FUX1ZFQzNdID0ge1xuICBUeXBlOiBGbG9hdDMyQXJyYXksXG4gIHNpemU6IDEyLFxuICBzZXR0ZXI6IGZsb2F0VmVjM1NldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfVkVDNF0gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogMTYsXG4gIHNldHRlcjogZmxvYXRWZWM0U2V0dGVyXG59O1xudHlwZU1hcFtJTlRdID0ge1xuICBUeXBlOiBJbnQzMkFycmF5LFxuICBzaXplOiA0LFxuICBzZXR0ZXI6IGludFNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IGludEFycmF5U2V0dGVyXG59O1xudHlwZU1hcFtJTlRfVkVDMl0gPSB7XG4gIFR5cGU6IEludDMyQXJyYXksXG4gIHNpemU6IDgsXG4gIHNldHRlcjogaW50VmVjMlNldHRlclxufTtcbnR5cGVNYXBbSU5UX1ZFQzNdID0ge1xuICBUeXBlOiBJbnQzMkFycmF5LFxuICBzaXplOiAxMixcbiAgc2V0dGVyOiBpbnRWZWMzU2V0dGVyXG59O1xudHlwZU1hcFtJTlRfVkVDNF0gPSB7XG4gIFR5cGU6IEludDMyQXJyYXksXG4gIHNpemU6IDE2LFxuICBzZXR0ZXI6IGludFZlYzRTZXR0ZXJcbn07XG50eXBlTWFwW1VOU0lHTkVEX0lOVF0gPSB7XG4gIFR5cGU6IFVpbnQzMkFycmF5LFxuICBzaXplOiA0LFxuICBzZXR0ZXI6IHVpbnRTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiB1aW50QXJyYXlTZXR0ZXJcbn07XG50eXBlTWFwW1VOU0lHTkVEX0lOVF9WRUMyXSA9IHtcbiAgVHlwZTogVWludDMyQXJyYXksXG4gIHNpemU6IDgsXG4gIHNldHRlcjogdWludFZlYzJTZXR0ZXJcbn07XG50eXBlTWFwW1VOU0lHTkVEX0lOVF9WRUMzXSA9IHtcbiAgVHlwZTogVWludDMyQXJyYXksXG4gIHNpemU6IDEyLFxuICBzZXR0ZXI6IHVpbnRWZWMzU2V0dGVyXG59O1xudHlwZU1hcFtVTlNJR05FRF9JTlRfVkVDNF0gPSB7XG4gIFR5cGU6IFVpbnQzMkFycmF5LFxuICBzaXplOiAxNixcbiAgc2V0dGVyOiB1aW50VmVjNFNldHRlclxufTtcbnR5cGVNYXBbQk9PTF0gPSB7XG4gIFR5cGU6IFVpbnQzMkFycmF5LFxuICBzaXplOiA0LFxuICBzZXR0ZXI6IGludFNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IGludEFycmF5U2V0dGVyXG59O1xudHlwZU1hcFtCT09MX1ZFQzJdID0ge1xuICBUeXBlOiBVaW50MzJBcnJheSxcbiAgc2l6ZTogOCxcbiAgc2V0dGVyOiBpbnRWZWMyU2V0dGVyXG59O1xudHlwZU1hcFtCT09MX1ZFQzNdID0ge1xuICBUeXBlOiBVaW50MzJBcnJheSxcbiAgc2l6ZTogMTIsXG4gIHNldHRlcjogaW50VmVjM1NldHRlclxufTtcbnR5cGVNYXBbQk9PTF9WRUM0XSA9IHtcbiAgVHlwZTogVWludDMyQXJyYXksXG4gIHNpemU6IDE2LFxuICBzZXR0ZXI6IGludFZlYzRTZXR0ZXJcbn07XG50eXBlTWFwW0ZMT0FUX01BVDJdID0ge1xuICBUeXBlOiBGbG9hdDMyQXJyYXksXG4gIHNpemU6IDE2LFxuICBzZXR0ZXI6IGZsb2F0TWF0MlNldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfTUFUM10gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogMzYsXG4gIHNldHRlcjogZmxvYXRNYXQzU2V0dGVyXG59O1xudHlwZU1hcFtGTE9BVF9NQVQ0XSA9IHtcbiAgVHlwZTogRmxvYXQzMkFycmF5LFxuICBzaXplOiA2NCxcbiAgc2V0dGVyOiBmbG9hdE1hdDRTZXR0ZXJcbn07XG50eXBlTWFwW0ZMT0FUX01BVDJ4M10gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogMjQsXG4gIHNldHRlcjogZmxvYXRNYXQyM1NldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfTUFUMng0XSA9IHtcbiAgVHlwZTogRmxvYXQzMkFycmF5LFxuICBzaXplOiAzMixcbiAgc2V0dGVyOiBmbG9hdE1hdDI0U2V0dGVyXG59O1xudHlwZU1hcFtGTE9BVF9NQVQzeDJdID0ge1xuICBUeXBlOiBGbG9hdDMyQXJyYXksXG4gIHNpemU6IDI0LFxuICBzZXR0ZXI6IGZsb2F0TWF0MzJTZXR0ZXJcbn07XG50eXBlTWFwW0ZMT0FUX01BVDN4NF0gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogNDgsXG4gIHNldHRlcjogZmxvYXRNYXQzNFNldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfTUFUNHgyXSA9IHtcbiAgVHlwZTogRmxvYXQzMkFycmF5LFxuICBzaXplOiAzMixcbiAgc2V0dGVyOiBmbG9hdE1hdDQyU2V0dGVyXG59O1xudHlwZU1hcFtGTE9BVF9NQVQ0eDNdID0ge1xuICBUeXBlOiBGbG9hdDMyQXJyYXksXG4gIHNpemU6IDQ4LFxuICBzZXR0ZXI6IGZsb2F0TWF0NDNTZXR0ZXJcbn07XG50eXBlTWFwW1NBTVBMRVJfMkRdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8yRFxufTtcbnR5cGVNYXBbU0FNUExFUl9DVUJFXSA9IHtcbiAgVHlwZTogbnVsbCxcbiAgc2l6ZTogMCxcbiAgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLFxuICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLFxuICBiaW5kUG9pbnQ6IFRFWFRVUkVfQ1VCRV9NQVBcbn07XG50eXBlTWFwW1NBTVBMRVJfM0RdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8zRFxufTtcbnR5cGVNYXBbU0FNUExFUl8yRF9TSEFET1ddID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8yRFxufTtcbnR5cGVNYXBbU0FNUExFUl8yRF9BUlJBWV0gPSB7XG4gIFR5cGU6IG51bGwsXG4gIHNpemU6IDAsXG4gIHNldHRlcjogc2FtcGxlclNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlcixcbiAgYmluZFBvaW50OiBURVhUVVJFXzJEX0FSUkFZXG59O1xudHlwZU1hcFtTQU1QTEVSXzJEX0FSUkFZX1NIQURPV10gPSB7XG4gIFR5cGU6IG51bGwsXG4gIHNpemU6IDAsXG4gIHNldHRlcjogc2FtcGxlclNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlcixcbiAgYmluZFBvaW50OiBURVhUVVJFXzJEX0FSUkFZXG59O1xudHlwZU1hcFtTQU1QTEVSX0NVQkVfU0hBRE9XXSA9IHtcbiAgVHlwZTogbnVsbCxcbiAgc2l6ZTogMCxcbiAgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLFxuICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLFxuICBiaW5kUG9pbnQ6IFRFWFRVUkVfQ1VCRV9NQVBcbn07XG50eXBlTWFwW0lOVF9TQU1QTEVSXzJEXSA9IHtcbiAgVHlwZTogbnVsbCxcbiAgc2l6ZTogMCxcbiAgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLFxuICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLFxuICBiaW5kUG9pbnQ6IFRFWFRVUkVfMkRcbn07XG50eXBlTWFwW0lOVF9TQU1QTEVSXzNEXSA9IHtcbiAgVHlwZTogbnVsbCxcbiAgc2l6ZTogMCxcbiAgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLFxuICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLFxuICBiaW5kUG9pbnQ6IFRFWFRVUkVfM0Rcbn07XG50eXBlTWFwW0lOVF9TQU1QTEVSX0NVQkVdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV9DVUJFX01BUFxufTtcbnR5cGVNYXBbSU5UX1NBTVBMRVJfMkRfQVJSQVldID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8yRF9BUlJBWVxufTtcbnR5cGVNYXBbVU5TSUdORURfSU5UX1NBTVBMRVJfMkRdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8yRFxufTtcbnR5cGVNYXBbVU5TSUdORURfSU5UX1NBTVBMRVJfM0RdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8zRFxufTtcbnR5cGVNYXBbVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRV0gPSB7XG4gIFR5cGU6IG51bGwsXG4gIHNpemU6IDAsXG4gIHNldHRlcjogc2FtcGxlclNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlcixcbiAgYmluZFBvaW50OiBURVhUVVJFX0NVQkVfTUFQXG59O1xudHlwZU1hcFtVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWV0gPSB7XG4gIFR5cGU6IG51bGwsXG4gIHNpemU6IDAsXG4gIHNldHRlcjogc2FtcGxlclNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlcixcbiAgYmluZFBvaW50OiBURVhUVVJFXzJEX0FSUkFZXG59O1xuXG5mdW5jdGlvbiBmbG9hdEF0dHJpYlNldHRlcihnbCwgaW5kZXgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XG4gICAgaWYgKGIudmFsdWUpIHtcbiAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG5cbiAgICAgIHN3aXRjaCAoYi52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjRmdihpbmRleCwgYi52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjNmdihpbmRleCwgYi52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjJmdihpbmRleCwgYi52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjFmdihpbmRleCwgYi52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBsZW5ndGggb2YgYSBmbG9hdCBjb25zdGFudCB2YWx1ZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNCEnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuYmluZEJ1ZmZlcihBUlJBWV9CVUZGRVIsIGIuYnVmZmVyKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaW5kZXgsIGIubnVtQ29tcG9uZW50cyB8fCBiLnNpemUsIGIudHlwZSB8fCBGTE9BVCwgYi5ub3JtYWxpemUgfHwgZmFsc2UsIGIuc3RyaWRlIHx8IDAsIGIub2Zmc2V0IHx8IDApO1xuXG4gICAgICBpZiAoYi5kaXZpc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihpbmRleCwgYi5kaXZpc29yKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludEF0dHJpYlNldHRlcihnbCwgaW5kZXgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XG4gICAgaWYgKGIudmFsdWUpIHtcbiAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG5cbiAgICAgIGlmIChiLnZhbHVlLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWI0aXYoaW5kZXgsIGIudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbGVuZ3RoIG9mIGFuIGludGVnZXIgY29uc3RhbnQgdmFsdWUgbXVzdCBiZSA0IScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC5iaW5kQnVmZmVyKEFSUkFZX0JVRkZFUiwgYi5idWZmZXIpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuICAgICAgZ2wudmVydGV4QXR0cmliSVBvaW50ZXIoaW5kZXgsIGIubnVtQ29tcG9uZW50cyB8fCBiLnNpemUsIGIudHlwZSB8fCBJTlQsIGIuc3RyaWRlIHx8IDAsIGIub2Zmc2V0IHx8IDApO1xuXG4gICAgICBpZiAoYi5kaXZpc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihpbmRleCwgYi5kaXZpc29yKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVpbnRBdHRyaWJTZXR0ZXIoZ2wsIGluZGV4KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYikge1xuICAgIGlmIChiLnZhbHVlKSB7XG4gICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuXG4gICAgICBpZiAoYi52YWx1ZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliNHVpdihpbmRleCwgYi52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBsZW5ndGggb2YgYW4gdW5zaWduZWQgaW50ZWdlciBjb25zdGFudCB2YWx1ZSBtdXN0IGJlIDQhJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmJpbmRCdWZmZXIoQVJSQVlfQlVGRkVSLCBiLmJ1ZmZlcik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJJUG9pbnRlcihpbmRleCwgYi5udW1Db21wb25lbnRzIHx8IGIuc2l6ZSwgYi50eXBlIHx8IFVOU0lHTkVEX0lOVCwgYi5zdHJpZGUgfHwgMCwgYi5vZmZzZXQgfHwgMCk7XG5cbiAgICAgIGlmIChiLmRpdmlzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGluZGV4LCBiLmRpdmlzb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbWF0QXR0cmliU2V0dGVyKGdsLCBpbmRleCwgdHlwZUluZm8pIHtcbiAgdmFyIGRlZmF1bHRTaXplID0gdHlwZUluZm8uc2l6ZTtcbiAgdmFyIGNvdW50ID0gdHlwZUluZm8uY291bnQ7XG4gIHJldHVybiBmdW5jdGlvbiAoYikge1xuICAgIGdsLmJpbmRCdWZmZXIoQVJSQVlfQlVGRkVSLCBiLmJ1ZmZlcik7XG4gICAgdmFyIG51bUNvbXBvbmVudHMgPSBiLnNpemUgfHwgYi5udW1Db21wb25lbnRzIHx8IGRlZmF1bHRTaXplO1xuICAgIHZhciBzaXplID0gbnVtQ29tcG9uZW50cyAvIGNvdW50O1xuICAgIHZhciB0eXBlID0gYi50eXBlIHx8IEZMT0FUO1xuICAgIHZhciB0eXBlSW5mbyA9IHR5cGVNYXBbdHlwZV07XG4gICAgdmFyIHN0cmlkZSA9IHR5cGVJbmZvLnNpemUgKiBudW1Db21wb25lbnRzO1xuICAgIHZhciBub3JtYWxpemUgPSBiLm5vcm1hbGl6ZSB8fCBmYWxzZTtcbiAgICB2YXIgb2Zmc2V0ID0gYi5vZmZzZXQgfHwgMDtcbiAgICB2YXIgcm93T2Zmc2V0ID0gc3RyaWRlIC8gY291bnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4ICsgaSk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGluZGV4ICsgaSwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplLCBzdHJpZGUsIG9mZnNldCArIHJvd09mZnNldCAqIGkpO1xuXG4gICAgICBpZiAoYi5kaXZpc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihpbmRleCArIGksIGIuZGl2aXNvcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgYXR0clR5cGVNYXAgPSB7fTtcbmF0dHJUeXBlTWFwW0ZMT0FUXSA9IHtcbiAgc2l6ZTogNCxcbiAgc2V0dGVyOiBmbG9hdEF0dHJpYlNldHRlclxufTtcbmF0dHJUeXBlTWFwW0ZMT0FUX1ZFQzJdID0ge1xuICBzaXplOiA4LFxuICBzZXR0ZXI6IGZsb2F0QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbRkxPQVRfVkVDM10gPSB7XG4gIHNpemU6IDEyLFxuICBzZXR0ZXI6IGZsb2F0QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbRkxPQVRfVkVDNF0gPSB7XG4gIHNpemU6IDE2LFxuICBzZXR0ZXI6IGZsb2F0QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbSU5UXSA9IHtcbiAgc2l6ZTogNCxcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtJTlRfVkVDMl0gPSB7XG4gIHNpemU6IDgsXG4gIHNldHRlcjogaW50QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbSU5UX1ZFQzNdID0ge1xuICBzaXplOiAxMixcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtJTlRfVkVDNF0gPSB7XG4gIHNpemU6IDE2LFxuICBzZXR0ZXI6IGludEF0dHJpYlNldHRlclxufTtcbmF0dHJUeXBlTWFwW1VOU0lHTkVEX0lOVF0gPSB7XG4gIHNpemU6IDQsXG4gIHNldHRlcjogdWludEF0dHJpYlNldHRlclxufTtcbmF0dHJUeXBlTWFwW1VOU0lHTkVEX0lOVF9WRUMyXSA9IHtcbiAgc2l6ZTogOCxcbiAgc2V0dGVyOiB1aW50QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbVU5TSUdORURfSU5UX1ZFQzNdID0ge1xuICBzaXplOiAxMixcbiAgc2V0dGVyOiB1aW50QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbVU5TSUdORURfSU5UX1ZFQzRdID0ge1xuICBzaXplOiAxNixcbiAgc2V0dGVyOiB1aW50QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbQk9PTF0gPSB7XG4gIHNpemU6IDQsXG4gIHNldHRlcjogaW50QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbQk9PTF9WRUMyXSA9IHtcbiAgc2l6ZTogOCxcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtCT09MX1ZFQzNdID0ge1xuICBzaXplOiAxMixcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtCT09MX1ZFQzRdID0ge1xuICBzaXplOiAxNixcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtGTE9BVF9NQVQyXSA9IHtcbiAgc2l6ZTogNCxcbiAgc2V0dGVyOiBtYXRBdHRyaWJTZXR0ZXIsXG4gIGNvdW50OiAyXG59O1xuYXR0clR5cGVNYXBbRkxPQVRfTUFUM10gPSB7XG4gIHNpemU6IDksXG4gIHNldHRlcjogbWF0QXR0cmliU2V0dGVyLFxuICBjb3VudDogM1xufTtcbmF0dHJUeXBlTWFwW0ZMT0FUX01BVDRdID0ge1xuICBzaXplOiAxNixcbiAgc2V0dGVyOiBtYXRBdHRyaWJTZXR0ZXIsXG4gIGNvdW50OiA0XG59OyAvLyBtYWtlIHN1cmUgd2UgZG9uJ3Qgc2VlIGEgZ2xvYmFsIGdsXG5cbnZhciBnbCA9IHVuZGVmaW5lZDtcbi8qIGVzbGludC1kaXNhYmxlLWxpbmUgKi9cblxudmFyIGVycm9yUkUgPSAvRVJST1I6XFxzKlxcZCs6KFxcZCspL2dpO1xuXG5mdW5jdGlvbiBhZGRMaW5lTnVtYmVyc1dpdGhFcnJvcihzcmMpIHtcbiAgdmFyIGxvZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gIHZhciBsaW5lT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuXG4gIC8vIE5vdGU6IEVycm9yIG1lc3NhZ2UgZm9ybWF0cyBhcmUgbm90IGRlZmluZWQgYnkgYW55IHNwZWMgc28gdGhpcyBtYXkgb3IgbWF5IG5vdCB3b3JrLlxuICB2YXIgbWF0Y2hlcyA9IF90b0NvbnN1bWFibGVBcnJheShsb2cubWF0Y2hBbGwoZXJyb3JSRSkpO1xuXG4gIHZhciBsaW5lTm9Ub0Vycm9yTWFwID0gbmV3IE1hcChtYXRjaGVzLm1hcChmdW5jdGlvbiAobSwgbmR4KSB7XG4gICAgdmFyIGxpbmVObyA9IHBhcnNlSW50KG1bMV0pO1xuICAgIHZhciBuZXh0ID0gbWF0Y2hlc1tuZHggKyAxXTtcbiAgICB2YXIgZW5kID0gbmV4dCA/IG5leHQuaW5kZXggOiBsb2cubGVuZ3RoO1xuICAgIHZhciBtc2cgPSBsb2cuc3Vic3RyaW5nKG0uaW5kZXgsIGVuZCk7XG4gICAgcmV0dXJuIFtsaW5lTm8gLSAxLCBtc2ddO1xuICB9KSk7XG4gIHJldHVybiBzcmMuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbiAobGluZSwgbGluZU5vKSB7XG4gICAgdmFyIGVyciA9IGxpbmVOb1RvRXJyb3JNYXAuZ2V0KGxpbmVObyk7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGxpbmVObyArIDEgKyBsaW5lT2Zmc2V0LCBcIjogXCIpLmNvbmNhdChsaW5lKS5jb25jYXQoZXJyID8gXCJcXG5cXG5eXl4gXCIuY29uY2F0KGVycikgOiAnJyk7XG4gIH0pLmpvaW4oJ1xcbicpO1xufVxuLyoqXG4gKiBFcnJvciBDYWxsYmFja1xuICogQGNhbGxiYWNrIEVycm9yQ2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGluZU9mZnNldF0gYW1vdW50IHRvIGFkZCB0byBsaW5lIG51bWJlclxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG52YXIgc3BhY2VSRSA9IC9eWyBcXHRdKlxcbi87XG4vKipcbiAqIExvYWRzIGEgc2hhZGVyLlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHNoYWRlclNvdXJjZSBUaGUgc2hhZGVyIHNvdXJjZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaGFkZXJUeXBlIFRoZSB0eXBlIG9mIHNoYWRlci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gb3B0X2Vycm9yQ2FsbGJhY2sgY2FsbGJhY2sgZm9yIGVycm9ycy5cbiAqIEByZXR1cm4ge1dlYkdMU2hhZGVyfSBUaGUgY3JlYXRlZCBzaGFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWRTaGFkZXIoZ2wsIHNoYWRlclNvdXJjZSwgc2hhZGVyVHlwZSwgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgdmFyIGVyckZuID0gb3B0X2Vycm9yQ2FsbGJhY2sgfHwgZXJyb3I7IC8vIENyZWF0ZSB0aGUgc2hhZGVyIG9iamVjdFxuXG4gIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7IC8vIFJlbW92ZSB0aGUgZmlyc3QgZW5kIG9mIGxpbmUgYmVjYXVzZSBXZWJHTCAyLjAgcmVxdWlyZXNcbiAgLy8gI3ZlcnNpb24gMzAwIGVzXG4gIC8vIGFzIHRoZSBmaXJzdCBsaW5lLiBObyB3aGl0ZXNwYWNlIGFsbG93ZWQgYmVmb3JlIHRoYXQgbGluZVxuICAvLyBzb1xuICAvL1xuICAvLyA8c2NyaXB0PlxuICAvLyAjdmVyc2lvbiAzMDAgZXNcbiAgLy8gPC9zY3JpcHQ+XG4gIC8vXG4gIC8vIEhhcyBvbmUgbGluZSBiZWZvcmUgaXQgd2hpY2ggaXMgaW52YWxpZCBhY2NvcmRpbmcgdG8gR0xTTCBFUyAzLjAwXG4gIC8vXG5cbiAgdmFyIGxpbmVPZmZzZXQgPSAwO1xuXG4gIGlmIChzcGFjZVJFLnRlc3Qoc2hhZGVyU291cmNlKSkge1xuICAgIGxpbmVPZmZzZXQgPSAxO1xuICAgIHNoYWRlclNvdXJjZSA9IHNoYWRlclNvdXJjZS5yZXBsYWNlKHNwYWNlUkUsICcnKTtcbiAgfSAvLyBMb2FkIHRoZSBzaGFkZXIgc291cmNlXG5cblxuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpOyAvLyBDb21waWxlIHRoZSBzaGFkZXJcblxuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7IC8vIENoZWNrIHRoZSBjb21waWxlIHN0YXR1c1xuXG4gIHZhciBjb21waWxlZCA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIENPTVBJTEVfU1RBVFVTKTtcblxuICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIGNvbXBpbGF0aW9uOyBnZXQgdGhlIGVycm9yXG4gICAgdmFyIGxhc3RFcnJvciA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICBlcnJGbihcIlwiLmNvbmNhdChhZGRMaW5lTnVtYmVyc1dpdGhFcnJvcihzaGFkZXJTb3VyY2UsIGxhc3RFcnJvciwgbGluZU9mZnNldCksIFwiXFxuRXJyb3IgY29tcGlsaW5nIFwiKS5jb25jYXQodXRpbHMuZ2xFbnVtVG9TdHJpbmcoZ2wsIHNoYWRlclR5cGUpLCBcIjogXCIpLmNvbmNhdChsYXN0RXJyb3IpKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBzaGFkZXI7XG59XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb2dyYW1PcHRpb25zXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKHN0cmluZyl9IFtlcnJvckNhbGxiYWNrXSBjYWxsYmFjayBmb3IgZXJyb3JzXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLG51bWJlcj59IFthdHRyaWJMb2NhdGlvbnNdIGEgYXR0cmlidXRlIG5hbWUgdG8gbG9jYXRpb24gbWFwXG4gKiBAcHJvcGVydHkgeyhtb2R1bGU6dHdnbC5CdWZmZXJJbmZvfE9iamVjdC48c3RyaW5nLG1vZHVsZTp0d2dsLkF0dHJpYkluZm8+fHN0cmluZ1tdKX0gW3RyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3NdIElmIHBhc3NlZFxuICogICBhIEJ1ZmZlckluZm8gd2lsbCB1c2UgdGhlIGF0dHJpYnMgbmFtZXMgaW5zaWRlLiBJZiBwYXNzZWQgYW4gb2JqZWN0IG9mIEF0dHJpYkluZm9zIHdpbGwgdXNlIHRoZSBuYW1lcyBmcm9tIHRoYXQgb2JqZWN0LiBPdGhlcndpc2VcbiAqICAgeW91IGNhbiBwYXNzIGFuIGFycmF5IG9mIG5hbWVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2Zvcm1GZWVkYmFja01vZGVdIHRoZSBtb2RlIHRvIHBhc3MgYGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3NgLiBEZWZhdWx0cyB0byBgU0VQQVJBVEVfQVRUUklCU2AuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEdldHMgdGhlIHByb2dyYW0gb3B0aW9ucyBiYXNlZCBvbiBhbGwgdGhlc2Ugb3B0aW9uYWwgYXJndW1lbnRzXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1PcHRpb25zfHN0cmluZ1tdfSBbb3B0X2F0dHJpYnNdIE9wdGlvbnMgZm9yIHRoZSBwcm9ncmFtIG9yIGFuIGFycmF5IG9mIGF0dHJpYnMgbmFtZXMuIExvY2F0aW9ucyB3aWxsIGJlIGFzc2lnbmVkIGJ5IGluZGV4IGlmIG5vdCBwYXNzZWQgaW5cbiAqIEBwYXJhbSB7bnVtYmVyW119IFtvcHRfbG9jYXRpb25zXSBUaGUgbG9jYXRpb25zIGZvciB0aGUuIEEgcGFyYWxsZWwgYXJyYXkgdG8gb3B0X2F0dHJpYnMgbGV0dGluZyB5b3UgYXNzaWduIGxvY2F0aW9ucy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9lcnJvckNhbGxiYWNrXSBjYWxsYmFjayBmb3IgZXJyb3JzLiBCeSBkZWZhdWx0IGl0IGp1c3QgcHJpbnRzIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlXG4gKiAgICAgICAgb24gZXJyb3IuIElmIHlvdSB3YW50IHNvbWV0aGluZyBlbHNlIHBhc3MgYW4gY2FsbGJhY2suIEl0J3MgcGFzc2VkIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5Qcm9ncmFtT3B0aW9uc30gYW4gaW5zdGFuY2Ugb2YgUHJvZ3JhbU9wdGlvbnMgYmFzZWQgb24gdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW5cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRQcm9ncmFtT3B0aW9ucyhvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgdmFyIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3M7XG4gIHZhciB0cmFuc2Zvcm1GZWVkYmFja01vZGU7XG5cbiAgaWYgKHR5cGVvZiBvcHRfbG9jYXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0X2Vycm9yQ2FsbGJhY2sgPSBvcHRfbG9jYXRpb25zO1xuICAgIG9wdF9sb2NhdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdF9hdHRyaWJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0X2Vycm9yQ2FsbGJhY2sgPSBvcHRfYXR0cmlicztcbiAgICBvcHRfYXR0cmlicyA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChvcHRfYXR0cmlicyAmJiAhQXJyYXkuaXNBcnJheShvcHRfYXR0cmlicykpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGVycm9yQ2FsbGJhY2sgd2UgY2FuIGp1c3QgcmV0dXJuIHRoaXMgb2JqZWN0XG4gICAgLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gY29uc3RydWN0IG9uZSB3aXRoIGRlZmF1bHQgZXJyb3JDYWxsYmFja1xuICAgIGlmIChvcHRfYXR0cmlicy5lcnJvckNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gb3B0X2F0dHJpYnM7XG4gICAgfVxuXG4gICAgdmFyIG9wdCA9IG9wdF9hdHRyaWJzO1xuICAgIG9wdF9lcnJvckNhbGxiYWNrID0gb3B0LmVycm9yQ2FsbGJhY2s7XG4gICAgb3B0X2F0dHJpYnMgPSBvcHQuYXR0cmliTG9jYXRpb25zO1xuICAgIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MgPSBvcHQudHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncztcbiAgICB0cmFuc2Zvcm1GZWVkYmFja01vZGUgPSBvcHQudHJhbnNmb3JtRmVlZGJhY2tNb2RlO1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgZXJyb3JDYWxsYmFjazogb3B0X2Vycm9yQ2FsbGJhY2sgfHwgZXJyb3IsXG4gICAgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nczogdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyxcbiAgICB0cmFuc2Zvcm1GZWVkYmFja01vZGU6IHRyYW5zZm9ybUZlZWRiYWNrTW9kZVxuICB9O1xuXG4gIGlmIChvcHRfYXR0cmlicykge1xuICAgIHZhciBhdHRyaWJMb2NhdGlvbnMgPSB7fTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdF9hdHRyaWJzKSkge1xuICAgICAgb3B0X2F0dHJpYnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmliLCBuZHgpIHtcbiAgICAgICAgYXR0cmliTG9jYXRpb25zW2F0dHJpYl0gPSBvcHRfbG9jYXRpb25zID8gb3B0X2xvY2F0aW9uc1tuZHhdIDogbmR4O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYkxvY2F0aW9ucyA9IG9wdF9hdHRyaWJzO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYXR0cmliTG9jYXRpb25zID0gYXR0cmliTG9jYXRpb25zO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbnZhciBkZWZhdWx0U2hhZGVyVHlwZSA9IFtcIlZFUlRFWF9TSEFERVJcIiwgXCJGUkFHTUVOVF9TSEFERVJcIl07XG5cbmZ1bmN0aW9uIGdldFNoYWRlclR5cGVGcm9tU2NyaXB0VHlwZShnbCwgc2NyaXB0VHlwZSkge1xuICBpZiAoc2NyaXB0VHlwZS5pbmRleE9mKFwiZnJhZ1wiKSA+PSAwKSB7XG4gICAgcmV0dXJuIEZSQUdNRU5UX1NIQURFUjtcbiAgfSBlbHNlIGlmIChzY3JpcHRUeXBlLmluZGV4T2YoXCJ2ZXJ0XCIpID49IDApIHtcbiAgICByZXR1cm4gVkVSVEVYX1NIQURFUjtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZVNoYWRlcnMoZ2wsIHNoYWRlcnMpIHtcbiAgc2hhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzaGFkZXIpIHtcbiAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBwcm9ncmFtLCBhdHRhY2hlcyAoYW5kL29yIGNvbXBpbGVzKSBzaGFkZXJzLCBiaW5kcyBhdHRyaWIgbG9jYXRpb25zLCBsaW5rcyB0aGVcbiAqIHByb2dyYW0gYW5kIGNhbGxzIHVzZVByb2dyYW0uXG4gKlxuICogTk9URTogVGhlcmUgYXJlIDQgc2lnbmF0dXJlcyBmb3IgdGhpcyBmdW5jdGlvblxuICpcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW0oZ2wsIFt2cywgZnNdLCBvcHRpb25zKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW0oZ2wsIFt2cywgZnNdLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtKGdsLCBbdnMsIGZzXSwgb3B0X2F0dHJpYnMsIG9wdF9lcnJGdW5jKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW0oZ2wsIFt2cywgZnNdLCBvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2VyckZ1bmMpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHRvIHVzZS5cbiAqIEBwYXJhbSB7V2ViR0xTaGFkZXJbXXxzdHJpbmdbXX0gc2hhZGVycyBUaGUgc2hhZGVycyB0byBhdHRhY2gsIG9yIGVsZW1lbnQgaWRzIGZvciB0aGVpciBzb3VyY2UsIG9yIHN0cmluZ3MgdGhhdCBjb250YWluIHRoZWlyIHNvdXJjZVxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtT3B0aW9uc3xzdHJpbmdbXXxtb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrfSBbb3B0X2F0dHJpYnNdIE9wdGlvbnMgZm9yIHRoZSBwcm9ncmFtIG9yIGFuIGFycmF5IG9mIGF0dHJpYnMgbmFtZXMgb3IgYW4gZXJyb3IgY2FsbGJhY2suIExvY2F0aW9ucyB3aWxsIGJlIGFzc2lnbmVkIGJ5IGluZGV4IGlmIG5vdCBwYXNzZWQgaW5cbiAqIEBwYXJhbSB7bnVtYmVyW119IFtvcHRfbG9jYXRpb25zfG1vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2tdIFRoZSBsb2NhdGlvbnMgZm9yIHRoZS4gQSBwYXJhbGxlbCBhcnJheSB0byBvcHRfYXR0cmlicyBsZXR0aW5nIHlvdSBhc3NpZ24gbG9jYXRpb25zIG9yIGFuIGVycm9yIGNhbGxiYWNrLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrfSBbb3B0X2Vycm9yQ2FsbGJhY2tdIGNhbGxiYWNrIGZvciBlcnJvcnMuIEJ5IGRlZmF1bHQgaXQganVzdCBwcmludHMgYW4gZXJyb3IgdG8gdGhlIGNvbnNvbGVcbiAqICAgICAgICBvbiBlcnJvci4gSWYgeW91IHdhbnQgc29tZXRoaW5nIGVsc2UgcGFzcyBhbiBjYWxsYmFjay4gSXQncyBwYXNzZWQgYW4gZXJyb3IgbWVzc2FnZS5cbiAqIEByZXR1cm4ge1dlYkdMUHJvZ3JhbT99IHRoZSBjcmVhdGVkIHByb2dyYW0gb3IgbnVsbCBpZiBlcnJvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShnbCwgc2hhZGVycywgb3B0X2F0dHJpYnMsIG9wdF9sb2NhdGlvbnMsIG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gIHZhciBwcm9nT3B0aW9ucyA9IGdldFByb2dyYW1PcHRpb25zKG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjayk7XG4gIHZhciByZWFsU2hhZGVycyA9IFtdO1xuICB2YXIgbmV3U2hhZGVycyA9IFtdO1xuXG4gIGZvciAodmFyIG5keCA9IDA7IG5keCA8IHNoYWRlcnMubGVuZ3RoOyArK25keCkge1xuICAgIHZhciBzaGFkZXIgPSBzaGFkZXJzW25keF07XG5cbiAgICBpZiAodHlwZW9mIHNoYWRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBlbGVtID0gZ2V0RWxlbWVudEJ5SWQoc2hhZGVyKTtcbiAgICAgIHZhciBzcmMgPSBlbGVtID8gZWxlbS50ZXh0IDogc2hhZGVyO1xuICAgICAgdmFyIHR5cGUgPSBnbFtkZWZhdWx0U2hhZGVyVHlwZVtuZHhdXTtcblxuICAgICAgaWYgKGVsZW0gJiYgZWxlbS50eXBlKSB7XG4gICAgICAgIHR5cGUgPSBnZXRTaGFkZXJUeXBlRnJvbVNjcmlwdFR5cGUoZ2wsIGVsZW0udHlwZSkgfHwgdHlwZTtcbiAgICAgIH1cblxuICAgICAgc2hhZGVyID0gbG9hZFNoYWRlcihnbCwgc3JjLCB0eXBlLCBwcm9nT3B0aW9ucy5lcnJvckNhbGxiYWNrKTtcbiAgICAgIG5ld1NoYWRlcnMucHVzaChzaGFkZXIpO1xuICAgIH1cblxuICAgIGlmIChoZWxwZXIuaXNTaGFkZXIoZ2wsIHNoYWRlcikpIHtcbiAgICAgIHJlYWxTaGFkZXJzLnB1c2goc2hhZGVyKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVhbFNoYWRlcnMubGVuZ3RoICE9PSBzaGFkZXJzLmxlbmd0aCkge1xuICAgIHByb2dPcHRpb25zLmVycm9yQ2FsbGJhY2soXCJub3QgZW5vdWdoIHNoYWRlcnMgZm9yIHByb2dyYW1cIik7XG4gICAgZGVsZXRlU2hhZGVycyhnbCwgbmV3U2hhZGVycyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgcmVhbFNoYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2hhZGVyKSB7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcik7XG4gIH0pO1xuXG4gIGlmIChwcm9nT3B0aW9ucy5hdHRyaWJMb2NhdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhwcm9nT3B0aW9ucy5hdHRyaWJMb2NhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYikge1xuICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIHByb2dPcHRpb25zLmF0dHJpYkxvY2F0aW9uc1thdHRyaWJdLCBhdHRyaWIpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHZhcnlpbmdzID0gcHJvZ09wdGlvbnMudHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncztcblxuICBpZiAodmFyeWluZ3MpIHtcbiAgICBpZiAodmFyeWluZ3MuYXR0cmlicykge1xuICAgICAgdmFyeWluZ3MgPSB2YXJ5aW5ncy5hdHRyaWJzO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YXJ5aW5ncykpIHtcbiAgICAgIHZhcnlpbmdzID0gT2JqZWN0LmtleXModmFyeWluZ3MpO1xuICAgIH1cblxuICAgIGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MocHJvZ3JhbSwgdmFyeWluZ3MsIHByb2dPcHRpb25zLnRyYW5zZm9ybUZlZWRiYWNrTW9kZSB8fCBTRVBBUkFURV9BVFRSSUJTKTtcbiAgfVxuXG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pOyAvLyBDaGVjayB0aGUgbGluayBzdGF0dXNcblxuICB2YXIgbGlua2VkID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBMSU5LX1NUQVRVUyk7XG5cbiAgaWYgKCFsaW5rZWQpIHtcbiAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZyB3aXRoIHRoZSBsaW5rXG4gICAgdmFyIGxhc3RFcnJvciA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xuICAgIHByb2dPcHRpb25zLmVycm9yQ2FsbGJhY2soXCJcIi5jb25jYXQocmVhbFNoYWRlcnMubWFwKGZ1bmN0aW9uIChzaGFkZXIpIHtcbiAgICAgIHZhciBzcmMgPSBhZGRMaW5lTnVtYmVyc1dpdGhFcnJvcihnbC5nZXRTaGFkZXJTb3VyY2Uoc2hhZGVyKSwgJycsIDApO1xuICAgICAgdmFyIHR5cGUgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5TSEFERVJfVFlQRSk7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodXRpbHMuZ2xFbnVtVG9TdHJpbmcoZ2wsIHR5cGUpLCBcIlxcblwiKS5jb25jYXQoc3JjLCBcIn1cIik7XG4gICAgfSkuam9pbignXFxuJyksIFwiXFxuRXJyb3IgaW4gcHJvZ3JhbSBsaW5raW5nOiBcIikuY29uY2F0KGxhc3RFcnJvcikpO1xuICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgZGVsZXRlU2hhZGVycyhnbCwgbmV3U2hhZGVycyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcHJvZ3JhbTtcbn1cbi8qKlxuICogTG9hZHMgYSBzaGFkZXIgZnJvbSBhIHNjcmlwdCB0YWcuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0SWQgVGhlIGlkIG9mIHRoZSBzY3JpcHQgdGFnLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc2hhZGVyVHlwZV0gVGhlIHR5cGUgb2Ygc2hhZGVyLiBJZiBub3QgcGFzc2VkIGluIGl0IHdpbGxcbiAqICAgICBiZSBkZXJpdmVkIGZyb20gdGhlIHR5cGUgb2YgdGhlIHNjcmlwdCB0YWcuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9ycy5cbiAqIEByZXR1cm4ge1dlYkdMU2hhZGVyP30gVGhlIGNyZWF0ZWQgc2hhZGVyIG9yIG51bGwgaWYgZXJyb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlU2hhZGVyRnJvbVNjcmlwdChnbCwgc2NyaXB0SWQsIG9wdF9zaGFkZXJUeXBlLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICB2YXIgc2hhZGVyU291cmNlID0gXCJcIjtcbiAgdmFyIHNoYWRlclNjcmlwdCA9IGdldEVsZW1lbnRCeUlkKHNjcmlwdElkKTtcblxuICBpZiAoIXNoYWRlclNjcmlwdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gc2NyaXB0IGVsZW1lbnQ6IFwiLmNvbmNhdChzY3JpcHRJZCkpO1xuICB9XG5cbiAgc2hhZGVyU291cmNlID0gc2hhZGVyU2NyaXB0LnRleHQ7XG4gIHZhciBzaGFkZXJUeXBlID0gb3B0X3NoYWRlclR5cGUgfHwgZ2V0U2hhZGVyVHlwZUZyb21TY3JpcHRUeXBlKGdsLCBzaGFkZXJTY3JpcHQudHlwZSk7XG5cbiAgaWYgKCFzaGFkZXJUeXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHNoYWRlciB0eXBlJyk7XG4gIH1cblxuICByZXR1cm4gbG9hZFNoYWRlcihnbCwgc2hhZGVyU291cmNlLCBzaGFkZXJUeXBlLCBvcHRfZXJyb3JDYWxsYmFjayk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBwcm9ncmFtIGZyb20gMiBzY3JpcHQgdGFncy5cbiAqXG4gKiBOT1RFOiBUaGVyZSBhcmUgNCBzaWduYXR1cmVzIGZvciB0aGlzIGZ1bmN0aW9uXG4gKlxuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzKGdsLCBbdnMsIGZzXSwgb3B0X29wdGlvbnMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzKGdsLCBbdnMsIGZzXSwgb3B0X2VyckZ1bmMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzKGdsLCBbdnMsIGZzXSwgb3B0X2F0dHJpYnMsIG9wdF9lcnJGdW5jKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyhnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyRnVuYyk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqICAgICAgICB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzaGFkZXJTY3JpcHRJZHMgQXJyYXkgb2YgaWRzIG9mIHRoZSBzY3JpcHRcbiAqICAgICAgICB0YWdzIGZvciB0aGUgc2hhZGVycy4gVGhlIGZpcnN0IGlzIGFzc3VtZWQgdG8gYmUgdGhlXG4gKiAgICAgICAgdmVydGV4IHNoYWRlciwgdGhlIHNlY29uZCB0aGUgZnJhZ21lbnQgc2hhZGVyLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtT3B0aW9uc3xzdHJpbmdbXXxtb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrfSBbb3B0X2F0dHJpYnNdIE9wdGlvbnMgZm9yIHRoZSBwcm9ncmFtIG9yIGFuIGFycmF5IG9mIGF0dHJpYnMgbmFtZXMgb3IgYW4gZXJyb3IgY2FsbGJhY2suIExvY2F0aW9ucyB3aWxsIGJlIGFzc2lnbmVkIGJ5IGluZGV4IGlmIG5vdCBwYXNzZWQgaW5cbiAqIEBwYXJhbSB7bnVtYmVyW119IFtvcHRfbG9jYXRpb25zfG1vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2tdIFRoZSBsb2NhdGlvbnMgZm9yIHRoZS4gQSBwYXJhbGxlbCBhcnJheSB0byBvcHRfYXR0cmlicyBsZXR0aW5nIHlvdSBhc3NpZ24gbG9jYXRpb25zIG9yIGFuIGVycm9yIGNhbGxiYWNrLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrfSBbb3B0X2Vycm9yQ2FsbGJhY2tdIGNhbGxiYWNrIGZvciBlcnJvcnMuIEJ5IGRlZmF1bHQgaXQganVzdCBwcmludHMgYW4gZXJyb3IgdG8gdGhlIGNvbnNvbGVcbiAqICAgICAgICBvbiBlcnJvci4gSWYgeW91IHdhbnQgc29tZXRoaW5nIGVsc2UgcGFzcyBhbiBjYWxsYmFjay4gSXQncyBwYXNzZWQgYW4gZXJyb3IgbWVzc2FnZS5cbiAqIEByZXR1cm4ge1dlYkdMUHJvZ3JhbT99IHRoZSBjcmVhdGVkIHByb2dyYW0gb3IgbnVsbCBpZiBlcnJvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzKGdsLCBzaGFkZXJTY3JpcHRJZHMsIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICB2YXIgcHJvZ09wdGlvbnMgPSBnZXRQcm9ncmFtT3B0aW9ucyhvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spO1xuICB2YXIgc2hhZGVycyA9IFtdO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBzaGFkZXJTY3JpcHRJZHMubGVuZ3RoOyArK2lpKSB7XG4gICAgdmFyIHNoYWRlciA9IGNyZWF0ZVNoYWRlckZyb21TY3JpcHQoZ2wsIHNoYWRlclNjcmlwdElkc1tpaV0sIGdsW2RlZmF1bHRTaGFkZXJUeXBlW2lpXV0sIHByb2dPcHRpb25zLmVycm9yQ2FsbGJhY2spO1xuXG4gICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHNoYWRlcnMucHVzaChzaGFkZXIpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVByb2dyYW0oZ2wsIHNoYWRlcnMsIHByb2dPcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHByb2dyYW0gZnJvbSAyIHNvdXJjZXMuXG4gKlxuICogTk9URTogVGhlcmUgYXJlIDQgc2lnbmF0dXJlcyBmb3IgdGhpcyBmdW5jdGlvblxuICpcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Gcm9tU291cmNlKGdsLCBbdnMsIGZzXSwgb3B0X29wdGlvbnMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2UoZ2wsIFt2cywgZnNdLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtRnJvbVNvdXJjZShnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtRnJvbVNvdXJjZShnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyRnVuYyk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqICAgICAgICB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzaGFkZXJTb3VyY2VzIEFycmF5IG9mIHNvdXJjZXMgZm9yIHRoZVxuICogICAgICAgIHNoYWRlcnMuIFRoZSBmaXJzdCBpcyBhc3N1bWVkIHRvIGJlIHRoZSB2ZXJ0ZXggc2hhZGVyLFxuICogICAgICAgIHRoZSBzZWNvbmQgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuUHJvZ3JhbU9wdGlvbnN8c3RyaW5nW118bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9hdHRyaWJzXSBPcHRpb25zIGZvciB0aGUgcHJvZ3JhbSBvciBhbiBhcnJheSBvZiBhdHRyaWJzIG5hbWVzIG9yIGFuIGVycm9yIGNhbGxiYWNrLiBMb2NhdGlvbnMgd2lsbCBiZSBhc3NpZ25lZCBieSBpbmRleCBpZiBub3QgcGFzc2VkIGluXG4gKiBAcGFyYW0ge251bWJlcltdfSBbb3B0X2xvY2F0aW9uc3xtb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrXSBUaGUgbG9jYXRpb25zIGZvciB0aGUuIEEgcGFyYWxsZWwgYXJyYXkgdG8gb3B0X2F0dHJpYnMgbGV0dGluZyB5b3UgYXNzaWduIGxvY2F0aW9ucyBvciBhbiBlcnJvciBjYWxsYmFjay5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9lcnJvckNhbGxiYWNrXSBjYWxsYmFjayBmb3IgZXJyb3JzLiBCeSBkZWZhdWx0IGl0IGp1c3QgcHJpbnRzIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlXG4gKiAgICAgICAgb24gZXJyb3IuIElmIHlvdSB3YW50IHNvbWV0aGluZyBlbHNlIHBhc3MgYW4gY2FsbGJhY2suIEl0J3MgcGFzc2VkIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHtXZWJHTFByb2dyYW0/fSB0aGUgY3JlYXRlZCBwcm9ncmFtIG9yIG51bGwgaWYgZXJyb3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW1Gcm9tU291cmNlcyhnbCwgc2hhZGVyU291cmNlcywgb3B0X2F0dHJpYnMsIG9wdF9sb2NhdGlvbnMsIG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gIHZhciBwcm9nT3B0aW9ucyA9IGdldFByb2dyYW1PcHRpb25zKG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjayk7XG4gIHZhciBzaGFkZXJzID0gW107XG5cbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHNoYWRlclNvdXJjZXMubGVuZ3RoOyArK2lpKSB7XG4gICAgdmFyIHNoYWRlciA9IGxvYWRTaGFkZXIoZ2wsIHNoYWRlclNvdXJjZXNbaWldLCBnbFtkZWZhdWx0U2hhZGVyVHlwZVtpaV1dLCBwcm9nT3B0aW9ucy5lcnJvckNhbGxiYWNrKTtcblxuICAgIGlmICghc2hhZGVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzaGFkZXJzLnB1c2goc2hhZGVyKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVQcm9ncmFtKGdsLCBzaGFkZXJzLCBwcm9nT3B0aW9ucyk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhdHRyaWJ1dGUvdW5pZm9ybSBpcyBhIHJlc2VydmVkL2J1aWx0IGluXG4gKlxuICogSXQgbWFrZXMgbm8gc2Vuc2UgdG8gbWUgd2h5IEdMIHJldHVybnMgdGhlc2UgYmVjYXVzZSBpdCdzXG4gKiBpbGxlZ2FsIHRvIGNhbGwgYGdsLmdldFVuaWZvcm1Mb2NhdGlvbmAgYW5kIGBnbC5nZXRBdHRyaWJMb2NhdGlvbmBcbiAqIHdpdGggbmFtZXMgdGhhdCBzdGFydCB3aXRoIGBnbF9gIChhbmQgYHdlYmdsX2AgaW4gV2ViR0wpXG4gKlxuICogSSBjYW4gb25seSBhc3N1bWUgdGhleSBhcmUgdGhlcmUgYmVjYXVzZSB0aGV5IG1pZ2h0IGNvdW50XG4gKiB3aGVuIGNvbXB1dGluZyB0aGUgbnVtYmVyIG9mIHVuaWZvcm1zL2F0dHJpYnV0ZXMgdXNlZCB3aGVuIHlvdSB3YW50IHRvXG4gKiBrbm93IGlmIHlvdSBhcmUgbmVhciB0aGUgbGltaXQuIFRoYXQgZG9lc24ndCByZWFsbHkgbWFrZSBzZW5zZVxuICogdG8gbWUgYnV0IHRoZSBmYWN0IHRoYXQgdGhlc2UgZ2V0IHJldHVybmVkIGFyZSBpbiB0aGUgc3BlYy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMQWN0aXZlSW5mb30gaW5mbyBBcyByZXR1cm5lZCBmcm9tIGBnbC5nZXRBY3RpdmVVbmlmb3JtYCBvclxuICogICAgYGdsLmdldEFjdGl2ZUF0dHJpYmAuXG4gKiBAcmV0dXJuIHtib29sfSB0cnVlIGlmIGl0J3MgcmVzZXJ2ZWRcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBpc0J1aWx0SW4oaW5mbykge1xuICB2YXIgbmFtZSA9IGluZm8ubmFtZTtcbiAgcmV0dXJuIG5hbWUuc3RhcnRzV2l0aChcImdsX1wiKSB8fCBuYW1lLnN0YXJ0c1dpdGgoXCJ3ZWJnbF9cIik7XG59XG4vKipcbiAqIENyZWF0ZXMgc2V0dGVyIGZ1bmN0aW9ucyBmb3IgYWxsIHVuaWZvcm1zIG9mIGEgc2hhZGVyXG4gKiBwcm9ncmFtLlxuICpcbiAqIEBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLnNldFVuaWZvcm1zfVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHRvIHVzZS5cbiAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtIHRoZSBwcm9ncmFtIHRvIGNyZWF0ZSBzZXR0ZXJzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBhbiBvYmplY3Qgd2l0aCBhIHNldHRlciBieSBuYW1lIGZvciBlYWNoIHVuaWZvcm1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlVW5pZm9ybVNldHRlcnMoZ2wsIHByb2dyYW0pIHtcbiAgdmFyIHRleHR1cmVVbml0ID0gMDtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzZXR0ZXIgZm9yIGEgdW5pZm9ybSBvZiB0aGUgZ2l2ZW4gcHJvZ3JhbSB3aXRoIGl0J3NcbiAgICogbG9jYXRpb24gZW1iZWRkZWQgaW4gdGhlIHNldHRlci5cbiAgICogQHBhcmFtIHtXZWJHTFByb2dyYW19IHByb2dyYW1cbiAgICogQHBhcmFtIHtXZWJHTFVuaWZvcm1JbmZvfSB1bmlmb3JtSW5mb1xuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IHRoZSBjcmVhdGVkIHNldHRlci5cbiAgICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pZm9ybVNldHRlcihwcm9ncmFtLCB1bmlmb3JtSW5mbywgbG9jYXRpb24pIHtcbiAgICB2YXIgaXNBcnJheSA9IHVuaWZvcm1JbmZvLm5hbWUuZW5kc1dpdGgoXCJbMF1cIik7XG4gICAgdmFyIHR5cGUgPSB1bmlmb3JtSW5mby50eXBlO1xuICAgIHZhciB0eXBlSW5mbyA9IHR5cGVNYXBbdHlwZV07XG5cbiAgICBpZiAoIXR5cGVJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IDB4XCIuY29uY2F0KHR5cGUudG9TdHJpbmcoMTYpKSk7IC8vIHdlIHNob3VsZCBuZXZlciBnZXQgaGVyZS5cbiAgICB9XG5cbiAgICB2YXIgc2V0dGVyO1xuXG4gICAgaWYgKHR5cGVJbmZvLmJpbmRQb2ludCkge1xuICAgICAgLy8gaXQncyBhIHNhbXBsZXJcbiAgICAgIHZhciB1bml0ID0gdGV4dHVyZVVuaXQ7XG4gICAgICB0ZXh0dXJlVW5pdCArPSB1bmlmb3JtSW5mby5zaXplO1xuXG4gICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICBzZXR0ZXIgPSB0eXBlSW5mby5hcnJheVNldHRlcihnbCwgdHlwZSwgdW5pdCwgbG9jYXRpb24sIHVuaWZvcm1JbmZvLnNpemUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0dGVyID0gdHlwZUluZm8uc2V0dGVyKGdsLCB0eXBlLCB1bml0LCBsb2NhdGlvbiwgdW5pZm9ybUluZm8uc2l6ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlSW5mby5hcnJheVNldHRlciAmJiBpc0FycmF5KSB7XG4gICAgICAgIHNldHRlciA9IHR5cGVJbmZvLmFycmF5U2V0dGVyKGdsLCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXR0ZXIgPSB0eXBlSW5mby5zZXR0ZXIoZ2wsIGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXR0ZXIubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICByZXR1cm4gc2V0dGVyO1xuICB9XG5cbiAgdmFyIHVuaWZvcm1TZXR0ZXJzID0ge307XG4gIHZhciBudW1Vbmlmb3JtcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgQUNUSVZFX1VOSUZPUk1TKTtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbnVtVW5pZm9ybXM7ICsraWkpIHtcbiAgICB2YXIgdW5pZm9ybUluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGlpKTtcblxuICAgIGlmIChpc0J1aWx0SW4odW5pZm9ybUluZm8pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IHVuaWZvcm1JbmZvLm5hbWU7IC8vIHJlbW92ZSB0aGUgYXJyYXkgc3VmZml4LlxuXG4gICAgaWYgKG5hbWUuZW5kc1dpdGgoXCJbMF1cIikpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigwLCBuYW1lLmxlbmd0aCAtIDMpO1xuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtSW5mby5uYW1lKTsgLy8gdGhlIHVuaWZvcm0gd2lsbCBoYXZlIG5vIGxvY2F0aW9uIGlmIGl0J3MgaW4gYSB1bmlmb3JtIGJsb2NrXG5cbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIHVuaWZvcm1TZXR0ZXJzW25hbWVdID0gY3JlYXRlVW5pZm9ybVNldHRlcihwcm9ncmFtLCB1bmlmb3JtSW5mbywgbG9jYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmlmb3JtU2V0dGVycztcbn1cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVHJhbnNmb3JtRmVlZGJhY2tJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggaW5kZXggb2YgdHJhbnNmb3JtIGZlZWRiYWNrXG4gKiBAcHJvcGVydHkge251bWJlcn0gdHlwZSBHTCB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2l6ZSAxIC0gNFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgVHJhbnNmb3JtRmVlZGJhY2tJbmZvIGZvciBwYXNzaW5nIHRvIGJpbmRUcmFuc2Zvcm1GZWVkYmFja0luZm8uXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSBhbiBleGlzdGluZyBXZWJHTFByb2dyYW0uXG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5UcmFuc2Zvcm1GZWVkYmFja0luZm8+fVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1GZWVkYmFja0luZm8oZ2wsIHByb2dyYW0pIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgdmFyIG51bVZhcnlpbmdzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBUUkFOU0ZPUk1fRkVFREJBQ0tfVkFSWUlOR1MpO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1WYXJ5aW5nczsgKytpaSkge1xuICAgIHZhciB2YXJ5aW5nID0gZ2wuZ2V0VHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nKHByb2dyYW0sIGlpKTtcbiAgICBpbmZvW3ZhcnlpbmcubmFtZV0gPSB7XG4gICAgICBpbmRleDogaWksXG4gICAgICB0eXBlOiB2YXJ5aW5nLnR5cGUsXG4gICAgICBzaXplOiB2YXJ5aW5nLnNpemVcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIEJpbmRzIGJ1ZmZlcnMgZm9yIHRyYW5zZm9ybSBmZWVkYmFjay5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5UcmFuc2Zvcm1GZWVkYmFja0luZm8+KX0gdHJhbnNmb3JtRmVlZGJhY2tJbmZvIEEgUHJvZ3JhbUluZm8gb3IgVHJhbnNmb3JtRmVlZGJhY2tJbmZvLlxuICogQHBhcmFtIHsobW9kdWxlOnR3Z2wuQnVmZmVySW5mb3xPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5BdHRyaWJJbmZvPil9IFtidWZmZXJJbmZvXSBBIEJ1ZmZlckluZm8gb3Igc2V0IG9mIEF0dHJpYkluZm9zLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG5mdW5jdGlvbiBiaW5kVHJhbnNmb3JtRmVlZGJhY2tJbmZvKGdsLCB0cmFuc2Zvcm1GZWVkYmFja0luZm8sIGJ1ZmZlckluZm8pIHtcbiAgaWYgKHRyYW5zZm9ybUZlZWRiYWNrSW5mby50cmFuc2Zvcm1GZWVkYmFja0luZm8pIHtcbiAgICB0cmFuc2Zvcm1GZWVkYmFja0luZm8gPSB0cmFuc2Zvcm1GZWVkYmFja0luZm8udHJhbnNmb3JtRmVlZGJhY2tJbmZvO1xuICB9XG5cbiAgaWYgKGJ1ZmZlckluZm8uYXR0cmlicykge1xuICAgIGJ1ZmZlckluZm8gPSBidWZmZXJJbmZvLmF0dHJpYnM7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIGJ1ZmZlckluZm8pIHtcbiAgICB2YXIgdmFyeWluZyA9IHRyYW5zZm9ybUZlZWRiYWNrSW5mb1tuYW1lXTtcblxuICAgIGlmICh2YXJ5aW5nKSB7XG4gICAgICB2YXIgYnVmID0gYnVmZmVySW5mb1tuYW1lXTtcblxuICAgICAgaWYgKGJ1Zi5vZmZzZXQpIHtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlclJhbmdlKFRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIsIHZhcnlpbmcuaW5kZXgsIGJ1Zi5idWZmZXIsIGJ1Zi5vZmZzZXQsIGJ1Zi5zaXplKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmJpbmRCdWZmZXJCYXNlKFRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIsIHZhcnlpbmcuaW5kZXgsIGJ1Zi5idWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIGZlZWRiYWNrIGFuZCBzZXRzIHRoZSBidWZmZXJzXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfSBwcm9ncmFtSW5mbyBBIFByb2dyYW1JbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVByb2dyYW1JbmZvfVxuICogQHBhcmFtIHsobW9kdWxlOnR3Z2wuQnVmZmVySW5mb3xPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5BdHRyaWJJbmZvPil9IFtidWZmZXJJbmZvXSBBIEJ1ZmZlckluZm8gb3Igc2V0IG9mIEF0dHJpYkluZm9zLlxuICogQHJldHVybiB7V2ViR0xUcmFuc2Zvcm1GZWVkYmFja30gdGhlIGNyZWF0ZWQgdHJhbnNmb3JtIGZlZWRiYWNrXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrKGdsLCBwcm9ncmFtSW5mbywgYnVmZmVySW5mbykge1xuICB2YXIgdGYgPSBnbC5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFjaygpO1xuICBnbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soVFJBTlNGT1JNX0ZFRURCQUNLLCB0Zik7XG4gIGdsLnVzZVByb2dyYW0ocHJvZ3JhbUluZm8ucHJvZ3JhbSk7XG4gIGJpbmRUcmFuc2Zvcm1GZWVkYmFja0luZm8oZ2wsIHByb2dyYW1JbmZvLCBidWZmZXJJbmZvKTtcbiAgZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKFRSQU5TRk9STV9GRUVEQkFDSywgbnVsbCk7XG4gIHJldHVybiB0Zjtcbn1cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVW5pZm9ybURhdGFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0eXBlIFRoZSBXZWJHTCB0eXBlIGVudW0gZm9yIHRoaXMgdW5pZm9ybVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpemUgVGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3IgdGhpcyB1bmlmb3JtXG4gKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tOZHggVGhlIGJsb2NrIGluZGV4IHRoaXMgdW5pZm9ybSBhcHBlYXJzIGluXG4gKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0IFRoZSBieXRlIG9mZnNldCBpbiB0aGUgYmxvY2sgZm9yIHRoaXMgdW5pZm9ybSdzIHZhbHVlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIFRoZSBzcGVjaWZpY2F0aW9uIGZvciBvbmUgVW5pZm9ybUJsb2NrT2JqZWN0XG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQmxvY2tTcGVjXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBibG9jay5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaXplIFRoZSBzaXplIGluIGJ5dGVzIG5lZWRlZCBmb3IgdGhlIGJsb2NrXG4gKiBAcHJvcGVydHkge251bWJlcltdfSB1bmlmb3JtSW5kaWNlcyBUaGUgaW5kaWNlcyBvZiB0aGUgdW5pZm9ybXMgdXNlZCBieSB0aGUgYmxvY2suIFRoZXNlIGluZGljZXNcbiAqICAgIGNvcnJlc3BvbmQgdG8gZW50cmllcyBpbiBhIFVuaWZvcm1EYXRhIGFycmF5IGluIHRoZSB7QGxpbmsgbW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrU3BlY30uXG4gKiBAcHJvcGVydHkge2Jvb2x9IHVzZWRCeVZlcnRleFNoYWRlciBTZWxmIGV4cGxhbmF0b3J5XG4gKiBAcHJvcGVydHkge2Jvb2x9IHVzZWRCeUZyYWdtZW50U2hhZGVyIFNlbGYgZXhwbGFuYXRvcnlcbiAqIEBwcm9wZXJ0eSB7Ym9vbH0gdXNlZCBTZWxmIGV4cGxhbmF0b3J5XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEEgYFVuaWZvcm1CbG9ja1NwZWNgIHJlcHJlc2VudHMgdGhlIGRhdGEgbmVlZGVkIHRvIGNyZWF0ZSBhbmQgYmluZFxuICogVW5pZm9ybUJsb2NrT2JqZWN0cyBmb3IgYSBnaXZlbiBwcm9ncmFtXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVW5pZm9ybUJsb2NrU3BlY1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnR3Z2wuQmxvY2tTcGVjPiBibG9ja1NwZWNzIFRoZSBCbG9ja1NwZWMgZm9yIGVhY2ggYmxvY2sgYnkgYmxvY2sgbmFtZVxuICogQHByb3BlcnR5IHtVbmlmb3JtRGF0YVtdfSB1bmlmb3JtRGF0YSBBbiBhcnJheSBvZiBkYXRhIGZvciBlYWNoIHVuaWZvcm0gYnkgdW5pZm9ybSBpbmRleC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIFVuaWZvcm1CbG9ja1NwZWMgZm9yIHRoZSBnaXZlbiBwcm9ncmFtLlxuICpcbiAqIEEgVW5pZm9ybUJsb2NrU3BlYyByZXByZXNlbnRzIHRoZSBkYXRhIG5lZWRlZCB0byBjcmVhdGUgYW5kIGJpbmRcbiAqIFVuaWZvcm1CbG9ja09iamVjdHNcbiAqXG4gKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0wyIFJlbmRlcmluZyBDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSBBIFdlYkdMUHJvZ3JhbSBmb3IgYSBzdWNjZXNzZnVsbHkgbGlua2VkIHByb2dyYW1cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja1NwZWN9IFRoZSBjcmVhdGVkIFVuaWZvcm1CbG9ja1NwZWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtKGdsLCBwcm9ncmFtKSB7XG4gIHZhciBudW1Vbmlmb3JtcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgQUNUSVZFX1VOSUZPUk1TKTtcbiAgdmFyIHVuaWZvcm1EYXRhID0gW107XG4gIHZhciB1bmlmb3JtSW5kaWNlcyA9IFtdO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1Vbmlmb3JtczsgKytpaSkge1xuICAgIHVuaWZvcm1JbmRpY2VzLnB1c2goaWkpO1xuICAgIHVuaWZvcm1EYXRhLnB1c2goe30pO1xuICAgIHZhciB1bmlmb3JtSW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaWkpO1xuXG4gICAgaWYgKGlzQnVpbHRJbih1bmlmb3JtSW5mbykpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHVuaWZvcm1EYXRhW2lpXS5uYW1lID0gdW5pZm9ybUluZm8ubmFtZTtcbiAgfVxuXG4gIFtbXCJVTklGT1JNX1RZUEVcIiwgXCJ0eXBlXCJdLCBbXCJVTklGT1JNX1NJWkVcIiwgXCJzaXplXCJdLCAvLyBudW0gZWxlbWVudHNcbiAgW1wiVU5JRk9STV9CTE9DS19JTkRFWFwiLCBcImJsb2NrTmR4XCJdLCBbXCJVTklGT1JNX09GRlNFVFwiLCBcIm9mZnNldFwiXV0uZm9yRWFjaChmdW5jdGlvbiAocGFpcikge1xuICAgIHZhciBwbmFtZSA9IHBhaXJbMF07XG4gICAgdmFyIGtleSA9IHBhaXJbMV07XG4gICAgZ2wuZ2V0QWN0aXZlVW5pZm9ybXMocHJvZ3JhbSwgdW5pZm9ybUluZGljZXMsIGdsW3BuYW1lXSkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIG5keCkge1xuICAgICAgdW5pZm9ybURhdGFbbmR4XVtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gIH0pO1xuICB2YXIgYmxvY2tTcGVjcyA9IHt9O1xuICB2YXIgbnVtVW5pZm9ybUJsb2NrcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgQUNUSVZFX1VOSUZPUk1fQkxPQ0tTKTtcblxuICBmb3IgKHZhciBfaWkgPSAwOyBfaWkgPCBudW1Vbmlmb3JtQmxvY2tzOyArK19paSkge1xuICAgIHZhciBuYW1lID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybUJsb2NrTmFtZShwcm9ncmFtLCBfaWkpO1xuICAgIHZhciBibG9ja1NwZWMgPSB7XG4gICAgICBpbmRleDogZ2wuZ2V0VW5pZm9ybUJsb2NrSW5kZXgocHJvZ3JhbSwgbmFtZSksXG4gICAgICB1c2VkQnlWZXJ0ZXhTaGFkZXI6IGdsLmdldEFjdGl2ZVVuaWZvcm1CbG9ja1BhcmFtZXRlcihwcm9ncmFtLCBfaWksIFVOSUZPUk1fQkxPQ0tfUkVGRVJFTkNFRF9CWV9WRVJURVhfU0hBREVSKSxcbiAgICAgIHVzZWRCeUZyYWdtZW50U2hhZGVyOiBnbC5nZXRBY3RpdmVVbmlmb3JtQmxvY2tQYXJhbWV0ZXIocHJvZ3JhbSwgX2lpLCBVTklGT1JNX0JMT0NLX1JFRkVSRU5DRURfQllfRlJBR01FTlRfU0hBREVSKSxcbiAgICAgIHNpemU6IGdsLmdldEFjdGl2ZVVuaWZvcm1CbG9ja1BhcmFtZXRlcihwcm9ncmFtLCBfaWksIFVOSUZPUk1fQkxPQ0tfREFUQV9TSVpFKSxcbiAgICAgIHVuaWZvcm1JbmRpY2VzOiBnbC5nZXRBY3RpdmVVbmlmb3JtQmxvY2tQYXJhbWV0ZXIocHJvZ3JhbSwgX2lpLCBVTklGT1JNX0JMT0NLX0FDVElWRV9VTklGT1JNX0lORElDRVMpXG4gICAgfTtcbiAgICBibG9ja1NwZWMudXNlZCA9IGJsb2NrU3BlYy51c2VkQnlWZXJ0ZXhTaGFkZXIgfHwgYmxvY2tTcGVjLnVzZWRCeUZyYWdtZW50U2hhZGVyO1xuICAgIGJsb2NrU3BlY3NbbmFtZV0gPSBibG9ja1NwZWM7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJsb2NrU3BlY3M6IGJsb2NrU3BlY3MsXG4gICAgdW5pZm9ybURhdGE6IHVuaWZvcm1EYXRhXG4gIH07XG59XG5cbnZhciBhcnJheVN1ZmZpeFJFID0gL1xcW1xcZCtcXF1cXC4kLzsgLy8gYmV0dGVyIHdheSB0byBjaGVjaz9cblxudmFyIHBhZCA9IGZ1bmN0aW9uIHBhZCh2LCBwYWRkaW5nKSB7XG4gIHJldHVybiAoKHYgKyAocGFkZGluZyAtIDEpKSAvIHBhZGRpbmcgfCAwKSAqIHBhZGRpbmc7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVVbmlmb3JtQmxvY2tVbmlmb3JtU2V0dGVyKHZpZXcsIFR5cGUsIHR5cGVTaXplLCBwYWRkZWRTaXplLCBpc0FycmF5KSB7XG4gIGlmIChpc0FycmF5KSB7XG4gICAgdmFyIG51bUVsZW1lbnRzID0gdHlwZVNpemUgLyBUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIHZhciBudW1QYWRkZWRFbGVtZW50cyA9IHBhZGRlZFNpemUgLyBUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBkc3QgPSAwO1xuXG4gICAgICBmb3IgKHZhciBzcmMgPSAwOyBzcmMgPCB2YWx1ZS5sZW5ndGg7IHNyYyArPSBudW1FbGVtZW50cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVsZW1lbnRzOyArK2kpIHtcbiAgICAgICAgICB2aWV3W2RzdCArIGldID0gdmFsdWVbc3JjICsgaV07XG4gICAgICAgIH1cblxuICAgICAgICBkc3QgKz0gbnVtUGFkZGVkRWxlbWVudHM7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZpZXcuc2V0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZXdbMF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBVbmlmb3JtQmxvY2tPYmplY3QgaW5jbHVkaW5nIGFuIEFycmF5QnVmZmVyIHdpdGggYWxsIHRoZSB1bmlmb3JtIHZhbHVlc1xuICogYW5kIGEgY29ycmVzcG9uZGluZyBXZWJHTEJ1ZmZlciB0byBob2xkIHRob3NlIHZhbHVlcyBvbiB0aGUgR1BVXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVW5pZm9ybUJsb2NrSW5mb1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGJsb2NrXG4gKiBAcHJvcGVydHkge0FycmF5QnVmZmVyfSBhcnJheSBUaGUgYXJyYXkgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHVuaWZvcm0gdmFsdWVzXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gYXNGbG9hdCBBIGZsb2F0IHZpZXcgb24gdGhlIGFycmF5IGJ1ZmZlci4gVGhpcyBpcyB1c2VmdWxcbiAqICAgIGluc3BlY3RpbmcgdGhlIGNvbnRlbnRzIG9mIHRoZSBidWZmZXIgaW4gdGhlIGRlYnVnZ2VyLlxuICogQHByb3BlcnR5IHtXZWJHTEJ1ZmZlcn0gYnVmZmVyIEEgV2ViR0wgYnVmZmVyIHRoYXQgd2lsbCBob2xkIGEgY29weSBvZiB0aGUgdW5pZm9ybSB2YWx1ZXMgZm9yIHJlbmRlcmluZy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb2Zmc2V0XSBvZmZzZXQgaW50byBidWZmZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgQXJyYXlCdWZmZXJWaWV3Pn0gdW5pZm9ybXMgQSB1bmlmb3JtIG5hbWUgdG8gQXJyYXlCdWZmZXJWaWV3IG1hcC5cbiAqICAgZWFjaCBVbmlmb3JtIGhhcyBhIGNvcnJlY3RseSB0eXBlZCBgQXJyYXlCdWZmZXJWaWV3YCBpbnRvIGFycmF5IGF0IHRoZSBjb3JyZWN0IG9mZnNldFxuICogICBhbmQgbGVuZ3RoIG9mIHRoYXQgdW5pZm9ybS4gU28gZm9yIGV4YW1wbGUgYSBmbG9hdCB1bmlmb3JtIHdvdWxkIGhhdmUgYSAxIGZsb2F0IGBGbG9hdDMyQXJyYXlgXG4gKiAgIHZpZXcuIEEgc2luZ2xlIG1hdDQgd291bGQgaGF2ZSBhIDE2IGVsZW1lbnQgYEZsb2F0MzJBcnJheWAgdmlldy4gQW4gaXZlYzIgd291bGQgaGF2ZSBhblxuICogICBgSW50MzJBcnJheWAgdmlldywgZXRjLlxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBmdW5jdGlvbj59IHNldHRlcnMgQSBzZXR0ZXIgZm9yIHRoaXMgdW5pZm9ybS5cbiAqICAgVGhlIHJlYXNvbiB0byB1c2Ugc2V0dGVycyBpcyBlbGVtZW50cyBvZiBhcnJheXMgYXJlIHBhZGRlZCB0byB2ZWM0IHNpemVzIHdoaWNoXG4gKiAgIG1lYW5zIGlmIHlvdSB3YW50IHRvIHNldCBhbiBhcnJheSBvZiA0IGZsb2F0cyB5b3UnZCBuZWVkIHRvIHNldCAxNiB2YWx1ZXNcbiAqICAgKG9yIHNldCBlbGVtZW50cyAwLCA0LCA4LCAxMikuIEluIG90aGVyIHdvcmRzXG4gKiAgIGBzb21lQmxvY2tJbmZvLnVuaWZvcm1zLnNvbWU0RmxvYXRBcnJheVVuaWZvcm0uc2V0KFswLCAsICwgLCAxLCAsICwgLCAyLCAsICwgLCAzXSlgXG4gKiAgIHdoZXJlIGFzIHRoZSBzZXR0ZXIgaGFuZGxlcyBqdXN0IHBhc3NpbmcgaW4gWzAsIDEsIDIsIDNdIGVpdGhlciBkaXJlY3RseSBhcyBpblxuICogICBgc29tZUJsb2NrSW5mby5zZXR0ZXIuc29tZTRGbG9hdEFycmF5VW5pZm9ybS5zZXQoWzAsIDEsIDIsIDNdKWAgKG5vdCByZWNvbW1lbmRlZClcbiAqICAgb3IgdmlhIHtAbGluayBtb2R1bGU6dHdnbC5zZXRCbG9ja1VuaWZvcm1zfVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgYFVuaWZvcm1CbG9ja0luZm9gIGZvciB0aGUgc3BlY2lmaWVkIGJsb2NrXG4gKlxuICogTm90ZTogKipJZiB0aGUgYmxvY2tOYW1lIG1hdGNoZXMgbm8gZXhpc3RpbmcgYmxvY2tzIGEgd2FybmluZyBpcyBwcmludGVkIHRvIHRoZSBjb25zb2xlIGFuZCBhIGR1bW15XG4gKiBgVW5pZm9ybUJsb2NrSW5mb2AgaXMgcmV0dXJuZWQqKi4gVGhpcyBpcyBiZWNhdXNlIHdoZW4gZGVidWdnaW5nIEdMU0xcbiAqIGl0IGlzIGNvbW1vbiB0byBjb21tZW50IG91dCBsYXJnZSBwb3J0aW9ucyBvZiBhIHNoYWRlciBvciBmb3IgZXhhbXBsZSBzZXRcbiAqIHRoZSBmaW5hbCBvdXRwdXQgdG8gYSBjb25zdGFudC4gV2hlbiB0aGF0IGhhcHBlbnMgYmxvY2tzIGdldCBvcHRpbWl6ZWQgb3V0LlxuICogSWYgdGhpcyBmdW5jdGlvbiBkaWQgbm90IGNyZWF0ZSBkdW1teSBibG9ja3MgeW91ciBjb2RlIHdvdWxkIGNyYXNoIHdoZW4gZGVidWdnaW5nLlxuICpcbiAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSBBIFdlYkdMUHJvZ3JhbVxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tTcGVjfSB1bmlmb3JtQmxvY2tTcGVjLiBBIFVuaWZvcm1CbG9ja1NwZWMgYXMgcmV0dXJuZWRcbiAqICAgICBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVVbmlmb3JtQmxvY2tTcGVjRnJvbVByb2dyYW19LlxuICogQHBhcmFtIHtzdHJpbmd9IGJsb2NrTmFtZSBUaGUgbmFtZSBvZiB0aGUgYmxvY2suXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tJbmZvfSBUaGUgY3JlYXRlZCBVbmlmb3JtQmxvY2tJbmZvXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaWZvcm1CbG9ja0luZm9Gcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbSwgdW5pZm9ybUJsb2NrU3BlYywgYmxvY2tOYW1lKSB7XG4gIHZhciBibG9ja1NwZWNzID0gdW5pZm9ybUJsb2NrU3BlYy5ibG9ja1NwZWNzO1xuICB2YXIgdW5pZm9ybURhdGEgPSB1bmlmb3JtQmxvY2tTcGVjLnVuaWZvcm1EYXRhO1xuICB2YXIgYmxvY2tTcGVjID0gYmxvY2tTcGVjc1tibG9ja05hbWVdO1xuXG4gIGlmICghYmxvY2tTcGVjKSB7XG4gICAgd2FybihcIm5vIHVuaWZvcm0gYmxvY2sgb2JqZWN0IG5hbWVkOlwiLCBibG9ja05hbWUpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBibG9ja05hbWUsXG4gICAgICB1bmlmb3Jtczoge31cbiAgICB9O1xuICB9XG5cbiAgdmFyIGFycmF5ID0gbmV3IEFycmF5QnVmZmVyKGJsb2NrU3BlYy5zaXplKTtcbiAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICB2YXIgdW5pZm9ybUJ1ZmZlckluZGV4ID0gYmxvY2tTcGVjLmluZGV4O1xuICBnbC5iaW5kQnVmZmVyKFVOSUZPUk1fQlVGRkVSLCBidWZmZXIpO1xuICBnbC51bmlmb3JtQmxvY2tCaW5kaW5nKHByb2dyYW0sIGJsb2NrU3BlYy5pbmRleCwgdW5pZm9ybUJ1ZmZlckluZGV4KTtcbiAgdmFyIHByZWZpeCA9IGJsb2NrTmFtZSArIFwiLlwiO1xuXG4gIGlmIChhcnJheVN1ZmZpeFJFLnRlc3QocHJlZml4KSkge1xuICAgIHByZWZpeCA9IHByZWZpeC5yZXBsYWNlKGFycmF5U3VmZml4UkUsIFwiLlwiKTtcbiAgfVxuXG4gIHZhciB1bmlmb3JtcyA9IHt9O1xuICB2YXIgc2V0dGVycyA9IHt9O1xuICBibG9ja1NwZWMudW5pZm9ybUluZGljZXMuZm9yRWFjaChmdW5jdGlvbiAodW5pZm9ybU5keCkge1xuICAgIHZhciBkYXRhID0gdW5pZm9ybURhdGFbdW5pZm9ybU5keF07XG4gICAgdmFyIHR5cGVJbmZvID0gdHlwZU1hcFtkYXRhLnR5cGVdO1xuICAgIHZhciBUeXBlID0gdHlwZUluZm8uVHlwZTtcbiAgICB2YXIgcGFkZGVkU2l6ZSA9IHBhZCh0eXBlSW5mby5zaXplLCAxNik7XG4gICAgdmFyIGxlbmd0aCA9IHR5cGVJbmZvLnNpemUgKyAoZGF0YS5zaXplIC0gMSkgKiBwYWRkZWRTaXplO1xuICAgIHZhciBuYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIocHJlZml4Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIGlzQXJyYXkgPSBuYW1lLmVuZHNXaXRoKCdbMF0nKTtcblxuICAgIGlmIChpc0FycmF5KSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMCwgbmFtZS5sZW5ndGggLSAzKTtcbiAgICB9XG5cbiAgICB2YXIgdW5pZm9ybVZpZXcgPSBuZXcgVHlwZShhcnJheSwgZGF0YS5vZmZzZXQsIGxlbmd0aCAvIFR5cGUuQllURVNfUEVSX0VMRU1FTlQpO1xuICAgIHVuaWZvcm1zW25hbWVdID0gdW5pZm9ybVZpZXc7XG4gICAgc2V0dGVyc1tuYW1lXSA9IGNyZWF0ZVVuaWZvcm1CbG9ja1VuaWZvcm1TZXR0ZXIodW5pZm9ybVZpZXcsIFR5cGUsIHR5cGVJbmZvLnNpemUsIHBhZGRlZFNpemUsIGlzQXJyYXkpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBibG9ja05hbWUsXG4gICAgYXJyYXk6IGFycmF5LFxuICAgIGFzRmxvYXQ6IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkpLFxuICAgIC8vIGZvciBkZWJ1Z2dpbmdcbiAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICB1bmlmb3JtczogdW5pZm9ybXMsXG4gICAgc2V0dGVyczogc2V0dGVyc1xuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFVuaWZvcm1CbG9ja0luZm9gIGZvciB0aGUgc3BlY2lmaWVkIGJsb2NrXG4gKlxuICogTm90ZTogKipJZiB0aGUgYmxvY2tOYW1lIG1hdGNoZXMgbm8gZXhpc3RpbmcgYmxvY2tzIGEgd2FybmluZyBpcyBwcmludGVkIHRvIHRoZSBjb25zb2xlIGFuZCBhIGR1bW15XG4gKiBgVW5pZm9ybUJsb2NrSW5mb2AgaXMgcmV0dXJuZWQqKi4gVGhpcyBpcyBiZWNhdXNlIHdoZW4gZGVidWdnaW5nIEdMU0xcbiAqIGl0IGlzIGNvbW1vbiB0byBjb21tZW50IG91dCBsYXJnZSBwb3J0aW9ucyBvZiBhIHNoYWRlciBvciBmb3IgZXhhbXBsZSBzZXRcbiAqIHRoZSBmaW5hbCBvdXRwdXQgdG8gYSBjb25zdGFudC4gV2hlbiB0aGF0IGhhcHBlbnMgYmxvY2tzIGdldCBvcHRpbWl6ZWQgb3V0LlxuICogSWYgdGhpcyBmdW5jdGlvbiBkaWQgbm90IGNyZWF0ZSBkdW1teSBibG9ja3MgeW91ciBjb2RlIHdvdWxkIGNyYXNoIHdoZW4gZGVidWdnaW5nLlxuICpcbiAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfSBwcm9ncmFtSW5mbyBhIGBQcm9ncmFtSW5mb2BcbiAqICAgICBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVQcm9ncmFtSW5mb31cbiAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja05hbWUgVGhlIG5hbWUgb2YgdGhlIGJsb2NrLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrSW5mb30gVGhlIGNyZWF0ZWQgVW5pZm9ybUJsb2NrSW5mb1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvKGdsLCBwcm9ncmFtSW5mbywgYmxvY2tOYW1lKSB7XG4gIHJldHVybiBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvRnJvbVByb2dyYW0oZ2wsIHByb2dyYW1JbmZvLnByb2dyYW0sIHByb2dyYW1JbmZvLnVuaWZvcm1CbG9ja1NwZWMsIGJsb2NrTmFtZSk7XG59XG4vKipcbiAqIEJpbmRzIGEgdW5pZm9ybSBibG9jayB0byB0aGUgbWF0Y2hpbmcgdW5pZm9ybSBibG9jayBwb2ludC5cbiAqIE1hdGNoZXMgYnkgYmxvY2tzIGJ5IG5hbWUgc28gYmxvY2tzIG11c3QgaGF2ZSB0aGUgc2FtZSBuYW1lIG5vdCBqdXN0IHRoZSBzYW1lXG4gKiBzdHJ1Y3R1cmUuXG4gKlxuICogSWYgeW91IGhhdmUgY2hhbmdlZCBhbnkgdmFsdWVzIGFuZCB5b3UgdXBsb2FkIHRoZSB2YWx1ZXMgaW50byB0aGUgY29ycmVzcG9uZGluZyBXZWJHTEJ1ZmZlclxuICogY2FsbCB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0VW5pZm9ybUJsb2NrfSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTCAyIHJlbmRlcmluZyBjb250ZXh0LlxuICogQHBhcmFtIHsobW9kdWxlOnR3Z2wuUHJvZ3JhbUluZm98bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrU3BlYyl9IHByb2dyYW1JbmZvIGEgYFByb2dyYW1JbmZvYFxuICogICAgIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVByb2dyYW1JbmZvfSBvciBvciBgVW5pZm9ybUJsb2NrU3BlY2AgYXNcbiAqICAgICByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVVbmlmb3JtQmxvY2tTcGVjRnJvbVByb2dyYW19LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tJbmZvfSB1bmlmb3JtQmxvY2tJbmZvIGEgYFVuaWZvcm1CbG9ja0luZm9gIGFzIHJldHVybmVkIGZyb21cbiAqICAgICB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVW5pZm9ybUJsb2NrSW5mb30uXG4gKiBAcmV0dXJuIHtib29sfSB0cnVlIGlmIGJ1ZmZlciB3YXMgYm91bmQuIElmIHRoZSBwcm9ncmFtSW5mbyBoYXMgbm8gYmxvY2sgd2l0aCB0aGUgc2FtZSBibG9jayBuYW1lXG4gKiAgICAgbm8gYnVmZmVyIGlzIGJvdW5kLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cblxuXG5mdW5jdGlvbiBiaW5kVW5pZm9ybUJsb2NrKGdsLCBwcm9ncmFtSW5mbywgdW5pZm9ybUJsb2NrSW5mbykge1xuICB2YXIgdW5pZm9ybUJsb2NrU3BlYyA9IHByb2dyYW1JbmZvLnVuaWZvcm1CbG9ja1NwZWMgfHwgcHJvZ3JhbUluZm87XG4gIHZhciBibG9ja1NwZWMgPSB1bmlmb3JtQmxvY2tTcGVjLmJsb2NrU3BlY3NbdW5pZm9ybUJsb2NrSW5mby5uYW1lXTtcblxuICBpZiAoYmxvY2tTcGVjKSB7XG4gICAgdmFyIGJ1ZmZlckJpbmRJbmRleCA9IGJsb2NrU3BlYy5pbmRleDtcbiAgICBnbC5iaW5kQnVmZmVyUmFuZ2UoVU5JRk9STV9CVUZGRVIsIGJ1ZmZlckJpbmRJbmRleCwgdW5pZm9ybUJsb2NrSW5mby5idWZmZXIsIHVuaWZvcm1CbG9ja0luZm8ub2Zmc2V0IHx8IDAsIHVuaWZvcm1CbG9ja0luZm8uYXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFVwbG9hZHMgdGhlIGN1cnJlbnQgdW5pZm9ybSB2YWx1ZXMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgV2ViR0xCdWZmZXJcbiAqIGFuZCBiaW5kcyB0aGF0IGJ1ZmZlciB0byB0aGUgcHJvZ3JhbSdzIGNvcnJlc3BvbmRpbmcgYmluZCBwb2ludCBmb3IgdGhlIHVuaWZvcm0gYmxvY2sgb2JqZWN0LlxuICpcbiAqIElmIHlvdSBoYXZlbid0IGNoYW5nZWQgYW55IHZhbHVlcyBhbmQgeW91IG9ubHkgbmVlZCB0byBiaW5kIHRoZSB1bmlmb3JtIGJsb2NrIG9iamVjdFxuICogY2FsbCB7QGxpbmsgbW9kdWxlOnR3Z2wuYmluZFVuaWZvcm1CbG9ja30gaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0wgMiByZW5kZXJpbmcgY29udGV4dC5cbiAqIEBwYXJhbSB7KG1vZHVsZTp0d2dsLlByb2dyYW1JbmZvfG1vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja1NwZWMpfSBwcm9ncmFtSW5mbyBhIGBQcm9ncmFtSW5mb2BcbiAqICAgICBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVQcm9ncmFtSW5mb30gb3Igb3IgYFVuaWZvcm1CbG9ja1NwZWNgIGFzXG4gKiAgICAgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtfS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrSW5mb30gdW5pZm9ybUJsb2NrSW5mbyBhIGBVbmlmb3JtQmxvY2tJbmZvYCBhcyByZXR1cm5lZCBmcm9tXG4gKiAgICAge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVVuaWZvcm1CbG9ja0luZm99LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRVbmlmb3JtQmxvY2soZ2wsIHByb2dyYW1JbmZvLCB1bmlmb3JtQmxvY2tJbmZvKSB7XG4gIGlmIChiaW5kVW5pZm9ybUJsb2NrKGdsLCBwcm9ncmFtSW5mbywgdW5pZm9ybUJsb2NrSW5mbykpIHtcbiAgICBnbC5idWZmZXJEYXRhKFVOSUZPUk1fQlVGRkVSLCB1bmlmb3JtQmxvY2tJbmZvLmFycmF5LCBEWU5BTUlDX0RSQVcpO1xuICB9XG59XG4vKipcbiAqIFNldHMgdmFsdWVzIG9mIGEgdW5pZm9ybSBibG9jayBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja0luZm99IHVuaWZvcm1CbG9ja0luZm8gQSBVbmlmb3JtQmxvY2tJbmZvIGFzIHJldHVybmVkIGJ5IHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVVbmlmb3JtQmxvY2tJbmZvfS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsID8+fSB2YWx1ZXMgQSB1bmlmb3JtIG5hbWUgdG8gdmFsdWUgbWFwIHdoZXJlIHRoZSB2YWx1ZSBpcyBjb3JyZWN0IGZvciB0aGUgZ2l2ZW5cbiAqICAgIHR5cGUgb2YgdW5pZm9ybS4gU28gZm9yIGV4YW1wbGUgZ2l2ZW4gYSBibG9jayBsaWtlXG4gKlxuICogICAgICAgdW5pZm9ybSBTb21lQmxvY2sge1xuICogICAgICAgICBmbG9hdCBzb21lRmxvYXQ7XG4gKiAgICAgICAgIHZlYzIgc29tZVZlYzI7XG4gKiAgICAgICAgIHZlYzMgc29tZVZlYzNBcnJheVsyXTtcbiAqICAgICAgICAgaW50IHNvbWVJbnQ7XG4gKiAgICAgICB9XG4gKlxuICogIFlvdSBjYW4gc2V0IHRoZSB2YWx1ZXMgb2YgdGhlIHVuaWZvcm0gYmxvY2sgd2l0aFxuICpcbiAqICAgICAgIHR3Z2wuc2V0QmxvY2tVbmlmb3Jtcyhzb21lQmxvY2tJbmZvLCB7XG4gKiAgICAgICAgICBzb21lRmxvYXQ6IDEyLjMsXG4gKiAgICAgICAgICBzb21lVmVjMjogWzEsIDJdLFxuICogICAgICAgICAgc29tZVZlYzNBcnJheTogWzEsIDIsIDMsIDQsIDUsIDZdLFxuICogICAgICAgICAgc29tZUludDogNSxcbiAqICAgICAgIH1cbiAqXG4gKiAgQXJyYXlzIGNhbiBiZSBKYXZhU2NyaXB0IGFycmF5cyBvciB0eXBlZCBhcnJheXNcbiAqXG4gKiAgQW55IG5hbWUgdGhhdCBkb2Vzbid0IG1hdGNoIHdpbGwgYmUgaWdub3JlZFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRCbG9ja1VuaWZvcm1zKHVuaWZvcm1CbG9ja0luZm8sIHZhbHVlcykge1xuICB2YXIgc2V0dGVycyA9IHVuaWZvcm1CbG9ja0luZm8uc2V0dGVycztcblxuICBmb3IgKHZhciBuYW1lIGluIHZhbHVlcykge1xuICAgIHZhciBzZXR0ZXIgPSBzZXR0ZXJzW25hbWVdO1xuXG4gICAgaWYgKHNldHRlcikge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW25hbWVdO1xuICAgICAgc2V0dGVyKHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogU2V0IHVuaWZvcm1zIGFuZCBiaW5kcyByZWxhdGVkIHRleHR1cmVzLlxuICpcbiAqIGV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHByb2dyYW1JbmZvID0gY3JlYXRlUHJvZ3JhbUluZm8oXG4gKiAgICAgICAgIGdsLCBbXCJzb21lLXZzXCIsIFwic29tZS1mc1wiXSk7XG4gKlxuICogICAgIGNvbnN0IHRleDEgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gKiAgICAgY29uc3QgdGV4MiA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAqXG4gKiAgICAgLi4uIGFzc3VtZSB3ZSBzZXR1cCB0aGUgdGV4dHVyZXMgd2l0aCBkYXRhIC4uLlxuICpcbiAqICAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAqICAgICAgIHVfc29tZVNhbXBsZXI6IHRleDEsXG4gKiAgICAgICB1X3NvbWVPdGhlclNhbXBsZXI6IHRleDIsXG4gKiAgICAgICB1X3NvbWVDb2xvcjogWzEsMCwwLDFdLFxuICogICAgICAgdV9zb21lUG9zaXRpb246IFswLDEsMV0sXG4gKiAgICAgICB1X3NvbWVNYXRyaXg6IFtcbiAqICAgICAgICAgMSwwLDAsMCxcbiAqICAgICAgICAgMCwxLDAsMCxcbiAqICAgICAgICAgMCwwLDEsMCxcbiAqICAgICAgICAgMCwwLDAsMCxcbiAqICAgICAgIF0sXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAqXG4gKiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSBiaW5kIHRoZSB0ZXh0dXJlcyBBTkQgc2V0IHRoZVxuICogdW5pZm9ybXMuXG4gKlxuICogICAgIHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIHVuaWZvcm1zKTtcbiAqXG4gKiBGb3IgdGhlIGV4YW1wbGUgYWJvdmUgaXQgaXMgZXF1aXZhbGVudCB0b1xuICpcbiAqICAgICB2YXIgdGV4VW5pdCA9IDA7XG4gKiAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleFVuaXQpO1xuICogICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleDEpO1xuICogICAgIGdsLnVuaWZvcm0xaSh1X3NvbWVTYW1wbGVyTG9jYXRpb24sIHRleFVuaXQrKyk7XG4gKiAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleFVuaXQpO1xuICogICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleDIpO1xuICogICAgIGdsLnVuaWZvcm0xaSh1X3NvbWVTYW1wbGVyTG9jYXRpb24sIHRleFVuaXQrKyk7XG4gKiAgICAgZ2wudW5pZm9ybTRmdih1X3NvbWVDb2xvckxvY2F0aW9uLCBbMSwgMCwgMCwgMV0pO1xuICogICAgIGdsLnVuaWZvcm0zZnYodV9zb21lUG9zaXRpb25Mb2NhdGlvbiwgWzAsIDEsIDFdKTtcbiAqICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHVfc29tZU1hdHJpeCwgZmFsc2UsIFtcbiAqICAgICAgICAgMSwwLDAsMCxcbiAqICAgICAgICAgMCwxLDAsMCxcbiAqICAgICAgICAgMCwwLDEsMCxcbiAqICAgICAgICAgMCwwLDAsMCxcbiAqICAgICAgIF0pO1xuICpcbiAqIE5vdGUgaXQgaXMgcGVyZmVjdGx5IHJlYXNvbmFibGUgdG8gY2FsbCBgc2V0VW5pZm9ybXNgIG11bHRpcGxlIHRpbWVzLiBGb3IgZXhhbXBsZVxuICpcbiAqICAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAqICAgICAgIHVfc29tZVNhbXBsZXI6IHRleDEsXG4gKiAgICAgICB1X3NvbWVPdGhlclNhbXBsZXI6IHRleDIsXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgY29uc3QgbW9yZVVuaWZvcm1zIHtcbiAqICAgICAgIHVfc29tZUNvbG9yOiBbMSwwLDAsMV0sXG4gKiAgICAgICB1X3NvbWVQb3NpdGlvbjogWzAsMSwxXSxcbiAqICAgICAgIHVfc29tZU1hdHJpeDogW1xuICogICAgICAgICAxLDAsMCwwLFxuICogICAgICAgICAwLDEsMCwwLFxuICogICAgICAgICAwLDAsMSwwLFxuICogICAgICAgICAwLDAsMCwwLFxuICogICAgICAgXSxcbiAqICAgICB9O1xuICpcbiAqICAgICB0d2dsLnNldFVuaWZvcm1zKHByb2dyYW1JbmZvLCB1bmlmb3Jtcyk7XG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgbW9yZVVuaWZvcm1zKTtcbiAqXG4gKiBZb3UgY2FuIGFsc28gYWRkIFdlYkdMU2FtcGxlcnMgdG8gdW5pZm9ybSBzYW1wbGVycyBhcyBpblxuICpcbiAqICAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAqICAgICAgIHVfc29tZVNhbXBsZXI6IHtcbiAqICAgICAgICAgdGV4dHVyZTogc29tZVdlYkdMVGV4dHVyZSxcbiAqICAgICAgICAgc2FtcGxlcjogc29tZVdlYkdMU2FtcGxlcixcbiAqICAgICAgIH0sXG4gKiAgICAgfTtcbiAqXG4gKiBJbiB3aGljaCBjYXNlIGJvdGggdGhlIHNhbXBsZXIgYW5kIHRleHR1cmUgd2lsbCBiZSBib3VuZCB0byB0aGVcbiAqIHNhbWUgdW5pdC5cbiAqXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+KX0gc2V0dGVycyBhIGBQcm9ncmFtSW5mb2AgYXMgcmV0dXJuZWQgZnJvbSBgY3JlYXRlUHJvZ3JhbUluZm9gIG9yIHRoZSBzZXR0ZXJzIHJldHVybmVkIGZyb21cbiAqICAgICAgICBgY3JlYXRlVW5pZm9ybVNldHRlcnNgLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgPz59IHZhbHVlcyBhbiBvYmplY3Qgd2l0aCB2YWx1ZXMgZm9yIHRoZVxuICogICAgICAgIHVuaWZvcm1zLlxuICogICBZb3UgY2FuIHBhc3MgbXVsdGlwbGUgb2JqZWN0cyBieSBwdXR0aW5nIHRoZW0gaW4gYW4gYXJyYXkgb3IgYnkgY2FsbGluZyB3aXRoIG1vcmUgYXJndW1lbnRzLkZvciBleGFtcGxlXG4gKlxuICogICAgIGNvbnN0IHNoYXJlZFVuaWZvcm1zID0ge1xuICogICAgICAgdV9mb2dOZWFyOiAxMCxcbiAqICAgICAgIHVfcHJvamVjdGlvbjogLi4uXG4gKiAgICAgICAuLi5cbiAqICAgICB9O1xuICpcbiAqICAgICBjb25zdCBsb2NhbFVuaWZvcm1zID0ge1xuICogICAgICAgdV93b3JsZDogLi4uXG4gKiAgICAgICB1X2RpZmZ1c2VDb2xvcjogLi4uXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgc2hhcmVkVW5pZm9ybXMsIGxvY2FsVW5pZm9ybXMpO1xuICpcbiAqICAgICAvLyBpcyB0aGUgc2FtZSBhc1xuICpcbiAqICAgICB0d2dsLnNldFVuaWZvcm1zKHByb2dyYW1JbmZvLCBbc2hhcmVkVW5pZm9ybXMsIGxvY2FsVW5pZm9ybXNdKTtcbiAqXG4gKiAgICAgLy8gaXMgdGhlIHNhbWUgYXNcbiAqXG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgc2hhcmVkVW5pZm9ybXMpO1xuICogICAgIHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIGxvY2FsVW5pZm9ybXN9O1xuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gc2V0VW5pZm9ybXMoc2V0dGVycywgdmFsdWVzKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGFjdHVhbFNldHRlcnMgPSBzZXR0ZXJzLnVuaWZvcm1TZXR0ZXJzIHx8IHNldHRlcnM7XG4gIHZhciBudW1BcmdzID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICBmb3IgKHZhciBhTmR4ID0gMTsgYU5keCA8IG51bUFyZ3M7ICsrYU5keCkge1xuICAgIHZhciBfdmFsdWVzID0gYXJndW1lbnRzW2FOZHhdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX3ZhbHVlcykpIHtcbiAgICAgIHZhciBudW1WYWx1ZXMgPSBfdmFsdWVzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG51bVZhbHVlczsgKytpaSkge1xuICAgICAgICBzZXRVbmlmb3JtcyhhY3R1YWxTZXR0ZXJzLCBfdmFsdWVzW2lpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gX3ZhbHVlcykge1xuICAgICAgICB2YXIgc2V0dGVyID0gYWN0dWFsU2V0dGVyc1tuYW1lXTtcblxuICAgICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgICAgc2V0dGVyKF92YWx1ZXNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEFsaWFzIGZvciBgc2V0VW5pZm9ybXNgXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7KG1vZHVsZTp0d2dsLlByb2dyYW1JbmZvfE9iamVjdC48c3RyaW5nLCBmdW5jdGlvbj4pfSBzZXR0ZXJzIGEgYFByb2dyYW1JbmZvYCBhcyByZXR1cm5lZCBmcm9tIGBjcmVhdGVQcm9ncmFtSW5mb2Agb3IgdGhlIHNldHRlcnMgcmV0dXJuZWQgZnJvbVxuICogICAgICAgIGBjcmVhdGVVbmlmb3JtU2V0dGVyc2AuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCA/Pn0gdmFsdWVzIGFuIG9iamVjdCB3aXRoIHZhbHVlcyBmb3IgdGhlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuXG5cbnZhciBzZXRVbmlmb3Jtc0FuZEJpbmRUZXh0dXJlcyA9IHNldFVuaWZvcm1zO1xuLyoqXG4gKiBDcmVhdGVzIHNldHRlciBmdW5jdGlvbnMgZm9yIGFsbCBhdHRyaWJ1dGVzIG9mIGEgc2hhZGVyXG4gKiBwcm9ncmFtLiBZb3UgY2FuIHBhc3MgdGhpcyB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXN9IHRvIHNldCBhbGwgeW91ciBidWZmZXJzIGFuZCBhdHRyaWJ1dGVzLlxuICpcbiAqIEBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLnNldEF0dHJpYnV0ZXN9IGZvciBleGFtcGxlXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSB0aGUgcHJvZ3JhbSB0byBjcmVhdGUgc2V0dGVycyBmb3IuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBhbiBvYmplY3Qgd2l0aCBhIHNldHRlciBmb3IgZWFjaCBhdHRyaWJ1dGUgYnkgbmFtZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cbmV4cG9ydHMuc2V0VW5pZm9ybXNBbmRCaW5kVGV4dHVyZXMgPSBzZXRVbmlmb3Jtc0FuZEJpbmRUZXh0dXJlcztcblxuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlU2V0dGVycyhnbCwgcHJvZ3JhbSkge1xuICB2YXIgYXR0cmliU2V0dGVycyA9IHt9O1xuICB2YXIgbnVtQXR0cmlicyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgQUNUSVZFX0FUVFJJQlVURVMpO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1BdHRyaWJzOyArK2lpKSB7XG4gICAgdmFyIGF0dHJpYkluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaWkpO1xuXG4gICAgaWYgKGlzQnVpbHRJbihhdHRyaWJJbmZvKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmliSW5mby5uYW1lKTtcbiAgICB2YXIgdHlwZUluZm8gPSBhdHRyVHlwZU1hcFthdHRyaWJJbmZvLnR5cGVdO1xuICAgIHZhciBzZXR0ZXIgPSB0eXBlSW5mby5zZXR0ZXIoZ2wsIGluZGV4LCB0eXBlSW5mbyk7XG4gICAgc2V0dGVyLmxvY2F0aW9uID0gaW5kZXg7XG4gICAgYXR0cmliU2V0dGVyc1thdHRyaWJJbmZvLm5hbWVdID0gc2V0dGVyO1xuICB9XG5cbiAgcmV0dXJuIGF0dHJpYlNldHRlcnM7XG59XG4vKipcbiAqIFNldHMgYXR0cmlidXRlcyBhbmQgYmluZHMgYnVmZmVycyAoZGVwcmVjYXRlZC4uLiB1c2Uge0BsaW5rIG1vZHVsZTp0d2dsLnNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzfSlcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzKFxuICogICAgICAgICBnbCwgW1wic29tZS12c1wiLCBcInNvbWUtZnNcIik7XG4gKlxuICogICAgIGNvbnN0IGF0dHJpYlNldHRlcnMgPSBjcmVhdGVBdHRyaWJ1dGVTZXR0ZXJzKHByb2dyYW0pO1xuICpcbiAqICAgICBjb25zdCBwb3NpdGlvbkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICogICAgIGNvbnN0IHRleGNvb3JkQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gKlxuICogICAgIGNvbnN0IGF0dHJpYnMgPSB7XG4gKiAgICAgICBhX3Bvc2l0aW9uOiB7YnVmZmVyOiBwb3NpdGlvbkJ1ZmZlciwgbnVtQ29tcG9uZW50czogM30sXG4gKiAgICAgICBhX3RleGNvb3JkOiB7YnVmZmVyOiB0ZXhjb29yZEJ1ZmZlciwgbnVtQ29tcG9uZW50czogMn0sXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAqXG4gKiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSBiaW5kIHRoZSBidWZmZXJzIEFORCBzZXQgdGhlXG4gKiBhdHRyaWJ1dGVzLlxuICpcbiAqICAgICBzZXRBdHRyaWJ1dGVzKGF0dHJpYlNldHRlcnMsIGF0dHJpYnMpO1xuICpcbiAqIFByb3BlcnRpZXMgb2YgYXR0cmlicy4gRm9yIGVhY2ggYXR0cmliIHlvdSBjYW4gYWRkXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICogICB0eXBlOiB0aGUgdHlwZSBvZiBkYXRhIGluIHRoZSBidWZmZXIuIERlZmF1bHQgPSBnbC5GTE9BVFxuICogKiAgIG5vcm1hbGl6ZTogd2hldGhlciBvciBub3QgdG8gbm9ybWFsaXplIHRoZSBkYXRhLiBEZWZhdWx0ID0gZmFsc2VcbiAqICogICBzdHJpZGU6IHRoZSBzdHJpZGUuIERlZmF1bHQgPSAwXG4gKiAqICAgb2Zmc2V0OiBvZmZzZXQgaW50byB0aGUgYnVmZmVyLiBEZWZhdWx0ID0gMFxuICogKiAgIGRpdmlzb3I6IHRoZSBkaXZpc29yIGZvciBpbnN0YW5jZXMuIERlZmF1bHQgPSB1bmRlZmluZWRcbiAqXG4gKiBGb3IgZXhhbXBsZSBpZiB5b3UgaGFkIDMgdmFsdWUgZmxvYXQgcG9zaXRpb25zLCAyIHZhbHVlXG4gKiBmbG9hdCB0ZXhjb29yZCBhbmQgNCB2YWx1ZSB1aW50OCBjb2xvcnMgeW91J2Qgc2V0dXAgeW91clxuICogYXR0cmlicyBsaWtlIHRoaXNcbiAqXG4gKiAgICAgY29uc3QgYXR0cmlicyA9IHtcbiAqICAgICAgIGFfcG9zaXRpb246IHtidWZmZXI6IHBvc2l0aW9uQnVmZmVyLCBudW1Db21wb25lbnRzOiAzfSxcbiAqICAgICAgIGFfdGV4Y29vcmQ6IHtidWZmZXI6IHRleGNvb3JkQnVmZmVyLCBudW1Db21wb25lbnRzOiAyfSxcbiAqICAgICAgIGFfY29sb3I6IHtcbiAqICAgICAgICAgYnVmZmVyOiBjb2xvckJ1ZmZlcixcbiAqICAgICAgICAgbnVtQ29tcG9uZW50czogNCxcbiAqICAgICAgICAgdHlwZTogZ2wuVU5TSUdORURfQllURSxcbiAqICAgICAgICAgbm9ybWFsaXplOiB0cnVlLFxuICogICAgICAgfSxcbiAqICAgICB9O1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn0gc2V0dGVycyBBdHRyaWJ1dGUgc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUF0dHJpYnV0ZVNldHRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkF0dHJpYkluZm8+fSBidWZmZXJzIEF0dHJpYkluZm9zIG1hcHBlZCBieSBhdHRyaWJ1dGUgbmFtZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayBtb2R1bGU6dHdnbC5zZXRCdWZmZXJzQW5kQXR0cmlidXRlc31cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoc2V0dGVycywgYnVmZmVycykge1xuICBmb3IgKHZhciBuYW1lIGluIGJ1ZmZlcnMpIHtcbiAgICB2YXIgc2V0dGVyID0gc2V0dGVyc1tuYW1lXTtcblxuICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgIHNldHRlcihidWZmZXJzW25hbWVdKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogU2V0cyBhdHRyaWJ1dGVzIGFuZCBidWZmZXJzIGluY2x1ZGluZyB0aGUgYEVMRU1FTlRfQVJSQVlfQlVGRkVSYCBpZiBhcHByb3ByaWF0ZVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHByb2dyYW1JbmZvID0gY3JlYXRlUHJvZ3JhbUluZm8oXG4gKiAgICAgICAgIGdsLCBbXCJzb21lLXZzXCIsIFwic29tZS1mc1wiKTtcbiAqXG4gKiAgICAgY29uc3QgYXJyYXlzID0ge1xuICogICAgICAgcG9zaXRpb246IHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDAsIDAsIDEwLCAwLCAwLCAwLCAxMCwgMCwgMTAsIDEwLCAwXSwgfSxcbiAqICAgICAgIHRleGNvb3JkOiB7IG51bUNvbXBvbmVudHM6IDIsIGRhdGE6IFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSwgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgY29uc3QgYnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzKGdsLCBhcnJheXMpO1xuICpcbiAqICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW1JbmZvLnByb2dyYW0pO1xuICpcbiAqIFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IGJpbmQgdGhlIGJ1ZmZlcnMgQU5EIHNldCB0aGVcbiAqIGF0dHJpYnV0ZXMuXG4gKlxuICogICAgIHNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzKGdsLCBwcm9ncmFtSW5mbywgYnVmZmVySW5mbyk7XG4gKlxuICogRm9yIHRoZSBleGFtcGxlIGFib3ZlIGl0IGlzIGVxdWl2YWxlbnQgdG9cbiAqXG4gKiAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uQnVmZmVyKTtcbiAqICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX3Bvc2l0aW9uTG9jYXRpb24pO1xuICogICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9wb3NpdGlvbkxvY2F0aW9uLCAzLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICogICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0ZXhjb29yZEJ1ZmZlcik7XG4gKiAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV90ZXhjb29yZExvY2F0aW9uKTtcbiAqICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfdGV4Y29vcmRMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+KX0gc2V0dGVycyBBIGBQcm9ncmFtSW5mb2AgYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlUHJvZ3JhbUluZm99IG9yIEF0dHJpYnV0ZSBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUF0dHJpYnV0ZVNldHRlcnN9XG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5CdWZmZXJJbmZvfG1vZHVsZTp0d2dsLlZlcnRleEFycmF5SW5mbyl9IGJ1ZmZlcnMgYSBgQnVmZmVySW5mb2AgYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXN9LlxuICogICBvciBhIGBWZXJ0ZXhBcnJheUluZm9gIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVZlcnRleEFycmF5SW5mb31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXMoZ2wsIHByb2dyYW1JbmZvLCBidWZmZXJzKSB7XG4gIGlmIChidWZmZXJzLnZlcnRleEFycmF5T2JqZWN0KSB7XG4gICAgZ2wuYmluZFZlcnRleEFycmF5KGJ1ZmZlcnMudmVydGV4QXJyYXlPYmplY3QpO1xuICB9IGVsc2Uge1xuICAgIHNldEF0dHJpYnV0ZXMocHJvZ3JhbUluZm8uYXR0cmliU2V0dGVycyB8fCBwcm9ncmFtSW5mbywgYnVmZmVycy5hdHRyaWJzKTtcblxuICAgIGlmIChidWZmZXJzLmluZGljZXMpIHtcbiAgICAgIGdsLmJpbmRCdWZmZXIoRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMuaW5kaWNlcyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb2dyYW1JbmZvXG4gKiBAcHJvcGVydHkge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSBBIHNoYWRlciBwcm9ncmFtXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIGZ1bmN0aW9uPn0gdW5pZm9ybVNldHRlcnMgb2JqZWN0IG9mIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVVbmlmb3JtU2V0dGVycyxcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgZnVuY3Rpb24+fSBhdHRyaWJTZXR0ZXJzIG9iamVjdCBvZiBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20gY3JlYXRlQXR0cmliU2V0dGVycyxcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrU3BlY30gW3VuaWZvcm1CbG9ja1NwYWNlXSBhIHVuaWZvcm0gYmxvY2sgc3BlYyBmb3IgbWFraW5nIFVuaWZvcm1CbG9ja0luZm9zIHdpdGggY3JlYXRlVW5pZm9ybUJsb2NrSW5mbyBldGMuLlxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5UcmFuc2Zvcm1GZWVkYmFja0luZm8+fSBbdHJhbnNmb3JtRmVlZGJhY2tJbmZvXSBpbmZvIGZvciB0cmFuc2Zvcm0gZmVlZGJhY2tzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBQcm9ncmFtSW5mbyBmcm9tIGFuIGV4aXN0aW5nIHByb2dyYW0uXG4gKlxuICogQSBQcm9ncmFtSW5mbyBjb250YWluc1xuICpcbiAqICAgICBwcm9ncmFtSW5mbyA9IHtcbiAqICAgICAgICBwcm9ncmFtOiBXZWJHTFByb2dyYW0sXG4gKiAgICAgICAgdW5pZm9ybVNldHRlcnM6IG9iamVjdCBvZiBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20gY3JlYXRlVW5pZm9ybVNldHRlcnMsXG4gKiAgICAgICAgYXR0cmliU2V0dGVyczogb2JqZWN0IG9mIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVBdHRyaWJTZXR0ZXJzLFxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogICAgICAgIHRvIHVzZS5cbiAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtIGFuIGV4aXN0aW5nIFdlYkdMUHJvZ3JhbS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfSBUaGUgY3JlYXRlZCBQcm9ncmFtSW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbUluZm9Gcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbSkge1xuICB2YXIgdW5pZm9ybVNldHRlcnMgPSBjcmVhdGVVbmlmb3JtU2V0dGVycyhnbCwgcHJvZ3JhbSk7XG4gIHZhciBhdHRyaWJTZXR0ZXJzID0gY3JlYXRlQXR0cmlidXRlU2V0dGVycyhnbCwgcHJvZ3JhbSk7XG4gIHZhciBwcm9ncmFtSW5mbyA9IHtcbiAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgIHVuaWZvcm1TZXR0ZXJzOiB1bmlmb3JtU2V0dGVycyxcbiAgICBhdHRyaWJTZXR0ZXJzOiBhdHRyaWJTZXR0ZXJzXG4gIH07XG5cbiAgaWYgKHV0aWxzLmlzV2ViR0wyKGdsKSkge1xuICAgIHByb2dyYW1JbmZvLnVuaWZvcm1CbG9ja1NwZWMgPSBjcmVhdGVVbmlmb3JtQmxvY2tTcGVjRnJvbVByb2dyYW0oZ2wsIHByb2dyYW0pO1xuICAgIHByb2dyYW1JbmZvLnRyYW5zZm9ybUZlZWRiYWNrSW5mbyA9IGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrSW5mbyhnbCwgcHJvZ3JhbSk7XG4gIH1cblxuICByZXR1cm4gcHJvZ3JhbUluZm87XG59XG4vKipcbiAqIENyZWF0ZXMgYSBQcm9ncmFtSW5mbyBmcm9tIDIgc291cmNlcy5cbiAqXG4gKiBBIFByb2dyYW1JbmZvIGNvbnRhaW5zXG4gKlxuICogICAgIHByb2dyYW1JbmZvID0ge1xuICogICAgICAgIHByb2dyYW06IFdlYkdMUHJvZ3JhbSxcbiAqICAgICAgICB1bmlmb3JtU2V0dGVyczogb2JqZWN0IG9mIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVVbmlmb3JtU2V0dGVycyxcbiAqICAgICAgICBhdHRyaWJTZXR0ZXJzOiBvYmplY3Qgb2Ygc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUF0dHJpYlNldHRlcnMsXG4gKiAgICAgfVxuICpcbiAqIE5PVEU6IFRoZXJlIGFyZSA0IHNpZ25hdHVyZXMgZm9yIHRoaXMgZnVuY3Rpb25cbiAqXG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZzLCBmc10sIG9wdGlvbnMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUluZm8oZ2wsIFt2cywgZnNdLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyRnVuYyk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqICAgICAgICB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzaGFkZXJTb3VyY2VzIEFycmF5IG9mIHNvdXJjZXMgZm9yIHRoZVxuICogICAgICAgIHNoYWRlcnMgb3IgaWRzLiBUaGUgZmlyc3QgaXMgYXNzdW1lZCB0byBiZSB0aGUgdmVydGV4IHNoYWRlcixcbiAqICAgICAgICB0aGUgc2Vjb25kIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1PcHRpb25zfHN0cmluZ1tdfG1vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfYXR0cmlic10gT3B0aW9ucyBmb3IgdGhlIHByb2dyYW0gb3IgYW4gYXJyYXkgb2YgYXR0cmlicyBuYW1lcyBvciBhbiBlcnJvciBjYWxsYmFjay4gTG9jYXRpb25zIHdpbGwgYmUgYXNzaWduZWQgYnkgaW5kZXggaWYgbm90IHBhc3NlZCBpblxuICogQHBhcmFtIHtudW1iZXJbXX0gW29wdF9sb2NhdGlvbnN8bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja10gVGhlIGxvY2F0aW9ucyBmb3IgdGhlLiBBIHBhcmFsbGVsIGFycmF5IHRvIG9wdF9hdHRyaWJzIGxldHRpbmcgeW91IGFzc2lnbiBsb2NhdGlvbnMgb3IgYW4gZXJyb3IgY2FsbGJhY2suXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9ycy4gQnkgZGVmYXVsdCBpdCBqdXN0IHByaW50cyBhbiBlcnJvciB0byB0aGUgY29uc29sZVxuICogICAgICAgIG9uIGVycm9yLiBJZiB5b3Ugd2FudCBzb21ldGhpbmcgZWxzZSBwYXNzIGFuIGNhbGxiYWNrLiBJdCdzIHBhc3NlZCBhbiBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuUHJvZ3JhbUluZm8/fSBUaGUgY3JlYXRlZCBQcm9ncmFtSW5mbyBvciBudWxsIGlmIGl0IGZhaWxlZCB0byBsaW5rIG9yIGNvbXBpbGVcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbUluZm8oZ2wsIHNoYWRlclNvdXJjZXMsIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICB2YXIgcHJvZ09wdGlvbnMgPSBnZXRQcm9ncmFtT3B0aW9ucyhvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spO1xuICB2YXIgZ29vZCA9IHRydWU7XG4gIHNoYWRlclNvdXJjZXMgPSBzaGFkZXJTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgLy8gTGV0cyBhc3N1bWUgaWYgdGhlcmUgaXMgbm8gXFxuIGl0J3MgYW4gaWRcbiAgICBpZiAoc291cmNlLmluZGV4T2YoXCJcXG5cIikgPCAwKSB7XG4gICAgICB2YXIgc2NyaXB0ID0gZ2V0RWxlbWVudEJ5SWQoc291cmNlKTtcblxuICAgICAgaWYgKCFzY3JpcHQpIHtcbiAgICAgICAgcHJvZ09wdGlvbnMuZXJyb3JDYWxsYmFjayhcIm5vIGVsZW1lbnQgd2l0aCBpZDogXCIgKyBzb3VyY2UpO1xuICAgICAgICBnb29kID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2UgPSBzY3JpcHQudGV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlO1xuICB9KTtcblxuICBpZiAoIWdvb2QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2VzKGdsLCBzaGFkZXJTb3VyY2VzLCBwcm9nT3B0aW9ucyk7XG5cbiAgaWYgKCFwcm9ncmFtKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlUHJvZ3JhbUluZm9Gcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RleHR1cmVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RleHR1cmVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuc2V0VGV4dHVyZURlZmF1bHRzXyA9IHNldERlZmF1bHRzO1xuZXhwb3J0cy5jcmVhdGVTYW1wbGVyID0gY3JlYXRlU2FtcGxlcjtcbmV4cG9ydHMuY3JlYXRlU2FtcGxlcnMgPSBjcmVhdGVTYW1wbGVycztcbmV4cG9ydHMuc2V0U2FtcGxlclBhcmFtZXRlcnMgPSBzZXRTYW1wbGVyUGFyYW1ldGVycztcbmV4cG9ydHMuY3JlYXRlVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmU7XG5leHBvcnRzLnNldEVtcHR5VGV4dHVyZSA9IHNldEVtcHR5VGV4dHVyZTtcbmV4cG9ydHMuc2V0VGV4dHVyZUZyb21BcnJheSA9IHNldFRleHR1cmVGcm9tQXJyYXk7XG5leHBvcnRzLmxvYWRUZXh0dXJlRnJvbVVybCA9IGxvYWRUZXh0dXJlRnJvbVVybDtcbmV4cG9ydHMuc2V0VGV4dHVyZUZyb21FbGVtZW50ID0gc2V0VGV4dHVyZUZyb21FbGVtZW50O1xuZXhwb3J0cy5zZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZSA9IHNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplO1xuZXhwb3J0cy5zZXRUZXh0dXJlUGFyYW1ldGVycyA9IHNldFRleHR1cmVQYXJhbWV0ZXJzO1xuZXhwb3J0cy5zZXREZWZhdWx0VGV4dHVyZUNvbG9yID0gc2V0RGVmYXVsdFRleHR1cmVDb2xvcjtcbmV4cG9ydHMuY3JlYXRlVGV4dHVyZXMgPSBjcmVhdGVUZXh0dXJlcztcbmV4cG9ydHMucmVzaXplVGV4dHVyZSA9IHJlc2l6ZVRleHR1cmU7XG5leHBvcnRzLmNhbkdlbmVyYXRlTWlwbWFwID0gY2FuR2VuZXJhdGVNaXBtYXA7XG5leHBvcnRzLmNhbkZpbHRlciA9IGNhbkZpbHRlcjtcbmV4cG9ydHMuZ2V0TnVtQ29tcG9uZW50c0ZvckZvcm1hdCA9IGdldE51bUNvbXBvbmVudHNGb3JGb3JtYXQ7XG5leHBvcnRzLmdldEJ5dGVzUGVyRWxlbWVudEZvckludGVybmFsRm9ybWF0ID0gZ2V0Qnl0ZXNQZXJFbGVtZW50Rm9ySW50ZXJuYWxGb3JtYXQ7XG5leHBvcnRzLmdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdCA9IGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdDtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy5qcyAqLyBcIi4vc3JjL3V0aWxzLmpzXCIpKTtcblxudmFyIHR5cGVkQXJyYXlzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90eXBlZGFycmF5cy5qcyAqLyBcIi4vc3JjL3R5cGVkYXJyYXlzLmpzXCIpKTtcblxudmFyIGhlbHBlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGVscGVyLmpzICovIFwiLi9zcmMvaGVscGVyLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIExvdyBsZXZlbCB0ZXh0dXJlIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKlxuICogWW91IHNob3VsZCBnZW5lcmFsbHkgbm90IG5lZWQgdG8gdXNlIHRoZXNlIGZ1bmN0aW9ucy4gVGhleSBhcmUgcHJvdmlkZWRcbiAqIGZvciB0aG9zZSBjYXNlcyB3aGVyZSB5b3UncmUgZG9pbmcgc29tZXRoaW5nIG91dCBvZiB0aGUgb3JkaW5hcnlcbiAqIGFuZCB5b3UgbmVlZCBsb3dlciBsZXZlbCBhY2Nlc3MuXG4gKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgdGhleSBhcmUgYXZhaWxhYmxlIGF0IGJvdGggYHR3Z2wudGV4dHVyZXNgIGFuZCBgdHdnbGBcbiAqIGl0c2VsZlxuICpcbiAqIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2x9IGZvciBjb3JlIGZ1bmN0aW9uc1xuICpcbiAqIEBtb2R1bGUgdHdnbC90ZXh0dXJlc1xuICovXG4vLyBtYWtlIHN1cmUgd2UgZG9uJ3Qgc2VlIGEgZ2xvYmFsIGdsXG52YXIgZ2wgPSB1bmRlZmluZWQ7XG4vKiBlc2xpbnQtZGlzYWJsZS1saW5lICovXG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgdGV4dHVyZUNvbG9yOiBuZXcgVWludDhBcnJheShbMTI4LCAxOTIsIDI1NSwgMjU1XSksXG4gIHRleHR1cmVPcHRpb25zOiB7fSxcbiAgY3Jvc3NPcmlnaW46IHVuZGVmaW5lZFxufTtcbnZhciBpc0FycmF5QnVmZmVyID0gdHlwZWRBcnJheXMuaXNBcnJheUJ1ZmZlcjsgLy8gU2hvdWxkIHdlIG1ha2UgdGhpcyBvbiBkZW1hbmQ/XG5cbnZhciBnZXRTaGFyZWQyRENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzX2N0eDtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFNoYXJlZDJEQ29udGV4dCgpIHtcbiAgICBzX2N0eCA9IHNfY3R4IHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKSA6IG51bGwpO1xuICAgIHJldHVybiBzX2N0eDtcbiAgfTtcbn0oKTsgLy8gTk9URTogQ2hyb21lIHN1cHBvcnRzIDJEIGNhbnZhcyBpbiBhIFdvcmtlciAoYmVoaW5kIGZsYWcgYXMgb2YgdjY0IGJ1dFxuLy8gICAgICAgbm90IG9ubHkgZG9lcyBGaXJlZm94IE5PVCBzdXBwb3J0IGl0IGJ1dCBGaXJlZm94IGZyZWV6ZXMgaW1tZWRpYXRlbHlcbi8vICAgICAgIGlmIHlvdSB0cnkgdG8gY3JlYXRlIG9uZSBpbnN0ZWFkIG9mIGp1c3QgcmV0dXJuaW5nIG51bGwgYW5kIGNvbnRpbnVpbmcuXG4vLyAgOiAoZ2xvYmFsLk9mZnNjcmVlbkNhbnZhcyAmJiAobmV3IGdsb2JhbC5PZmZzY3JlZW5DYW52YXMoMSwgMSkpLmdldENvbnRleHQoXCIyZFwiKSk7ICAvLyBPZmZzY3JlZW5DYW52YXMgbWF5IG5vdCBzdXBwb3J0IDJkXG4vLyBOT1RFOiBXZSBjYW4gbWF5YmUgcmVtb3ZlIHNvbWUgb2YgdGhlIG5lZWQgZm9yIHRoZSAyZCBjYW52YXMuIEluIFdlYkdMMlxuLy8gd2UgY2FuIHVzZSB0aGUgdmFyaW91cyB1bnBhY2sgc2V0dGluZ3MuIE90aGVyd2lzZSB3ZSBjb3VsZCB0cnkgdXNpbmdcbi8vIHRoZSBhYmlsaXR5IG9mIGFuIEltYWdlQml0bWFwIHRvIGJlIGN1dC4gVW5mb3J0dW5hdGVseSBjdXR0aW5nIGFuIEltYWdlQml0bWFwXG4vLyBpcyBhc3luYyBhbmQgdGhlIGN1cnJlbnQgVFdHTCBjb2RlIGV4cGVjdHMgYSBub24tQXN5bmMgcmVzdWx0IHRob3VnaCB0aGF0XG4vLyBtaWdodCBub3QgYmUgYSBwcm9ibGVtLiBJbWFnZUJpdG1hcCB0aG91Z2ggaXMgbm90IGF2YWlsYWJsZSBpbiBFZGdlIG9yIFNhZmFyaVxuLy8gYXMgb2YgMjAxOC0wMS0wMlxuXG4vKiBQaXhlbEZvcm1hdCAqL1xuXG5cbnZhciBBTFBIQSA9IDB4MTkwNjtcbnZhciBSR0IgPSAweDE5MDc7XG52YXIgUkdCQSA9IDB4MTkwODtcbnZhciBMVU1JTkFOQ0UgPSAweDE5MDk7XG52YXIgTFVNSU5BTkNFX0FMUEhBID0gMHgxOTBBO1xudmFyIERFUFRIX0NPTVBPTkVOVCA9IDB4MTkwMjtcbnZhciBERVBUSF9TVEVOQ0lMID0gMHg4NEY5O1xuLyogVGV4dHVyZVdyYXBNb2RlICovXG4vLyBjb25zdCBSRVBFQVQgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDI5MDE7XG4vLyBjb25zdCBNSVJST1JFRF9SRVBFQVQgICAgICAgICAgICAgICAgPSAweDgzNzA7XG5cbnZhciBDTEFNUF9UT19FREdFID0gMHg4MTJmO1xuLyogVGV4dHVyZU1hZ0ZpbHRlciAqL1xuXG52YXIgTkVBUkVTVCA9IDB4MjYwMDtcbnZhciBMSU5FQVIgPSAweDI2MDE7XG4vKiBUZXh0dXJlTWluRmlsdGVyICovXG4vLyBjb25zdCBORUFSRVNUX01JUE1BUF9ORUFSRVNUICAgICAgICAgPSAweDI3MDA7XG4vLyBjb25zdCBMSU5FQVJfTUlQTUFQX05FQVJFU1QgICAgICAgICAgPSAweDI3MDE7XG4vLyBjb25zdCBORUFSRVNUX01JUE1BUF9MSU5FQVIgICAgICAgICAgPSAweDI3MDI7XG4vLyBjb25zdCBMSU5FQVJfTUlQTUFQX0xJTkVBUiAgICAgICAgICAgPSAweDI3MDM7XG5cbi8qIFRleHR1cmUgVGFyZ2V0ICovXG5cbnZhciBURVhUVVJFXzJEID0gMHgwZGUxO1xudmFyIFRFWFRVUkVfQ1VCRV9NQVAgPSAweDg1MTM7XG52YXIgVEVYVFVSRV8zRCA9IDB4ODA2ZjtcbnZhciBURVhUVVJFXzJEX0FSUkFZID0gMHg4YzFhO1xuLyogQ3ViZW1hcCBUYXJnZXRzICovXG5cbnZhciBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggPSAweDg1MTU7XG52YXIgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YID0gMHg4NTE2O1xudmFyIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSA9IDB4ODUxNztcbnZhciBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1kgPSAweDg1MTg7XG52YXIgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aID0gMHg4NTE5O1xudmFyIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWiA9IDB4ODUxYTtcbi8qIFRleHR1cmUgUGFyYW1ldGVycyAqL1xuXG52YXIgVEVYVFVSRV9NSU5fRklMVEVSID0gMHgyODAxO1xudmFyIFRFWFRVUkVfTUFHX0ZJTFRFUiA9IDB4MjgwMDtcbnZhciBURVhUVVJFX1dSQVBfUyA9IDB4MjgwMjtcbnZhciBURVhUVVJFX1dSQVBfVCA9IDB4MjgwMztcbnZhciBURVhUVVJFX1dSQVBfUiA9IDB4ODA3MjtcbnZhciBURVhUVVJFX01JTl9MT0QgPSAweDgxM2E7XG52YXIgVEVYVFVSRV9NQVhfTE9EID0gMHg4MTNiO1xudmFyIFRFWFRVUkVfQkFTRV9MRVZFTCA9IDB4ODEzYztcbnZhciBURVhUVVJFX01BWF9MRVZFTCA9IDB4ODEzZDtcbi8qIFBpeGVsIHN0b3JlICovXG5cbnZhciBVTlBBQ0tfQUxJR05NRU5UID0gMHgwY2Y1O1xudmFyIFVOUEFDS19ST1dfTEVOR1RIID0gMHgwY2YyO1xudmFyIFVOUEFDS19JTUFHRV9IRUlHSFQgPSAweDgwNmU7XG52YXIgVU5QQUNLX1NLSVBfUElYRUxTID0gMHgwY2Y0O1xudmFyIFVOUEFDS19TS0lQX1JPV1MgPSAweDBjZjM7XG52YXIgVU5QQUNLX1NLSVBfSU1BR0VTID0gMHg4MDZkO1xudmFyIFVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wgPSAweDkyNDM7XG52YXIgVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMID0gMHg5MjQxO1xudmFyIFVOUEFDS19GTElQX1lfV0VCR0wgPSAweDkyNDA7XG52YXIgUjggPSAweDgyMjk7XG52YXIgUjhfU05PUk0gPSAweDhGOTQ7XG52YXIgUjE2RiA9IDB4ODIyRDtcbnZhciBSMzJGID0gMHg4MjJFO1xudmFyIFI4VUkgPSAweDgyMzI7XG52YXIgUjhJID0gMHg4MjMxO1xudmFyIFJHMTZVSSA9IDB4ODIzQTtcbnZhciBSRzE2SSA9IDB4ODIzOTtcbnZhciBSRzMyVUkgPSAweDgyM0M7XG52YXIgUkczMkkgPSAweDgyM0I7XG52YXIgUkc4ID0gMHg4MjJCO1xudmFyIFJHOF9TTk9STSA9IDB4OEY5NTtcbnZhciBSRzE2RiA9IDB4ODIyRjtcbnZhciBSRzMyRiA9IDB4ODIzMDtcbnZhciBSRzhVSSA9IDB4ODIzODtcbnZhciBSRzhJID0gMHg4MjM3O1xudmFyIFIxNlVJID0gMHg4MjM0O1xudmFyIFIxNkkgPSAweDgyMzM7XG52YXIgUjMyVUkgPSAweDgyMzY7XG52YXIgUjMySSA9IDB4ODIzNTtcbnZhciBSR0I4ID0gMHg4MDUxO1xudmFyIFNSR0I4ID0gMHg4QzQxO1xudmFyIFJHQjU2NSA9IDB4OEQ2MjtcbnZhciBSR0I4X1NOT1JNID0gMHg4Rjk2O1xudmFyIFIxMUZfRzExRl9CMTBGID0gMHg4QzNBO1xudmFyIFJHQjlfRTUgPSAweDhDM0Q7XG52YXIgUkdCMTZGID0gMHg4ODFCO1xudmFyIFJHQjMyRiA9IDB4ODgxNTtcbnZhciBSR0I4VUkgPSAweDhEN0Q7XG52YXIgUkdCOEkgPSAweDhEOEY7XG52YXIgUkdCMTZVSSA9IDB4OEQ3NztcbnZhciBSR0IxNkkgPSAweDhEODk7XG52YXIgUkdCMzJVSSA9IDB4OEQ3MTtcbnZhciBSR0IzMkkgPSAweDhEODM7XG52YXIgUkdCQTggPSAweDgwNTg7XG52YXIgU1JHQjhfQUxQSEE4ID0gMHg4QzQzO1xudmFyIFJHQkE4X1NOT1JNID0gMHg4Rjk3O1xudmFyIFJHQjVfQTEgPSAweDgwNTc7XG52YXIgUkdCQTQgPSAweDgwNTY7XG52YXIgUkdCMTBfQTIgPSAweDgwNTk7XG52YXIgUkdCQTE2RiA9IDB4ODgxQTtcbnZhciBSR0JBMzJGID0gMHg4ODE0O1xudmFyIFJHQkE4VUkgPSAweDhEN0M7XG52YXIgUkdCQThJID0gMHg4RDhFO1xudmFyIFJHQjEwX0EyVUkgPSAweDkwNkY7XG52YXIgUkdCQTE2VUkgPSAweDhENzY7XG52YXIgUkdCQTE2SSA9IDB4OEQ4ODtcbnZhciBSR0JBMzJJID0gMHg4RDgyO1xudmFyIFJHQkEzMlVJID0gMHg4RDcwO1xudmFyIERFUFRIX0NPTVBPTkVOVDE2ID0gMHg4MUE1O1xudmFyIERFUFRIX0NPTVBPTkVOVDI0ID0gMHg4MUE2O1xudmFyIERFUFRIX0NPTVBPTkVOVDMyRiA9IDB4OENBQztcbnZhciBERVBUSDMyRl9TVEVOQ0lMOCA9IDB4OENBRDtcbnZhciBERVBUSDI0X1NURU5DSUw4ID0gMHg4OEYwO1xuLyogRGF0YVR5cGUgKi9cblxudmFyIEJZVEUgPSAweDE0MDA7XG52YXIgVU5TSUdORURfQllURSA9IDB4MTQwMTtcbnZhciBTSE9SVCA9IDB4MTQwMjtcbnZhciBVTlNJR05FRF9TSE9SVCA9IDB4MTQwMztcbnZhciBJTlQgPSAweDE0MDQ7XG52YXIgVU5TSUdORURfSU5UID0gMHgxNDA1O1xudmFyIEZMT0FUID0gMHgxNDA2O1xudmFyIFVOU0lHTkVEX1NIT1JUXzRfNF80XzQgPSAweDgwMzM7XG52YXIgVU5TSUdORURfU0hPUlRfNV81XzVfMSA9IDB4ODAzNDtcbnZhciBVTlNJR05FRF9TSE9SVF81XzZfNSA9IDB4ODM2MztcbnZhciBIQUxGX0ZMT0FUID0gMHgxNDBCO1xudmFyIEhBTEZfRkxPQVRfT0VTID0gMHg4RDYxOyAvLyBUaGFua3MgS2hyb25vcyBmb3IgbWFraW5nIHRoaXMgZGlmZmVyZW50ID46KFxuXG52YXIgVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWID0gMHg4MzY4O1xudmFyIFVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVYgPSAweDhDM0I7XG52YXIgVU5TSUdORURfSU5UXzVfOV85XzlfUkVWID0gMHg4QzNFO1xudmFyIEZMT0FUXzMyX1VOU0lHTkVEX0lOVF8yNF84X1JFViA9IDB4OERBRDtcbnZhciBVTlNJR05FRF9JTlRfMjRfOCA9IDB4ODRGQTtcbnZhciBSRyA9IDB4ODIyNztcbnZhciBSR19JTlRFR0VSID0gMHg4MjI4O1xudmFyIFJFRCA9IDB4MTkwMztcbnZhciBSRURfSU5URUdFUiA9IDB4OEQ5NDtcbnZhciBSR0JfSU5URUdFUiA9IDB4OEQ5ODtcbnZhciBSR0JBX0lOVEVHRVIgPSAweDhEOTk7XG52YXIgZm9ybWF0SW5mbyA9IHt9O1xue1xuICAvLyBOT1RFOiB0aGlzIGlzIG5hbWVkIGBudW1Db2xvckNvbXBvbmVudHNgIHZzIGBudW1Db21wb25lbnRzYCBzbyB3ZSBjYW4gbGV0IFVnbGlmeSBtYW5nbGVcbiAgLy8gdGhlIG5hbWUuXG4gIHZhciBmID0gZm9ybWF0SW5mbztcbiAgZltBTFBIQV0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiAxXG4gIH07XG4gIGZbTFVNSU5BTkNFXSA9IHtcbiAgICBudW1Db2xvckNvbXBvbmVudHM6IDFcbiAgfTtcbiAgZltMVU1JTkFOQ0VfQUxQSEFdID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogMlxuICB9O1xuICBmW1JHQl0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiAzXG4gIH07XG4gIGZbUkdCQV0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiA0XG4gIH07XG4gIGZbUkVEXSA9IHtcbiAgICBudW1Db2xvckNvbXBvbmVudHM6IDFcbiAgfTtcbiAgZltSRURfSU5URUdFUl0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiAxXG4gIH07XG4gIGZbUkddID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogMlxuICB9O1xuICBmW1JHX0lOVEVHRVJdID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogMlxuICB9O1xuICBmW1JHQl0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiAzXG4gIH07XG4gIGZbUkdCX0lOVEVHRVJdID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogM1xuICB9O1xuICBmW1JHQkFdID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogNFxuICB9O1xuICBmW1JHQkFfSU5URUdFUl0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiA0XG4gIH07XG4gIGZbREVQVEhfQ09NUE9ORU5UXSA9IHtcbiAgICBudW1Db2xvckNvbXBvbmVudHM6IDFcbiAgfTtcbiAgZltERVBUSF9TVEVOQ0lMXSA9IHtcbiAgICBudW1Db2xvckNvbXBvbmVudHM6IDJcbiAgfTtcbn1cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGV4dHVyZUZvcm1hdERldGFpbHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0ZXh0dXJlRm9ybWF0IGZvcm1hdCB0byBwYXNzIHRleEltYWdlMkQgYW5kIHNpbWlsYXIgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb2xvclJlbmRlcmFibGUgdHJ1ZSBpZiB5b3UgY2FuIHJlbmRlciB0byB0aGlzIGZvcm1hdCBvZiB0ZXh0dXJlLlxuICogQHByb3BlcnR5IHtib29sZWFufSB0ZXh0dXJlRmlsdGVyYWJsZSB0cnVlIGlmIHlvdSBjYW4gZmlsdGVyIHRoZSB0ZXh0dXJlLCBmYWxzZSBpZiB5b3UgY2FuIG9ueSB1c2UgYE5FQVJFU1RgLlxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gdHlwZSBBcnJheSBvZiBwb3NzaWJsZSB0eXBlcyB5b3UgY2FuIHBhc3MgdG8gdGV4SW1hZ2UyRCBhbmQgc2ltaWxhciBmdW5jdGlvblxuICogQHByb3BlcnR5IHtPYmplY3QuPG51bWJlcixudW1iZXI+fSBieXRlc1BlckVsZW1lbnRNYXAgQSBtYXAgb2YgdHlwZXMgdG8gYnl0ZXMgcGVyIGVsZW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIHNfdGV4dHVyZUludGVybmFsRm9ybWF0SW5mbztcblxuZnVuY3Rpb24gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0SW5mbyhpbnRlcm5hbEZvcm1hdCkge1xuICBpZiAoIXNfdGV4dHVyZUludGVybmFsRm9ybWF0SW5mbykge1xuICAgIC8vIE5PVEU6IHRoZXNlIHByb3BlcnRpZXMgbmVlZCB1bmlxdWUgbmFtZXMgc28gd2UgY2FuIGxldCBVZ2xpZnkgbWFuZ2xlIHRoZSBuYW1lLlxuICAgIHZhciB0ID0ge307IC8vIHVuc2l6ZWQgZm9ybWF0c1xuXG4gICAgdFtBTFBIQV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBBTFBIQSxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbMSwgMiwgMiwgNF0sXG4gICAgICB0eXBlOiBbVU5TSUdORURfQllURSwgSEFMRl9GTE9BVCwgSEFMRl9GTE9BVF9PRVMsIEZMT0FUXVxuICAgIH07XG4gICAgdFtMVU1JTkFOQ0VdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogTFVNSU5BTkNFLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFsxLCAyLCAyLCA0XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFLCBIQUxGX0ZMT0FULCBIQUxGX0ZMT0FUX09FUywgRkxPQVRdXG4gICAgfTtcbiAgICB0W0xVTUlOQU5DRV9BTFBIQV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBMVU1JTkFOQ0VfQUxQSEEsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzIsIDQsIDQsIDhdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUsIEhBTEZfRkxPQVQsIEhBTEZfRkxPQVRfT0VTLCBGTE9BVF1cbiAgICB9O1xuICAgIHRbUkdCXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHQixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbMywgNiwgNiwgMTIsIDJdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUsIEhBTEZfRkxPQVQsIEhBTEZfRkxPQVRfT0VTLCBGTE9BVCwgVU5TSUdORURfU0hPUlRfNV82XzVdXG4gICAgfTtcbiAgICB0W1JHQkFdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCQSxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNCwgOCwgOCwgMTYsIDIsIDJdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUsIEhBTEZfRkxPQVQsIEhBTEZfRkxPQVRfT0VTLCBGTE9BVCwgVU5TSUdORURfU0hPUlRfNF80XzRfNCwgVU5TSUdORURfU0hPUlRfNV81XzVfMV1cbiAgICB9O1xuICAgIHRbREVQVEhfQ09NUE9ORU5UXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IERFUFRIX0NPTVBPTkVOVCxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzIsIDRdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0lOVCwgVU5TSUdORURfU0hPUlRdXG4gICAgfTsgLy8gc2l6ZWQgZm9ybWF0c1xuXG4gICAgdFtSOF0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSRUQsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzFdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEVdXG4gICAgfTtcbiAgICB0W1I4X1NOT1JNXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJFRCxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzFdLFxuICAgICAgdHlwZTogW0JZVEVdXG4gICAgfTtcbiAgICB0W1IxNkZdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkVELFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNCwgMl0sXG4gICAgICB0eXBlOiBbRkxPQVQsIEhBTEZfRkxPQVRdXG4gICAgfTtcbiAgICB0W1IzMkZdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkVELFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzRdLFxuICAgICAgdHlwZTogW0ZMT0FUXVxuICAgIH07XG4gICAgdFtSOFVJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJFRF9JTlRFR0VSLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbMV0sXG4gICAgICB0eXBlOiBbVU5TSUdORURfQllURV1cbiAgICB9O1xuICAgIHRbUjhJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJFRF9JTlRFR0VSLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbMV0sXG4gICAgICB0eXBlOiBbQllURV1cbiAgICB9O1xuICAgIHRbUjE2VUldID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkVEX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFsyXSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9TSE9SVF1cbiAgICB9O1xuICAgIHRbUjE2SV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSRURfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzJdLFxuICAgICAgdHlwZTogW1NIT1JUXVxuICAgIH07XG4gICAgdFtSMzJVSV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSRURfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzRdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0lOVF1cbiAgICB9O1xuICAgIHRbUjMySV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSRURfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzRdLFxuICAgICAgdHlwZTogW0lOVF1cbiAgICB9O1xuICAgIHRbUkc4XSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFsyXSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFXVxuICAgIH07XG4gICAgdFtSRzhfU05PUk1dID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkcsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFsyXSxcbiAgICAgIHR5cGU6IFtCWVRFXVxuICAgIH07XG4gICAgdFtSRzE2Rl0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSRyxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzgsIDRdLFxuICAgICAgdHlwZTogW0ZMT0FULCBIQUxGX0ZMT0FUXVxuICAgIH07XG4gICAgdFtSRzMyRl0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSRyxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs4XSxcbiAgICAgIHR5cGU6IFtGTE9BVF1cbiAgICB9O1xuICAgIHRbUkc4VUldID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzJdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEVdXG4gICAgfTtcbiAgICB0W1JHOEldID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzJdLFxuICAgICAgdHlwZTogW0JZVEVdXG4gICAgfTtcbiAgICB0W1JHMTZVSV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR19JTlRFR0VSLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sXG4gICAgICB0eXBlOiBbVU5TSUdORURfU0hPUlRdXG4gICAgfTtcbiAgICB0W1JHMTZJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs0XSxcbiAgICAgIHR5cGU6IFtTSE9SVF1cbiAgICB9O1xuICAgIHRbUkczMlVJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs4XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlRdXG4gICAgfTtcbiAgICB0W1JHMzJJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs4XSxcbiAgICAgIHR5cGU6IFtJTlRdXG4gICAgfTtcbiAgICB0W1JHQjhdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFszXSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFXVxuICAgIH07XG4gICAgdFtTUkdCOF0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0IsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFszXSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFXVxuICAgIH07XG4gICAgdFtSR0I1NjVdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFszLCAyXSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFLCBVTlNJR05FRF9TSE9SVF81XzZfNV1cbiAgICB9O1xuICAgIHRbUkdCOF9TTk9STV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0IsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFszXSxcbiAgICAgIHR5cGU6IFtCWVRFXVxuICAgIH07XG4gICAgdFtSMTFGX0cxMUZfQjEwRl0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0IsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFsxMiwgNiwgNF0sXG4gICAgICB0eXBlOiBbRkxPQVQsIEhBTEZfRkxPQVQsIFVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVZdXG4gICAgfTtcbiAgICB0W1JHQjlfRTVdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbMTIsIDYsIDRdLFxuICAgICAgdHlwZTogW0ZMT0FULCBIQUxGX0ZMT0FULCBVTlNJR05FRF9JTlRfNV85XzlfOV9SRVZdXG4gICAgfTtcbiAgICB0W1JHQjE2Rl0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0IsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFsxMiwgNl0sXG4gICAgICB0eXBlOiBbRkxPQVQsIEhBTEZfRkxPQVRdXG4gICAgfTtcbiAgICB0W1JHQjMyRl0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0IsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbMTJdLFxuICAgICAgdHlwZTogW0ZMT0FUXVxuICAgIH07XG4gICAgdFtSR0I4VUldID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbM10sXG4gICAgICB0eXBlOiBbVU5TSUdORURfQllURV1cbiAgICB9O1xuICAgIHRbUkdCOEldID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbM10sXG4gICAgICB0eXBlOiBbQllURV1cbiAgICB9O1xuICAgIHRbUkdCMTZVSV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs2XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9TSE9SVF1cbiAgICB9O1xuICAgIHRbUkdCMTZJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHQl9JTlRFR0VSLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzZdLFxuICAgICAgdHlwZTogW1NIT1JUXVxuICAgIH07XG4gICAgdFtSR0IzMlVJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHQl9JTlRFR0VSLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzEyXSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlRdXG4gICAgfTtcbiAgICB0W1JHQjMySV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFsxMl0sXG4gICAgICB0eXBlOiBbSU5UXVxuICAgIH07XG4gICAgdFtSR0JBOF0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs0XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFXVxuICAgIH07XG4gICAgdFtTUkdCOF9BTFBIQThdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCQSxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sXG4gICAgICB0eXBlOiBbVU5TSUdORURfQllURV1cbiAgICB9O1xuICAgIHRbUkdCQThfU05PUk1dID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCQSxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzRdLFxuICAgICAgdHlwZTogW0JZVEVdXG4gICAgfTtcbiAgICB0W1JHQjVfQTFdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCQSxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNCwgMiwgNF0sXG4gICAgICB0eXBlOiBbVU5TSUdORURfQllURSwgVU5TSUdORURfU0hPUlRfNV81XzVfMSwgVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWXVxuICAgIH07XG4gICAgdFtSR0JBNF0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs0LCAyXSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFLCBVTlNJR05FRF9TSE9SVF80XzRfNF80XVxuICAgIH07XG4gICAgdFtSR0IxMF9BMl0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs0XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlRfMl8xMF8xMF8xMF9SRVZdXG4gICAgfTtcbiAgICB0W1JHQkExNkZdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCQSxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzE2LCA4XSxcbiAgICAgIHR5cGU6IFtGTE9BVCwgSEFMRl9GTE9BVF1cbiAgICB9O1xuICAgIHRbUkdCQTMyRl0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzE2XSxcbiAgICAgIHR5cGU6IFtGTE9BVF1cbiAgICB9O1xuICAgIHRbUkdCQThVSV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs0XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFXVxuICAgIH07XG4gICAgdFtSR0JBOEldID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogUkdCQV9JTlRFR0VSLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sXG4gICAgICB0eXBlOiBbQllURV1cbiAgICB9O1xuICAgIHRbUkdCMTBfQTJVSV0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBX0lOVEVHRVIsXG4gICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgICBieXRlc1BlckVsZW1lbnQ6IFs0XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlRfMl8xMF8xMF8xMF9SRVZdXG4gICAgfTtcbiAgICB0W1JHQkExNlVJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzhdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX1NIT1JUXVxuICAgIH07XG4gICAgdFtSR0JBMTZJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzhdLFxuICAgICAgdHlwZTogW1NIT1JUXVxuICAgIH07XG4gICAgdFtSR0JBMzJJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzE2XSxcbiAgICAgIHR5cGU6IFtJTlRdXG4gICAgfTtcbiAgICB0W1JHQkEzMlVJXSA9IHtcbiAgICAgIHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUixcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzE2XSxcbiAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlRdXG4gICAgfTsgLy8gU2l6ZWQgSW50ZXJuYWxcblxuICAgIHRbREVQVEhfQ09NUE9ORU5UMTZdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogREVQVEhfQ09NUE9ORU5ULFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbMiwgNF0sXG4gICAgICB0eXBlOiBbVU5TSUdORURfU0hPUlQsIFVOU0lHTkVEX0lOVF1cbiAgICB9O1xuICAgIHRbREVQVEhfQ09NUE9ORU5UMjRdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogREVQVEhfQ09NUE9ORU5ULFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sXG4gICAgICB0eXBlOiBbVU5TSUdORURfSU5UXVxuICAgIH07XG4gICAgdFtERVBUSF9DT01QT05FTlQzMkZdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogREVQVEhfQ09NUE9ORU5ULFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sXG4gICAgICB0eXBlOiBbRkxPQVRdXG4gICAgfTtcbiAgICB0W0RFUFRIMjRfU1RFTkNJTDhdID0ge1xuICAgICAgdGV4dHVyZUZvcm1hdDogREVQVEhfU1RFTkNJTCxcbiAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogWzRdLFxuICAgICAgdHlwZTogW1VOU0lHTkVEX0lOVF8yNF84XVxuICAgIH07XG4gICAgdFtERVBUSDMyRl9TVEVOQ0lMOF0gPSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0OiBERVBUSF9TVEVOQ0lMLFxuICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sXG4gICAgICB0eXBlOiBbRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWXVxuICAgIH07XG4gICAgT2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJuYWxGb3JtYXQpIHtcbiAgICAgIHZhciBpbmZvID0gdFtpbnRlcm5hbEZvcm1hdF07XG4gICAgICBpbmZvLmJ5dGVzUGVyRWxlbWVudE1hcCA9IHt9O1xuICAgICAgaW5mby5ieXRlc1BlckVsZW1lbnQuZm9yRWFjaChmdW5jdGlvbiAoYnl0ZXNQZXJFbGVtZW50LCBuZHgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBpbmZvLnR5cGVbbmR4XTtcbiAgICAgICAgaW5mby5ieXRlc1BlckVsZW1lbnRNYXBbdHlwZV0gPSBieXRlc1BlckVsZW1lbnQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBzX3RleHR1cmVJbnRlcm5hbEZvcm1hdEluZm8gPSB0O1xuICB9XG5cbiAgcmV0dXJuIHNfdGV4dHVyZUludGVybmFsRm9ybWF0SW5mb1tpbnRlcm5hbEZvcm1hdF07XG59XG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBieXRlcyBwZXIgZWxlbWVudCBmb3IgYSBnaXZlbiBpbnRlcm5hbEZvcm1hdCAvIHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcm5hbEZvcm1hdCBUaGUgaW50ZXJuYWxGb3JtYXQgcGFyYW1ldGVyIGZyb20gdGV4SW1hZ2UyRCBldGMuLlxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgVGhlIHR5cGUgcGFyYW1ldGVyIGZvciB0ZXhJbWFnZTJEIGV0Yy4uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgYnl0ZXMgcGVyIGVsZW1lbnQgZm9yIHRoZSBnaXZlbiBpbnRlcm5hbEZvcm1hdCwgdHlwZSBjb21ib1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRCeXRlc1BlckVsZW1lbnRGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCwgdHlwZSkge1xuICB2YXIgaW5mbyA9IGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdEluZm8oaW50ZXJuYWxGb3JtYXQpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHRocm93IFwidW5rbm93biBpbnRlcm5hbCBmb3JtYXRcIjtcbiAgfVxuXG4gIHZhciBieXRlc1BlckVsZW1lbnQgPSBpbmZvLmJ5dGVzUGVyRWxlbWVudE1hcFt0eXBlXTtcblxuICBpZiAoYnl0ZXNQZXJFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBcInVua25vd24gaW50ZXJuYWwgZm9ybWF0XCI7XG4gIH1cblxuICByZXR1cm4gYnl0ZXNQZXJFbGVtZW50O1xufVxuLyoqXG4gKiBJbmZvIHJlbGF0ZWQgdG8gYSBzcGVjaWZpYyB0ZXh0dXJlIGludGVybmFsRm9ybWF0IGFzIHJldHVybmVkXG4gKiBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC90ZXh0dXJlcy5nZXRGb3JtYXRBbmRUeXBlRm9ySW50ZXJuYWxGb3JtYXR9LlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHR1cmVGb3JtYXRJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gZm9ybWF0IEZvcm1hdCB0byBwYXNzIHRvIHRleEltYWdlMkQgYW5kIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gdHlwZSBUeXBlIHRvIHBhc3MgdG8gdGV4SW1hZ2UyRCBhbmQgcmVsYXRlZCBmdW5jdGlvbnNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cbi8qKlxuICogR2V0cyB0aGUgZm9ybWF0IGFuZCB0eXBlIGZvciBhIGdpdmVuIGludGVybmFsRm9ybWF0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGludGVybmFsRm9ybWF0IFRoZSBpbnRlcm5hbCBmb3JtYXRcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3RleHR1cmVzLlRleHR1cmVGb3JtYXRJbmZvfSB0aGUgY29ycmVzcG9uZGluZyBmb3JtYXQgYW5kIHR5cGUsXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCkge1xuICB2YXIgaW5mbyA9IGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdEluZm8oaW50ZXJuYWxGb3JtYXQpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHRocm93IFwidW5rbm93biBpbnRlcm5hbCBmb3JtYXRcIjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBpbmZvLnRleHR1cmVGb3JtYXQsXG4gICAgdHlwZTogaW5mby50eXBlWzBdXG4gIH07XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBwb3dlciBvZiAyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgbnVtYmVyIHRvIGNoZWNrLlxuICogQHJldHVybiB0cnVlIGlmIHZhbHVlIGlzIHBvd2VyIG9mIDJcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBpc1Bvd2VyT2YyKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgJiB2YWx1ZSAtIDEpID09PSAwO1xufVxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHdlIGNhbiBnZW5lcmF0ZSBtaXBzIGZvciB0aGUgZ2l2ZW5cbiAqIGludGVybmFsIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBwYXJhbWV0ZXIgZnJvbSB0ZXhJbWFnZTJEIGV0Yy4uXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgcGFyYW1ldGVyIGZyb20gdGV4SW1hZ2UyRCBldGMuLlxuICogQHBhcmFtIHtudW1iZXJ9IGludGVybmFsRm9ybWF0IFRoZSBpbnRlcm5hbEZvcm1hdCBwYXJhbWV0ZXIgZnJvbSB0ZXhJbWFnZTJEIGV0Yy4uXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHdlIGNhbiBnZW5lcmF0ZSBtaXBzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNhbkdlbmVyYXRlTWlwbWFwKGdsLCB3aWR0aCwgaGVpZ2h0LCBpbnRlcm5hbEZvcm1hdCkge1xuICBpZiAoIXV0aWxzLmlzV2ViR0wyKGdsKSkge1xuICAgIHJldHVybiBpc1Bvd2VyT2YyKHdpZHRoKSAmJiBpc1Bvd2VyT2YyKGhlaWdodCk7XG4gIH1cblxuICB2YXIgaW5mbyA9IGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdEluZm8oaW50ZXJuYWxGb3JtYXQpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHRocm93IFwidW5rbm93biBpbnRlcm5hbCBmb3JtYXRcIjtcbiAgfVxuXG4gIHJldHVybiBpbmZvLmNvbG9yUmVuZGVyYWJsZSAmJiBpbmZvLnRleHR1cmVGaWx0ZXJhYmxlO1xufVxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHdlIGNhbiBnZW5lcmF0ZSBtaXBzIGZvciB0aGUgZ2l2ZW4gZm9ybWF0XG4gKiBAcGFyYW0ge251bWJlcn0gaW50ZXJuYWxGb3JtYXQgVGhlIGludGVybmFsRm9ybWF0IHBhcmFtZXRlciBmcm9tIHRleEltYWdlMkQgZXRjLi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgd2UgY2FuIGdlbmVyYXRlIG1pcHNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cblxuZnVuY3Rpb24gY2FuRmlsdGVyKGludGVybmFsRm9ybWF0KSB7XG4gIHZhciBpbmZvID0gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0SW5mbyhpbnRlcm5hbEZvcm1hdCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdGhyb3cgXCJ1bmtub3duIGludGVybmFsIGZvcm1hdFwiO1xuICB9XG5cbiAgcmV0dXJuIGluZm8udGV4dHVyZUZpbHRlcmFibGU7XG59XG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBjb21wb25lbnRzIGZvciBhIGdpdmVuIGltYWdlIGZvcm1hdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3JtYXQgdGhlIGZvcm1hdC5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIGZvciB0aGUgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBnZXROdW1Db21wb25lbnRzRm9yRm9ybWF0KGZvcm1hdCkge1xuICB2YXIgaW5mbyA9IGZvcm1hdEluZm9bZm9ybWF0XTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB0aHJvdyBcInVua25vd24gZm9ybWF0OiBcIiArIGZvcm1hdDtcbiAgfVxuXG4gIHJldHVybiBpbmZvLm51bUNvbG9yQ29tcG9uZW50cztcbn1cbi8qKlxuICogR2V0cyB0aGUgdGV4dHVyZSB0eXBlIGZvciBhIGdpdmVuIGFycmF5IHR5cGUuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgZ2wgdGV4dHVyZSB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0VGV4dHVyZVR5cGVGb3JBcnJheVR5cGUoZ2wsIHNyYywgZGVmYXVsdFR5cGUpIHtcbiAgaWYgKGlzQXJyYXlCdWZmZXIoc3JjKSkge1xuICAgIHJldHVybiB0eXBlZEFycmF5cy5nZXRHTFR5cGVGb3JUeXBlZEFycmF5KHNyYyk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFR5cGUgfHwgVU5TSUdORURfQllURTtcbn1cblxuZnVuY3Rpb24gZ3Vlc3NEaW1lbnNpb25zKGdsLCB0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIG51bUVsZW1lbnRzKSB7XG4gIGlmIChudW1FbGVtZW50cyAlIDEgIT09IDApIHtcbiAgICB0aHJvdyBcImNhbid0IGd1ZXNzIGRpbWVuc2lvbnNcIjtcbiAgfVxuXG4gIGlmICghd2lkdGggJiYgIWhlaWdodCkge1xuICAgIHZhciBzaXplID0gTWF0aC5zcXJ0KG51bUVsZW1lbnRzIC8gKHRhcmdldCA9PT0gVEVYVFVSRV9DVUJFX01BUCA/IDYgOiAxKSk7XG5cbiAgICBpZiAoc2l6ZSAlIDEgPT09IDApIHtcbiAgICAgIHdpZHRoID0gc2l6ZTtcbiAgICAgIGhlaWdodCA9IHNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gbnVtRWxlbWVudHM7XG4gICAgICBoZWlnaHQgPSAxO1xuICAgIH1cbiAgfSBlbHNlIGlmICghaGVpZ2h0KSB7XG4gICAgaGVpZ2h0ID0gbnVtRWxlbWVudHMgLyB3aWR0aDtcblxuICAgIGlmIChoZWlnaHQgJSAxKSB7XG4gICAgICB0aHJvdyBcImNhbid0IGd1ZXNzIGRpbWVuc2lvbnNcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIXdpZHRoKSB7XG4gICAgd2lkdGggPSBudW1FbGVtZW50cyAvIGhlaWdodDtcblxuICAgIGlmICh3aWR0aCAlIDEpIHtcbiAgICAgIHRocm93IFwiY2FuJ3QgZ3Vlc3MgZGltZW5zaW9uc1wiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG4vKipcbiAqIFNldHMgdGhlIGRlZmF1bHQgdGV4dHVyZSBjb2xvci5cbiAqXG4gKiBUaGUgZGVmYXVsdCB0ZXh0dXJlIGNvbG9yIGlzIHVzZWQgd2hlbiBsb2FkaW5nIHRleHR1cmVzIGZyb21cbiAqIHVybHMuIEJlY2F1c2UgdGhlIFVSTCB3aWxsIGJlIGxvYWRlZCBhc3luYyB3ZSdkIGxpa2UgdG8gYmVcbiAqIGFibGUgdG8gdXNlIHRoZSB0ZXh0dXJlIGltbWVkaWF0ZWx5LiBCeSBwdXR0aW5nIGEgMXgxIHBpeGVsXG4gKiBjb2xvciBpbiB0aGUgdGV4dHVyZSB3ZSBjYW4gc3RhcnQgdXNpbmcgdGhlIHRleHR1cmUgYmVmb3JlXG4gKiB0aGUgVVJMIGhhcyBsb2FkZWQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IgQXJyYXkgb2YgNCB2YWx1ZXMgaW4gdGhlIHJhbmdlIDAgdG8gMVxuICogQGRlcHJlY2F0ZWQgc2VlIHtAbGluayBtb2R1bGU6dHdnbC5zZXREZWZhdWx0c31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cblxuZnVuY3Rpb24gc2V0RGVmYXVsdFRleHR1cmVDb2xvcihjb2xvcikge1xuICBkZWZhdWx0cy50ZXh0dXJlQ29sb3IgPSBuZXcgVWludDhBcnJheShbY29sb3JbMF0gKiAyNTUsIGNvbG9yWzFdICogMjU1LCBjb2xvclsyXSAqIDI1NSwgY29sb3JbM10gKiAyNTVdKTtcbn1cblxuZnVuY3Rpb24gc2V0RGVmYXVsdHMobmV3RGVmYXVsdHMpIHtcbiAgaGVscGVyLmNvcHlFeGlzdGluZ1Byb3BlcnRpZXMobmV3RGVmYXVsdHMsIGRlZmF1bHRzKTtcblxuICBpZiAobmV3RGVmYXVsdHMudGV4dHVyZUNvbG9yKSB7XG4gICAgc2V0RGVmYXVsdFRleHR1cmVDb2xvcihuZXdEZWZhdWx0cy50ZXh0dXJlQ29sb3IpO1xuICB9XG59XG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIHNvdXJjZSBmb3IgYSB0ZXh0dXJlLlxuICogQGNhbGxiYWNrIFRleHR1cmVGdW5jXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgdGhlIHRleHR1cmUgb3B0aW9uc1xuICogQHJldHVybiB7Kn0gUmV0dXJucyBhbnkgb2YgdGhlIHRoaW5ncyBkb2N1bWVudGVkIGZvciBgc3JjYCBmb3Ige0BsaW5rIG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogVGV4dHVyZSBvcHRpb25zIHBhc3NlZCB0byBtb3N0IHRleHR1cmUgZnVuY3Rpb25zLiBFYWNoIGZ1bmN0aW9uIHdpbGwgdXNlIHdoYXRldmVyIG9wdGlvbnNcbiAqIGFyZSBhcHByb3ByaWF0ZSBmb3IgaXRzIG5lZWRzLiBUaGlzIGxldHMgeW91IHBhc3MgdGhlIHNhbWUgb3B0aW9ucyB0byBhbGwgZnVuY3Rpb25zLlxuICpcbiAqIE5vdGU6IEEgYFRleEltYWdlU291cmNlYCBpcyBkZWZpbmVkIGluIHRoZSBXZWJHTCBzcGVjIGFzIGEgYEhUTUxJbWFnZUVsZW1lbnRgLCBgSFRNTFZpZGVvRWxlbWVudGAsXG4gKiBgSFRNTENhbnZhc0VsZW1lbnRgLCBgSW1hZ2VCaXRtYXBgLCBvciBgSW1hZ2VEYXRhYC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXh0dXJlT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YXJnZXRdIHRoZSB0eXBlIG9mIHRleHR1cmUgYGdsLlRFWFRVUkVfMkRgIG9yIGBnbC5URVhUVVJFX0NVQkVfTUFQYC4gRGVmYXVsdHMgdG8gYGdsLlRFWFRVUkVfMkRgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsZXZlbF0gdGhlIG1pcCBsZXZlbCB0byBhZmZlY3QuIERlZmF1bHRzIHRvIDAuIE5vdGUsIGlmIHNldCBhdXRvIHdpbGwgYmUgY29uc2lkZXJlZCBmYWxzZSB1bmxlc3MgZXhwbGljaXRseSBzZXQgdG8gdHJ1ZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd2lkdGhdIHRoZSB3aWR0aCBvZiB0aGUgdGV4dHVyZS4gT25seSB1c2VkIGlmIHNyYyBpcyBhbiBhcnJheSBvciB0eXBlZCBhcnJheSBvciBudWxsLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoZWlnaHRdIHRoZSBoZWlnaHQgb2YgYSB0ZXh0dXJlLiBPbmx5IHVzZWQgaWYgc3JjIGlzIGFuIGFycmF5IG9yIHR5cGVkIGFycmF5IG9yIG51bGwuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlcHRoXSB0aGUgZGVwdGggb2YgYSB0ZXh0dXJlLiBPbmx5IHVzZWQgaWYgc3JjIGlzIGFuIGFycmF5IG9yIHR5cGUgYXJyYXkgb3IgbnVsbCBhbmQgdGFyZ2V0IGlzIGBURVhUVVJFXzNEYCAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pbl0gdGhlIG1pbiBmaWx0ZXIgc2V0dGluZyAoZWcuIGBnbC5MSU5FQVJgKS4gRGVmYXVsdHMgdG8gYGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUmBcbiAqICAgICBvciBpZiB0ZXh0dXJlIGlzIG5vdCBhIHBvd2VyIG9mIDIgb24gYm90aCBkaW1lbnNpb25zIHRoZW4gZGVmYXVsdHMgdG8gYGdsLkxJTkVBUmAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21hZ10gdGhlIG1hZyBmaWx0ZXIgc2V0dGluZyAoZWcuIGBnbC5MSU5FQVJgKS4gRGVmYXVsdHMgdG8gYGdsLkxJTkVBUmBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluTWFnXSBib3RoIHRoZSBtaW4gYW5kIG1hZyBmaWx0ZXIgc2V0dGluZ3MuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ludGVybmFsRm9ybWF0XSBpbnRlcm5hbCBmb3JtYXQgZm9yIHRleHR1cmUuIERlZmF1bHRzIHRvIGBnbC5SR0JBYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmb3JtYXRdIGZvcm1hdCBmb3IgdGV4dHVyZS4gRGVmYXVsdHMgdG8gYGdsLlJHQkFgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0eXBlXSB0eXBlIGZvciB0ZXh0dXJlLiBEZWZhdWx0cyB0byBgZ2wuVU5TSUdORURfQllURWAgdW5sZXNzIGBzcmNgIGlzIEFycmF5QnVmZmVyVmlldy4gSWYgYHNyY2BcbiAqICAgICBpcyBBcnJheUJ1ZmZlclZpZXcgZGVmYXVsdHMgdG8gdHlwZSB0aGF0IG1hdGNoZXMgQXJyYXlCdWZmZXJWaWV3IHR5cGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dyYXBdIFRleHR1cmUgd3JhcHBpbmcgZm9yIGJvdGggUyBhbmQgVCAoYW5kIFIgaWYgVEVYVFVSRV8zRCBvciBXZWJHTFNhbXBsZXIpLiBEZWZhdWx0cyB0byBgZ2wuUkVQRUFUYCBmb3IgMkQgdW5sZXNzIHNyYyBpcyBXZWJHTDEgYW5kIHNyYyBub3QgbnBvdCBhbmQgYGdsLkNMQU1QX1RPX0VER0VgIGZvciBjdWJlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dyYXBTXSBUZXh0dXJlIHdyYXBwaW5nIGZvciBTLiBEZWZhdWx0cyB0byBgZ2wuUkVQRUFUYCBhbmQgYGdsLkNMQU1QX1RPX0VER0VgIGZvciBjdWJlLiBJZiBzZXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGB3cmFwYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd3JhcFRdIFRleHR1cmUgd3JhcHBpbmcgZm9yIFQuIERlZmF1bHRzIHRvIGBnbC5SRVBFQVRgIGFuZCBgZ2wuQ0xBTVBfVE9fRURHRWAgZm9yIGN1YmUuIElmIHNldCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYHdyYXBgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3cmFwUl0gVGV4dHVyZSB3cmFwcGluZyBmb3IgUi4gRGVmYXVsdHMgdG8gYGdsLlJFUEVBVGAgYW5kIGBnbC5DTEFNUF9UT19FREdFYCBmb3IgY3ViZS4gSWYgc2V0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgd3JhcGAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pbkxvZF0gVEVYVFVSRV9NSU5fTE9EIHNldHRpbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4TG9kXSBURVhUVVJFX01BWF9MT0Qgc2V0dGluZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtiYXNlTGV2ZWxdIFRFWFRVUkVfQkFTRV9MRVZFTCBzZXR0aW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heExldmVsXSBURVhUVVJFX01BWF9MRVZFTCBzZXR0aW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3VucGFja0FsaWdubWVudF0gVGhlIGBnbC5VTlBBQ0tfQUxJR05NRU5UYCB1c2VkIHdoZW4gdXBsb2FkaW5nIGFuIGFycmF5LiBEZWZhdWx0cyB0byAxLlxuICogQHByb3BlcnR5IHtudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd9IFtjb2xvcl0gQ29sb3IgdG8gaW5pdGlhbGl6ZSB0aGlzIHRleHR1cmUgd2l0aCBpZiBsb2FkaW5nIGFuIGltYWdlIGFzeW5jaHJvbm91c2x5LlxuICogICAgIFRoZSBkZWZhdWx0IHVzZSBhIGJsdWUgMXgxIHBpeGVsIHRleHR1cmUuIFlvdSBjYW4gc2V0IGFub3RoZXIgZGVmYXVsdCBieSBjYWxsaW5nIGB0d2dsLnNldERlZmF1bHRzYFxuICogICAgIG9yIHlvdSBjYW4gc2V0IGFuIGluZGl2aWR1YWwgdGV4dHVyZSdzIGluaXRpYWwgY29sb3IgYnkgc2V0dGluZyB0aGlzIHByb3BlcnR5LiBFeGFtcGxlOiBgWzEsIC41LCAuNSwgMV1gID0gcGlua1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwcmVtdWx0aXBseUFscGhhXSBXaGV0aGVyIG9yIG5vdCB0byBwcmVtdWx0aXBseSBhbHBoYS4gRGVmYXVsdHMgdG8gd2hhdGV2ZXIgdGhlIGN1cnJlbnQgc2V0dGluZyBpcy5cbiAqICAgICBUaGlzIGxldHMgeW91IHNldCBpdCBvbmNlIGJlZm9yZSBjYWxsaW5nIGB0d2dsLmNyZWF0ZVRleHR1cmVgIG9yIGB0d2dsLmNyZWF0ZVRleHR1cmVzYCBhbmQgb25seSBvdmVycmlkZVxuICogICAgIHRoZSBjdXJyZW50IHNldHRpbmcgZm9yIHNwZWNpZmljIHRleHR1cmVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmbGlwWV0gV2hldGhlciBvciBub3QgdG8gZmxpcCB0aGUgdGV4dHVyZSB2ZXJ0aWNhbGx5IG9uIHVwbG9hZC4gRGVmYXVsdHMgdG8gd2hhdGV2ZXIgdGhlIGN1cnJlbnQgc2V0dGluZyBpcy5cbiAqICAgICBUaGlzIGxldHMgeW91IHNldCBpdCBvbmNlIGJlZm9yZSBjYWxsaW5nIGB0d2dsLmNyZWF0ZVRleHR1cmVgIG9yIGB0d2dsLmNyZWF0ZVRleHR1cmVzYCBhbmQgb25seSBvdmVycmlkZVxuICogICAgIHRoZSBjdXJyZW50IHNldHRpbmcgZm9yIHNwZWNpZmljIHRleHR1cmVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjb2xvcnNwYWNlQ29udmVyc2lvbl0gV2hldGhlciBvciBub3QgdG8gbGV0IHRoZSBicm93c2VyIGRvIGNvbG9yc3BhY2UgY29udmVyc2lvbiBvZiB0aGUgdGV4dHVyZSBvbiB1cGxvYWQuIERlZmF1bHRzIHRvIHdoYXRldmVyIHRoZSBjdXJyZW50IHNldHRpbmcgaXMuXG4gKiAgICAgVGhpcyBsZXRzIHlvdSBzZXQgaXQgb25jZSBiZWZvcmUgY2FsbGluZyBgdHdnbC5jcmVhdGVUZXh0dXJlYCBvciBgdHdnbC5jcmVhdGVUZXh0dXJlc2AgYW5kIG9ubHkgb3ZlcnJpZGVcbiAqICAgICB0aGUgY3VycmVudCBzZXR0aW5nIGZvciBzcGVjaWZpYyB0ZXh0dXJlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F1dG9dIElmIGB1bmRlZmluZWRgIG9yIGB0cnVlYCwgaW4gV2ViR0wxLCB0ZXh0dXJlIGZpbHRlcmluZyBpcyBzZXQgYXV0b21hdGljYWxseSBmb3Igbm9uLXBvd2VyIG9mIDIgaW1hZ2VzIGFuZFxuICogICAgbWlwcyBhcmUgZ2VuZXJhdGVkIGZvciBwb3dlciBvZiAyIGltYWdlcy4gSW4gV2ViR0wyIG1pcHMgYXJlIGdlbmVyYXRlZCBpZiB0aGV5IGNhbiBiZS4gTm90ZTogaWYgYGxldmVsYCBpcyBzZXQgYWJvdmVcbiAqICAgIHRoZW4gdGhlbiBgYXV0b2AgaXMgYXNzdW1lZCB0byBiZSBgZmFsc2VgIHVubGVzcyBleHBsaWNpdHkgc2V0IHRvIGB0cnVlYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IFtjdWJlRmFjZU9yZGVyXSBUaGUgb3JkZXIgdGhhdCBjdWJlIGZhY2VzIGFyZSBwdWxsZWQgb3V0IG9mIGFuIGltZyBvciBzZXQgb2YgaW1hZ2VzLiBUaGUgZGVmYXVsdCBpc1xuICpcbiAqICAgICBbZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLFxuICogICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gsXG4gKiAgICAgIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSxcbiAqICAgICAgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZLFxuICogICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osXG4gKiAgICAgIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWl1cbiAqXG4gKiBAcHJvcGVydHkgeyhudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd8VGV4SW1hZ2VTb3VyY2V8VGV4SW1hZ2VTb3VyY2VbXXxzdHJpbmd8c3RyaW5nW118bW9kdWxlOnR3Z2wuVGV4dHVyZUZ1bmMpfSBbc3JjXSBzb3VyY2UgZm9yIHRleHR1cmVcbiAqXG4gKiAgICBJZiBgc3RyaW5nYCB0aGVuIGl0J3MgYXNzdW1lZCB0byBiZSBhIFVSTCB0byBhbiBpbWFnZS4gVGhlIGltYWdlIHdpbGwgYmUgZG93bmxvYWRlZCBhc3luYy4gQSB1c2FibGVcbiAqICAgIDF4MSBwaXhlbCB0ZXh0dXJlIHdpbGwgYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHkuIFRoZSB0ZXh0dXJlIHdpbGwgYmUgdXBkYXRlZCBvbmNlIHRoZSBpbWFnZSBoYXMgZG93bmxvYWRlZC5cbiAqICAgIElmIGB0YXJnZXRgIGlzIGBnbC5URVhUVVJFX0NVQkVfTUFQYCB3aWxsIGF0dGVtcHQgdG8gZGl2aWRlIGltYWdlIGludG8gNiBzcXVhcmUgcGllY2VzLiAxeDYsIDZ4MSwgM3gyLCAyeDMuXG4gKiAgICBUaGUgcGllY2VzIHdpbGwgYmUgdXBsb2FkZWQgaW4gYGN1YmVGYWNlT3JkZXJgXG4gKlxuICogICAgSWYgYHN0cmluZ1tdYCBvciBgVGV4SW1hZ2VTb3VyY2VbXWAgYW5kIHRhcmdldCBpcyBgZ2wuVEVYVFVSRV9DVUJFX01BUGAgdGhlbiBpdCBtdXN0IGhhdmUgNiBlbnRyaWVzLCBvbmUgZm9yIGVhY2ggZmFjZSBvZiBhIGN1YmUgbWFwLlxuICpcbiAqICAgIElmIGBzdHJpbmdbXWAgb3IgYFRleEltYWdlU291cmNlW11gIGFuZCB0YXJnZXQgaXMgYGdsLlRFWFRVUkVfMkRfQVJSQVlgIHRoZW4gZWFjaCBlbnRyeSBpcyBhIHNsaWNlIG9mIHRoZSBhIDJkIGFycmF5IHRleHR1cmVcbiAqICAgIGFuZCB3aWxsIGJlIHNjYWxlZCB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQgT1IgdG8gdGhlIHNpemUgb2YgdGhlIGZpcnN0IGltYWdlIHRoYXQgbG9hZHMuXG4gKlxuICogICAgSWYgYFRleEltYWdlU291cmNlYCB0aGVuIGl0IHdpbCBiZSB1c2VkIGltbWVkaWF0ZWx5IHRvIGNyZWF0ZSB0aGUgY29udGVudHMgb2YgdGhlIHRleHR1cmUuIEV4YW1wbGVzIGBIVE1MSW1hZ2VFbGVtZW50YCxcbiAqICAgIGBIVE1MQ2FudmFzRWxlbWVudGAsIGBIVE1MVmlkZW9FbGVtZW50YC5cbiAqXG4gKiAgICBJZiBgbnVtYmVyW11gIG9yIGBBcnJheUJ1ZmZlclZpZXdgIGl0J3MgYXNzdW1lZCB0byBiZSBkYXRhIGZvciBhIHRleHR1cmUuIElmIGB3aWR0aGAgb3IgYGhlaWdodGAgaXNcbiAqICAgIG5vdCBzcGVjaWZpZWQgaXQgaXMgZ3Vlc3NlZCBhcyBmb2xsb3dzLiBGaXJzdCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGlzIGNvbXB1dGVkIGJ5IGBzcmMubGVuZ3RoIC8gbnVtQ29tcG9uZW50c2BcbiAqICAgIHdoZXJlIGBudW1Db21wb25lbnRzYCBpcyBkZXJpdmVkIGZyb20gYGZvcm1hdGAuIElmIGB0YXJnZXRgIGlzIGBnbC5URVhUVVJFX0NVQkVfTUFQYCB0aGVuIGBudW1FbGVtZW50c2AgaXMgZGl2aWRlZFxuICogICAgYnkgNi4gVGhlblxuICpcbiAqICAgICogICBJZiBuZWl0aGVyIGB3aWR0aGAgbm9yIGBoZWlnaHRgIGFyZSBzcGVjaWZpZWQgYW5kIGBzcXJ0KG51bUVsZW1lbnRzKWAgaXMgYW4gaW50ZWdlciB0aGVuIHdpZHRoIGFuZCBoZWlnaHRcbiAqICAgICAgICBhcmUgc2V0IHRvIGBzcXJ0KG51bUVsZW1lbnRzKWAuIE90aGVyd2lzZSBgd2lkdGggPSBudW1FbGVtZW50c2AgYW5kIGBoZWlnaHQgPSAxYC5cbiAqXG4gKiAgICAqICAgSWYgb25seSBvbmUgb2YgYHdpZHRoYCBvciBgaGVpZ2h0YCBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgb3RoZXIgZXF1YWxzIGBudW1FbGVtZW50cyAvIHNwZWNpZmllZERpbWVuc2lvbmAuXG4gKlxuICogSWYgYG51bWJlcltdYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBgdHlwZWAuXG4gKlxuICogSWYgYHNyY2AgaXMgYSBmdW5jdGlvbiBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgYFdlYkdMUmVuZGVyaW5nQ29udGV4dGAgYW5kIHRoZXNlIG9wdGlvbnMuXG4gKiBXaGF0ZXZlciBpdCByZXR1cm5zIGlzIHN1YmplY3QgdG8gdGhlc2UgcnVsZXMuIFNvIGl0IGNhbiByZXR1cm4gYSBzdHJpbmcgdXJsLCBhbiBgSFRNTEVsZW1lbnRgXG4gKiBhbiBhcnJheSBldGMuLi5cbiAqXG4gKiBJZiBgc3JjYCBpcyB1bmRlZmluZWQgdGhlbiBhbiBlbXB0eSB0ZXh0dXJlIHdpbGwgYmUgY3JlYXRlZCBvZiBzaXplIGB3aWR0aGAgYnkgYGhlaWdodGAuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjcm9zc09yaWdpbl0gV2hhdCB0byBzZXQgdGhlIGNyb3NzT3JpZ2luIHByb3BlcnR5IG9mIGltYWdlcyB3aGVuIHRoZXkgYXJlIGRvd25sb2FkZWQuXG4gKiAgICBkZWZhdWx0OiB1bmRlZmluZWQuIEFsc28gc2VlIHtAbGluayBtb2R1bGU6dHdnbC5zZXREZWZhdWx0c30uXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBTZXRzIGFueSBwYWNraW5nIHN0YXRlIHRoYXQgd2lsbCBiZSBzZXQgYmFzZWQgb24gdGhlIG9wdGlvbnMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFBhY2tTdGF0ZShnbCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5jb2xvcnNwYWNlQ29udmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgb3B0aW9ucy5jb2xvcnNwYWNlQ29udmVyc2lvbik7XG4gIH1cblxuICBpZiAob3B0aW9ucy5wcmVtdWx0aXBseUFscGhhICE9PSB1bmRlZmluZWQpIHtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIG9wdGlvbnMucHJlbXVsdGlwbHlBbHBoYSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5mbGlwWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX0ZMSVBfWV9XRUJHTCwgb3B0aW9ucy5mbGlwWSk7XG4gIH1cbn1cbi8qKlxuICogU2V0IHNraXAgc3RhdGUgdG8gZGVmYXVsdHNcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2V0U2tpcFN0YXRlVG9EZWZhdWx0KGdsKSB7XG4gIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19BTElHTk1FTlQsIDQpO1xuXG4gIGlmICh1dGlscy5pc1dlYkdMMihnbCkpIHtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfUk9XX0xFTkdUSCwgMCk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX0lNQUdFX0hFSUdIVCwgMCk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX1NLSVBfUElYRUxTLCAwKTtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfU0tJUF9ST1dTLCAwKTtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfU0tJUF9JTUFHRVMsIDApO1xuICB9XG59XG4vKipcbiAqIFNldHMgdGhlIHBhcmFtZXRlcnMgb2YgYSB0ZXh0dXJlIG9yIHNhbXBsZXJcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcnxXZWJHTFNhbXBsZXJ9IHRhcmdldCB0ZXh0dXJlIHRhcmdldCBvciBzYW1wbGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IHBhcmFtZXRlcmlGbiB0ZXhQYXJhbWV0ZXJpIG9yIHNhbXBsZXJQYXJhbWV0ZXJpIGZuXG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiAgIFRoaXMgaXMgb2Z0ZW4gdGhlIHNhbWUgb3B0aW9ucyB5b3UgcGFzc2VkIGluIHdoZW4geW91IGNyZWF0ZWQgdGhlIHRleHR1cmUuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2V0VGV4dHVyZVNhbXBsZXJQYXJhbWV0ZXJzKGdsLCB0YXJnZXQsIHBhcmFtZXRlcmlGbiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5taW5NYWcpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX01JTl9GSUxURVIsIG9wdGlvbnMubWluTWFnKTtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX01BR19GSUxURVIsIG9wdGlvbnMubWluTWFnKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLm1pbikge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfTUlOX0ZJTFRFUiwgb3B0aW9ucy5taW4pO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMubWFnKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9NQUdfRklMVEVSLCBvcHRpb25zLm1hZyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy53cmFwKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9XUkFQX1MsIG9wdGlvbnMud3JhcCk7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9XUkFQX1QsIG9wdGlvbnMud3JhcCk7XG5cbiAgICBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEIHx8IGhlbHBlci5pc1NhbXBsZXIoZ2wsIHRhcmdldCkpIHtcbiAgICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfV1JBUF9SLCBvcHRpb25zLndyYXApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLndyYXBSKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9XUkFQX1IsIG9wdGlvbnMud3JhcFIpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMud3JhcFMpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX1dSQVBfUywgb3B0aW9ucy53cmFwUyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy53cmFwVCkge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfV1JBUF9ULCBvcHRpb25zLndyYXBUKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLm1pbkxvZCkge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfTUlOX0xPRCwgb3B0aW9ucy5taW5Mb2QpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMubWF4TG9kKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9NQVhfTE9ELCBvcHRpb25zLm1heExvZCk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5iYXNlTGV2ZWwpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX0JBU0VfTEVWRUwsIG9wdGlvbnMuYmFzZUxldmVsKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLm1heExldmVsKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9NQVhfTEVWRUwsIG9wdGlvbnMubWF4TGV2ZWwpO1xuICB9XG59XG4vKipcbiAqIFNldHMgdGhlIHRleHR1cmUgcGFyYW1ldGVycyBvZiBhIHRleHR1cmUuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogICBUaGlzIGlzIG9mdGVuIHRoZSBzYW1lIG9wdGlvbnMgeW91IHBhc3NlZCBpbiB3aGVuIHlvdSBjcmVhdGVkIHRoZSB0ZXh0dXJlLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRUZXh0dXJlUGFyYW1ldGVycyhnbCwgdGV4LCBvcHRpb25zKSB7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJEO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gIHNldFRleHR1cmVTYW1wbGVyUGFyYW1ldGVycyhnbCwgdGFyZ2V0LCBnbC50ZXhQYXJhbWV0ZXJpLCBvcHRpb25zKTtcbn1cbi8qKlxuICogU2V0cyB0aGUgc2FtcGxlciBwYXJhbWV0ZXJzIG9mIGEgc2FtcGxlci5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMU2FtcGxlcn0gc2FtcGxlciB0aGUgV2ViR0xTYW1wbGVyIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRTYW1wbGVyUGFyYW1ldGVycyhnbCwgc2FtcGxlciwgb3B0aW9ucykge1xuICBzZXRUZXh0dXJlU2FtcGxlclBhcmFtZXRlcnMoZ2wsIHNhbXBsZXIsIGdsLnNhbXBsZXJQYXJhbWV0ZXJpLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzYW1wbGVyIG9iamVjdCBhbmQgc2V0cyBwYXJhbWV0ZXJzLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICBjb25zdCBzYW1wbGVyID0gdHdnbC5jcmVhdGVTYW1wbGVyKGdsLCB7XG4gKiAgICAgICAgbWluTWFnOiBnbC5ORUFSRVNULCAgICAgICAgIC8vIHNldHMgYm90aCBURVhUVVJFX01JTl9GSUxURVIgYW5kIFRFWFRVUkVfTUFHX0ZJTFRFUlxuICogICAgICAgIHdyYXA6IGdsLkNMQU1QX1RPX05FQVJFU1QsICAvLyBzZXRzIGJvdGggVEVYVFVSRV9XUkFQX1MgYW5kIFRFWFRVUkVfV1JBUF9UIGFuZCBURVhUVVJFX1dSQVBfUlxuICogICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxtb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9ucz59IG9wdGlvbnMgQSBvYmplY3Qgb2YgVGV4dHVyZU9wdGlvbnMgb25lIHBlciBzYW1wbGVyLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsV2ViR0xTYW1wbGVyPn0gdGhlIGNyZWF0ZWQgc2FtcGxlcnMgYnkgbmFtZVxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNhbXBsZXIoZ2wsIG9wdGlvbnMpIHtcbiAgdmFyIHNhbXBsZXIgPSBnbC5jcmVhdGVTYW1wbGVyKCk7XG4gIHNldFNhbXBsZXJQYXJhbWV0ZXJzKGdsLCBzYW1wbGVyLCBvcHRpb25zKTtcbiAgcmV0dXJuIHNhbXBsZXI7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtdWx0aXBsZSBzYW1wbGVyIG9iamVjdHMgYW5kIHNldHMgcGFyYW1ldGVycyBvbiBlYWNoLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICBjb25zdCBzYW1wbGVycyA9IHR3Z2wuY3JlYXRlU2FtcGxlcnMoZ2wsIHtcbiAqICAgICAgICBuZWFyZXN0OiB7XG4gKiAgICAgICAgICBtaW5NYWc6IGdsLk5FQVJFU1QsXG4gKiAgICAgICAgfSxcbiAqICAgICAgICBuZWFyZXN0Q2xhbXBTOiB7XG4gKiAgICAgICAgICBtaW5NYWc6IGdsLk5FQVJFU1QsXG4gKiAgICAgICAgICB3cmFwUzogZ2wuQ0xBTVBfVE9fTkVBUkVTVCxcbiAqICAgICAgICB9LFxuICogICAgICAgIGxpbmVhcjoge1xuICogICAgICAgICAgbWluTWFnOiBnbC5MSU5FQVIsXG4gKiAgICAgICAgfSxcbiAqICAgICAgICBuZWFyZXN0Q2xhbXA6IHtcbiAqICAgICAgICAgIG1pbk1hZzogZ2wuTkVBUkVTVCxcbiAqICAgICAgICAgIHdyYXA6IGdsLkNMQU1QX1RPX0VER0UsXG4gKiAgICAgICAgfSxcbiAqICAgICAgICBsaW5lYXJDbGFtcDoge1xuICogICAgICAgICAgbWluTWFnOiBnbC5MSU5FQVIsXG4gKiAgICAgICAgICB3cmFwOiBnbC5DTEFNUF9UT19FREdFLFxuICogICAgICAgIH0sXG4gKiAgICAgICAgbGluZWFyQ2xhbXBUOiB7XG4gKiAgICAgICAgICBtaW5NYWc6IGdsLkxJTkVBUixcbiAqICAgICAgICAgIHdyYXBUOiBnbC5DTEFNUF9UT19FREdFLFxuICogICAgICAgIH0sXG4gKiAgICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldCBvbiB0aGUgc2FtcGxlclxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNhbXBsZXJzKGdsLCBzYW1wbGVyT3B0aW9ucykge1xuICB2YXIgc2FtcGxlcnMgPSB7fTtcbiAgT2JqZWN0LmtleXMoc2FtcGxlck9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBzYW1wbGVyc1tuYW1lXSA9IGNyZWF0ZVNhbXBsZXIoZ2wsIHNhbXBsZXJPcHRpb25zW25hbWVdKTtcbiAgfSk7XG4gIHJldHVybiBzYW1wbGVycztcbn1cbi8qKlxuICogTWFrZXMgYSAxeDEgcGl4ZWxcbiAqIElmIG5vIGNvbG9yIGlzIHBhc3NlZCBpbiB1c2VzIHRoZSBkZWZhdWx0IGNvbG9yIHdoaWNoIGNhbiBiZSBzZXQgYnkgY2FsbGluZyBgc2V0RGVmYXVsdFRleHR1cmVDb2xvcmAuXG4gKiBAcGFyYW0geyhudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXcpfSBbY29sb3JdIFRoZSBjb2xvciB1c2luZyAwLTEgdmFsdWVzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fSBVbml0OEFycmF5IHdpdGggY29sb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbWFrZTFQaXhlbChjb2xvcikge1xuICBjb2xvciA9IGNvbG9yIHx8IGRlZmF1bHRzLnRleHR1cmVDb2xvcjtcblxuICBpZiAoaXNBcnJheUJ1ZmZlcihjb2xvcikpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW2NvbG9yWzBdICogMjU1LCBjb2xvclsxXSAqIDI1NSwgY29sb3JbMl0gKiAyNTUsIGNvbG9yWzNdICogMjU1XSk7XG59XG4vKipcbiAqIFNldHMgZmlsdGVyaW5nIG9yIGdlbmVyYXRlcyBtaXBzIGZvciB0ZXh0dXJlIGJhc2VkIG9uIHdpZHRoIG9yIGhlaWdodFxuICogSWYgd2lkdGggb3IgaGVpZ2h0IGlzIG5vdCBwYXNzZWQgaW4gdXNlcyBgb3B0aW9ucy53aWR0aGAgYW5kLy9vciBgb3B0aW9ucy5oZWlnaHRgXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIFdlYkdMVGV4dHVyZSB0byBzZXQgcGFyYW1ldGVycyBmb3JcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IFtvcHRpb25zXSBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogICBUaGlzIGlzIG9mdGVuIHRoZSBzYW1lIG9wdGlvbnMgeW91IHBhc3NlZCBpbiB3aGVuIHlvdSBjcmVhdGVkIHRoZSB0ZXh0dXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gd2lkdGggb2YgdGV4dHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIGhlaWdodCBvZiB0ZXh0dXJlXG4gKiBAcGFyYW0ge251bWJlcn0gW2ludGVybmFsRm9ybWF0XSBUaGUgaW50ZXJuYWxGb3JtYXQgcGFyYW1ldGVyIGZyb20gdGV4SW1hZ2UyRCBldGMuLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShnbCwgdGV4LCBvcHRpb25zLCB3aWR0aCwgaGVpZ2h0LCBpbnRlcm5hbEZvcm1hdCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cy50ZXh0dXJlT3B0aW9ucztcbiAgaW50ZXJuYWxGb3JtYXQgPSBpbnRlcm5hbEZvcm1hdCB8fCBSR0JBO1xuICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRDtcbiAgd2lkdGggPSB3aWR0aCB8fCBvcHRpb25zLndpZHRoO1xuICBoZWlnaHQgPSBoZWlnaHQgfHwgb3B0aW9ucy5oZWlnaHQ7XG4gIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcblxuICBpZiAoY2FuR2VuZXJhdGVNaXBtYXAoZ2wsIHdpZHRoLCBoZWlnaHQsIGludGVybmFsRm9ybWF0KSkge1xuICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpbHRlcmluZyA9IGNhbkZpbHRlcihpbnRlcm5hbEZvcm1hdCkgPyBMSU5FQVIgOiBORUFSRVNUO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBURVhUVVJFX01JTl9GSUxURVIsIGZpbHRlcmluZyk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIFRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyaW5nKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgVEVYVFVSRV9XUkFQX1MsIENMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBURVhUVVJFX1dSQVBfVCwgQ0xBTVBfVE9fRURHRSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQXV0b21hdGljYWxseVNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuYXV0byA9PT0gdHJ1ZSB8fCBvcHRpb25zLmF1dG8gPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmxldmVsID09PSB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEdldHMgYW4gYXJyYXkgb2YgY3ViZW1hcCBmYWNlIGVudW1zXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogICBUaGlzIGlzIG9mdGVuIHRoZSBzYW1lIG9wdGlvbnMgeW91IHBhc3NlZCBpbiB3aGVuIHlvdSBjcmVhdGVkIHRoZSB0ZXh0dXJlLlxuICogQHJldHVybiB7bnVtYmVyW119IGN1YmVtYXAgZmFjZSBlbnVtc1xuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEN1YmVGYWNlT3JkZXIoZ2wsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHJldHVybiBvcHRpb25zLmN1YmVGYWNlT3JkZXIgfHwgW1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCwgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YLCBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ksIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWSwgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aLCBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1pdO1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGYWNlSW5mb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGZhY2UgZ2wgZW51bSBmb3IgdGV4SW1hZ2UyRFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG5keCBmYWNlIGluZGV4ICgwIC0gNSkgaW50byBzb3VyY2UgZGF0YVxuICogQGlnbm9yZVxuICovXG5cbi8qKlxuICogR2V0cyBhbiBhcnJheSBvZiBGYWNlSW5mb3NcbiAqIFRoZXJlJ3MgYSBidWcgaW4gc29tZSBOVmlkaWEgZHJpdmVycyB0aGF0IHdpbGwgY3Jhc2ggdGhlIGRyaXZlciBpZlxuICogYGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWGAgaXMgbm90IHVwbG9hZGVkIGZpcnN0LiBTbywgd2UgdGFrZVxuICogdGhlIHVzZXIncyBkZXNpcmVkIG9yZGVyIGZyb20gaGlzIGZhY2VzIHRvIFdlYkdMIGFuZCBtYWtlIHN1cmUgd2VcbiAqIGRvIHRoZSBmYWNlcyBpbiBXZWJHTCBvcmRlclxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAcmV0dXJuIHtGYWNlSW5mb1tdfSBjdWJlbWFwIGZhY2UgaW5mb3MuIEFyZ3VhYmx5IHRoZSBgZmFjZWAgcHJvcGVydHkgb2YgZWFjaCBlbGVtZW50IGlzIHJlZHVuZGFudCBidXRcbiAqICAgIGl0J3MgbmVlZGVkIGludGVybmFsbHkgdG8gc29ydCB0aGUgYXJyYXkgb2YgYG5keGAgcHJvcGVydGllcyBieSBgZmFjZWAuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q3ViZUZhY2VzV2l0aE5keChnbCwgb3B0aW9ucykge1xuICB2YXIgZmFjZXMgPSBnZXRDdWJlRmFjZU9yZGVyKGdsLCBvcHRpb25zKTsgLy8gd29yayBhcm91bmQgYnVnIGluIE5WaWRpYSBkcml2ZXJzLiBXZSBoYXZlIHRvIHVwbG9hZCB0aGUgZmlyc3QgZmFjZSBmaXJzdCBlbHNlIHRoZSBkcml2ZXIgY3Jhc2hlcyA6KFxuXG4gIHZhciBmYWNlc1dpdGhOZHggPSBmYWNlcy5tYXAoZnVuY3Rpb24gKGZhY2UsIG5keCkge1xuICAgIHJldHVybiB7XG4gICAgICBmYWNlOiBmYWNlLFxuICAgICAgbmR4OiBuZHhcbiAgICB9O1xuICB9KTtcbiAgZmFjZXNXaXRoTmR4LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5mYWNlIC0gYi5mYWNlO1xuICB9KTtcbiAgcmV0dXJuIGZhY2VzV2l0aE5keDtcbn1cbi8qKlxuICogU2V0IGEgdGV4dHVyZSBmcm9tIHRoZSBjb250ZW50cyBvZiBhbiBlbGVtZW50LiBXaWxsIGFsc28gc2V0XG4gKiB0ZXh0dXJlIGZpbHRlcmluZyBvciBnZW5lcmF0ZSBtaXBzIGJhc2VkIG9uIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBlbGVtZW50XG4gKiB1bmxlc3MgYG9wdGlvbnMuYXV0byA9PT0gZmFsc2VgLiBJZiBgdGFyZ2V0ID09PSBnbC5URVhUVVJFX0NVQkVfTUFQYCB3aWxsXG4gKiBhdHRlbXB0IHRvIHNsaWNlIGltYWdlIGludG8gMXg2LCAyeDMsIDN4Miwgb3IgNngxIGltYWdlcywgb25lIGZvciBlYWNoIGZhY2UuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBhIGNhbnZhcywgaW1nLCBvciB2aWRlbyBlbGVtZW50LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gW29wdGlvbnNdIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiAgIFRoaXMgaXMgb2Z0ZW4gdGhlIHNhbWUgb3B0aW9ucyB5b3UgcGFzc2VkIGluIHdoZW4geW91IGNyZWF0ZWQgdGhlIHRleHR1cmUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqIEBraW5kIGZ1bmN0aW9uXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRUZXh0dXJlRnJvbUVsZW1lbnQoZ2wsIHRleCwgZWxlbWVudCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cy50ZXh0dXJlT3B0aW9ucztcbiAgdmFyIHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IFRFWFRVUkVfMkQ7XG4gIHZhciBsZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwgMDtcbiAgdmFyIHdpZHRoID0gZWxlbWVudC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnQuaGVpZ2h0O1xuICB2YXIgaW50ZXJuYWxGb3JtYXQgPSBvcHRpb25zLmludGVybmFsRm9ybWF0IHx8IG9wdGlvbnMuZm9ybWF0IHx8IFJHQkE7XG4gIHZhciBmb3JtYXRUeXBlID0gZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0KTtcbiAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGZvcm1hdFR5cGUuZm9ybWF0O1xuICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBmb3JtYXRUeXBlLnR5cGU7XG4gIHNldFBhY2tTdGF0ZShnbCwgb3B0aW9ucyk7XG4gIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcblxuICBpZiAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgLy8gZ3Vlc3MgdGhlIHBhcnRzXG4gICAgdmFyIGltZ1dpZHRoID0gZWxlbWVudC53aWR0aDtcbiAgICB2YXIgaW1nSGVpZ2h0ID0gZWxlbWVudC5oZWlnaHQ7XG4gICAgdmFyIHNpemU7XG4gICAgdmFyIHNsaWNlcztcblxuICAgIGlmIChpbWdXaWR0aCAvIDYgPT09IGltZ0hlaWdodCkge1xuICAgICAgLy8gSXQncyA2eDFcbiAgICAgIHNpemUgPSBpbWdIZWlnaHQ7XG4gICAgICBzbGljZXMgPSBbMCwgMCwgMSwgMCwgMiwgMCwgMywgMCwgNCwgMCwgNSwgMF07XG4gICAgfSBlbHNlIGlmIChpbWdIZWlnaHQgLyA2ID09PSBpbWdXaWR0aCkge1xuICAgICAgLy8gSXQncyAxeDZcbiAgICAgIHNpemUgPSBpbWdXaWR0aDtcbiAgICAgIHNsaWNlcyA9IFswLCAwLCAwLCAxLCAwLCAyLCAwLCAzLCAwLCA0LCAwLCA1XTtcbiAgICB9IGVsc2UgaWYgKGltZ1dpZHRoIC8gMyA9PT0gaW1nSGVpZ2h0IC8gMikge1xuICAgICAgLy8gSXQncyAzeDJcbiAgICAgIHNpemUgPSBpbWdXaWR0aCAvIDM7XG4gICAgICBzbGljZXMgPSBbMCwgMCwgMSwgMCwgMiwgMCwgMCwgMSwgMSwgMSwgMiwgMV07XG4gICAgfSBlbHNlIGlmIChpbWdXaWR0aCAvIDIgPT09IGltZ0hlaWdodCAvIDMpIHtcbiAgICAgIC8vIEl0J3MgMngzXG4gICAgICBzaXplID0gaW1nV2lkdGggLyAyO1xuICAgICAgc2xpY2VzID0gWzAsIDAsIDEsIDAsIDAsIDEsIDEsIDEsIDAsIDIsIDEsIDJdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBcImNhbid0IGZpZ3VyZSBvdXQgY3ViZSBtYXAgZnJvbSBlbGVtZW50OiBcIiArIChlbGVtZW50LnNyYyA/IGVsZW1lbnQuc3JjIDogZWxlbWVudC5ub2RlTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGN0eCA9IGdldFNoYXJlZDJEQ29udGV4dCgpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmNhbnZhcy53aWR0aCA9IHNpemU7XG4gICAgICBjdHguY2FudmFzLmhlaWdodCA9IHNpemU7XG4gICAgICB3aWR0aCA9IHNpemU7XG4gICAgICBoZWlnaHQgPSBzaXplO1xuICAgICAgZ2V0Q3ViZUZhY2VzV2l0aE5keChnbCwgb3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICB2YXIgeE9mZnNldCA9IHNsaWNlc1tmLm5keCAqIDIgKyAwXSAqIHNpemU7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gc2xpY2VzW2YubmR4ICogMiArIDFdICogc2l6ZTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShlbGVtZW50LCB4T2Zmc2V0LCB5T2Zmc2V0LCBzaXplLCBzaXplLCAwLCAwLCBzaXplLCBzaXplKTtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChmLmZhY2UsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBjdHguY2FudmFzKTtcbiAgICAgIH0pOyAvLyBGcmVlIHVwIHRoZSBjYW52YXMgbWVtb3J5XG5cbiAgICAgIGN0eC5jYW52YXMud2lkdGggPSAxO1xuICAgICAgY3R4LmNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gTk9URTogSXQgc2VlbXMgbGlrZSB3ZSBzaG91bGQgcHJlZmVyIEltYWdlQml0bWFwIGJlY2F1c2UgdW5saWtlIGNhbnZhcyBpdCdzXG4gICAgICAvLyBub3RlIGxvc3N5PyAoYWxwaGEgaXMgbm90IHByZW11bHRpcGxpZWQ/IGFsdGhvdWdoIEknbSBub3Qgc3VyZSB3aGF0XG4gICAgICB3aWR0aCA9IHNpemU7XG4gICAgICBoZWlnaHQgPSBzaXplO1xuICAgICAgZ2V0Q3ViZUZhY2VzV2l0aE5keChnbCwgb3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICB2YXIgeE9mZnNldCA9IHNsaWNlc1tmLm5keCAqIDIgKyAwXSAqIHNpemU7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gc2xpY2VzW2YubmR4ICogMiArIDFdICogc2l6ZTsgLy8gV2UgY2FuJ3QgZWFzaWx5IHVzZSBhIGRlZmF1bHQgdGV4dHVyZSBjb2xvciBoZXJlIGFzIGl0IHdvdWxkIGhhdmUgdG8gbWF0Y2hcbiAgICAgICAgLy8gdGhlIHR5cGUgYWNyb3NzIGFsbCBmYWNlcyB3aGVyZSBhcyB3aXRoIGEgMkQgb25lIHRoZXJlJ3Mgb25seSBvbmUgZmFjZVxuICAgICAgICAvLyBzbyB3ZSdyZSByZXBsYWNpbmcgZXZlcnl0aGluZyBhbGwgYXQgb25jZS4gSXQgYWxzbyBoYXMgdG8gYmUgdGhlIGNvcnJlY3Qgc2l6ZS5cbiAgICAgICAgLy8gT24gdGhlIG90aGVyIGhhbmQgd2UgbmVlZCBhbGwgZmFjZXMgdG8gYmUgdGhlIHNhbWUgc2l6ZSBzbyBhcyBvbmUgZmFjZSBsb2Fkc1xuICAgICAgICAvLyB0aGUgcmVzdCBtYXRjaCBlbHNlIHRoZSB0ZXh0dXJlIHdpbGwgYmUgdW4tcmVuZGVyYWJsZS5cblxuICAgICAgICBnbC50ZXhJbWFnZTJEKGYuZmFjZSwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBzaXplLCBzaXplLCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuICAgICAgICBjcmVhdGVJbWFnZUJpdG1hcChlbGVtZW50LCB4T2Zmc2V0LCB5T2Zmc2V0LCBzaXplLCBzaXplLCB7XG4gICAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogJ25vbmUnLFxuICAgICAgICAgIGNvbG9yU3BhY2VDb252ZXJzaW9uOiAnbm9uZSdcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoaW1hZ2VCaXRtYXApIHtcbiAgICAgICAgICBzZXRQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xuICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcbiAgICAgICAgICBnbC50ZXhJbWFnZTJEKGYuZmFjZSwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIGltYWdlQml0bWFwKTtcblxuICAgICAgICAgIGlmIChzaG91bGRBdXRvbWF0aWNhbGx5U2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKGdsLCB0ZXgsIG9wdGlvbnMsIHdpZHRoLCBoZWlnaHQsIGludGVybmFsRm9ybWF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV8zRCB8fCB0YXJnZXQgPT09IFRFWFRVUkVfMkRfQVJSQVkpIHtcbiAgICB2YXIgc21hbGxlc3QgPSBNYXRoLm1pbihlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCk7XG4gICAgdmFyIGxhcmdlc3QgPSBNYXRoLm1heChlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCk7XG4gICAgdmFyIGRlcHRoID0gbGFyZ2VzdCAvIHNtYWxsZXN0O1xuXG4gICAgaWYgKGRlcHRoICUgMSAhPT0gMCkge1xuICAgICAgdGhyb3cgXCJjYW4gbm90IGNvbXB1dGUgM0QgZGltZW5zaW9ucyBvZiBlbGVtZW50XCI7XG4gICAgfVxuXG4gICAgdmFyIHhNdWx0ID0gZWxlbWVudC53aWR0aCA9PT0gbGFyZ2VzdCA/IDEgOiAwO1xuICAgIHZhciB5TXVsdCA9IGVsZW1lbnQuaGVpZ2h0ID09PSBsYXJnZXN0ID8gMSA6IDA7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX0FMSUdOTUVOVCwgMSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX1JPV19MRU5HVEgsIGVsZW1lbnQud2lkdGgpO1xuICAgIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19JTUFHRV9IRUlHSFQsIDApO1xuICAgIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19TS0lQX0lNQUdFUywgMCk7XG4gICAgZ2wudGV4SW1hZ2UzRCh0YXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgc21hbGxlc3QsIHNtYWxsZXN0LCBzbWFsbGVzdCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcblxuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGVwdGg7ICsrZCkge1xuICAgICAgdmFyIHNyY1ggPSBkICogc21hbGxlc3QgKiB4TXVsdDtcbiAgICAgIHZhciBzcmNZID0gZCAqIHNtYWxsZXN0ICogeU11bHQ7XG4gICAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfU0tJUF9QSVhFTFMsIHNyY1gpO1xuICAgICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX1NLSVBfUk9XUywgc3JjWSk7XG4gICAgICBnbC50ZXhTdWJJbWFnZTNEKHRhcmdldCwgbGV2ZWwsIDAsIDAsIGQsIHNtYWxsZXN0LCBzbWFsbGVzdCwgMSwgZm9ybWF0LCB0eXBlLCBlbGVtZW50KTtcbiAgICB9XG5cbiAgICBzZXRTa2lwU3RhdGVUb0RlZmF1bHQoZ2wpO1xuICB9IGVsc2Uge1xuICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgZWxlbWVudCk7XG4gIH1cblxuICBpZiAoc2hvdWxkQXV0b21hdGljYWxseVNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKG9wdGlvbnMpKSB7XG4gICAgc2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUoZ2wsIHRleCwgb3B0aW9ucywgd2lkdGgsIGhlaWdodCwgaW50ZXJuYWxGb3JtYXQpO1xuICB9XG5cbiAgc2V0VGV4dHVyZVBhcmFtZXRlcnMoZ2wsIHRleCwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXJsJ3Mgb3JpZ2luIGlzIHRoZSBzYW1lIHNvIHRoYXQgd2UgY2FuIHNldCB0aGUgYGNyb3NzT3JpZ2luYFxuICogQHBhcmFtIHtzdHJpbmd9IHVybCB1cmwgdG8gaW1hZ2VcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB3aW5kb3cncyBvcmlnaW4gaXMgdGhlIHNhbWUgYXMgaW1hZ2UncyB1cmxcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiB1cmxJc1NhbWVPcmlnaW4odXJsKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gZm9yIElFIHJlYWxseVxuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGEuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gYS5ob3N0bmFtZSA9PT0gbG9jYXRpb24uaG9zdG5hbWUgJiYgYS5wb3J0ID09PSBsb2NhdGlvbi5wb3J0ICYmIGEucHJvdG9jb2wgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICB9IGVsc2Uge1xuICAgIHZhciBsb2NhbE9yaWdpbiA9IG5ldyBVUkwobG9jYXRpb24uaHJlZikub3JpZ2luO1xuICAgIHZhciB1cmxPcmlnaW4gPSBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZikub3JpZ2luO1xuICAgIHJldHVybiB1cmxPcmlnaW4gPT09IGxvY2FsT3JpZ2luO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldFRvQW5vbnltb3VzSWZVbmRlZmluZWRBbmRVUkxJc05vdFNhbWVPcmlnaW4odXJsLCBjcm9zc09yaWdpbikge1xuICByZXR1cm4gY3Jvc3NPcmlnaW4gPT09IHVuZGVmaW5lZCAmJiAhdXJsSXNTYW1lT3JpZ2luKHVybCkgPyAnYW5vbnltb3VzJyA6IGNyb3NzT3JpZ2luO1xufVxuLyoqXG4gKiBMb2FkcyBhbiBpbWFnZVxuICogQHBhcmFtIHtzdHJpbmd9IHVybCB1cmwgdG8gaW1hZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBjcm9zc09yaWdpblxuICogQHBhcmFtIHtmdW5jdGlvbihlcnIsIGltZyl9IFtjYWxsYmFja10gYSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIGFuIGVycm9yIGFuZCB0aGUgaW1hZ2UuIFRoZSBlcnJvciB3aWxsIGJlIG5vbi1udWxsXG4gKiAgICAgaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSB0aGUgaW1hZ2UgYmVpbmcgbG9hZGVkLlxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRJbWFnZSh1cmwsIGNyb3NzT3JpZ2luLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gIHZhciBpbWc7XG4gIGNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCA/IGNyb3NzT3JpZ2luIDogZGVmYXVsdHMuY3Jvc3NPcmlnaW47XG4gIGNyb3NzT3JpZ2luID0gc2V0VG9Bbm9ueW1vdXNJZlVuZGVmaW5lZEFuZFVSTElzTm90U2FtZU9yaWdpbih1cmwsIGNyb3NzT3JpZ2luKTtcblxuICBpZiAodHlwZW9mIEltYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGltZyA9IG5ldyBJbWFnZSgpO1xuXG4gICAgaWYgKGNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgIH1cblxuICAgIHZhciBjbGVhckV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiBjbGVhckV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICBpbWcucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICBpbWcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgaW1nID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgICAgdmFyIG1zZyA9IFwiY291bGRuJ3QgbG9hZCBpbWFnZTogXCIgKyB1cmw7XG4gICAgICBoZWxwZXIuZXJyb3IobXNnKTtcbiAgICAgIGNhbGxiYWNrKG1zZywgaW1nKTtcbiAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpO1xuICAgIH07XG5cbiAgICB2YXIgb25Mb2FkID0gZnVuY3Rpb24gb25Mb2FkKCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgaW1nKTtcbiAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpO1xuICAgIH07XG5cbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgaW1nLnNyYyA9IHVybDtcbiAgICByZXR1cm4gaW1nO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgZXJyO1xuICAgIHZhciBibTtcblxuICAgIHZhciBjYiA9IGZ1bmN0aW9uIGNiKCkge1xuICAgICAgY2FsbGJhY2soZXJyLCBibSk7XG4gICAgfTtcblxuICAgIHZhciBvcHRpb25zID0ge307XG5cbiAgICBpZiAoY3Jvc3NPcmlnaW4pIHtcbiAgICAgIG9wdGlvbnMubW9kZSA9ICdjb3JzJzsgLy8gVE9ETzogbm90IHN1cmUgaG93IHRvIHRyYW5zbGF0ZSBpbWFnZS5jcm9zc09yaWdpblxuICAgIH1cblxuICAgIGZldGNoKHVybCwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgcmVzcG9uc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKGJsb2IsIHtcbiAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogJ25vbmUnLFxuICAgICAgICBjb2xvclNwYWNlQ29udmVyc2lvbjogJ25vbmUnXG4gICAgICB9KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChiaXRtYXApIHtcbiAgICAgIC8vIG5vdCBzdXJlIGlmIHRoaXMgd29ya3MuIFdlIGRvbid0IHdhbnRcbiAgICAgIC8vIHRvIGNhdGNoIHRoZSB1c2VyJ3MgZXJyb3IuIFNvLCBjYWxsXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgaW4gYSB0aW1lb3V0IHNvIHdlJ3JlXG4gICAgICAvLyBub3QgaW4gdGhpcyBzY29wZSBpbnNpZGUgdGhlIHByb21pc2UuXG4gICAgICBibSA9IGJpdG1hcDtcbiAgICAgIHNldFRpbWVvdXQoY2IpO1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgICBzZXRUaW1lb3V0KGNiKTtcbiAgICB9KTtcbiAgICBpbWcgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGltZztcbn1cbi8qKlxuICogY2hlY2sgaWYgb2JqZWN0IGlzIGEgVGV4SW1hZ2VTb3VyY2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBhIFRleEltYWdlU291cmNlXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gaXNUZXhJbWFnZVNvdXJjZShvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAgfHwgdHlwZW9mIEltYWdlRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgSW1hZ2VEYXRhIHx8IHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG4vKipcbiAqIGlmIG9iaiBpcyBhbiBUZXhJbWFnZVNvdXJjZSB0aGVuIGp1c3RcbiAqIHVzZXMgaXQgb3RoZXJ3aXNlIGlmIG9iaiBpcyBhIHN0cmluZ1xuICogdGhlbiBsb2FkIGl0IGZpcnN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFRleEltYWdlU291cmNlfSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjcm9zc09yaWdpblxuICogQHBhcmFtIHtmdW5jdGlvbihlcnIsIGltZyl9IFtjYWxsYmFja10gYSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIGFuIGVycm9yIGFuZCB0aGUgaW1hZ2UuIFRoZSBlcnJvciB3aWxsIGJlIG5vbi1udWxsXG4gKiAgICAgaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9hZEFuZFVzZUltYWdlKG9iaiwgY3Jvc3NPcmlnaW4sIGNhbGxiYWNrKSB7XG4gIGlmIChpc1RleEltYWdlU291cmNlKG9iaikpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIG9iaik7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHJldHVybiBsb2FkSW1hZ2Uob2JqLCBjcm9zc09yaWdpbiwgY2FsbGJhY2spO1xufVxuLyoqXG4gKiBTZXRzIGEgdGV4dHVyZSB0byBhIDF4MSBwaXhlbCBjb2xvci4gSWYgYG9wdGlvbnMuY29sb3IgPT09IGZhbHNlYCBpcyBub3RoaW5nIGhhcHBlbnMuIElmIGl0J3Mgbm90IHNldFxuICogdGhlIGRlZmF1bHQgdGV4dHVyZSBjb2xvciBpcyB1c2VkIHdoaWNoIGNhbiBiZSBzZXQgYnkgY2FsbGluZyBgc2V0RGVmYXVsdFRleHR1cmVDb2xvcmAuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gW29wdGlvbnNdIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiAgIFRoaXMgaXMgb2Z0ZW4gdGhlIHNhbWUgb3B0aW9ucyB5b3UgcGFzc2VkIGluIHdoZW4geW91IGNyZWF0ZWQgdGhlIHRleHR1cmUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRleHR1cmVUbzFQaXhlbENvbG9yKGdsLCB0ZXgsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHMudGV4dHVyZU9wdGlvbnM7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJEO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG5cbiAgaWYgKG9wdGlvbnMuY29sb3IgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIEFzc3VtZSBpdCdzIGEgVVJMXG4gIC8vIFB1dCAxeDEgcGl4ZWxzIGluIHRleHR1cmUuIFRoYXQgbWFrZXMgaXQgcmVuZGVyYWJsZSBpbW1lZGlhdGVseSByZWdhcmRsZXNzIG9mIGZpbHRlcmluZy5cblxuXG4gIHZhciBjb2xvciA9IG1ha2UxUGl4ZWwob3B0aW9ucy5jb2xvcik7XG5cbiAgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV9DVUJFX01BUCkge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCA2OyArK2lpKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGlpLCAwLCBSR0JBLCAxLCAxLCAwLCBSR0JBLCBVTlNJR05FRF9CWVRFLCBjb2xvcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV8zRCB8fCB0YXJnZXQgPT09IFRFWFRVUkVfMkRfQVJSQVkpIHtcbiAgICBnbC50ZXhJbWFnZTNEKHRhcmdldCwgMCwgUkdCQSwgMSwgMSwgMSwgMCwgUkdCQSwgVU5TSUdORURfQllURSwgY29sb3IpO1xuICB9IGVsc2Uge1xuICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCAwLCBSR0JBLCAxLCAxLCAwLCBSR0JBLCBVTlNJR05FRF9CWVRFLCBjb2xvcik7XG4gIH1cbn1cbi8qKlxuICogVGhlIHNyYyBpbWFnZShzKSB1c2VkIHRvIGNyZWF0ZSBhIHRleHR1cmUuXG4gKlxuICogV2hlbiB5b3UgY2FsbCB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVGV4dHVyZX0gb3Ige0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVRleHR1cmVzfVxuICogeW91IGNhbiBwYXNzIGluIHVybHMgZm9yIGltYWdlcyB0byBsb2FkIGludG8gdGhlIHRleHR1cmVzLiBJZiBpdCdzIGEgc2luZ2xlIHVybFxuICogdGhlbiB0aGlzIHdpbGwgYmUgYSBzaW5nbGUgSFRNTEltYWdlRWxlbWVudC4gSWYgaXQncyBhbiBhcnJheSBvZiB1cmxzIHVzZWQgZm9yIGEgY3ViZW1hcFxuICogdGhpcyB3aWxsIGJlIGEgY29ycmVzcG9uZGluZyBhcnJheSBvZiBpbWFnZXMgZm9yIHRoZSBjdWJlbWFwLlxuICpcbiAqIEB0eXBlZGVmIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnRbXX0gVGV4dHVyZVNyY1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBBIGNhbGxiYWNrIGZvciB3aGVuIGFuIGltYWdlIGZpbmlzaGVkIGRvd25sb2FkaW5nIGFuZCBiZWVuIHVwbG9hZGVkIGludG8gYSB0ZXh0dXJlXG4gKiBAY2FsbGJhY2sgVGV4dHVyZVJlYWR5Q2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gZXJyIElmIHRydXRoeSB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4dHVyZSB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZVNyY30gc291cmNlIGltYWdlKHMpIHVzZWQgdG8gYXMgdGhlIHNyYyBmb3IgdGhlIHRleHR1cmVcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQSBjYWxsYmFjayBmb3Igd2hlbiBhbGwgaW1hZ2VzIGhhdmUgZmluaXNoZWQgZG93bmxvYWRpbmcgYW5kIGJlZW4gdXBsb2FkZWQgaW50byB0aGVpciByZXNwZWN0aXZlIHRleHR1cmVzXG4gKiBAY2FsbGJhY2sgVGV4dHVyZXNSZWFkeUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGVyciBJZiB0cnV0aHkgdGhlcmUgd2FzIGFuIGVycm9yLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgV2ViR0xUZXh0dXJlPn0gdGV4dHVyZXMgdGhlIGNyZWF0ZWQgdGV4dHVyZXMgYnkgbmFtZS4gU2FtZSBhcyByZXR1cm5lZCBieSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVGV4dHVyZXN9LlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnR3Z2wuVGV4dHVyZVNyYz59IHNvdXJjZXMgdGhlIGltYWdlKHMpIHVzZWQgZm9yIHRoZSB0ZXh0dXJlIGJ5IG5hbWUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgZm9yIHdoZW4gYW4gaW1hZ2UgZmluaXNoZWQgZG93bmxvYWRpbmcgYW5kIGJlZW4gdXBsb2FkZWQgaW50byBhIHRleHR1cmVcbiAqIEBjYWxsYmFjayBDdWJlbWFwUmVhZHlDYWxsYmFja1xuICogQHBhcmFtIHsqfSBlcnIgSWYgdHJ1dGh5IHRoZXJlIHdhcyBhbiBlcnJvci5cbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIHRleHR1cmUuXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnRbXX0gaW1ncyB0aGUgaW1hZ2VzIGZvciBlYWNoIGZhY2UuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgZm9yIHdoZW4gYW4gaW1hZ2UgZmluaXNoZWQgZG93bmxvYWRpbmcgYW5kIGJlZW4gdXBsb2FkZWQgaW50byBhIHRleHR1cmVcbiAqIEBjYWxsYmFjayBUaHJlZURSZWFkeUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGVyciBJZiB0cnV0aHkgdGhlcmUgd2FzIGFuIGVycm9yLlxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudFtdfSBpbWdzIHRoZSBpbWFnZXMgZm9yIGVhY2ggc2xpY2UuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIExvYWRzIGEgdGV4dHVyZSBmcm9tIGFuIGltYWdlIGZyb20gYSBVcmwgYXMgc3BlY2lmaWVkIGluIGBvcHRpb25zLnNyY2BcbiAqIElmIGBvcHRpb25zLmNvbG9yICE9PSBmYWxzZWAgd2lsbCBzZXQgdGhlIHRleHR1cmUgdG8gYSAxeDEgcGl4ZWwgY29sb3Igc28gdGhhdCB0aGUgdGV4dHVyZSBpc1xuICogaW1tZWRpYXRlbHkgdXNlYWJsZS4gSXQgd2lsbCBiZSB1cGRhdGVkIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBpbWFnZSBvbmNlIHRoZSBpbWFnZSBoYXMgZmluaXNoZWRcbiAqIGRvd25sb2FkaW5nLiBGaWx0ZXJpbmcgb3B0aW9ucyB3aWxsIGJlIHNldCBhcyBhcHByb3ByaWF0ZSBmb3IgaW1hZ2UgdW5sZXNzIGBvcHRpb25zLmF1dG8gPT09IGZhbHNlYC5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZVJlYWR5Q2FsbGJhY2t9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgaW1hZ2UgaGFzIGZpbmlzaGVkIGxvYWRpbmcuIGVyciB3aWxsXG4gKiAgICBiZSBub24gbnVsbCBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSB0aGUgaW1hZ2UgYmVpbmcgZG93bmxvYWRlZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cblxuZnVuY3Rpb24gbG9hZFRleHR1cmVGcm9tVXJsKGdsLCB0ZXgsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHMudGV4dHVyZU9wdGlvbnM7XG4gIHNldFRleHR1cmVUbzFQaXhlbENvbG9yKGdsLCB0ZXgsIG9wdGlvbnMpOyAvLyBCZWNhdXNlIGl0J3MgYXN5bmMgd2UgbmVlZCB0byBjb3B5IHRoZSBvcHRpb25zLlxuXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgdmFyIGltZyA9IGxvYWRBbmRVc2VJbWFnZShvcHRpb25zLnNyYywgb3B0aW9ucy5jcm9zc09yaWdpbiwgZnVuY3Rpb24gKGVyciwgaW1nKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyLCB0ZXgsIGltZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRleHR1cmVGcm9tRWxlbWVudChnbCwgdGV4LCBpbWcsIG9wdGlvbnMpO1xuICAgICAgY2FsbGJhY2sobnVsbCwgdGV4LCBpbWcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbWc7XG59XG4vKipcbiAqIExvYWRzIGEgY3ViZW1hcCBmcm9tIDYgdXJscyBvciBUZXhJbWFnZVNvdXJjZXMgYXMgc3BlY2lmaWVkIGluIGBvcHRpb25zLnNyY2AuIFdpbGwgc2V0IHRoZSBjdWJlbWFwIHRvIGEgMXgxIHBpeGVsIGNvbG9yXG4gKiBzbyB0aGF0IGl0IGlzIHVzYWJsZSBpbW1lZGlhdGVseSB1bmxlc3MgYG9wdGlvbi5jb2xvciA9PT0gZmFsc2VgLlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIFdlYkdMVGV4dHVyZSB0byBzZXQgcGFyYW1ldGVycyBmb3JcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQ3ViZW1hcFJlYWR5Q2FsbGJhY2t9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBhbGwgdGhlIGltYWdlcyBoYXZlIGZpbmlzaGVkIGxvYWRpbmcuIGVyciB3aWxsXG4gKiAgICBiZSBub24gbnVsbCBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRDdWJlbWFwRnJvbVVybHMoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICB2YXIgdXJscyA9IG9wdGlvbnMuc3JjO1xuXG4gIGlmICh1cmxzLmxlbmd0aCAhPT0gNikge1xuICAgIHRocm93IFwidGhlcmUgbXVzdCBiZSA2IHVybHMgZm9yIGEgY3ViZW1hcFwiO1xuICB9XG5cbiAgdmFyIGxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCAwO1xuICB2YXIgaW50ZXJuYWxGb3JtYXQgPSBvcHRpb25zLmludGVybmFsRm9ybWF0IHx8IG9wdGlvbnMuZm9ybWF0IHx8IFJHQkE7XG4gIHZhciBmb3JtYXRUeXBlID0gZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0KTtcbiAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGZvcm1hdFR5cGUuZm9ybWF0O1xuICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBVTlNJR05FRF9CWVRFO1xuICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRDtcblxuICBpZiAodGFyZ2V0ICE9PSBURVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgdGhyb3cgXCJ0YXJnZXQgbXVzdCBiZSBURVhUVVJFX0NVQkVfTUFQXCI7XG4gIH1cblxuICBzZXRUZXh0dXJlVG8xUGl4ZWxDb2xvcihnbCwgdGV4LCBvcHRpb25zKTsgLy8gQmVjYXVzZSBpdCdzIGFzeW5jIHdlIG5lZWQgdG8gY29weSB0aGUgb3B0aW9ucy5cblxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gIHZhciBudW1Ub0xvYWQgPSA2O1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBmYWNlcyA9IGdldEN1YmVGYWNlT3JkZXIoZ2wsIG9wdGlvbnMpO1xuICB2YXIgaW1nczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGZ1bmN0aW9uIHVwbG9hZEltZyhmYWNlVGFyZ2V0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIGltZykge1xuICAgICAgLS1udW1Ub0xvYWQ7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbWcud2lkdGggIT09IGltZy5oZWlnaHQpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChcImN1YmVtYXAgZmFjZSBpbWcgaXMgbm90IGEgc3F1YXJlOiBcIiArIGltZy5zcmMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFBhY2tTdGF0ZShnbCwgb3B0aW9ucyk7XG4gICAgICAgICAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpOyAvLyBTbyBhc3N1bWluZyB0aGlzIGlzIHRoZSBmaXJzdCBpbWFnZSB3ZSBub3cgaGF2ZSBvbmUgZmFjZSB0aGF0J3MgaW1nIHNpemVkXG4gICAgICAgICAgLy8gYW5kIDUgZmFjZXMgdGhhdCBhcmUgMXgxIHBpeGVsIHNvIHNpemUgdGhlIG90aGVyIGZhY2VzXG5cbiAgICAgICAgICBpZiAobnVtVG9Mb2FkID09PSA1KSB7XG4gICAgICAgICAgICAvLyB1c2UgdGhlIGRlZmF1bHQgb3JkZXJcbiAgICAgICAgICAgIGdldEN1YmVGYWNlT3JkZXIoZ2wpLmZvckVhY2goZnVuY3Rpb24gKG90aGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICAgIC8vIFNob3VsZCB3ZSByZS11c2UgdGhlIHNhbWUgZmFjZSBvciBhIGNvbG9yP1xuICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKG90aGVyVGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgaW1nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGZhY2VUYXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBpbWcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG91bGRBdXRvbWF0aWNhbGx5U2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1Ub0xvYWQgPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IHVuZGVmaW5lZCwgdGV4LCBpbWdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaW1ncyA9IHVybHMubWFwKGZ1bmN0aW9uICh1cmwsIG5keCkge1xuICAgIHJldHVybiBsb2FkQW5kVXNlSW1hZ2UodXJsLCBvcHRpb25zLmNyb3NzT3JpZ2luLCB1cGxvYWRJbWcoZmFjZXNbbmR4XSkpO1xuICB9KTtcbn1cbi8qKlxuICogTG9hZHMgYSAyZCBhcnJheSBvciAzZCB0ZXh0dXJlIGZyb20gdXJscyBPUiBUZXhJbWFnZVNvdXJjZXMgYXMgc3BlY2lmaWVkIGluIGBvcHRpb25zLnNyY2AuXG4gKiBXaWxsIHNldCB0aGUgdGV4dHVyZSB0byBhIDF4MSBwaXhlbCBjb2xvclxuICogc28gdGhhdCBpdCBpcyB1c2FibGUgaW1tZWRpYXRlbHkgdW5sZXNzIGBvcHRpb24uY29sb3IgPT09IGZhbHNlYC5cbiAqXG4gKiBJZiB0aGUgd2lkdGggYW5kIGhlaWdodCBpcyBub3Qgc3BlY2lmaWVkIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBmaXJzdFxuICogaW1hZ2UgbG9hZGVkIHdpbGwgYmUgdXNlZC4gTm90ZSB0aGF0IHNpbmNlIGltYWdlcyBhcmUgbG9hZGVkIGFzeW5jXG4gKiB3aGljaCBpbWFnZSBkb3dubG9hZHMgZmlyc3QgaXMgdW5rbm93bi5cbiAqXG4gKiBJZiBhbiBpbWFnZSBpcyBub3QgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgd2lkdGggYW5kIGhlaWdodCBpdCB3aWxsIGJlIHNjYWxlZFxuICogdG8gdGhhdCB3aWR0aCBhbmQgaGVpZ2h0LlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRocmVlRFJlYWR5Q2FsbGJhY2t9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBhbGwgdGhlIGltYWdlcyBoYXZlIGZpbmlzaGVkIGxvYWRpbmcuIGVyciB3aWxsXG4gKiAgICBiZSBub24gbnVsbCBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRTbGljZXNGcm9tVXJscyhnbCwgdGV4LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gIHZhciB1cmxzID0gb3B0aW9ucy5zcmM7XG4gIHZhciBpbnRlcm5hbEZvcm1hdCA9IG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgfHwgb3B0aW9ucy5mb3JtYXQgfHwgUkdCQTtcbiAgdmFyIGZvcm1hdFR5cGUgPSBnZXRGb3JtYXRBbmRUeXBlRm9ySW50ZXJuYWxGb3JtYXQoaW50ZXJuYWxGb3JtYXQpO1xuICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgZm9ybWF0VHlwZS5mb3JtYXQ7XG4gIHZhciB0eXBlID0gb3B0aW9ucy50eXBlIHx8IFVOU0lHTkVEX0JZVEU7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJEX0FSUkFZO1xuXG4gIGlmICh0YXJnZXQgIT09IFRFWFRVUkVfM0QgJiYgdGFyZ2V0ICE9PSBURVhUVVJFXzJEX0FSUkFZKSB7XG4gICAgdGhyb3cgXCJ0YXJnZXQgbXVzdCBiZSBURVhUVVJFXzNEIG9yIFRFWFRVUkVfMkRfQVJSQVlcIjtcbiAgfVxuXG4gIHNldFRleHR1cmVUbzFQaXhlbENvbG9yKGdsLCB0ZXgsIG9wdGlvbnMpOyAvLyBCZWNhdXNlIGl0J3MgYXN5bmMgd2UgbmVlZCB0byBjb3B5IHRoZSBvcHRpb25zLlxuXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgdmFyIG51bVRvTG9hZCA9IHVybHMubGVuZ3RoO1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBpbWdzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgdmFyIGxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCAwO1xuICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciBkZXB0aCA9IHVybHMubGVuZ3RoO1xuICB2YXIgZmlyc3RJbWFnZSA9IHRydWU7XG5cbiAgZnVuY3Rpb24gdXBsb2FkSW1nKHNsaWNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIGltZykge1xuICAgICAgLS1udW1Ub0xvYWQ7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFBhY2tTdGF0ZShnbCwgb3B0aW9ucyk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcblxuICAgICAgICBpZiAoZmlyc3RJbWFnZSkge1xuICAgICAgICAgIGZpcnN0SW1hZ2UgPSBmYWxzZTtcbiAgICAgICAgICB3aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgaW1nLndpZHRoO1xuICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IGltZy5oZWlnaHQ7XG4gICAgICAgICAgZ2wudGV4SW1hZ2UzRCh0YXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7IC8vIHB1dCBpdCBpbiBldmVyeSBzbGljZSBvdGhlcndpc2Ugc29tZSBzbGljZXMgd2lsbCBiZSAwLDAsMCwwXG5cbiAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IGRlcHRoOyArK3MpIHtcbiAgICAgICAgICAgIGdsLnRleFN1YkltYWdlM0QodGFyZ2V0LCBsZXZlbCwgMCwgMCwgcywgd2lkdGgsIGhlaWdodCwgMSwgZm9ybWF0LCB0eXBlLCBpbWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3JjID0gaW1nO1xuICAgICAgICAgIHZhciBjdHg7XG5cbiAgICAgICAgICBpZiAoaW1nLndpZHRoICE9PSB3aWR0aCB8fCBpbWcuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIFNpemUgdGhlIGltYWdlIHRvIGZpeFxuICAgICAgICAgICAgY3R4ID0gZ2V0U2hhcmVkMkRDb250ZXh0KCk7XG4gICAgICAgICAgICBzcmMgPSBjdHguY2FudmFzO1xuICAgICAgICAgICAgY3R4LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgY3R4LmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2wudGV4U3ViSW1hZ2UzRCh0YXJnZXQsIGxldmVsLCAwLCAwLCBzbGljZSwgd2lkdGgsIGhlaWdodCwgMSwgZm9ybWF0LCB0eXBlLCBzcmMpOyAvLyBmcmVlIHRoZSBjYW52YXMgbWVtb3J5XG5cbiAgICAgICAgICBpZiAoY3R4ICYmIHNyYyA9PT0gY3R4LmNhbnZhcykge1xuICAgICAgICAgICAgY3R4LmNhbnZhcy53aWR0aCA9IDA7XG4gICAgICAgICAgICBjdHguY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZEF1dG9tYXRpY2FsbHlTZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShvcHRpb25zKSkge1xuICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG51bVRvTG9hZCA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjayhlcnJvcnMubGVuZ3RoID8gZXJyb3JzIDogdW5kZWZpbmVkLCB0ZXgsIGltZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpbWdzID0gdXJscy5tYXAoZnVuY3Rpb24gKHVybCwgbmR4KSB7XG4gICAgcmV0dXJuIGxvYWRBbmRVc2VJbWFnZSh1cmwsIG9wdGlvbnMuY3Jvc3NPcmlnaW4sIHVwbG9hZEltZyhuZHgpKTtcbiAgfSk7XG59XG4vKipcbiAqIFNldHMgYSB0ZXh0dXJlIGZyb20gYW4gYXJyYXkgb3IgdHlwZWQgYXJyYXkuIElmIHRoZSB3aWR0aCBvciBoZWlnaHQgaXMgbm90IHByb3ZpZGVkIHdpbGwgYXR0ZW1wdCB0b1xuICogZ3Vlc3MgdGhlIHNpemUuIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9LlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIFdlYkdMVGV4dHVyZSB0byBzZXQgcGFyYW1ldGVycyBmb3JcbiAqIEBwYXJhbSB7KG51bWJlcltdfEFycmF5QnVmZmVyVmlldyl9IHNyYyBBbiBhcnJheSBvciB0eXBlZCBhcnJ5IHdpdGggdGV4dHVyZSBkYXRhLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gW29wdGlvbnNdIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiAgIFRoaXMgaXMgb2Z0ZW4gdGhlIHNhbWUgb3B0aW9ucyB5b3UgcGFzc2VkIGluIHdoZW4geW91IGNyZWF0ZWQgdGhlIHRleHR1cmUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRleHR1cmVGcm9tQXJyYXkoZ2wsIHRleCwgc3JjLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzLnRleHR1cmVPcHRpb25zO1xuICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRDtcbiAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciBkZXB0aCA9IG9wdGlvbnMuZGVwdGg7XG4gIHZhciBsZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwgMDtcbiAgdmFyIGludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCB8fCBvcHRpb25zLmZvcm1hdCB8fCBSR0JBO1xuICB2YXIgZm9ybWF0VHlwZSA9IGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCk7XG4gIHZhciBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBmb3JtYXRUeXBlLmZvcm1hdDtcbiAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgZ2V0VGV4dHVyZVR5cGVGb3JBcnJheVR5cGUoZ2wsIHNyYywgZm9ybWF0VHlwZS50eXBlKTtcblxuICBpZiAoIWlzQXJyYXlCdWZmZXIoc3JjKSkge1xuICAgIHZhciBUeXBlID0gdHlwZWRBcnJheXMuZ2V0VHlwZWRBcnJheVR5cGVGb3JHTFR5cGUodHlwZSk7XG4gICAgc3JjID0gbmV3IFR5cGUoc3JjKTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgIHNyYyA9IG5ldyBVaW50OEFycmF5KHNyYy5idWZmZXIpO1xuICB9XG5cbiAgdmFyIGJ5dGVzUGVyRWxlbWVudCA9IGdldEJ5dGVzUGVyRWxlbWVudEZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0LCB0eXBlKTtcbiAgdmFyIG51bUVsZW1lbnRzID0gc3JjLmJ5dGVMZW5ndGggLyBieXRlc1BlckVsZW1lbnQ7IC8vIFRPRE86IGNoZWNrIFVOUEFDS19BTElHTk1FTlQ/XG5cbiAgaWYgKG51bUVsZW1lbnRzICUgMSkge1xuICAgIHRocm93IFwibGVuZ3RoIHdyb25nIHNpemUgZm9yIGZvcm1hdDogXCIgKyB1dGlscy5nbEVudW1Ub1N0cmluZyhnbCwgZm9ybWF0KTtcbiAgfVxuXG4gIHZhciBkaW1lbnNpb25zO1xuXG4gIGlmICh0YXJnZXQgPT09IFRFWFRVUkVfM0QgfHwgdGFyZ2V0ID09PSBURVhUVVJFXzJEX0FSUkFZKSB7XG4gICAgaWYgKCF3aWR0aCAmJiAhaGVpZ2h0ICYmICFkZXB0aCkge1xuICAgICAgdmFyIHNpemUgPSBNYXRoLmNicnQobnVtRWxlbWVudHMpO1xuXG4gICAgICBpZiAoc2l6ZSAlIDEgIT09IDApIHtcbiAgICAgICAgdGhyb3cgXCJjYW4ndCBndWVzcyBjdWJlIHNpemUgb2YgYXJyYXkgb2YgbnVtRWxlbWVudHM6IFwiICsgbnVtRWxlbWVudHM7XG4gICAgICB9XG5cbiAgICAgIHdpZHRoID0gc2l6ZTtcbiAgICAgIGhlaWdodCA9IHNpemU7XG4gICAgICBkZXB0aCA9IHNpemU7XG4gICAgfSBlbHNlIGlmICh3aWR0aCAmJiAoIWhlaWdodCB8fCAhZGVwdGgpKSB7XG4gICAgICBkaW1lbnNpb25zID0gZ3Vlc3NEaW1lbnNpb25zKGdsLCB0YXJnZXQsIGhlaWdodCwgZGVwdGgsIG51bUVsZW1lbnRzIC8gd2lkdGgpO1xuICAgICAgaGVpZ2h0ID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgIGRlcHRoID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChoZWlnaHQgJiYgKCF3aWR0aCB8fCAhZGVwdGgpKSB7XG4gICAgICBkaW1lbnNpb25zID0gZ3Vlc3NEaW1lbnNpb25zKGdsLCB0YXJnZXQsIHdpZHRoLCBkZXB0aCwgbnVtRWxlbWVudHMgLyBoZWlnaHQpO1xuICAgICAgd2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgZGVwdGggPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGltZW5zaW9ucyA9IGd1ZXNzRGltZW5zaW9ucyhnbCwgdGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBudW1FbGVtZW50cyAvIGRlcHRoKTtcbiAgICAgIHdpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgIGhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkaW1lbnNpb25zID0gZ3Vlc3NEaW1lbnNpb25zKGdsLCB0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIG51bUVsZW1lbnRzKTtcbiAgICB3aWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gIH1cblxuICBzZXRTa2lwU3RhdGVUb0RlZmF1bHQoZ2wpO1xuICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfQUxJR05NRU5ULCBvcHRpb25zLnVucGFja0FsaWdubWVudCB8fCAxKTtcbiAgc2V0UGFja1N0YXRlKGdsLCBvcHRpb25zKTtcblxuICBpZiAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgdmFyIGVsZW1lbnRzUGVyRWxlbWVudCA9IGJ5dGVzUGVyRWxlbWVudCAvIHNyYy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICB2YXIgZmFjZVNpemUgPSBudW1FbGVtZW50cyAvIDYgKiBlbGVtZW50c1BlckVsZW1lbnQ7XG4gICAgZ2V0Q3ViZUZhY2VzV2l0aE5keChnbCwgb3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgdmFyIG9mZnNldCA9IGZhY2VTaXplICogZi5uZHg7XG4gICAgICB2YXIgZGF0YSA9IHNyYy5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGZhY2VTaXplKTtcbiAgICAgIGdsLnRleEltYWdlMkQoZi5mYWNlLCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdHlwZSwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEIHx8IHRhcmdldCA9PT0gVEVYVFVSRV8yRF9BUlJBWSkge1xuICAgIGdsLnRleEltYWdlM0QodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCAwLCBmb3JtYXQsIHR5cGUsIHNyYyk7XG4gIH0gZWxzZSB7XG4gICAgZ2wudGV4SW1hZ2UyRCh0YXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBzcmMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgZGVwdGg6IGRlcHRoLFxuICAgIHR5cGU6IHR5cGVcbiAgfTtcbn1cbi8qKlxuICogU2V0cyBhIHRleHR1cmUgd2l0aCBubyBjb250ZW50cyBvZiBhIGNlcnRhaW4gc2l6ZS4gSW4gb3RoZXIgd29yZHMgY2FsbHMgYGdsLnRleEltYWdlMkRgIHdpdGggYG51bGxgLlxuICogWW91IG11c3Qgc2V0IGBvcHRpb25zLndpZHRoYCBhbmQgYG9wdGlvbnMuaGVpZ2h0YC5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldEVtcHR5VGV4dHVyZShnbCwgdGV4LCBvcHRpb25zKSB7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJEO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gIHZhciBsZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwgMDtcbiAgdmFyIGludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCB8fCBvcHRpb25zLmZvcm1hdCB8fCBSR0JBO1xuICB2YXIgZm9ybWF0VHlwZSA9IGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCk7XG4gIHZhciBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBmb3JtYXRUeXBlLmZvcm1hdDtcbiAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgZm9ybWF0VHlwZS50eXBlO1xuICBzZXRQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xuXG4gIGlmICh0YXJnZXQgPT09IFRFWFRVUkVfQ1VCRV9NQVApIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgNjsgKytpaSkge1xuICAgICAgZ2wudGV4SW1hZ2UyRChURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpaSwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEIHx8IHRhcmdldCA9PT0gVEVYVFVSRV8yRF9BUlJBWSkge1xuICAgIGdsLnRleEltYWdlM0QodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0LCBvcHRpb25zLmRlcHRoLCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0LCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSB0ZXh0dXJlIGJhc2VkIG9uIHRoZSBvcHRpb25zIHBhc3NlZCBpbi5cbiAqXG4gKiBOb3RlOiBtYXkgcmVzZXQgVU5QQUNLX0FMSUdOTUVOVCwgVU5QQUNLX1JPV19MRU5HVEgsIFVOUEFDS19JTUFHRV9IRUlHSFQsIFVOUEFDS19TS0lQX0lNQUdFU1xuICogVU5QQUNLX1NLSVBfUElYRUxTLCBhbmQgVU5QQUNLX1NLSVBfUk9XU1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZVJlYWR5Q2FsbGJhY2t9IFtjYWxsYmFja10gQSBjYWxsYmFjayBjYWxsZWQgd2hlbiBhbiBpbWFnZSBoYXMgYmVlbiBkb3dubG9hZGVkIGFuZCB1cGxvYWRlZCB0byB0aGUgdGV4dHVyZS5cbiAqIEByZXR1cm4ge1dlYkdMVGV4dHVyZX0gdGhlIGNyZWF0ZWQgdGV4dHVyZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShnbCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cy50ZXh0dXJlT3B0aW9ucztcbiAgdmFyIHRleCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgdmFyIHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IFRFWFRVUkVfMkQ7XG4gIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgMTtcbiAgdmFyIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IDE7XG4gIHZhciBpbnRlcm5hbEZvcm1hdCA9IG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgfHwgUkdCQTtcbiAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuXG4gIGlmICh0YXJnZXQgPT09IFRFWFRVUkVfQ1VCRV9NQVApIHtcbiAgICAvLyB0aGlzIHNob3VsZCBoYXZlIGJlZW4gdGhlIGRlZmF1bHQgZm9yIGN1YmVtYXBzIDooXG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIFRFWFRVUkVfV1JBUF9TLCBDTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgVEVYVFVSRV9XUkFQX1QsIENMQU1QX1RPX0VER0UpO1xuICB9XG5cbiAgdmFyIHNyYyA9IG9wdGlvbnMuc3JjO1xuXG4gIGlmIChzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBzcmMgPSBzcmMoZ2wsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3JjID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBsb2FkVGV4dHVyZUZyb21VcmwoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihzcmMpIHx8IEFycmF5LmlzQXJyYXkoc3JjKSAmJiAodHlwZW9mIHNyY1swXSA9PT0gJ251bWJlcicgfHwgQXJyYXkuaXNBcnJheShzcmNbMF0pIHx8IGlzQXJyYXlCdWZmZXIoc3JjWzBdKSkpIHtcbiAgICAgIHZhciBkaW1lbnNpb25zID0gc2V0VGV4dHVyZUZyb21BcnJheShnbCwgdGV4LCBzcmMsIG9wdGlvbnMpO1xuICAgICAgd2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNyYykgJiYgKHR5cGVvZiBzcmNbMF0gPT09ICdzdHJpbmcnIHx8IGlzVGV4SW1hZ2VTb3VyY2Uoc3JjWzBdKSkpIHtcbiAgICAgIGlmICh0YXJnZXQgPT09IFRFWFRVUkVfQ1VCRV9NQVApIHtcbiAgICAgICAgbG9hZEN1YmVtYXBGcm9tVXJscyhnbCwgdGV4LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkU2xpY2VzRnJvbVVybHMoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiAoaXNUZXhJbWFnZVNvdXJjZShzcmMpKVxuICAgICAgc2V0VGV4dHVyZUZyb21FbGVtZW50KGdsLCB0ZXgsIHNyYywgb3B0aW9ucyk7XG4gICAgICB3aWR0aCA9IHNyYy53aWR0aDtcbiAgICAgIGhlaWdodCA9IHNyYy5oZWlnaHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNldEVtcHR5VGV4dHVyZShnbCwgdGV4LCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChzaG91bGRBdXRvbWF0aWNhbGx5U2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUob3B0aW9ucykpIHtcbiAgICBzZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShnbCwgdGV4LCBvcHRpb25zLCB3aWR0aCwgaGVpZ2h0LCBpbnRlcm5hbEZvcm1hdCk7XG4gIH1cblxuICBzZXRUZXh0dXJlUGFyYW1ldGVycyhnbCwgdGV4LCBvcHRpb25zKTtcbiAgcmV0dXJuIHRleDtcbn1cbi8qKlxuICogUmVzaXplcyBhIHRleHR1cmUgYmFzZWQgb24gdGhlIG9wdGlvbnMgcGFzc2VkIGluLlxuICpcbiAqIE5vdGU6IFRoaXMgaXMgbm90IGEgZ2VuZXJpYyByZXNpemUgYW55dGhpbmcgZnVuY3Rpb24uXG4gKiBJdCdzIG1vc3RseSB1c2VkIGJ5IHtAbGluayBtb2R1bGU6dHdnbC5yZXNpemVGcmFtZWJ1ZmZlckluZm99XG4gKiBJdCB3aWxsIHVzZSBgb3B0aW9ucy5zcmNgIGlmIGl0IGV4aXN0cyB0byB0cnkgdG8gZGV0ZXJtaW5lIGEgYHR5cGVgXG4gKiBvdGhlcndpc2UgaXQgd2lsbCBhc3N1bWUgYGdsLlVOU0lHTkVEX0JZVEVgLiBObyBkYXRhIGlzIHByb3ZpZGVkXG4gKiBmb3IgdGhlIHRleHR1cmUuIFRleHR1cmUgcGFyYW1ldGVycyB3aWxsIGJlIHNldCBhY2NvcmRpbmdseVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSB0ZXh0dXJlIHRvIHJlc2l6ZVxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gdGhlIG5ldyB3aWR0aC4gSWYgbm90IHBhc3NlZCBpbiB3aWxsIHVzZSBgb3B0aW9ucy53aWR0aGBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSB0aGUgbmV3IGhlaWdodC4gSWYgbm90IHBhc3NlZCBpbiB3aWxsIHVzZSBgb3B0aW9ucy5oZWlnaHRgXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoXSB0aGUgbmV3IGRlcHRoLiBJZiBub3QgcGFzc2VkIGluIHdpbGwgdXNlIGBvcHRpb25zLmRlcHRoYFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiByZXNpemVUZXh0dXJlKGdsLCB0ZXgsIG9wdGlvbnMsIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSB7XG4gIHdpZHRoID0gd2lkdGggfHwgb3B0aW9ucy53aWR0aDtcbiAgaGVpZ2h0ID0gaGVpZ2h0IHx8IG9wdGlvbnMuaGVpZ2h0O1xuICBkZXB0aCA9IGRlcHRoIHx8IG9wdGlvbnMuZGVwdGg7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJEO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gIHZhciBsZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwgMDtcbiAgdmFyIGludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCB8fCBvcHRpb25zLmZvcm1hdCB8fCBSR0JBO1xuICB2YXIgZm9ybWF0VHlwZSA9IGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCk7XG4gIHZhciBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBmb3JtYXRUeXBlLmZvcm1hdDtcbiAgdmFyIHR5cGU7XG4gIHZhciBzcmMgPSBvcHRpb25zLnNyYztcblxuICBpZiAoIXNyYykge1xuICAgIHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgZm9ybWF0VHlwZS50eXBlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIoc3JjKSB8fCBBcnJheS5pc0FycmF5KHNyYykgJiYgdHlwZW9mIHNyY1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB0eXBlID0gb3B0aW9ucy50eXBlIHx8IGdldFRleHR1cmVUeXBlRm9yQXJyYXlUeXBlKGdsLCBzcmMsIGZvcm1hdFR5cGUudHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBmb3JtYXRUeXBlLnR5cGU7XG4gIH1cblxuICBpZiAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDY7ICsraWkpIHtcbiAgICAgIGdsLnRleEltYWdlMkQoVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaWksIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEIHx8IHRhcmdldCA9PT0gVEVYVFVSRV8yRF9BUlJBWSkge1xuICAgIGdsLnRleEltYWdlM0QodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBzcmMgaXMgYW4gYXN5bmMgcmVxdWVzdC5cbiAqIGlmIHNyYyBpcyBhIHN0cmluZyB3ZSdyZSBnb2luZyB0byBkb3dubG9hZCBhbiBpbWFnZVxuICogaWYgc3JjIGlzIGFuIGFycmF5IG9mIHN0cmluZ3Mgd2UncmUgZ29pbmcgdG8gZG93bmxvYWQgY3ViZW1hcCBpbWFnZXNcbiAqIEBwYXJhbSB7Kn0gc3JjIFRoZSBzcmMgZnJvbSBhIFRleHR1cmVPcHRpb25zXG4gKiBAcmV0dXJucyB7Ym9vbH0gdHJ1ZSBpZiBzcmMgaXMgYXN5bmMuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gaXNBc3luY1NyYyhzcmMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoc3JjKSAmJiB0eXBlb2Ygc3JjWzBdID09PSAnc3RyaW5nJztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGJ1bmNoIG9mIHRleHR1cmVzIGJhc2VkIG9uIHRoZSBwYXNzZWQgaW4gb3B0aW9ucy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB0ZXh0dXJlcyA9IHR3Z2wuY3JlYXRlVGV4dHVyZXMoZ2wsIHtcbiAqICAgICAgIC8vIGEgcG93ZXIgb2YgMiBpbWFnZVxuICogICAgICAgaGZ0SWNvbjogeyBzcmM6IFwiaW1hZ2VzL2hmdC1pY29uLTE2LnBuZ1wiLCBtYWc6IGdsLk5FQVJFU1QgfSxcbiAqICAgICAgIC8vIGEgbm9uLXBvd2VyIG9mIDIgaW1hZ2VcbiAqICAgICAgIGNsb3ZlcjogeyBzcmM6IFwiaW1hZ2VzL2Nsb3Zlci5qcGdcIiB9LFxuICogICAgICAgLy8gRnJvbSBhIGNhbnZhc1xuICogICAgICAgZnJvbUNhbnZhczogeyBzcmM6IGN0eC5jYW52YXMgfSxcbiAqICAgICAgIC8vIEEgY3ViZW1hcCBmcm9tIDYgaW1hZ2VzXG4gKiAgICAgICB5b2tvaGFtYToge1xuICogICAgICAgICB0YXJnZXQ6IGdsLlRFWFRVUkVfQ1VCRV9NQVAsXG4gKiAgICAgICAgIHNyYzogW1xuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvcG9zeC5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvbmVneC5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvcG9zeS5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvbmVneS5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvcG9zei5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvbmVnei5qcGcnLFxuICogICAgICAgICBdLFxuICogICAgICAgfSxcbiAqICAgICAgIC8vIEEgY3ViZW1hcCBmcm9tIDEgaW1hZ2UgKGNhbiBiZSAxeDYsIDJ4MywgM3gyLCA2eDEpXG4gKiAgICAgICBnb2xkZW5nYXRlOiB7XG4gKiAgICAgICAgIHRhcmdldDogZ2wuVEVYVFVSRV9DVUJFX01BUCxcbiAqICAgICAgICAgc3JjOiAnaW1hZ2VzL2dvbGRlbmdhdGUuanBnJyxcbiAqICAgICAgIH0sXG4gKiAgICAgICAvLyBBIDJ4MiBwaXhlbCB0ZXh0dXJlIGZyb20gYSBKYXZhU2NyaXB0IGFycmF5XG4gKiAgICAgICBjaGVja2VyOiB7XG4gKiAgICAgICAgIG1hZzogZ2wuTkVBUkVTVCxcbiAqICAgICAgICAgbWluOiBnbC5MSU5FQVIsXG4gKiAgICAgICAgIHNyYzogW1xuICogICAgICAgICAgIDI1NSwyNTUsMjU1LDI1NSxcbiAqICAgICAgICAgICAxOTIsMTkyLDE5MiwyNTUsXG4gKiAgICAgICAgICAgMTkyLDE5MiwxOTIsMjU1LFxuICogICAgICAgICAgIDI1NSwyNTUsMjU1LDI1NSxcbiAqICAgICAgICAgXSxcbiAqICAgICAgIH0sXG4gKiAgICAgICAvLyBhIDF4MiBwaXhlbCB0ZXh0dXJlIGZyb20gYSB0eXBlZCBhcnJheS5cbiAqICAgICAgIHN0cmlwZToge1xuICogICAgICAgICBtYWc6IGdsLk5FQVJFU1QsXG4gKiAgICAgICAgIG1pbjogZ2wuTElORUFSLFxuICogICAgICAgICBmb3JtYXQ6IGdsLkxVTUlOQU5DRSxcbiAqICAgICAgICAgc3JjOiBuZXcgVWludDhBcnJheShbXG4gKiAgICAgICAgICAgMjU1LFxuICogICAgICAgICAgIDEyOCxcbiAqICAgICAgICAgICAyNTUsXG4gKiAgICAgICAgICAgMTI4LFxuICogICAgICAgICAgIDI1NSxcbiAqICAgICAgICAgICAxMjgsXG4gKiAgICAgICAgICAgMjU1LFxuICogICAgICAgICAgIDEyOCxcbiAqICAgICAgICAgXSksXG4gKiAgICAgICAgIHdpZHRoOiAxLFxuICogICAgICAgfSxcbiAqICAgICB9KTtcbiAqXG4gKiBOb3dcbiAqXG4gKiAqICAgYHRleHR1cmVzLmhmdEljb25gIHdpbGwgYmUgYSAyZCB0ZXh0dXJlXG4gKiAqICAgYHRleHR1cmVzLmNsb3ZlcmAgd2lsbCBiZSBhIDJkIHRleHR1cmVcbiAqICogICBgdGV4dHVyZXMuZnJvbUNhbnZhc2Agd2lsbCBiZSBhIDJkIHRleHR1cmVcbiAqICogICBgdGV4dHVyZXMueW9ob2hhbWFgIHdpbGwgYmUgYSBjdWJlbWFwIHRleHR1cmVcbiAqICogICBgdGV4dHVyZXMuZ29sZGVuZ2F0ZWAgd2lsbCBiZSBhIGN1YmVtYXAgdGV4dHVyZVxuICogKiAgIGB0ZXh0dXJlcy5jaGVja2VyYCB3aWxsIGJlIGEgMmQgdGV4dHVyZVxuICogKiAgIGB0ZXh0dXJlcy5zdHJpcGVgIHdpbGwgYmUgYSAyZCB0ZXh0dXJlXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsbW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnM+fSBvcHRpb25zIEEgb2JqZWN0IG9mIFRleHR1cmVPcHRpb25zIG9uZSBwZXIgdGV4dHVyZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZXNSZWFkeUNhbGxiYWNrfSBbY2FsbGJhY2tdIEEgY2FsbGJhY2sgY2FsbGVkIHdoZW4gYWxsIHRleHR1cmVzIGhhdmUgYmVlbiBkb3dubG9hZGVkLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsV2ViR0xUZXh0dXJlPn0gdGhlIGNyZWF0ZWQgdGV4dHVyZXMgYnkgbmFtZVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlcyhnbCwgdGV4dHVyZU9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgdmFyIG51bURvd25sb2FkaW5nID0gMDtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdGV4dHVyZXMgPSB7fTtcbiAgdmFyIGltYWdlcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGNhbGxDYWxsYmFja0lmUmVhZHkoKSB7XG4gICAgaWYgKG51bURvd25sb2FkaW5nID09PSAwKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IHVuZGVmaW5lZCwgdGV4dHVyZXMsIGltYWdlcyk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyh0ZXh0dXJlT3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBvcHRpb25zID0gdGV4dHVyZU9wdGlvbnNbbmFtZV07XG4gICAgdmFyIG9uTG9hZEZuO1xuXG4gICAgaWYgKGlzQXN5bmNTcmMob3B0aW9ucy5zcmMpKSB7XG4gICAgICBvbkxvYWRGbiA9IGZ1bmN0aW9uIG9uTG9hZEZuKGVyciwgdGV4LCBpbWcpIHtcbiAgICAgICAgaW1hZ2VzW25hbWVdID0gaW1nO1xuICAgICAgICAtLW51bURvd25sb2FkaW5nO1xuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbENhbGxiYWNrSWZSZWFkeSgpO1xuICAgICAgfTtcblxuICAgICAgKytudW1Eb3dubG9hZGluZztcbiAgICB9XG5cbiAgICB0ZXh0dXJlc1tuYW1lXSA9IGNyZWF0ZVRleHR1cmUoZ2wsIG9wdGlvbnMsIG9uTG9hZEZuKTtcbiAgfSk7IC8vIHF1ZXVlIHRoZSBjYWxsYmFjayBpZiB0aGVyZSBhcmUgbm8gaW1hZ2VzIHRvIGRvd25sb2FkLlxuICAvLyBXZSBkbyB0aGlzIGJlY2F1c2UgaWYgeW91ciBjb2RlIGlzIHN0cnVjdHVyZWQgdG8gd2FpdCBmb3JcbiAgLy8gaW1hZ2VzIHRvIGRvd25sb2FkIGJ1dCB0aGVuIHlvdSBjb21tZW50IG91dCBhbGwgdGhlIGFzeW5jXG4gIC8vIGltYWdlcyB5b3VyIGNvZGUgd291bGQgYnJlYWsuXG5cbiAgY2FsbENhbGxiYWNrSWZSZWFkeSgpO1xuICByZXR1cm4gdGV4dHVyZXM7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3R3Z2wtZnVsbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHdnbC1mdWxsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgX2V4cG9ydE5hbWVzID0ge1xuICBtNDogdHJ1ZSxcbiAgdjM6IHRydWUsXG4gIHByaW1pdGl2ZXM6IHRydWVcbn07XG5leHBvcnRzLnByaW1pdGl2ZXMgPSBleHBvcnRzLnYzID0gZXhwb3J0cy5tNCA9IHZvaWQgMDtcblxudmFyIG00ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tNC5qcyAqLyBcIi4vc3JjL200LmpzXCIpKTtcblxuZXhwb3J0cy5tNCA9IG00O1xuXG52YXIgdjMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3YzLmpzICovIFwiLi9zcmMvdjMuanNcIikpO1xuXG5leHBvcnRzLnYzID0gdjM7XG5cbnZhciBwcmltaXRpdmVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wcmltaXRpdmVzLmpzICovIFwiLi9zcmMvcHJpbWl0aXZlcy5qc1wiKSk7XG5cbmV4cG9ydHMucHJpbWl0aXZlcyA9IHByaW1pdGl2ZXM7XG5cbnZhciBfdHdnbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHdnbC5qcyAqLyBcIi4vc3JjL3R3Z2wuanNcIik7XG5cbk9iamVjdC5rZXlzKF90d2dsKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfdHdnbFtrZXldO1xufSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3R3Z2wuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90d2dsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIF9leHBvcnROYW1lcyA9IHtcbiAgYWRkRXh0ZW5zaW9uc1RvQ29udGV4dDogdHJ1ZSxcbiAgZ2V0Q29udGV4dDogdHJ1ZSxcbiAgZ2V0V2ViR0xDb250ZXh0OiB0cnVlLFxuICByZXNpemVDYW52YXNUb0Rpc3BsYXlTaXplOiB0cnVlLFxuICBzZXREZWZhdWx0czogdHJ1ZSxcbiAgYXR0cmlidXRlczogdHJ1ZSxcbiAgdGV4dHVyZXM6IHRydWUsXG4gIHV0aWxzOiB0cnVlLFxuICBkcmF3OiB0cnVlLFxuICBmcmFtZWJ1ZmZlcnM6IHRydWUsXG4gIHByb2dyYW1zOiB0cnVlLFxuICB0eXBlZGFycmF5czogdHJ1ZSxcbiAgdmVydGV4QXJyYXlzOiB0cnVlXG59O1xuZXhwb3J0cy5hZGRFeHRlbnNpb25zVG9Db250ZXh0ID0gYWRkRXh0ZW5zaW9uc1RvQ29udGV4dDtcbmV4cG9ydHMuZ2V0Q29udGV4dCA9IGdldENvbnRleHQ7XG5leHBvcnRzLmdldFdlYkdMQ29udGV4dCA9IGdldFdlYkdMQ29udGV4dDtcbmV4cG9ydHMucmVzaXplQ2FudmFzVG9EaXNwbGF5U2l6ZSA9IHJlc2l6ZUNhbnZhc1RvRGlzcGxheVNpemU7XG5leHBvcnRzLnNldERlZmF1bHRzID0gc2V0RGVmYXVsdHM7XG5leHBvcnRzLnZlcnRleEFycmF5cyA9IGV4cG9ydHMudHlwZWRhcnJheXMgPSBleHBvcnRzLnByb2dyYW1zID0gZXhwb3J0cy5mcmFtZWJ1ZmZlcnMgPSBleHBvcnRzLmRyYXcgPSBleHBvcnRzLnV0aWxzID0gZXhwb3J0cy50ZXh0dXJlcyA9IGV4cG9ydHMuYXR0cmlidXRlcyA9IHZvaWQgMDtcblxudmFyIGF0dHJpYnV0ZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2F0dHJpYnV0ZXMuanMgKi8gXCIuL3NyYy9hdHRyaWJ1dGVzLmpzXCIpKTtcblxuZXhwb3J0cy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbk9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbn0pO1xuXG52YXIgdGV4dHVyZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RleHR1cmVzLmpzICovIFwiLi9zcmMvdGV4dHVyZXMuanNcIikpO1xuXG5leHBvcnRzLnRleHR1cmVzID0gdGV4dHVyZXM7XG5PYmplY3Qua2V5cyh0ZXh0dXJlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gdGV4dHVyZXNba2V5XTtcbn0pO1xuXG52YXIgaGVscGVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9oZWxwZXIuanMgKi8gXCIuL3NyYy9oZWxwZXIuanNcIikpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIikpO1xuXG5leHBvcnRzLnV0aWxzID0gdXRpbHM7XG5PYmplY3Qua2V5cyh1dGlscykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gdXRpbHNba2V5XTtcbn0pO1xuXG52YXIgZHJhdyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZHJhdy5qcyAqLyBcIi4vc3JjL2RyYXcuanNcIikpO1xuXG5leHBvcnRzLmRyYXcgPSBkcmF3O1xuT2JqZWN0LmtleXMoZHJhdykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gZHJhd1trZXldO1xufSk7XG5cbnZhciBmcmFtZWJ1ZmZlcnMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYW1lYnVmZmVycy5qcyAqLyBcIi4vc3JjL2ZyYW1lYnVmZmVycy5qc1wiKSk7XG5cbmV4cG9ydHMuZnJhbWVidWZmZXJzID0gZnJhbWVidWZmZXJzO1xuT2JqZWN0LmtleXMoZnJhbWVidWZmZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBmcmFtZWJ1ZmZlcnNba2V5XTtcbn0pO1xuXG52YXIgcHJvZ3JhbXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Byb2dyYW1zLmpzICovIFwiLi9zcmMvcHJvZ3JhbXMuanNcIikpO1xuXG5leHBvcnRzLnByb2dyYW1zID0gcHJvZ3JhbXM7XG5PYmplY3Qua2V5cyhwcm9ncmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gcHJvZ3JhbXNba2V5XTtcbn0pO1xuXG52YXIgdHlwZWRhcnJheXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3R5cGVkYXJyYXlzLmpzICovIFwiLi9zcmMvdHlwZWRhcnJheXMuanNcIikpO1xuXG5leHBvcnRzLnR5cGVkYXJyYXlzID0gdHlwZWRhcnJheXM7XG5PYmplY3Qua2V5cyh0eXBlZGFycmF5cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gdHlwZWRhcnJheXNba2V5XTtcbn0pO1xuXG52YXIgdmVydGV4QXJyYXlzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92ZXJ0ZXgtYXJyYXlzLmpzICovIFwiLi9zcmMvdmVydGV4LWFycmF5cy5qc1wiKSk7XG5cbmV4cG9ydHMudmVydGV4QXJyYXlzID0gdmVydGV4QXJyYXlzO1xuT2JqZWN0LmtleXModmVydGV4QXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSB2ZXJ0ZXhBcnJheXNba2V5XTtcbn0pO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogVGhlIG1haW4gVFdHTCBtb2R1bGUuXG4gKlxuICogRm9yIG1vc3QgdXNlIGNhc2VzIHlvdSBzaG91bGRuJ3QgbmVlZCBhbnl0aGluZyBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuICogRXhjZXB0aW9ucyBiZXR3ZWVuIHRoZSBzdHVmZiBhZGRlZCB0byB0d2dsLWZ1bGwgKHYzLCBtNCwgcHJpbWl0aXZlcylcbiAqXG4gKiBAbW9kdWxlIHR3Z2xcbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXMuc2V0QXR0cmliSW5mb0J1ZmZlckZyb21BcnJheSBhcyBzZXRBdHRyaWJJbmZvQnVmZmVyRnJvbUFycmF5XG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9hdHRyaWJ1dGVzLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzIGFzIGNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9hdHRyaWJ1dGVzLmNyZWF0ZVZlcnRleEFycmF5SW5mbyBhcyBjcmVhdGVWZXJ0ZXhBcnJheUluZm9cbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL2RyYXcuZHJhd0J1ZmZlckluZm8gYXMgZHJhd0J1ZmZlckluZm9cbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL2RyYXcuZHJhd09iamVjdExpc3QgYXMgZHJhd09iamVjdExpc3RcbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL2ZyYW1lYnVmZmVycy5jcmVhdGVGcmFtZWJ1ZmZlckluZm8gYXMgY3JlYXRlRnJhbWVidWZmZXJJbmZvXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9mcmFtZWJ1ZmZlcnMucmVzaXplRnJhbWVidWZmZXJJbmZvIGFzIHJlc2l6ZUZyYW1lYnVmZmVySW5mb1xuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvZnJhbWVidWZmZXJzLmJpbmRGcmFtZWJ1ZmZlckluZm8gYXMgYmluZEZyYW1lYnVmZmVySW5mb1xuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvcHJvZ3JhbXMuY3JlYXRlUHJvZ3JhbUluZm8gYXMgY3JlYXRlUHJvZ3JhbUluZm9cbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL3Byb2dyYW1zLmNyZWF0ZVVuaWZvcm1CbG9ja0luZm8gYXMgY3JlYXRlVW5pZm9ybUJsb2NrSW5mb1xuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvcHJvZ3JhbXMuYmluZFVuaWZvcm1CbG9jayBhcyBiaW5kVW5pZm9ybUJsb2NrXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9wcm9ncmFtcy5zZXRVbmlmb3JtQmxvY2sgYXMgc2V0VW5pZm9ybUJsb2NrXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9wcm9ncmFtcy5zZXRCbG9ja1VuaWZvcm1zIGFzIHNldEJsb2NrVW5pZm9ybXNcbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL3Byb2dyYW1zLnNldFVuaWZvcm1zIGFzIHNldFVuaWZvcm1zXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9wcm9ncmFtcy5zZXRCdWZmZXJzQW5kQXR0cmlidXRlcyBhcyBzZXRCdWZmZXJzQW5kQXR0cmlidXRlc1xuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvdGV4dHVyZXMuc2V0VGV4dHVyZUZyb21BcnJheSBhcyBzZXRUZXh0dXJlRnJvbUFycmF5XG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC90ZXh0dXJlcy5jcmVhdGVUZXh0dXJlIGFzIGNyZWF0ZVRleHR1cmVcbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL3RleHR1cmVzLnJlc2l6ZVRleHR1cmUgYXMgcmVzaXplVGV4dHVyZVxuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvdGV4dHVyZXMuY3JlYXRlVGV4dHVyZXMgYXMgY3JlYXRlVGV4dHVyZXNcbiAqL1xuLy8gbWFrZSBzdXJlIHdlIGRvbid0IHNlZSBhIGdsb2JhbCBnbFxudmFyIGdsID0gdW5kZWZpbmVkO1xuLyogZXNsaW50LWRpc2FibGUtbGluZSAqL1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkZEV4dGVuc2lvbnNUb0NvbnRleHQ6IHRydWVcbn07XG4vKipcbiAqIFZhcmlvdXMgZGVmYXVsdCBzZXR0aW5ncyBmb3IgdHdnbC5cbiAqXG4gKiBOb3RlOiBZb3UgY2FuIGNhbGwgdGhpcyBhbnkgbnVtYmVyIG9mIHRpbWVzLiBFeGFtcGxlOlxuICpcbiAqICAgICB0d2dsLnNldERlZmF1bHRzKHsgdGV4dHVyZUNvbG9yOiBbMSwgMCwgMCwgMV0gfSk7XG4gKiAgICAgdHdnbC5zZXREZWZhdWx0cyh7IGF0dHJpYlByZWZpeDogJ2FfJyB9KTtcbiAqXG4gKiBpcyBlcXVpdmFsZW50IHRvXG4gKlxuICogICAgIHR3Z2wuc2V0RGVmYXVsdHMoe1xuICogICAgICAgdGV4dHVyZUNvbG9yOiBbMSwgMCwgMCwgMV0sXG4gKiAgICAgICBhdHRyaWJQcmVmaXg6ICdhXycsXG4gKiAgICAgfSk7XG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRGVmYXVsdHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXR0cmliUHJlZml4XSBUaGUgcHJlZml4IHRvIHN0aWNrIG9uIGF0dHJpYnV0ZXNcbiAqXG4gKiAgIFdoZW4gd3JpdGluZyBzaGFkZXJzIEkgcHJlZmVyIHRvIG5hbWUgYXR0cmlidXRlcyB3aXRoIGBhX2AsIHVuaWZvcm1zIHdpdGggYHVfYCBhbmQgdmFyeWluZ3Mgd2l0aCBgdl9gXG4gKiAgIGFzIGl0IG1ha2VzIGl0IGNsZWFyIHdoZXJlIHRoZXkgY2FtZSBmcm9tLiBCdXQsIHdoZW4gYnVpbGRpbmcgZ2VvbWV0cnkgSSBwcmVmZXIgdXNpbmcgdW4tcHJlZml4ZWQgbmFtZXMuXG4gKlxuICogICBJbiBvdGhlciB3b3JkcyBJJ2xsIGNyZWF0ZSBhcnJheXMgb2YgZ2VvbWV0cnkgbGlrZSB0aGlzXG4gKlxuICogICAgICAgY29uc3QgYXJyYXlzID0ge1xuICogICAgICAgICBwb3NpdGlvbjogLi4uXG4gKiAgICAgICAgIG5vcm1hbDogLi4uXG4gKiAgICAgICAgIHRleGNvb3JkOiAuLi5cbiAqICAgICAgIH07XG4gKlxuICogICBCdXQgbmVlZCB0aG9zZSBtYXBwZWQgdG8gYXR0cmlidXRlcyBhbmQgbXkgYXR0cmlidXRlcyBzdGFydCB3aXRoIGBhX2AuXG4gKlxuICogICBEZWZhdWx0OiBgXCJcImBcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcltdfSBbdGV4dHVyZUNvbG9yXSBBcnJheSBvZiA0IHZhbHVlcyBpbiB0aGUgcmFuZ2UgMCB0byAxXG4gKlxuICogICBUaGUgZGVmYXVsdCB0ZXh0dXJlIGNvbG9yIGlzIHVzZWQgd2hlbiBsb2FkaW5nIHRleHR1cmVzIGZyb21cbiAqICAgdXJscy4gQmVjYXVzZSB0aGUgVVJMIHdpbGwgYmUgbG9hZGVkIGFzeW5jIHdlJ2QgbGlrZSB0byBiZVxuICogICBhYmxlIHRvIHVzZSB0aGUgdGV4dHVyZSBpbW1lZGlhdGVseS4gQnkgcHV0dGluZyBhIDF4MSBwaXhlbFxuICogICBjb2xvciBpbiB0aGUgdGV4dHVyZSB3ZSBjYW4gc3RhcnQgdXNpbmcgdGhlIHRleHR1cmUgYmVmb3JlXG4gKiAgIHRoZSBVUkwgaGFzIGxvYWRlZC5cbiAqXG4gKiAgIERlZmF1bHQ6IGBbMC41LCAwLjc1LCAxLCAxXWBcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2Nyb3NzT3JpZ2luXVxuICpcbiAqICAgSWYgbm90IHVuZGVmaW5lZCBzZXRzIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgb24gaW1hZ2VzXG4gKiAgIHRoYXQgdHdnbCBjcmVhdGVzIHdoZW4gZG93bmxvYWRpbmcgaW1hZ2VzIGZvciB0ZXh0dXJlcy5cbiAqXG4gKiAgIEFsc28gc2VlIHtAbGluayBtb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30uXG4gKlxuICogQHByb3BlcnR5IHtib29sfSBbYWRkRXh0ZW5zaW9uc1RvQ29udGV4dF1cbiAqXG4gKiAgIElmIHRydWUsIHRoZW4sIHdoZW4gdHdnbCB3aWxsIHRyeSB0byBhZGQgYW55IHN1cHBvcnRlZCBXZWJHTCBleHRlbnNpb25zXG4gKiAgIGRpcmVjdGx5IHRvIHRoZSBjb250ZXh0IHVuZGVyIHRoZWlyIG5vcm1hbCBHTCBuYW1lcy4gRm9yIGV4YW1wbGVcbiAqICAgaWYgQU5HTEVfaW5zdGFuY2VzX2FycmF5cyBleGlzdHMgdGhlbiB0d2dsIHdvdWxkIGVuYWJsZSBpdCxcbiAqICAgYWRkIHRoZSBmdW5jdGlvbnMgYHZlcnRleEF0dHJpYkRpdmlzb3JgLCBgZHJhd0FycmF5c0luc3RhbmNlZGAsXG4gKiAgIGBkcmF3RWxlbWVudHNJbnN0YW5jZWRgLCBhbmQgdGhlIGNvbnN0YW50IGBWRVJURVhfQVRUUklCX0FSUkFZX0RJVklTT1JgXG4gKiAgIHRvIHRoZSBgV2ViR0xSZW5kZXJpbmdDb250ZXh0YC5cbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIFNldHMgdmFyaW91cyBkZWZhdWx0cyBmb3IgdHdnbC5cbiAqXG4gKiBJbiB0aGUgaW50ZXJlc3Qgb2YgdGVyc2VuZXNzIHdoaWNoIGlzIGtpbmQgb2YgdGhlIHBvaW50XG4gKiBvZiB0d2dsIEkndmUgaW50ZWdyYXRlZCBhIGZldyBvZiB0aGUgb2xkZXIgZnVuY3Rpb25zIGhlcmVcbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkRlZmF1bHRzfSBuZXdEZWZhdWx0cyBUaGUgZGVmYXVsdCBzZXR0aW5ncy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbmZ1bmN0aW9uIHNldERlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gIGhlbHBlci5jb3B5RXhpc3RpbmdQcm9wZXJ0aWVzKG5ld0RlZmF1bHRzLCBkZWZhdWx0cyk7XG4gIGF0dHJpYnV0ZXMuc2V0QXR0cmlidXRlRGVmYXVsdHNfKG5ld0RlZmF1bHRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIHRleHR1cmVzLnNldFRleHR1cmVEZWZhdWx0c18obmV3RGVmYXVsdHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59XG5cbnZhciBwcmVmaXhSRSA9IC9eKC4qPylfLztcblxuZnVuY3Rpb24gYWRkRXh0ZW5zaW9uVG9Db250ZXh0KGdsLCBleHRlbnNpb25OYW1lKSB7XG4gIHV0aWxzLmdsRW51bVRvU3RyaW5nKGdsLCAwKTtcbiAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbihleHRlbnNpb25OYW1lKTtcblxuICBpZiAoZXh0KSB7XG4gICAgdmFyIGVudW1zID0ge307XG4gICAgdmFyIGZuU3VmZml4ID0gcHJlZml4UkUuZXhlYyhleHRlbnNpb25OYW1lKVsxXTtcbiAgICB2YXIgZW51bVN1ZmZpeCA9ICdfJyArIGZuU3VmZml4O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGV4dCkge1xuICAgICAgdmFyIHZhbHVlID0gZXh0W2tleV07XG4gICAgICB2YXIgaXNGdW5jID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgICAgdmFyIHN1ZmZpeCA9IGlzRnVuYyA/IGZuU3VmZml4IDogZW51bVN1ZmZpeDtcbiAgICAgIHZhciBuYW1lID0ga2V5OyAvLyBleGFtcGxlcyBvZiB3aGVyZSB0aGlzIGlzIG5vdCB0cnVlIGFyZSBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xuICAgICAgLy8gYW5kIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xuXG4gICAgICBpZiAoa2V5LmVuZHNXaXRoKHN1ZmZpeCkpIHtcbiAgICAgICAgbmFtZSA9IGtleS5zdWJzdHJpbmcoMCwga2V5Lmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2xbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWlzRnVuYyAmJiBnbFtuYW1lXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBoZWxwZXIud2FybihuYW1lLCBnbFtuYW1lXSwgdmFsdWUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBnbFtuYW1lXSA9IGZ1bmN0aW9uIChvcmlnRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvcmlnRm4uYXBwbHkoZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIGVudW1zW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHBhc3MgdGhlIG1vZGlmaWVkIGVudW1zIHRvIGdsRW51bVRvU3RyaW5nXG5cblxuICAgIGVudW1zLmNvbnN0cnVjdG9yID0ge1xuICAgICAgbmFtZTogZXh0LmNvbnN0cnVjdG9yLm5hbWVcbiAgICB9O1xuICAgIHV0aWxzLmdsRW51bVRvU3RyaW5nKGVudW1zLCAwKTtcbiAgfVxuXG4gIHJldHVybiBleHQ7XG59XG4vKlxuICogSWYgeW91J3JlIHdvbmRlcmluZyB3aHkgdGhlIGNvZGUgZG9lc24ndCBqdXN0IGl0ZXJhdGVcbiAqIG92ZXIgYWxsIGV4dGVuc2lvbnMgdXNpbmcgYGdsLmdldEV4dGVuc2lvbnNgIGlzIHRoYXQgaXQncyBwb3NzaWJsZVxuICogc29tZSBmdXR1cmUgZXh0ZW5zaW9uIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoaXMgY29kZS4gUmF0aGVyIHRoYW5cbiAqIGhhdmUgdGhpbmcgc3VkZGVubHkgYnJlYWsgaXQgc2VlbXMgYmV0dGVyIHRvIG1hbnVhbGx5IGFkZCB0byB0aGlzXG4gKiBsaXN0LlxuICpcbiAqL1xuXG5cbnZhciBzdXBwb3J0ZWRFeHRlbnNpb25zID0gWydBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJywgJ0VYVF9ibGVuZF9taW5tYXgnLCAnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcsICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnLCAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5JywgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInLCAnRVhUX2ZyYWdfZGVwdGgnLCAnRVhUX3NSR0InLCAnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcsICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnLCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcsICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnLCAnT0VTX3RleHR1cmVfZmxvYXQnLCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJywgJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnLCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInLCAnT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnLCAnV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JywgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hdGMnLCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnLCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJywgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJywgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2InLCAnV0VCR0xfZGVwdGhfdGV4dHVyZScsICdXRUJHTF9kcmF3X2J1ZmZlcnMnXTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gZW5hYmxlIGFsbCBvZiB0aGUgZm9sbG93aW5nIGV4dGVuc2lvbnNcbiAqIGFuZCBhZGQgdGhlaXIgZnVuY3Rpb25zIGFuZCBjb25zdGFudHMgdG8gdGhlXG4gKiBgV2ViR0xSZW5kZXJpbmdDb250ZXh0YCB1c2luZyB0aGVpciBub3JtYWwgbm9uLWV4dGVuc2lvbiBsaWtlIG5hbWVzLlxuICpcbiAqICAgICAgQU5HTEVfaW5zdGFuY2VkX2FycmF5c1xuICogICAgICBFWFRfYmxlbmRfbWlubWF4XG4gKiAgICAgIEVYVF9jb2xvcl9idWZmZXJfZmxvYXRcbiAqICAgICAgRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XG4gKiAgICAgIEVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVxuICogICAgICBFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyXG4gKiAgICAgIEVYVF9mcmFnX2RlcHRoXG4gKiAgICAgIEVYVF9zUkdCXG4gKiAgICAgIEVYVF9zaGFkZXJfdGV4dHVyZV9sb2RcbiAqICAgICAgRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXG4gKiAgICAgIE9FU19lbGVtZW50X2luZGV4X3VpbnRcbiAqICAgICAgT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXG4gKiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0XG4gKiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclxuICogICAgICBPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XG4gKiAgICAgIE9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXG4gKiAgICAgIE9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XG4gKiAgICAgIFdFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdFxuICogICAgICBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXRjXG4gKiAgICAgIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxXG4gKiAgICAgIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xuICogICAgICBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xuICogICAgICBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiXG4gKiAgICAgIFdFQkdMX2RlcHRoX3RleHR1cmVcbiAqICAgICAgV0VCR0xfZHJhd19idWZmZXJzXG4gKlxuICogRm9yIGV4YW1wbGUgaWYgYEFOR0xFX2luc3RhbmNlZF9hcnJheXNgIGV4aXN0cyB0aGVuIHRoZSBmdW5jdGlvbnNcbiAqIGBkcmF3QXJyYXlzSW5zdGFuY2VkYCwgYGRyYXdFbGVtZW50c0luc3RhbmNlZGAsIGB2ZXJ0ZXhBdHRyaWJEaXZpc29yYFxuICogYW5kIHRoZSBjb25zdGFudCBgVkVSVEVYX0FUVFJJQl9BUlJBWV9ESVZJU09SYCBhcmUgYWRkZWQgdG8gdGhlXG4gKiBgV2ViR0xSZW5kZXJpbmdDb250ZXh0YC5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgeW91IHdhbnQgdG8ga25vdyBpZiB0aGUgZXh0ZW5zaW9uIGV4aXN0cyB5b3Ugc2hvdWxkXG4gKiBwcm9iYWJseSBjYWxsIGBnbC5nZXRFeHRlbnNpb25gIGZvciBlYWNoIGV4dGVuc2lvbi4gQWx0ZXJuYXRpdmVseVxuICogeW91IGNhbiBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgZnVuY3Rpb25zIG9yIGNvbnN0YW50cyB0aGF0XG4gKiBhcmUgZXhwZWN0ZWQgdG8gYmUgYWRkZWQuIEZvciBleGFtcGxlXG4gKlxuICogICAgaWYgKGdsLmRyYXdCdWZmZXJzKSB7XG4gKiAgICAgIC8vIEVpdGhlciBXRUJHTF9kcmF3X2J1ZmZlcnMgd2FzIGVuYWJsZWQgT1IgeW91J3JlIHJ1bm5pbmcgaW4gV2ViR0wyXG4gKiAgICAgIC4uLi5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbmZ1bmN0aW9uIGFkZEV4dGVuc2lvbnNUb0NvbnRleHQoZ2wpIHtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHN1cHBvcnRlZEV4dGVuc2lvbnMubGVuZ3RoOyArK2lpKSB7XG4gICAgYWRkRXh0ZW5zaW9uVG9Db250ZXh0KGdsLCBzdXBwb3J0ZWRFeHRlbnNpb25zW2lpXSk7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIHdlYmdsIGNvbnRleHQuXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgVGhlIGNhbnZhcyB0YWcgdG8gZ2V0XG4gKiAgICAgY29udGV4dCBmcm9tLiBJZiBvbmUgaXMgbm90IHBhc3NlZCBpbiBvbmUgd2lsbCBiZVxuICogICAgIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjcmVhdGVkIGNvbnRleHQuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlM0RDb250ZXh0KGNhbnZhcywgb3B0X2F0dHJpYnMpIHtcbiAgdmFyIG5hbWVzID0gW1wid2ViZ2xcIiwgXCJleHBlcmltZW50YWwtd2ViZ2xcIl07XG4gIHZhciBjb250ZXh0ID0gbnVsbDtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmFtZXMubGVuZ3RoOyArK2lpKSB7XG4gICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KG5hbWVzW2lpXSwgb3B0X2F0dHJpYnMpO1xuXG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIGlmIChkZWZhdWx0cy5hZGRFeHRlbnNpb25zVG9Db250ZXh0KSB7XG4gICAgICAgIGFkZEV4dGVuc2lvbnNUb0NvbnRleHQoY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuLyoqXG4gKiBHZXRzIGEgV2ViR0wxIGNvbnRleHQuXG4gKlxuICogTm90ZTogV2lsbCBhdHRlbXB0IHRvIGVuYWJsZSBWZXJ0ZXggQXJyYXkgT2JqZWN0c1xuICogYW5kIGFkZCBXZWJHTDIgZW50cnkgcG9pbnRzLiAodW5sZXNzIHlvdSBmaXJzdCBzZXQgZGVmYXVsdHMgd2l0aFxuICogYHR3Z2wuc2V0RGVmYXVsdHMoe2VuYWJsZVZlcnRleEFycmF5T2JqZWN0czogZmFsc2V9KWA7XG4gKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIGEgY2FudmFzIGVsZW1lbnQuXG4gKiBAcGFyYW0ge1dlYkdMQ29udGV4dEF0dHJpYnV0ZXN9IFtvcHRfYXR0cmlic10gb3B0aW9uYWwgd2ViZ2wgY29udGV4dCBjcmVhdGlvbiBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjcmVhdGVkIGNvbnRleHQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFdlYkdMQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKSB7XG4gIHZhciBnbCA9IGNyZWF0ZTNEQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKTtcbiAgcmV0dXJuIGdsO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgd2ViZ2wgY29udGV4dC5cbiAqXG4gKiBXaWxsIHJldHVybiBhIFdlYkdMMiBjb250ZXh0IGlmIHBvc3NpYmxlLlxuICpcbiAqIFlvdSBjYW4gY2hlY2sgaWYgaXQncyBXZWJHTDIgd2l0aFxuICpcbiAqICAgICB0d2dsLmlzV2ViR0wyKGdsKTtcbiAqXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgVGhlIGNhbnZhcyB0YWcgdG8gZ2V0XG4gKiAgICAgY29udGV4dCBmcm9tLiBJZiBvbmUgaXMgbm90IHBhc3NlZCBpbiBvbmUgd2lsbCBiZVxuICogICAgIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjcmVhdGVkIGNvbnRleHQuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGNhbnZhcywgb3B0X2F0dHJpYnMpIHtcbiAgdmFyIG5hbWVzID0gW1wid2ViZ2wyXCIsIFwid2ViZ2xcIiwgXCJleHBlcmltZW50YWwtd2ViZ2xcIl07XG4gIHZhciBjb250ZXh0ID0gbnVsbDtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmFtZXMubGVuZ3RoOyArK2lpKSB7XG4gICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KG5hbWVzW2lpXSwgb3B0X2F0dHJpYnMpO1xuXG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIGlmIChkZWZhdWx0cy5hZGRFeHRlbnNpb25zVG9Db250ZXh0KSB7XG4gICAgICAgIGFkZEV4dGVuc2lvbnNUb0NvbnRleHQoY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuLyoqXG4gKiBHZXRzIGEgV2ViR0wgY29udGV4dC4gIFdpbGwgY3JlYXRlIGEgV2ViR0wyIGNvbnRleHQgaWYgcG9zc2libGUuXG4gKlxuICogWW91IGNhbiBjaGVjayBpZiBpdCdzIFdlYkdMMiB3aXRoXG4gKlxuICogICAgZnVuY3Rpb24gaXNXZWJHTDIoZ2wpIHtcbiAqICAgICAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5WRVJTSU9OKS5pbmRleE9mKFwiV2ViR0wgMi4wIFwiKSA9PSAwO1xuICogICAgfVxuICpcbiAqIE5vdGU6IEZvciBhIFdlYkdMMSBjb250ZXh0IHdpbGwgYXR0ZW1wdCB0byBlbmFibGUgVmVydGV4IEFycmF5IE9iamVjdHNcbiAqIGFuZCBhZGQgV2ViR0wyIGVudHJ5IHBvaW50cy4gKHVubGVzcyB5b3UgZmlyc3Qgc2V0IGRlZmF1bHRzIHdpdGhcbiAqIGB0d2dsLnNldERlZmF1bHRzKHtlbmFibGVWZXJ0ZXhBcnJheU9iamVjdHM6IGZhbHNlfSlgO1xuICpcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBhIGNhbnZhcyBlbGVtZW50LlxuICogQHBhcmFtIHtXZWJHTENvbnRleHRBdHRyaWJ1dGVzfSBbb3B0X2F0dHJpYnNdIG9wdGlvbmFsIHdlYmdsIGNvbnRleHQgY3JlYXRpb24gYXR0cmlidXRlc1xuICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3JlYXRlZCBjb250ZXh0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0KGNhbnZhcywgb3B0X2F0dHJpYnMpIHtcbiAgdmFyIGdsID0gY3JlYXRlQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKTtcbiAgcmV0dXJuIGdsO1xufVxuLyoqXG4gKiBSZXNpemUgYSBjYW52YXMgdG8gbWF0Y2ggdGhlIHNpemUgaXQncyBkaXNwbGF5ZWQuXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgVGhlIGNhbnZhcyB0byByZXNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gW211bHRpcGxpZXJdIFNvIHlvdSBjYW4gcGFzcyBpbiBgd2luZG93LmRldmljZVBpeGVsUmF0aW9gIG9yIG90aGVyIHNjYWxlIHZhbHVlIGlmIHlvdSB3YW50IHRvLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2FudmFzIHdhcyByZXNpemVkLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG5mdW5jdGlvbiByZXNpemVDYW52YXNUb0Rpc3BsYXlTaXplKGNhbnZhcywgbXVsdGlwbGllcikge1xuICBtdWx0aXBsaWVyID0gbXVsdGlwbGllciB8fCAxO1xuICBtdWx0aXBsaWVyID0gTWF0aC5tYXgoMCwgbXVsdGlwbGllcik7XG4gIHZhciB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aCAqIG11bHRpcGxpZXIgfCAwO1xuICB2YXIgaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodCAqIG11bHRpcGxpZXIgfCAwO1xuXG4gIGlmIChjYW52YXMud2lkdGggIT09IHdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3R5cGVkYXJyYXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3R5cGVkYXJyYXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmdldEdMVHlwZUZvclR5cGVkQXJyYXkgPSBnZXRHTFR5cGVGb3JUeXBlZEFycmF5O1xuZXhwb3J0cy5nZXRHTFR5cGVGb3JUeXBlZEFycmF5VHlwZSA9IGdldEdMVHlwZUZvclR5cGVkQXJyYXlUeXBlO1xuZXhwb3J0cy5nZXRUeXBlZEFycmF5VHlwZUZvckdMVHlwZSA9IGdldFR5cGVkQXJyYXlUeXBlRm9yR0xUeXBlO1xuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gdm9pZCAwO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogTG93IGxldmVsIHNoYWRlciB0eXBlZCBhcnJheSByZWxhdGVkIGZ1bmN0aW9uc1xuICpcbiAqIFlvdSBzaG91bGQgZ2VuZXJhbGx5IG5vdCBuZWVkIHRvIHVzZSB0aGVzZSBmdW5jdGlvbnMuIFRoZXkgYXJlIHByb3ZpZGVkXG4gKiBmb3IgdGhvc2UgY2FzZXMgd2hlcmUgeW91J3JlIGRvaW5nIHNvbWV0aGluZyBvdXQgb2YgdGhlIG9yZGluYXJ5XG4gKiBhbmQgeW91IG5lZWQgbG93ZXIgbGV2ZWwgYWNjZXNzLlxuICpcbiAqIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHRoZXkgYXJlIGF2YWlsYWJsZSBhdCBib3RoIGB0d2dsLnR5cGVkQXJyYXlgIGFuZCBgdHdnbGBcbiAqIGl0c2VsZlxuICpcbiAqIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2x9IGZvciBjb3JlIGZ1bmN0aW9uc1xuICpcbiAqIEBtb2R1bGUgdHdnbC90eXBlZEFycmF5XG4gKi9cbi8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBzZWUgYSBnbG9iYWwgZ2xcbnZhciBnbCA9IHVuZGVmaW5lZDtcbi8qIGVzbGludC1kaXNhYmxlLWxpbmUgKi9cblxuLyogRGF0YVR5cGUgKi9cblxudmFyIEJZVEUgPSAweDE0MDA7XG52YXIgVU5TSUdORURfQllURSA9IDB4MTQwMTtcbnZhciBTSE9SVCA9IDB4MTQwMjtcbnZhciBVTlNJR05FRF9TSE9SVCA9IDB4MTQwMztcbnZhciBJTlQgPSAweDE0MDQ7XG52YXIgVU5TSUdORURfSU5UID0gMHgxNDA1O1xudmFyIEZMT0FUID0gMHgxNDA2O1xudmFyIFVOU0lHTkVEX1NIT1JUXzRfNF80XzQgPSAweDgwMzM7XG52YXIgVU5TSUdORURfU0hPUlRfNV81XzVfMSA9IDB4ODAzNDtcbnZhciBVTlNJR05FRF9TSE9SVF81XzZfNSA9IDB4ODM2MztcbnZhciBIQUxGX0ZMT0FUID0gMHgxNDBCO1xudmFyIFVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFViA9IDB4ODM2ODtcbnZhciBVTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWID0gMHg4QzNCO1xudmFyIFVOU0lHTkVEX0lOVF81XzlfOV85X1JFViA9IDB4OEMzRTtcbnZhciBGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVYgPSAweDhEQUQ7XG52YXIgVU5TSUdORURfSU5UXzI0XzggPSAweDg0RkE7XG52YXIgZ2xUeXBlVG9UeXBlZEFycmF5ID0ge307XG57XG4gIHZhciB0dCA9IGdsVHlwZVRvVHlwZWRBcnJheTtcbiAgdHRbQllURV0gPSBJbnQ4QXJyYXk7XG4gIHR0W1VOU0lHTkVEX0JZVEVdID0gVWludDhBcnJheTtcbiAgdHRbU0hPUlRdID0gSW50MTZBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRdID0gVWludDE2QXJyYXk7XG4gIHR0W0lOVF0gPSBJbnQzMkFycmF5O1xuICB0dFtVTlNJR05FRF9JTlRdID0gVWludDMyQXJyYXk7XG4gIHR0W0ZMT0FUXSA9IEZsb2F0MzJBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRfNF80XzRfNF0gPSBVaW50MTZBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRfNV81XzVfMV0gPSBVaW50MTZBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRfNV82XzVdID0gVWludDE2QXJyYXk7XG4gIHR0W0hBTEZfRkxPQVRdID0gVWludDE2QXJyYXk7XG4gIHR0W1VOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVl0gPSBVaW50MzJBcnJheTtcbiAgdHRbVU5TSUdORURfSU5UXzEwRl8xMUZfMTFGX1JFVl0gPSBVaW50MzJBcnJheTtcbiAgdHRbVU5TSUdORURfSU5UXzVfOV85XzlfUkVWXSA9IFVpbnQzMkFycmF5O1xuICB0dFtGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVZdID0gVWludDMyQXJyYXk7XG4gIHR0W1VOU0lHTkVEX0lOVF8yNF84XSA9IFVpbnQzMkFycmF5O1xufVxuLyoqXG4gKiBHZXQgdGhlIEdMIHR5cGUgZm9yIGEgdHlwZWRBcnJheVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IHR5cGVkQXJyYXkgYSB0eXBlZEFycmF5XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBHTCB0eXBlIGZvciBhcnJheS4gRm9yIGV4YW1wbGUgcGFzcyBpbiBhbiBgSW50OEFycmF5YCBhbmQgYGdsLkJZVEVgIHdpbGxcbiAqICAgYmUgcmV0dXJuZWQuIFBhc3MgaW4gYSBgVWludDMyQXJyYXlgIGFuZCBgZ2wuVU5TSUdORURfSU5UYCB3aWxsIGJlIHJldHVybmVkXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdHlwZWRBcnJheVxuICovXG5cbmZ1bmN0aW9uIGdldEdMVHlwZUZvclR5cGVkQXJyYXkodHlwZWRBcnJheSkge1xuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSkge1xuICAgIHJldHVybiBCWVRFO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBVTlNJR05FRF9CWVRFO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICByZXR1cm4gVU5TSUdORURfQllURTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkpIHtcbiAgICByZXR1cm4gU0hPUlQ7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgIHJldHVybiBVTlNJR05FRF9TSE9SVDtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkpIHtcbiAgICByZXR1cm4gSU5UO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcbiAgICByZXR1cm4gVU5TSUdORURfSU5UO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgcmV0dXJuIEZMT0FUO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgdHlwZWQgYXJyYXkgdHlwZScpO1xufVxuLyoqXG4gKiBHZXQgdGhlIEdMIHR5cGUgZm9yIGEgdHlwZWRBcnJheSB0eXBlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gdHlwZWRBcnJheVR5cGUgYSB0eXBlZEFycmF5IGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBHTCB0eXBlIGZvciB0eXBlLiBGb3IgZXhhbXBsZSBwYXNzIGluIGBJbnQ4QXJyYXlgIGFuZCBgZ2wuQllURWAgd2lsbFxuICogICBiZSByZXR1cm5lZC4gUGFzcyBpbiBgVWludDMyQXJyYXlgIGFuZCBgZ2wuVU5TSUdORURfSU5UYCB3aWxsIGJlIHJldHVybmVkXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdHlwZWRBcnJheVxuICovXG5cblxuZnVuY3Rpb24gZ2V0R0xUeXBlRm9yVHlwZWRBcnJheVR5cGUodHlwZWRBcnJheVR5cGUpIHtcbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBJbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gQllURTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gVU5TSUdORURfQllURTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgcmV0dXJuIFVOU0lHTkVEX0JZVEU7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBJbnQxNkFycmF5KSB7XG4gICAgcmV0dXJuIFNIT1JUO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5VHlwZSA9PT0gVWludDE2QXJyYXkpIHtcbiAgICByZXR1cm4gVU5TSUdORURfU0hPUlQ7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBJbnQzMkFycmF5KSB7XG4gICAgcmV0dXJuIElOVDtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IFVpbnQzMkFycmF5KSB7XG4gICAgcmV0dXJuIFVOU0lHTkVEX0lOVDtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IEZsb2F0MzJBcnJheSkge1xuICAgIHJldHVybiBGTE9BVDtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHR5cGVkIGFycmF5IHR5cGUnKTtcbn1cbi8qKlxuICogR2V0IHRoZSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciBmb3IgYSBnaXZlbiBHTCB0eXBlXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSB0aGUgR0wgdHlwZS4gKGVnOiBgZ2wuVU5TSUdORURfSU5UYClcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSB0aGUgY29uc3RydWN0b3IgZm9yIGEgdGhlIGNvcnJlc3BvbmRpbmcgdHlwZWQgYXJyYXkuIChlZy4gYFVpbnQzMkFycmF5YCkuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdHlwZWRBcnJheVxuICovXG5cblxuZnVuY3Rpb24gZ2V0VHlwZWRBcnJheVR5cGVGb3JHTFR5cGUodHlwZSkge1xuICB2YXIgQ1RPUiA9IGdsVHlwZVRvVHlwZWRBcnJheVt0eXBlXTtcblxuICBpZiAoIUNUT1IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZ2wgdHlwZScpO1xuICB9XG5cbiAgcmV0dXJuIENUT1I7XG59XG5cbnZhciBpc0FycmF5QnVmZmVyID0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJPclNoYXJlZEFycmF5QnVmZmVyKGEpIHtcbiAgcmV0dXJuIGEgJiYgYS5idWZmZXIgJiYgKGEuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgYS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcik7XG59IDogZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcihhKSB7XG4gIHJldHVybiBhICYmIGEuYnVmZmVyICYmIGEuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59O1xuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuaXNXZWJHTDEgPSBpc1dlYkdMMTtcbmV4cG9ydHMuaXNXZWJHTDIgPSBpc1dlYkdMMjtcbmV4cG9ydHMuZ2xFbnVtVG9TdHJpbmcgPSB2b2lkIDA7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBnbCB2ZXJzaW9uIGFzIGEgbnVtYmVyXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEByZXR1cm4ge251bWJlcn0gdmVyc2lvbiBvZiBnbFxuICogQHByaXZhdGVcbiAqL1xuLy9mdW5jdGlvbiBnZXRWZXJzaW9uQXNOdW1iZXIoZ2wpIHtcbi8vICByZXR1cm4gcGFyc2VGbG9hdChnbC5nZXRQYXJhbWV0ZXIoZ2wuVkVSU0lPTikuc3Vic3RyKDYpKTtcbi8vfVxuXG4vKipcbiAqIENoZWNrIGlmIGNvbnRleHQgaXMgV2ViR0wgMi4wXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEByZXR1cm4ge2Jvb2x9IHRydWUgaWYgaXQncyBXZWJHTCAyLjBcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5mdW5jdGlvbiBpc1dlYkdMMihnbCkge1xuICAvLyBUaGlzIGlzIHRoZSBjb3JyZWN0IGNoZWNrIGJ1dCBpdCdzIHNsb3dcbiAgLy8gIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuVkVSU0lPTikuaW5kZXhPZihcIldlYkdMIDIuMFwiKSA9PT0gMDtcbiAgLy8gVGhpcyBtaWdodCBhbHNvIGJlIHRoZSBjb3JyZWN0IGNoZWNrIGJ1dCBJJ20gYXNzdW1pbmcgaXQncyBzbG93LWlzaFxuICAvLyByZXR1cm4gZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICByZXR1cm4gISFnbC50ZXhTdG9yYWdlMkQ7XG59XG4vKipcbiAqIENoZWNrIGlmIGNvbnRleHQgaXMgV2ViR0wgMS4wXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEByZXR1cm4ge2Jvb2x9IHRydWUgaWYgaXQncyBXZWJHTCAxLjBcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cblxuZnVuY3Rpb24gaXNXZWJHTDEoZ2wpIHtcbiAgLy8gVGhpcyBpcyB0aGUgY29ycmVjdCBjaGVjayBidXQgaXQncyBzbG93XG4gIC8vIGNvbnN0IHZlcnNpb24gPSBnZXRWZXJzaW9uQXNOdW1iZXIoZ2wpO1xuICAvLyByZXR1cm4gdmVyc2lvbiA8PSAxLjAgJiYgdmVyc2lvbiA+IDAuMDsgIC8vIGJlY2F1c2UgYXMgb2YgMjAxNi81IEVkZ2UgcmV0dXJucyAwLjk2XG4gIC8vIFRoaXMgbWlnaHQgYWxzbyBiZSB0aGUgY29ycmVjdCBjaGVjayBidXQgSSdtIGFzc3VtaW5nIGl0J3Mgc2xvdy1pc2hcbiAgLy8gcmV0dXJuIGdsIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICByZXR1cm4gIWdsLnRleFN0b3JhZ2UyRDtcbn1cbi8qKlxuICogR2V0cyBhIHN0cmluZyBmb3IgV2ViR0wgZW51bVxuICpcbiAqIE5vdGU6IFNldmVyYWwgZW51bXMgYXJlIHRoZSBzYW1lLiBXaXRob3V0IG1vcmVcbiAqIGNvbnRleHQgKHdoaWNoIGZ1bmN0aW9uKSBpdCdzIGltcG9zc2libGUgdG8gYWx3YXlzXG4gKiBnaXZlIHRoZSBjb3JyZWN0IGVudW0uIEFzIGl0IGlzLCBmb3IgbWF0Y2hpbmcgdmFsdWVzXG4gKiBpdCBnaXZlcyBhbGwgZW51bXMuIENoZWNraW5nIHRoZSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0XG4gKiB0aGF0IG1lYW5zXG4gKlxuICogICAgICAwICAgICA9IFpFUk8gfCBQT0lOVCB8IE5PTkUgfCBOT19FUlJPUlxuICogICAgICAxICAgICA9IE9ORSB8IExJTkVTIHwgU1lOQ19GTFVTSF9DT01NQU5EU19CSVRcbiAqICAgICAgMzI3NzcgPSBCTEVORF9FUVVBVElPTl9SR0IgfCBCTEVORF9FUVVBVElPTl9SR0JcbiAqICAgICAgMzY2NjIgPSBDT1BZX1JFQURfQlVGRkVSIHwgQ09QWV9SRUFEX0JVRkZFUl9CSU5ESU5HXG4gKiAgICAgIDM2NjYzID0gQ09QWV9XUklURV9CVUZGRVIgfCBDT1BZX1dSSVRFX0JVRkZFUl9CSU5ESU5HXG4gKiAgICAgIDM2MDA2ID0gRlJBTUVCVUZGRVJfQklORElORyB8IERSQVdfRlJBTUVCVUZGRVJfQklORElOR1xuICpcbiAqIEl0J3MgYWxzbyBub3QgdXNlZnVsIGZvciBiaXRzIHJlYWxseSB1bmxlc3MgeW91IHBhc3MgaW4gaW5kaXZpZHVhbCBiaXRzLlxuICogSW4gb3RoZXIgd29yZHNcbiAqXG4gKiAgICAgY29uc3QgYml0cyA9IGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUO1xuICogICAgIHR3Z2wuZ2xFbnVtVG9TdHJpbmcoZ2wsIGJpdHMpOyAgLy8gbm90IGdvaW5nIHRvIHdvcmtcbiAqXG4gKiBOb3RlIHRoYXQgc29tZSBlbnVtcyBvbmx5IGV4aXN0IG9uIGV4dGVuc2lvbnMuIElmIHlvdVxuICogd2FudCB0aGVtIHRvIHNob3cgdXAgeW91IG5lZWQgdG8gcGFzcyB0aGUgZXh0ZW5zaW9uIGF0IGxlYXN0XG4gKiBvbmNlLiBGb3IgZXhhbXBsZVxuICpcbiAqICAgICBjb25zdCBleHQgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyk7XG4gKiAgICAgaWYgKGV4dCkge1xuICogICAgICAgIHR3Z2wuZ2xFbnVtVG9TdHJpbmcoZXh0LCAwKTsgIC8vIGp1c3QgcHJpbWUgdGhlIGZ1bmN0aW9uXG4gKlxuICogICAgICAgIC4ubGF0ZXIuLlxuICpcbiAqICAgICAgICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IGV4dC5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xuICogICAgICAgIGNvbnNvbGUubG9nKHR3Z2wuZ2xFbnVtVG9TdHJpbmcoZ2wsIGludGVybmFsRm9ybWF0KSk7XG4gKlxuICogTm90aWNlIEkgZGlkbid0IGhhdmUgdG8gcGFzcyB0aGUgZXh0ZW5zaW9uIHRoZSBzZWNvbmQgdGltZS4gVGhpcyBtZWFuc1xuICogeW91IGNhbiBoYXZlIHBsYWNlIHRoYXQgZ2VuZXJpY2FsbHkgZ2V0cyBhbiBlbnVtIGZvciB0ZXh0dXJlIGZvcm1hdHMgZm9yIGV4YW1wbGUuXG4gKiBhbmQgYXMgbG9uZyBhcyB5b3UgcHJpbWVkIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBleHRlbnNpb25zXG4gKlxuICogSWYgeW91J3JlIHVzaW5nIGB0d2dsLmFkZEV4dGVuc2lvbnNUb0NvbnRleHRgIHRvIGVuYWJsZSB5b3VyIGV4dGVuc2lvbnNcbiAqIHRoZW4gdHdnbCB3aWxsIGF1dG9tYXRpY2FsbHkgZ2V0IHRoZSBleHRlbnNpb24ncyBlbnVtcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgb3IgYW55IGV4dGVuc2lvbiBvYmplY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB0aGUgdmFsdWUgb2YgdGhlIGVudW0geW91IHdhbnQgdG8gbG9vayB1cC5cbiAqIEByZXR1cm4ge3N0cmluZ30gZW51bSBzdHJpbmcgb3IgaGV4IHZhbHVlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqIEBmdW5jdGlvbiBnbEVudW1Ub1N0cmluZ1xuICovXG5cblxudmFyIGdsRW51bVRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGF2ZUVudW1zRm9yVHlwZSA9IHt9O1xuICB2YXIgZW51bXMgPSB7fTtcblxuICBmdW5jdGlvbiBhZGRFbnVtcyhnbCkge1xuICAgIHZhciB0eXBlID0gZ2wuY29uc3RydWN0b3IubmFtZTtcblxuICAgIGlmICghaGF2ZUVudW1zRm9yVHlwZVt0eXBlXSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGdsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2xba2V5XSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBlbnVtc1tnbFtrZXldXTtcbiAgICAgICAgICBlbnVtc1tnbFtrZXldXSA9IGV4aXN0aW5nID8gXCJcIi5jb25jYXQoZXhpc3RpbmcsIFwiIHwgXCIpLmNvbmNhdChrZXkpIDoga2V5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGhhdmVFbnVtc0ZvclR5cGVbdHlwZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBnbEVudW1Ub1N0cmluZyhnbCwgdmFsdWUpIHtcbiAgICBhZGRFbnVtcyhnbCk7XG4gICAgcmV0dXJuIGVudW1zW3ZhbHVlXSB8fCAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IFwiMHhcIi5jb25jYXQodmFsdWUudG9TdHJpbmcoMTYpKSA6IHZhbHVlKTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5nbEVudW1Ub1N0cmluZyA9IGdsRW51bVRvU3RyaW5nO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy92My5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy92My5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNyb3NzID0gY3Jvc3M7XG5leHBvcnRzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLmRpc3RhbmNlU3EgPSBkaXN0YW5jZVNxO1xuZXhwb3J0cy5kaXZpZGUgPSBkaXZpZGU7XG5leHBvcnRzLmRpdlNjYWxhciA9IGRpdlNjYWxhcjtcbmV4cG9ydHMuZG90ID0gZG90O1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMubGVycFYgPSBsZXJwVjtcbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xuZXhwb3J0cy5sZW5ndGhTcSA9IGxlbmd0aFNxO1xuZXhwb3J0cy5tYXggPSBtYXg7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubXVsU2NhbGFyID0gbXVsU2NhbGFyO1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy5uZWdhdGUgPSBuZWdhdGU7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMuc2V0RGVmYXVsdFR5cGUgPSBzZXREZWZhdWx0VHlwZTtcbmV4cG9ydHMuc3VidHJhY3QgPSBzdWJ0cmFjdDtcblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqXG4gKiBWZWMzIG1hdGggbWF0aCBmdW5jdGlvbnMuXG4gKlxuICogQWxtb3N0IGFsbCBmdW5jdGlvbnMgdGFrZSBhbiBvcHRpb25hbCBgZHN0YCBhcmd1bWVudC4gSWYgaXQgaXMgbm90IHBhc3NlZCBpbiB0aGVcbiAqIGZ1bmN0aW9ucyB3aWxsIGNyZWF0ZSBhIG5ldyBWZWMzLiBJbiBvdGhlciB3b3JkcyB5b3UgY2FuIGRvIHRoaXNcbiAqXG4gKiAgICAgdmFyIHYgPSB2My5jcm9zcyh2MSwgdjIpOyAgLy8gQ3JlYXRlcyBhIG5ldyBWZWMzIHdpdGggdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdjEgeCB2Mi5cbiAqXG4gKiBvclxuICpcbiAqICAgICB2YXIgdiA9IHYzLmNyZWF0ZSgpO1xuICogICAgIHYzLmNyb3NzKHYxLCB2Miwgdik7ICAvLyBQdXRzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHYxIHggdjIgaW4gdlxuICpcbiAqIFRoZSBmaXJzdCBzdHlsZSBpcyBvZnRlbiBlYXNpZXIgYnV0IGRlcGVuZGluZyBvbiB3aGVyZSBpdCdzIHVzZWQgaXQgZ2VuZXJhdGVzIGdhcmJhZ2Ugd2hlcmVcbiAqIGFzIHRoZXJlIGlzIGFsbW9zdCBuZXZlciBhbGxvY2F0aW9uIHdpdGggdGhlIHNlY29uZCBzdHlsZS5cbiAqXG4gKiBJdCBpcyBhbHdheXMgc2F2ZSB0byBwYXNzIGFueSB2ZWN0b3IgYXMgdGhlIGRlc3RpbmF0aW9uLiBTbyBmb3IgZXhhbXBsZVxuICpcbiAqICAgICB2My5jcm9zcyh2MSwgdjIsIHYxKTsgIC8vIFB1dHMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdjEgeCB2MiBpbiB2MVxuICpcbiAqIEBtb2R1bGUgdHdnbC92M1xuICovXG52YXIgVmVjVHlwZSA9IEZsb2F0MzJBcnJheTtcbi8qKlxuICogQSBKYXZhU2NyaXB0IGFycmF5IHdpdGggMyB2YWx1ZXMgb3IgYSBGbG9hdDMyQXJyYXkgd2l0aCAzIHZhbHVlcy5cbiAqIFdoZW4gY3JlYXRlZCBieSB0aGUgbGlicmFyeSB3aWxsIGNyZWF0ZSB0aGUgZGVmYXVsdCB0eXBlIHdoaWNoIGlzIGBGbG9hdDMyQXJyYXlgXG4gKiBidXQgY2FuIGJlIHNldCBieSBjYWxsaW5nIHtAbGluayBtb2R1bGU6dHdnbC92My5zZXREZWZhdWx0VHlwZX0uXG4gKiBAdHlwZWRlZiB7KG51bWJlcltdfEZsb2F0MzJBcnJheSl9IFZlYzNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cbi8qKlxuICogU2V0cyB0aGUgdHlwZSB0aGlzIGxpYnJhcnkgY3JlYXRlcyBmb3IgYSBWZWMzXG4gKiBAcGFyYW0ge2NvbnN0cnVjdG9yfSBjdG9yIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHR5cGUuIEVpdGhlciBgRmxvYXQzMkFycmF5YCBvciBgQXJyYXlgXG4gKiBAcmV0dXJuIHtjb25zdHJ1Y3Rvcn0gcHJldmlvdXMgY29uc3RydWN0b3IgZm9yIFZlYzNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cbmZ1bmN0aW9uIHNldERlZmF1bHRUeXBlKGN0b3IpIHtcbiAgdmFyIG9sZFR5cGUgPSBWZWNUeXBlO1xuICBWZWNUeXBlID0gY3RvcjtcbiAgcmV0dXJuIG9sZFR5cGU7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB2ZWMzOyBtYXkgYmUgY2FsbGVkIHdpdGggeCwgeSwgeiB0byBzZXQgaW5pdGlhbCB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW3hdIEluaXRpYWwgeCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gSW5pdGlhbCB5IHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt6XSBJbml0aWFsIHogdmFsdWUuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSB0aGUgY3JlYXRlZCB2ZWN0b3JcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlKHgsIHksIHopIHtcbiAgdmFyIGRzdCA9IG5ldyBWZWNUeXBlKDMpO1xuXG4gIGlmICh4KSB7XG4gICAgZHN0WzBdID0geDtcbiAgfVxuXG4gIGlmICh5KSB7XG4gICAgZHN0WzFdID0geTtcbiAgfVxuXG4gIGlmICh6KSB7XG4gICAgZHN0WzJdID0gejtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlY3RvcnM7IGFzc3VtZXMgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gQSB2ZWN0b3IgdGhhIHRpcyB0aGUgc3VtIG9mIGEgYW5kIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChhLCBiLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuICBkc3RbMF0gPSBhWzBdICsgYlswXTtcbiAgZHN0WzFdID0gYVsxXSArIGJbMV07XG4gIGRzdFsyXSA9IGFbMl0gKyBiWzJdO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBTdWJ0cmFjdHMgdHdvIHZlY3RvcnMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IEEgdmVjdG9yIHRoYXQgaXMgdGhlIGRpZmZlcmVuY2Ugb2YgYSBhbmQgYi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcbiAgZHN0WzBdID0gYVswXSAtIGJbMF07XG4gIGRzdFsxXSA9IGFbMV0gLSBiWzFdO1xuICBkc3RbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gb24gdHdvIHZlY3RvcnMuXG4gKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgYW5kIGludGVycG9sYXRpb24gY29lZmZpY2llbnQgdCwgcmV0dXJuc1xuICogYSArIHQgKiAoYiAtIGEpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBhIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBiIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIGxpbmVhciBpbnRlcnBvbGF0ZWQgcmVzdWx0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBsZXJwKGEsIGIsIHQsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IGFbMF0gKyB0ICogKGJbMF0gLSBhWzBdKTtcbiAgZHN0WzFdID0gYVsxXSArIHQgKiAoYlsxXSAtIGFbMV0pO1xuICBkc3RbMl0gPSBhWzJdICsgdCAqIChiWzJdIC0gYVsyXSk7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9uIHR3byB2ZWN0b3JzLlxuICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIGFuZCBpbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50IHZlY3RvciB0LCByZXR1cm5zXG4gKiBhICsgdCAqIChiIC0gYSkuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHQgSW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudHMgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSB0aGUgbGluZWFyIGludGVycG9sYXRlZCByZXN1bHQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlcnBWKGEsIGIsIHQsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IGFbMF0gKyB0WzBdICogKGJbMF0gLSBhWzBdKTtcbiAgZHN0WzFdID0gYVsxXSArIHRbMV0gKiAoYlsxXSAtIGFbMV0pO1xuICBkc3RbMl0gPSBhWzJdICsgdFsyXSAqIChiWzJdIC0gYVsyXSk7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFJldHVybiBtYXggdmFsdWVzIG9mIHR3byB2ZWN0b3JzLlxuICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIHJldHVybnNcbiAqIFttYXgoYVswXSwgYlswXSksIG1heChhWzFdLCBiWzFdKSwgbWF4KGFbMl0sIGJbMl0pXS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIG1heCBjb21wb25lbnRzIHZlY3Rvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gbWF4KGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBkc3RbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgZHN0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFJldHVybiBtaW4gdmFsdWVzIG9mIHR3byB2ZWN0b3JzLlxuICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIHJldHVybnNcbiAqIFttaW4oYVswXSwgYlswXSksIG1pbihhWzFdLCBiWzFdKSwgbWluKGFbMl0sIGJbMl0pXS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIG1pbiBjb21wb25lbnRzIHZlY3Rvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gbWluKGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBkc3RbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgZHN0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBrIFRoZSBzY2FsYXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSBzY2FsZWQgdmVjdG9yLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBtdWxTY2FsYXIodiwgaywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcbiAgZHN0WzBdID0gdlswXSAqIGs7XG4gIGRzdFsxXSA9IHZbMV0gKiBrO1xuICBkc3RbMl0gPSB2WzJdICogaztcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogRGl2aWRlcyBhIHZlY3RvciBieSBhIHNjYWxhci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgdmVjdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGsgVGhlIHNjYWxhci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIHNjYWxlZCB2ZWN0b3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpdlNjYWxhcih2LCBrLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuICBkc3RbMF0gPSB2WzBdIC8gaztcbiAgZHN0WzFdID0gdlsxXSAvIGs7XG4gIGRzdFsyXSA9IHZbMl0gLyBrO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjdG9yczsgYXNzdW1lcyBib3RoIHZlY3RvcnMgaGF2ZVxuICogdGhyZWUgZW50cmllcy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIHZlY3RvciBvZiBhIGNyb3NzIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyb3NzKGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIHZhciB0MSA9IGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl07XG4gIHZhciB0MiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIGRzdFswXSA9IGFbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV07XG4gIGRzdFsxXSA9IHQxO1xuICBkc3RbMl0gPSB0MjtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzOyBhc3N1bWVzIGJvdGggdmVjdG9ycyBoYXZlXG4gKiB0aHJlZSBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBhIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBiIE9wZXJhbmQgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBkb3QgcHJvZHVjdFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IHZlY3Rvci5cbiAqIEByZXR1cm4ge251bWJlcn0gbGVuZ3RoIG9mIHZlY3Rvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gbGVuZ3RoKHYpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh2WzBdICogdlswXSArIHZbMV0gKiB2WzFdICsgdlsyXSAqIHZbMl0pO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgdmVjdG9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlbmd0aFNxKHYpIHtcbiAgcmV0dXJuIHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0gKyB2WzJdICogdlsyXTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgZHggPSBhWzBdIC0gYlswXTtcbiAgdmFyIGR5ID0gYVsxXSAtIGJbMV07XG4gIHZhciBkeiA9IGFbMl0gLSBiWzJdO1xuICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBkaXN0YW5jZVNxKGEsIGIpIHtcbiAgdmFyIGR4ID0gYVswXSAtIGJbMF07XG4gIHZhciBkeSA9IGFbMV0gLSBiWzFdO1xuICB2YXIgZHogPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcbn1cbi8qKlxuICogRGl2aWRlcyBhIHZlY3RvciBieSBpdHMgRXVjbGlkZWFuIGxlbmd0aCBhbmQgcmV0dXJucyB0aGUgcXVvdGllbnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgVGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIG5vcm1hbGl6ZWQgdmVjdG9yLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemUoYSwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcbiAgdmFyIGxlblNxID0gYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXSArIGFbMl0gKiBhWzJdO1xuICB2YXIgbGVuID0gTWF0aC5zcXJ0KGxlblNxKTtcblxuICBpZiAobGVuID4gMC4wMDAwMSkge1xuICAgIGRzdFswXSA9IGFbMF0gLyBsZW47XG4gICAgZHN0WzFdID0gYVsxXSAvIGxlbjtcbiAgICBkc3RbMl0gPSBhWzJdIC8gbGVuO1xuICB9IGVsc2Uge1xuICAgIGRzdFswXSA9IDA7XG4gICAgZHN0WzFdID0gMDtcbiAgICBkc3RbMl0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogTmVnYXRlcyBhIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSAtdi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gbmVnYXRlKHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IC12WzBdO1xuICBkc3RbMV0gPSAtdlsxXTtcbiAgZHN0WzJdID0gLXZbMl07XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENvcGllcyBhIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBBIGNvcHkgb2Ygdi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gY29weSh2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuICBkc3RbMF0gPSB2WzBdO1xuICBkc3RbMV0gPSB2WzFdO1xuICBkc3RbMl0gPSB2WzJdO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSB2ZWN0b3Igb2YgcHJvZHVjdHMgb2YgZW50cmllcyBvZiBhIGFuZFxuICogICAgIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IGFbMF0gKiBiWzBdO1xuICBkc3RbMV0gPSBhWzFdICogYlsxXTtcbiAgZHN0WzJdID0gYVsyXSAqIGJbMl07XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICogYiBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIHZlY3RvciBvZiBxdW90aWVudHMgb2YgZW50cmllcyBvZiBhIGFuZFxuICogICAgIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpdmlkZShhLCBiLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuICBkc3RbMF0gPSBhWzBdIC8gYlswXTtcbiAgZHN0WzFdID0gYVsxXSAvIGJbMV07XG4gIGRzdFsyXSA9IGFbMl0gLyBiWzJdO1xuICByZXR1cm4gZHN0O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy92ZXJ0ZXgtYXJyYXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdmVydGV4LWFycmF5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlVmVydGV4QXJyYXlJbmZvID0gY3JlYXRlVmVydGV4QXJyYXlJbmZvO1xuZXhwb3J0cy5jcmVhdGVWQU9BbmRTZXRBdHRyaWJ1dGVzID0gY3JlYXRlVkFPQW5kU2V0QXR0cmlidXRlcztcbmV4cG9ydHMuY3JlYXRlVkFPRnJvbUJ1ZmZlckluZm8gPSBjcmVhdGVWQU9Gcm9tQnVmZmVySW5mbztcblxudmFyIHByb2dyYW1zID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wcm9ncmFtcy5qcyAqLyBcIi4vc3JjL3Byb2dyYW1zLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIHZlcnRleCBhcnJheSBvYmplY3QgcmVsYXRlZCBmdW5jdGlvbnNcbiAqXG4gKiBZb3Ugc2hvdWxkIGdlbmVyYWxseSBub3QgbmVlZCB0byB1c2UgdGhlc2UgZnVuY3Rpb25zLiBUaGV5IGFyZSBwcm92aWRlZFxuICogZm9yIHRob3NlIGNhc2VzIHdoZXJlIHlvdSdyZSBkb2luZyBzb21ldGhpbmcgb3V0IG9mIHRoZSBvcmRpbmFyeVxuICogYW5kIHlvdSBuZWVkIGxvd2VyIGxldmVsIGFjY2Vzcy5cbiAqXG4gKiBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB0aGV5IGFyZSBhdmFpbGFibGUgYXQgYm90aCBgdHdnbC5hdHRyaWJ1dGVzYCBhbmQgYHR3Z2xgXG4gKiBpdHNlbGZcbiAqXG4gKiBTZWUge0BsaW5rIG1vZHVsZTp0d2dsfSBmb3IgY29yZSBmdW5jdGlvbnNcbiAqXG4gKiBAbW9kdWxlIHR3Z2wvdmVydGV4QXJyYXlzXG4gKi9cbnZhciBFTEVNRU5UX0FSUkFZX0JVRkZFUiA9IDB4ODg5Mztcbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVmVydGV4QXJyYXlJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gbnVtRWxlbWVudHMgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBwYXNzIHRvIGBnbC5kcmF3QXJyYXlzYCBvciBgZ2wuZHJhd0VsZW1lbnRzYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZWxlbWVudFR5cGVdIFRoZSB0eXBlIG9mIGluZGljZXMgYFVOU0lHTkVEX0JZVEVgLCBgVU5TSUdORURfU0hPUlRgIGV0Yy4uXG4gKiBAcHJvcGVydHkge1dlYkdMVmVydGV4QXJyYXlPYmplY3R9IFt2ZXJ0ZXhBcnJheU9iamVjdF0gYSB2ZXJ0ZXggYXJyYXkgb2JqZWN0XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBWZXJ0ZXhBcnJheUluZm8gZnJvbSBhIEJ1ZmZlckluZm8gYW5kIG9uZSBvciBtb3JlIFByb2dyYW1JbmZvc1xuICpcbiAqIFRoaXMgY2FuIGJlIHBhc3NlZCB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXN9IGFuZCB0b1xuICoge0BsaW5rIG1vZHVsZTp0d2dsOmRyYXdCdWZmZXJJbmZvfS5cbiAqXG4gKiA+ICoqSU1QT1JUQU5UOioqIFZlcnRleCBBcnJheSBPYmplY3RzIGFyZSAqKm5vdCoqIGEgZGlyZWN0IGFuYWxvZyBmb3IgYSBCdWZmZXJJbmZvLiBWZXJ0ZXggQXJyYXkgT2JqZWN0c1xuICogICBhc3NpZ24gYnVmZmVycyB0byBzcGVjaWZpYyBhdHRyaWJ1dGVzIGF0IGNyZWF0aW9uIHRpbWUuIFRoYXQgbWVhbnMgdGhleSBjYW4gb25seSBiZSB1c2VkIHdpdGggcHJvZ3JhbXNcbiAqICAgd2hvJ3MgYXR0cmlidXRlcyB1c2UgdGhlIHNhbWUgYXR0cmlidXRlIGxvY2F0aW9ucyBmb3IgdGhlIHNhbWUgcHVycG9zZXMuXG4gKlxuICogPiBCaW5kIHlvdXIgYXR0cmlidXRlIGxvY2F0aW9ucyBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlUHJvZ3JhbUluZm99XG4gKiAgIG9yIHVzZSBXZWJHTCAyJ3MgR0xTTCBFUyAzJ3MgYGxheW91dChsb2NhdGlvbiA9IDxudW0+KWAgdG8gbWFrZSBzdXJlIGxvY2F0aW9ucyBtYXRjaC5cbiAqXG4gKiBhbHNvXG4gKlxuICogPiAqKklNUE9SVEFOVDoqKiBBZnRlciBjYWxsaW5nIHR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZSB3aXRoIGEgQnVmZmVySW5mbyB0aGF0IHVzZXMgYSBWZXJ0ZXggQXJyYXkgT2JqZWN0XG4gKiAgIHRoYXQgVmVydGV4IEFycmF5IE9iamVjdCB3aWxsIGJlIGJvdW5kLiBUaGF0IG1lYW5zICoqQU5ZIE1BTklQVUxBVElPTiBPRiBFTEVNRU5UX0FSUkFZX0JVRkZFUiBvciBBVFRSSUJVVEVTKipcbiAqICAgd2lsbCBhZmZlY3QgdGhlIFZlcnRleCBBcnJheSBPYmplY3Qgc3RhdGUuXG4gKlxuICogPiBDYWxsIGBnbC5iaW5kVmVydGV4QXJyYXkobnVsbClgIHRvIGdldCBiYWNrIG1hbmlwdWxhdGluZyB0aGUgZ2xvYmFsIGF0dHJpYnV0ZXMgYW5kIEVMRU1FTlRfQVJSQVlfQlVGRkVSLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb1tdfSBwcm9ncmFtSW5mbyBhIHByb2dyYW1JbmZvIG9yIGFycmF5IG9mIHByb2dyYW1JbmZvc1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBidWZmZXJJbmZvIEJ1ZmZlckluZm8gYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyBldGMuLi5cbiAqXG4gKiAgICBZb3UgbmVlZCB0byBtYWtlIHN1cmUgZXZlcnkgYXR0cmlidXRlIHRoYXQgd2lsbCBiZSB1c2VkIGlzIGJvdW5kLiBTbyBmb3IgZXhhbXBsZSBhc3N1bWUgc2hhZGVyIDFcbiAqICAgIHVzZXMgYXR0cmlidXRlcyBBLCBCLCBDIGFuZCBzaGFkZXIgMiB1c2VzIGF0dHJpYnV0ZXMgQSwgQiwgRC4gSWYgeW91IG9ubHkgcGFzcyBpbiB0aGUgcHJvZ3JhbUluZm9cbiAqICAgIGZvciBzaGFkZXIgMSB0aGVuIG9ubHkgYXR0cmlidXRlcyBBLCBCLCBhbmQgQyB3aWxsIGhhdmUgdGhlaXIgYXR0cmlidXRlcyBzZXQgYmVjYXVzZSBUV0dMIGRvZXNuJ3RcbiAqICAgIG5vdyBhdHRyaWJ1dGUgRCdzIGxvY2F0aW9uLlxuICpcbiAqICAgIFNvLCB5b3UgY2FuIHBhc3MgaW4gYm90aCBzaGFkZXIgMSBhbmQgc2hhZGVyIDIncyBwcm9ncmFtSW5mb1xuICpcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLlZlcnRleEFycmF5SW5mb30gVGhlIGNyZWF0ZWQgVmVydGV4QXJyYXlJbmZvXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ZlcnRleEFycmF5c1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleEFycmF5SW5mbyhnbCwgcHJvZ3JhbUluZm9zLCBidWZmZXJJbmZvKSB7XG4gIHZhciB2YW8gPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuICBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcblxuICBpZiAoIXByb2dyYW1JbmZvcy5sZW5ndGgpIHtcbiAgICBwcm9ncmFtSW5mb3MgPSBbcHJvZ3JhbUluZm9zXTtcbiAgfVxuXG4gIHByb2dyYW1JbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtSW5mbykge1xuICAgIHByb2dyYW1zLnNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzKGdsLCBwcm9ncmFtSW5mbywgYnVmZmVySW5mbyk7XG4gIH0pO1xuICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gIHJldHVybiB7XG4gICAgbnVtRWxlbWVudHM6IGJ1ZmZlckluZm8ubnVtRWxlbWVudHMsXG4gICAgZWxlbWVudFR5cGU6IGJ1ZmZlckluZm8uZWxlbWVudFR5cGUsXG4gICAgdmVydGV4QXJyYXlPYmplY3Q6IHZhb1xuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgdmVydGV4IGFycmF5IG9iamVjdCBhbmQgdGhlbiBzZXRzIHRoZSBhdHRyaWJ1dGVzIG9uIGl0XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBzZXR0ZXJzIEF0dHJpYnV0ZSBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20gY3JlYXRlQXR0cmlidXRlU2V0dGVyc1xuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnR3Z2wuQXR0cmliSW5mbz59IGF0dHJpYnMgQXR0cmliSW5mb3MgbWFwcGVkIGJ5IGF0dHJpYnV0ZSBuYW1lLlxuICogQHBhcmFtIHtXZWJHTEJ1ZmZlcn0gW2luZGljZXNdIGFuIG9wdGlvbmFsIEVMRU1FTlRfQVJSQVlfQlVGRkVSIG9mIGluZGljZXNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92ZXJ0ZXhBcnJheXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVZBT0FuZFNldEF0dHJpYnV0ZXMoZ2wsIHNldHRlcnMsIGF0dHJpYnMsIGluZGljZXMpIHtcbiAgdmFyIHZhbyA9IGdsLmNyZWF0ZVZlcnRleEFycmF5KCk7XG4gIGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xuICBwcm9ncmFtcy5zZXRBdHRyaWJ1dGVzKHNldHRlcnMsIGF0dHJpYnMpO1xuXG4gIGlmIChpbmRpY2VzKSB7XG4gICAgZ2wuYmluZEJ1ZmZlcihFTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kaWNlcyk7XG4gIH0gLy8gV2UgdW5iaW5kIHRoaXMgYmVjYXVzZSBvdGhlcndpc2UgYW55IGNoYW5nZSB0byBFTEVNRU5UX0FSUkFZX0JVRkZFUlxuICAvLyBsaWtlIHdoZW4gY3JlYXRpbmcgYnVmZmVycyBmb3Igb3RoZXIgc3R1ZmYgd2lsbCBtZXNzIHVwIHRoaXMgVkFPJ3MgYmluZGluZ1xuXG5cbiAgZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuICByZXR1cm4gdmFvO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgdmVydGV4IGFycmF5IG9iamVjdCBhbmQgdGhlbiBzZXRzIHRoZSBhdHRyaWJ1dGVzXG4gKiBvbiBpdFxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiAgICAgICAgdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fCBtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb30gcHJvZ3JhbUluZm8gYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVQcm9ncmFtSW5mbyBvciBBdHRyaWJ1dGUgc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUF0dHJpYnV0ZVNldHRlcnNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gYnVmZmVySW5mbyBCdWZmZXJJbmZvIGFzIHJldHVybmVkIGZyb20gY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMgZXRjLi4uXG4gKiBAcGFyYW0ge1dlYkdMQnVmZmVyfSBbaW5kaWNlc10gYW4gb3B0aW9uYWwgRUxFTUVOVF9BUlJBWV9CVUZGRVIgb2YgaW5kaWNlc1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ZlcnRleEFycmF5c1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlVkFPRnJvbUJ1ZmZlckluZm8oZ2wsIHByb2dyYW1JbmZvLCBidWZmZXJJbmZvKSB7XG4gIHJldHVybiBjcmVhdGVWQU9BbmRTZXRBdHRyaWJ1dGVzKGdsLCBwcm9ncmFtSW5mby5hdHRyaWJTZXR0ZXJzIHx8IHByb2dyYW1JbmZvLCBidWZmZXJJbmZvLmF0dHJpYnMsIGJ1ZmZlckluZm8uaW5kaWNlcyk7XG59XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10d2dsLWZ1bGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGxvYWRNYXAgPSByZXF1aXJlKFwiLi9sb2FkTWFwXCIpO1xuY29uc3QgdHdnbCA9IHJlcXVpcmUoXCJ0d2dsLmpzXCIpO1xuY29uc3QgbWF0MyA9IHJlcXVpcmUoXCJnbC1tYXRyaXgvbWF0M1wiKTtcbmNvbnN0IGNyZWF0ZURyYXdpbmcgPSByZXF1aXJlKFwiLi9yZW5kZXJlclwiKTtcbmNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcblxuY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpO1xuY29uc3Qgc2hhcGVzID0gcmVxdWlyZShcIi4vc2hhcGVzXCIpKGdsKTtcblxuY29uc3Qgc2NlbmUgPSBjcmVhdGVEcmF3aW5nKGdsKTtcblxuLy8gR0VUIE1BUCBEQVRBXG5sZXQgcHJvZ3Jlc3MgPSB7XG4gIG1lc3NhZ2U6IFwiXCIsXG4gIGNvbXBsZXRlZDogMFxufVxubGV0IG5vZGVzO1xubGV0IGVkZ2VzO1xubG9hZE1hcChcInRvcm9udG9cIiwgcHJvZ3Jlc3MpXG4gIC50aGVuKChyZXMpID0+IHtcbiAgICBub2RlcyA9IHJlcy5ub2RlcztcbiAgICBlZGdlcyA9IHJlcy5lZGdlcztcbiAgICBtYWluKCk7XG4gIH0pXG5cbmZ1bmN0aW9uIHJlbmRlcih0aW1lKSB7XG4gIHR3Z2wucmVzaXplQ2FudmFzVG9EaXNwbGF5U2l6ZShnbC5jYW52YXMpO1xuICBnbC52aWV3cG9ydCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpO1xuICBzY2VuZS5kcmF3KCk7IFxufVxuXG5mdW5jdGlvbiBtYWluKCl7XG4gIGxldCBjb2xvciA9IFsxLjAsIDEuMCwgMS4wLCAxLjBdO1xuXG4gIHNjZW5lLmFkZE9iamVjdChub2RlcywgZWRnZXMsIGNvbG9yLCBnbC5MSU5FUyk7XG5cbiAgYXR0YWNoSGFuZGxlcnMoKTtcblxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoSGFuZGxlcnMoKSB7XG4gIFxuICAvLyBoYW5kbGUgd2luZG93IHJlc2l6ZVxuICBmdW5jdGlvbiBoYW5kbGVSZXNpemUoZSkge1xuICAgIHNjZW5lLmRyYXcoKTtcbiAgfVxuICBcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gIFxuICBsZXQgY2FtZXJhID0gc2NlbmUuY2FtZXJhO1xuICBsZXQgdmlld1Byb2plY3Rpb25NYXQgPSBzY2VuZS52aWV3UHJvamVjdGlvbk1hdDtcbiAgbGV0IHVwZGF0ZVZpZXdQcm9qZWN0aW9uID0gc2NlbmUudXBkYXRlVmlld1Byb2plY3Rpb247XG4gIGxldCBzdGFydEludlZpZXdQcm9qTWF0ID0gbWF0My5jcmVhdGUoKTtcbiAgbGV0IHN0YXJ0Q2FtZXJhO1xuICBsZXQgc3RhcnRQb3M7XG4gIGxldCBzdGFydENsaXBQb3M7XG4gIGxldCBzdGFydE1vdXNlUG9zO1xuICBcbiAgbGV0IG1vdmVkID0gZmFsc2U7XG4gIFxuICBmdW5jdGlvbiBtb3ZlQ2FtZXJhKGUpIHtcbiAgICBjb25zdCBwb3MgPSB0cmFuc2Zvcm1Qb2ludChcbiAgICAgICAgc3RhcnRJbnZWaWV3UHJvak1hdCxcbiAgICAgICAgZ2V0Q2xpcFNwYWNlTW91c2VQb3NpdGlvbihlKSk7XG4gICAgXG4gICAgY2FtZXJhLnggPSBzdGFydENhbWVyYS54ICsgc3RhcnRQb3NbMF0gLSBwb3NbMF07XG4gICAgY2FtZXJhLnkgPSBzdGFydENhbWVyYS55ICsgc3RhcnRQb3NbMV0gLSBwb3NbMV07XG4gICAgc2NlbmUuZHJhdygpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZSkge1xuICAgIG1vdmVkID0gdHJ1ZTtcbiAgICBtb3ZlQ2FtZXJhKGUpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGUpIHtcbiAgICBzY2VuZS5kcmF3KCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKTtcbiAgICBcbiAgICAvLyBjaGVjayBpZiBtb3VzZSBjbGljayAobm90IGRyYWcpXG4gICAgaWYgKCFtb3ZlZCkge1xuICAgICAgY29uc29sZS5sb2coXCJtb3VzZSB0YXAhXCIpO1xuICAgICAgaGFuZGxlQ2xpY2soZSk7XG4gICAgfVxuICAgIG1vdmVkID0gZmFsc2U7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGUpIHtcbiAgICBjb25zdCBwb3MgPSB0cmFuc2Zvcm1Qb2ludChcbiAgICAgICAgc3RhcnRJbnZWaWV3UHJvak1hdCxcbiAgICAgICAgZ2V0Q2xpcFNwYWNlTW91c2VQb3NpdGlvbihlKSk7XG4gICAgXG4gICAgbGV0IG1hcmtlciA9IHNoYXBlcy5tYXJrZXI7XG4gICAgbGV0IHRyYW5zZm9ybXMgPSB7XG4gICAgICB4OiBwb3NbMF0sXG4gICAgICB5OiBwb3NbMV0sXG4gICAgICBzY2FsZTogNSxcbiAgICAgIHpvb206IGZhbHNlXG4gICAgfVxuICAgIFxuICAgIHNjZW5lLmFkZE9iamVjdChtYXJrZXIudmVydHMsIG1hcmtlci5pbmRpY2VzLCBbMC44NSwwLDAsMV0sIG1hcmtlci5kcmF3VHlwZSwgdHJhbnNmb3Jtcyk7XG4gICAgc2NlbmUuZHJhdygpO1xuICB9XG4gIFxuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGUpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKTtcbiAgXG4gICAgbWF0My5pbnZlcnQoc3RhcnRJbnZWaWV3UHJvak1hdCwgdmlld1Byb2plY3Rpb25NYXQpO1xuICAgIFxuICAgIHN0YXJ0Q2FtZXJhID0gT2JqZWN0LmFzc2lnbih7fSwgY2FtZXJhKTtcbiAgICBzdGFydENsaXBQb3MgPSBnZXRDbGlwU3BhY2VNb3VzZVBvc2l0aW9uKGUpO1xuICAgIHN0YXJ0UG9zID0gdHJhbnNmb3JtUG9pbnQoXG4gICAgICAgIHN0YXJ0SW52Vmlld1Byb2pNYXQsXG4gICAgICAgIHN0YXJ0Q2xpcFBvcyk7XG4gICAgc3RhcnRNb3VzZVBvcyA9IFtlLmNsaWVudFgsIGUuY2xpZW50WV07XG4gICAgc2NlbmUuZHJhdygpO1xuICB9KTtcbiAgXG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAgXG4gICAgY29uc3QgW2NsaXBYLCBjbGlwWV0gPSBnZXRDbGlwU3BhY2VNb3VzZVBvc2l0aW9uKGUpO1xuICAgIC8vIHBvc2l0aW9uIGJlZm9yZSB6b29taW5nXG4gICAgbGV0IHRlbXAgPSBtYXQzLmNyZWF0ZSgpO1xuICAgIG1hdDMuaW52ZXJ0KHRlbXAsIHZpZXdQcm9qZWN0aW9uTWF0KTsgXG4gICAgY29uc3QgW3ByZVpvb21YLCBwcmVab29tWV0gPSB0cmFuc2Zvcm1Qb2ludChcbiAgICAgICAgdGVtcCxcbiAgICAgICAgW2NsaXBYLCBjbGlwWV0pO1xuICAgICAgXG4gICAgLy8gbXVsdGlwbHkgdGhlIHdoZWVsIG1vdmVtZW50IGJ5IHRoZSBjdXJyZW50IHpvb20gbGV2ZWxcbiAgICAvLyBzbyB3ZSB6b29tIGxlc3Mgd2hlbiB6b29tZWQgaW4gYW5kIG1vcmUgd2hlbiB6b29tZWQgb3V0XG4gICAgY29uc3QgbmV3Wm9vbSA9IGNhbWVyYS56b29tICogTWF0aC5wb3coMiwgZS5kZWx0YVkgKiAtMC4wMSk7XG4gICAgY2FtZXJhLnpvb20gPSBNYXRoLm1heCgwLjAyLCBNYXRoLm1pbigxMDAsIG5ld1pvb20pKTtcbiAgICBcbiAgICB1cGRhdGVWaWV3UHJvamVjdGlvbigpO1xuICAgIFxuICAgIC8vIHBvc2l0aW9uIGFmdGVyIHpvb21pbmdcbiAgICBtYXQzLmludmVydCh0ZW1wLCB2aWV3UHJvamVjdGlvbk1hdCk7IFxuICAgIGNvbnN0IFtwb3N0Wm9vbVgsIHBvc3Rab29tWV0gPSB0cmFuc2Zvcm1Qb2ludChcbiAgICAgICAgdGVtcCxcbiAgICAgICAgW2NsaXBYLCBjbGlwWV0pO1xuICBcbiAgICAvLyBjYW1lcmEgbmVlZHMgdG8gYmUgbW92ZWQgdGhlIGRpZmZlcmVuY2Ugb2YgYmVmb3JlIGFuZCBhZnRlclxuICAgIGNhbWVyYS54ICs9IHByZVpvb21YIC0gcG9zdFpvb21YO1xuICAgIGNhbWVyYS55ICs9IHByZVpvb21ZIC0gcG9zdFpvb21ZOyAgXG4gICAgXG4gICAgc2NlbmUuZHJhdygpO1xuICB9KTtcbiAgXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KG0sIHYpIHtcbiAgICB2YXIgdjAgPSB2WzBdO1xuICAgIHZhciB2MSA9IHZbMV07XG4gICAgdmFyIGQgPSB2MCAqIG1bMCAqIDMgKyAyXSArIHYxICogbVsxICogMyArIDJdICsgbVsyICogMyArIDJdO1xuICAgIHJldHVybiBbXG4gICAgICAodjAgKiBtWzAgKiAzICsgMF0gKyB2MSAqIG1bMSAqIDMgKyAwXSArIG1bMiAqIDMgKyAwXSkgLyBkLFxuICAgICAgKHYwICogbVswICogMyArIDFdICsgdjEgKiBtWzEgKiAzICsgMV0gKyBtWzIgKiAzICsgMV0pIC8gZCxcbiAgICBdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENsaXBTcGFjZU1vdXNlUG9zaXRpb24oZSkge1xuICAvLyBnZXQgY2FudmFzIHJlbGF0aXZlIGNzcyBwb3NpdGlvblxuICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBjc3NYID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICBjb25zdCBjc3NZID0gZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gIFxuICAvLyBnZXQgbm9ybWFsaXplZCAwIHRvIDEgcG9zaXRpb24gYWNyb3NzIGFuZCBkb3duIGNhbnZhc1xuICBjb25zdCBub3JtYWxpemVkWCA9IGNzc1ggLyBjYW52YXMuY2xpZW50V2lkdGg7XG4gIGNvbnN0IG5vcm1hbGl6ZWRZID0gY3NzWSAvIGNhbnZhcy5jbGllbnRIZWlnaHQ7XG5cbiAgLy8gY29udmVydCB0byBjbGlwIHNwYWNlXG4gIGNvbnN0IGNsaXBYID0gbm9ybWFsaXplZFggKiAgMiAtIDE7XG4gIGNvbnN0IGNsaXBZID0gbm9ybWFsaXplZFkgKiAtMiArIDE7XG4gIFxuICByZXR1cm4gW2NsaXBYLCBjbGlwWV07XG59XG4iLCJjb25zdCByZXF1ZXN0ID0gcmVxdWlyZShcIi4vcmVxdWVzdFwiKTtcbmNvbnN0IGVuZHBvaW50ID0gXCIuL2RhdGEvXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSwgcHJvZ3Jlc3MpIHtcbiAgbGV0IG5vZGVzO1xuICBsZXQgZWRnZXM7XG4gIFxuICByZXR1cm4gbG9hZE5vZGVzKClcbiAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICBzZXROb2RlQ29vcmRpbmF0ZXMocmVzKTtcbiAgICAgICAgICAgIHJldHVybiBsb2FkRWRnZXMoKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgIHNldEVkZ2VMaW5rcyhyZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbm9kZXMsIGVkZ2VzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgXG4gIGZ1bmN0aW9uIGxvYWROb2RlcygpIHtcbiAgICByZXR1cm4gcmVxdWVzdChlbmRwb2ludCArIGAke25hbWV9LmNvLmJpbmAsIHtcbiAgICAgIHJlc3BvbnNlVHlwZTogXCJhcnJheWJ1ZmZlclwiLFxuICAgICAgcHJvZ3Jlc3M6IHJlcG9ydFByb2dyZXNzKFwiTG9hZGluZyBtYXAgbm9kZXNcIilcbiAgICB9KVxuICB9XG4gIFxuICBmdW5jdGlvbiBsb2FkRWRnZXMoKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QoZW5kcG9pbnQgKyBgJHtuYW1lfS5nci5iaW5gLCB7XG4gICAgICByZXNwb25zZVR5cGU6IFwiYXJyYXlidWZmZXJcIixcbiAgICAgIHByb2dyZXNzOiByZXBvcnRQcm9ncmVzcyhcIkxvYWRpbmcgbWFwIGVkZ2VzXCIpXG4gICAgfSlcbiAgfVxuICBcbiAgZnVuY3Rpb24gc2V0Tm9kZUNvb3JkaW5hdGVzKGJ1ZmZlcikge1xuICAgIG5vZGVzID0gbmV3IEludDMyQXJyYXkoYnVmZmVyKTsgICBcbiAgICAvLyBUT0RPOiBhZGQgdG8gZ3JhcGggc3RydWN0dXJlXG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHNldEVkZ2VMaW5rcyhidWZmZXIpIHtcbiAgICBlZGdlcyA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgZWRnZXMuZm9yRWFjaCgodixpKSA9PiB7XG4gICAgICBlZGdlc1tpXSAtPSAxO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwb3J0UHJvZ3Jlc3MobXNnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHByb2dyZXNzLm1lc3NhZ2UgPSBtc2c7XG4gICAgICBwcm9ncmVzcy5jb21wbGV0ZWQgPSBNYXRoLnJvdW5kKGUucGVyY2VudCAqIDEwMClcbiAgICAgIGNvbnNvbGUubG9nKHByb2dyZXNzLm1lc3NhZ2UgKyBcIiBcIiArIHByb2dyZXNzLmNvbXBsZXRlZCk7XG4gICAgfSBcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBnbHNsID0gcmVxdWlyZShcImdsc2xpZnlcIik7XG5jb25zdCB0d2dsID0gcmVxdWlyZShcInR3Z2wuanNcIik7XG5jb25zdCBtYXQzID0gcmVxdWlyZShcImdsLW1hdHJpeC9tYXQzXCIpO1xuXG5jb25zdCB2ZXJ0ZXhTaGFkZXIgPSBnbHNsKFtcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XFxuXFxudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgodV9tYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxKSkueHksIDAsIDEpO1xcbn1cIl0pO1xuY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBnbHNsKFtcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxuXFxudm9pZCBtYWluKCl7XFxuXFxuICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yO1xcblxcbn1cIl0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGdsKSB7XG4gIGNvbnN0IHByb2dyYW1JbmZvID0gdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdKTtcbiAgY29uc3Qgb2JqZWN0cyA9IFtdO1xuICBjb25zdCByZXNvbHV0aW9uID0gW2dsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodF07IFxuICBjb25zdCB2aWV3UHJvamVjdGlvbk1hdCA9IG1hdDMuY3JlYXRlKCk7XG4gIGNvbnN0IGNhbWVyYSA9IHtcbiAgICAvL3g6IC0zMzk0OCxcbiAgICAvL3k6IC0xNzY4OSxcbiAgICAvL3pvb206IDAuMDI3MTMxMVxuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB6b29tOiAxXG4gICB9XG5cbiAgdHdnbC5hZGRFeHRlbnNpb25zVG9Db250ZXh0KGdsKTtcbiAgXG4gIGZ1bmN0aW9uIHVwZGF0ZVZpZXdQcm9qZWN0aW9uKCkge1xuICAgIG1hdDMucHJvamVjdGlvbih2aWV3UHJvamVjdGlvbk1hdCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICAvLyBtYWtlIGNhbWVyYSBtYXRyaXhcbiAgICBjb25zdCB6b29tU2NhbGUgPSAxIC8gY2FtZXJhLnpvb207XG4gICAgbGV0IGNhbWVyYU1hdCA9IG1hdDMuY3JlYXRlKCk7IFxuICAgIG1hdDMudHJhbnNsYXRlKGNhbWVyYU1hdCwgY2FtZXJhTWF0LCBbY2FtZXJhLngsIGNhbWVyYS55XSk7XG4gICAgbWF0My5zY2FsZShjYW1lcmFNYXQsIGNhbWVyYU1hdCwgW3pvb21TY2FsZSwgem9vbVNjYWxlXSk7XG4gICAgXG4gICAgbGV0IHZpZXdNYXQgPSBtYXQzLmNyZWF0ZSgpO1xuICAgIG1hdDMuaW52ZXJ0KHZpZXdNYXQsIGNhbWVyYU1hdCk7XG4gICAgbWF0My5tdWx0aXBseSh2aWV3UHJvamVjdGlvbk1hdCwgdmlld1Byb2plY3Rpb25NYXQsIHZpZXdNYXQpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBjb21wdXRlTWF0cml4VW5pZm9ybSh0cmFuc2Zvcm1zKSB7XG4gICAgbGV0IG1hdCA9IG1hdDMuY3JlYXRlKCk7XG4gICAgbWF0My5pZGVudGl0eShtYXQpO1xuICAgIG1hdDMudHJhbnNsYXRlKG1hdCwgbWF0LCBbdHJhbnNmb3Jtcy54LCB0cmFuc2Zvcm1zLnldKTtcbiAgICBtYXQzLnNjYWxlKG1hdCwgbWF0LCBbdHJhbnNmb3Jtcy5zY2FsZSwgdHJhbnNmb3Jtcy5zY2FsZV0pO1xuICAgIFxuICAgIGlmICghdHJhbnNmb3Jtcy56b29tKSB7XG4gICAgICBtYXQzLnNjYWxlKG1hdCwgbWF0LCBbMS9jYW1lcmEuem9vbSwgMS9jYW1lcmEuem9vbV0pO1xuICAgICAgY29uc29sZS5sb2cobWF0KTtcbiAgICB9XG4gICAgXG4gICAgbWF0My5tdWx0aXBseShtYXQsIHZpZXdQcm9qZWN0aW9uTWF0LCBtYXQpO1xuICAgIHJldHVybiBtYXQ7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRPYmplY3QodmVydHMsIGluZHMsIGNvbG9yLCB0eXBlLCB0cmFuc2Zvcm1zID0geyB4OiAwLCB5OiAwLCBzY2FsZTogMSwgem9vbTogdHJ1ZSB9KSB7XG4gICAgY29uc3QgYnVmZmVyRGF0YSA9IHtcbiAgICAgIHBvc2l0aW9uOiB7IG51bUNvbXBvbmVudHM6IDIsIGRhdGE6IG5ldyBGbG9hdDMyQXJyYXkodmVydHMpIH0sXG4gICAgICBpbmRpY2VzOiAgeyBudW1Db21wb25lbnRzOiAyLCBkYXRhOiBuZXcgVWludDMyQXJyYXkoaW5kcykgfVxuICAgIH07XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IHR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMoZ2wsIGJ1ZmZlckRhdGEpO1xuICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgIGJ1ZmZlckluZm86IGJ1ZmZlckluZm8sXG4gICAgICBjb2xvcjogY29sb3IsXG4gICAgICBkcmF3VHlwZTogdHlwZSxcbiAgICAgIHRyYW5zZm9ybXM6IHRyYW5zZm9ybXNcbiAgICB9O1xuICAgIFxuICAgIG9iamVjdHMucHVzaChvYmopO1xuICB9XG4gIFxuICAvLyBJbml0L1JlLWluaXQgQnVmZmVySW5mbyBhbmQgc2V0XG4gIGZ1bmN0aW9uIHVwZGF0ZURhdGEoKSB7XG4gICAgYnVmZmVySW5mbyA9IHR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMoZ2wsIGJ1ZmZlckRhdGEpO1xuICAgIHR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXMoZ2wsIHByb2dyYW1JbmZvLCBidWZmZXJJbmZvKTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGVEYXRhLFxuICAgIHVwZGF0ZVZpZXdQcm9qZWN0aW9uLFxuICAgIGFkZE9iamVjdCxcbiAgICBjYW1lcmEsXG4gICAgdmlld1Byb2plY3Rpb25NYXQsXG5cbiAgICBkcmF3KCkge1xuICAgICAgaWYgKCFvYmplY3RzLmxlbmd0aCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwibm8gb2JqZWN0cyB0byBkcmF3IVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x1dGlvblswXSA9IGdsLmNhbnZhcy53aWR0aDsgXG4gICAgICByZXNvbHV0aW9uWzFdID0gZ2wuY2FudmFzLmhlaWdodDsgXG4gICAgICBcbiAgICAgIHR3Z2wucmVzaXplQ2FudmFzVG9EaXNwbGF5U2l6ZShnbC5jYW52YXMpO1xuXG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMDYsIDAuMjEsIDEuMCk7XG4gICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgIFxuICAgICAgdXBkYXRlVmlld1Byb2plY3Rpb24oKTtcbiAgICAgIFxuICAgICAgb2JqZWN0cy5mb3JFYWNoKG9iaiA9PiB7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1zID0ge1xuICAgICAgICAgIHVfY29sb3I6IG9iai5jb2xvcixcbiAgICAgICAgICB1X21hdHJpeDogY29tcHV0ZU1hdHJpeFVuaWZvcm0ob2JqLnRyYW5zZm9ybXMpXG4gICAgICAgIH1cbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtSW5mby5wcm9ncmFtKTtcbiAgICAgICAgdHdnbC5zZXRCdWZmZXJzQW5kQXR0cmlidXRlcyhnbCwgcHJvZ3JhbUluZm8sIG9iai5idWZmZXJJbmZvKTtcbiAgICAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgdW5pZm9ybXMpO1xuICAgICAgICB0d2dsLmRyYXdCdWZmZXJJbmZvKGdsLCBvYmouYnVmZmVySW5mbywgb2JqLmRyYXdUeXBlKTtcbiAgICAgIH0pXG5cbiAgICB9XG4gIH1cbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVlc3Q7XG5cbmZ1bmN0aW9uIHJlcXVlc3QodXJsLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShkb3dubG9hZCk7XG5cbiAgZnVuY3Rpb24gZG93bmxvYWQocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXEuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIHVwZGF0ZVByb2dyZXNzLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmVxLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRyYW5zZmVyQ29tcGxldGUsIGZhbHNlKTtcbiAgICByZXEuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRyYW5zZmVyRmFpbGVkLCBmYWxzZSk7XG4gICAgcmVxLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCB0cmFuc2ZlckNhbmNlbGVkLCBmYWxzZSk7XG5cbiAgICByZXEub3BlbignR0VUJywgdXJsKTtcbiAgICBpZiAob3B0aW9ucy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHJlcS5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZTtcbiAgICB9XG4gICAgcmVxLnNlbmQobnVsbCk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzcyhlKSB7XG4gICAgICBpZiAoZS5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgIG9wdGlvbnMucHJvZ3Jlc3Moe1xuICAgICAgICAgIGxvYWRlZDogZS5sb2FkZWQsXG4gICAgICAgICAgdG90YWw6IGUudG90YWwsXG4gICAgICAgICAgcGVyY2VudDogZS5sb2FkZWQgLyBlLnRvdGFsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZmVyQ29tcGxldGUoKSB7XG4gICAgICBpZiAocmVxLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHJlamVjdChgVW5leHBlY3RlZCBzdGF0dXMgY29kZSAke3JlcS5zdGF0dXN9IHdoZW4gY2FsbGluZyAke3VybH1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3BvbnNlID0gcmVxLnJlc3BvbnNlO1xuXG4gICAgICBpZiAob3B0aW9ucy5yZXNwb25zZVR5cGUgPT09ICdqc29uJyAmJiB0eXBlb2YgcmVzcG9uc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIElFXG4gICAgICAgIHJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZmVyRmFpbGVkKCkge1xuICAgICAgcmVqZWN0KGBGYWlsZWQgdG8gZG93bmxvYWQgJHt1cmx9YCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNmZXJDYW5jZWxlZCgpIHtcbiAgICAgIHJlamVjdChgQ2FuY2VsbGVkIGRvd25sb2FkIG9mICR7dXJsfWApO1xuICAgIH1cbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGdsKSB7XG4gIHJldHVybiB7XG4gICAgbWFya2VyOiB7XG4gICAgICB2ZXJ0czogWzAsIC0xMCxcbiAgICAgICAgICAgICAgLTIuNiwgLTkuMCxcbiAgICAgICAgICAgICAgLTIuNiwgLTEwLFxuICAgICAgICAgICAgICAtMi4wLCAtMTEuNSxcbiAgICAgICAgICAgICAgLTAuNywgLTEyLjQsXG4gICAgICAgICAgICAgIDAuNywgLTEyLjQsXG4gICAgICAgICAgICAgIDIuMCwgLTExLjUsXG4gICAgICAgICAgICAgIDIuNiwgLTEwLFxuICAgICAgICAgICAgICAyLjYsIC05LjAsXG4gICAgICAgICAgICAgIDAsIDBdLFxuICAgICAgaW5kaWNlczogWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDFdLFxuICAgICAgZHJhd1R5cGU6IGdsLlRSSUFOR0xFX0ZBTlxuICAgIH0sXG4gIH1cbn0iXX0=
